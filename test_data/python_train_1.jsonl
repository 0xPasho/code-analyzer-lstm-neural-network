{"repo": "saltstack/salt", "path": "salt/transport/zeromq.py", "func_name": "ZeroMQReqServerChannel.zmq_device", "original_string": "def zmq_device(self):\n        '''\n        Multiprocessing target for the zmq queue device\n        '''\n        self.__setup_signals()\n        salt.utils.process.appendproctitle('MWorkerQueue')\n        self.context = zmq.Context(self.opts['worker_threads'])\n        # Prepare the zeromq sockets\n        self.uri = 'tcp://{interface}:{ret_port}'.format(**self.opts)\n        self.clients = self.context.socket(zmq.ROUTER)\n        if self.opts['ipv6'] is True and hasattr(zmq, 'IPV4ONLY'):\n            # IPv6 sockets work for both IPv6 and IPv4 addresses\n            self.clients.setsockopt(zmq.IPV4ONLY, 0)\n        self.clients.setsockopt(zmq.BACKLOG, self.opts.get('zmq_backlog', 1000))\n        self._start_zmq_monitor()\n        self.workers = self.context.socket(zmq.DEALER)\n\n        if self.opts.get('ipc_mode', '') == 'tcp':\n            self.w_uri = 'tcp://127.0.0.1:{0}'.format(\n                self.opts.get('tcp_master_workers', 4515)\n                )\n        else:\n            self.w_uri = 'ipc://{0}'.format(\n                os.path.join(self.opts['sock_dir'], 'workers.ipc')\n                )\n\n        log.info('Setting up the master communication server')\n        self.clients.bind(self.uri)\n        self.workers.bind(self.w_uri)\n\n        while True:\n            if self.clients.closed or self.workers.closed:\n                break\n            try:\n                zmq.device(zmq.QUEUE, self.clients, self.workers)\n            except zmq.ZMQError as exc:\n                if exc.errno == errno.EINTR:\n                    continue\n                raise exc\n            except (KeyboardInterrupt, SystemExit):\n                break", "language": "python", "code": "def zmq_device(self):\n        '''\n        Multiprocessing target for the zmq queue device\n        '''\n        self.__setup_signals()\n        salt.utils.process.appendproctitle('MWorkerQueue')\n        self.context = zmq.Context(self.opts['worker_threads'])\n        # Prepare the zeromq sockets\n        self.uri = 'tcp://{interface}:{ret_port}'.format(**self.opts)\n        self.clients = self.context.socket(zmq.ROUTER)\n        if self.opts['ipv6'] is True and hasattr(zmq, 'IPV4ONLY'):\n            # IPv6 sockets work for both IPv6 and IPv4 addresses\n            self.clients.setsockopt(zmq.IPV4ONLY, 0)\n        self.clients.setsockopt(zmq.BACKLOG, self.opts.get('zmq_backlog', 1000))\n        self._start_zmq_monitor()\n        self.workers = self.context.socket(zmq.DEALER)\n\n        if self.opts.get('ipc_mode', '') == 'tcp':\n            self.w_uri = 'tcp://127.0.0.1:{0}'.format(\n                self.opts.get('tcp_master_workers', 4515)\n                )\n        else:\n            self.w_uri = 'ipc://{0}'.format(\n                os.path.join(self.opts['sock_dir'], 'workers.ipc')\n                )\n\n        log.info('Setting up the master communication server')\n        self.clients.bind(self.uri)\n        self.workers.bind(self.w_uri)\n\n        while True:\n            if self.clients.closed or self.workers.closed:\n                break\n            try:\n                zmq.device(zmq.QUEUE, self.clients, self.workers)\n            except zmq.ZMQError as exc:\n                if exc.errno == errno.EINTR:\n                    continue\n                raise exc\n            except (KeyboardInterrupt, SystemExit):\n                break", "code_tokens": ["def", "zmq_device", "(", "self", ")", ":", "self", ".", "__setup_signals", "(", ")", "salt", ".", "utils", ".", "process", ".", "appendproctitle", "(", "'MWorkerQueue'", ")", "self", ".", "context", "=", "zmq", ".", "Context", "(", "self", ".", "opts", "[", "'worker_threads'", "]", ")", "# Prepare the zeromq sockets", "self", ".", "uri", "=", "'tcp://{interface}:{ret_port}'", ".", "format", "(", "*", "*", "self", ".", "opts", ")", "self", ".", "clients", "=", "self", ".", "context", ".", "socket", "(", "zmq", ".", "ROUTER", ")", "if", "self", ".", "opts", "[", "'ipv6'", "]", "is", "True", "and", "hasattr", "(", "zmq", ",", "'IPV4ONLY'", ")", ":", "# IPv6 sockets work for both IPv6 and IPv4 addresses", "self", ".", "clients", ".", "setsockopt", "(", "zmq", ".", "IPV4ONLY", ",", "0", ")", "self", ".", "clients", ".", "setsockopt", "(", "zmq", ".", "BACKLOG", ",", "self", ".", "opts", ".", "get", "(", "'zmq_backlog'", ",", "1000", ")", ")", "self", ".", "_start_zmq_monitor", "(", ")", "self", ".", "workers", "=", "self", ".", "context", ".", "socket", "(", "zmq", ".", "DEALER", ")", "if", "self", ".", "opts", ".", "get", "(", "'ipc_mode'", ",", "''", ")", "==", "'tcp'", ":", "self", ".", "w_uri", "=", "'tcp://127.0.0.1:{0}'", ".", "format", "(", "self", ".", "opts", ".", "get", "(", "'tcp_master_workers'", ",", "4515", ")", ")", "else", ":", "self", ".", "w_uri", "=", "'ipc://{0}'", ".", "format", "(", "os", ".", "path", ".", "join", "(", "self", ".", "opts", "[", "'sock_dir'", "]", ",", "'workers.ipc'", ")", ")", "log", ".", "info", "(", "'Setting up the master communication server'", ")", "self", ".", "clients", ".", "bind", "(", "self", ".", "uri", ")", "self", ".", "workers", ".", "bind", "(", "self", ".", "w_uri", ")", "while", "True", ":", "if", "self", ".", "clients", ".", "closed", "or", "self", ".", "workers", ".", "closed", ":", "break", "try", ":", "zmq", ".", "device", "(", "zmq", ".", "QUEUE", ",", "self", ".", "clients", ",", "self", ".", "workers", ")", "except", "zmq", ".", "ZMQError", "as", "exc", ":", "if", "exc", ".", "errno", "==", "errno", ".", "EINTR", ":", "continue", "raise", "exc", "except", "(", "KeyboardInterrupt", ",", "SystemExit", ")", ":", "break"], "docstring": "Multiprocessing target for the zmq queue device", "docstring_tokens": ["Multiprocessing", "target", "for", "the", "zmq", "queue", "device"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/transport/zeromq.py#L582-L622", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/transport/zeromq.py", "func_name": "ZeroMQReqServerChannel.close", "original_string": "def close(self):\n        '''\n        Cleanly shutdown the router socket\n        '''\n        if self._closing:\n            return\n        log.info('MWorkerQueue under PID %s is closing', os.getpid())\n        self._closing = True\n        # pylint: disable=E0203\n        if getattr(self, '_monitor', None) is not None:\n            self._monitor.stop()\n            self._monitor = None\n        if getattr(self, '_w_monitor', None) is not None:\n            self._w_monitor.stop()\n            self._w_monitor = None\n        if hasattr(self, 'clients') and self.clients.closed is False:\n            self.clients.close()\n        if hasattr(self, 'workers') and self.workers.closed is False:\n            self.workers.close()\n        if hasattr(self, 'stream'):\n            self.stream.close()\n        if hasattr(self, '_socket') and self._socket.closed is False:\n            self._socket.close()\n        if hasattr(self, 'context') and self.context.closed is False:\n            self.context.term()", "language": "python", "code": "def close(self):\n        '''\n        Cleanly shutdown the router socket\n        '''\n        if self._closing:\n            return\n        log.info('MWorkerQueue under PID %s is closing', os.getpid())\n        self._closing = True\n        # pylint: disable=E0203\n        if getattr(self, '_monitor', None) is not None:\n            self._monitor.stop()\n            self._monitor = None\n        if getattr(self, '_w_monitor', None) is not None:\n            self._w_monitor.stop()\n            self._w_monitor = None\n        if hasattr(self, 'clients') and self.clients.closed is False:\n            self.clients.close()\n        if hasattr(self, 'workers') and self.workers.closed is False:\n            self.workers.close()\n        if hasattr(self, 'stream'):\n            self.stream.close()\n        if hasattr(self, '_socket') and self._socket.closed is False:\n            self._socket.close()\n        if hasattr(self, 'context') and self.context.closed is False:\n            self.context.term()", "code_tokens": ["def", "close", "(", "self", ")", ":", "if", "self", ".", "_closing", ":", "return", "log", ".", "info", "(", "'MWorkerQueue under PID %s is closing'", ",", "os", ".", "getpid", "(", ")", ")", "self", ".", "_closing", "=", "True", "# pylint: disable=E0203", "if", "getattr", "(", "self", ",", "'_monitor'", ",", "None", ")", "is", "not", "None", ":", "self", ".", "_monitor", ".", "stop", "(", ")", "self", ".", "_monitor", "=", "None", "if", "getattr", "(", "self", ",", "'_w_monitor'", ",", "None", ")", "is", "not", "None", ":", "self", ".", "_w_monitor", ".", "stop", "(", ")", "self", ".", "_w_monitor", "=", "None", "if", "hasattr", "(", "self", ",", "'clients'", ")", "and", "self", ".", "clients", ".", "closed", "is", "False", ":", "self", ".", "clients", ".", "close", "(", ")", "if", "hasattr", "(", "self", ",", "'workers'", ")", "and", "self", ".", "workers", ".", "closed", "is", "False", ":", "self", ".", "workers", ".", "close", "(", ")", "if", "hasattr", "(", "self", ",", "'stream'", ")", ":", "self", ".", "stream", ".", "close", "(", ")", "if", "hasattr", "(", "self", ",", "'_socket'", ")", "and", "self", ".", "_socket", ".", "closed", "is", "False", ":", "self", ".", "_socket", ".", "close", "(", ")", "if", "hasattr", "(", "self", ",", "'context'", ")", "and", "self", ".", "context", ".", "closed", "is", "False", ":", "self", ".", "context", ".", "term", "(", ")"], "docstring": "Cleanly shutdown the router socket", "docstring_tokens": ["Cleanly", "shutdown", "the", "router", "socket"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/transport/zeromq.py#L624-L648", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/transport/zeromq.py", "func_name": "ZeroMQReqServerChannel.pre_fork", "original_string": "def pre_fork(self, process_manager):\n        '''\n        Pre-fork we need to create the zmq router device\n\n        :param func process_manager: An instance of salt.utils.process.ProcessManager\n        '''\n        salt.transport.mixins.auth.AESReqServerMixin.pre_fork(self, process_manager)\n        process_manager.add_process(self.zmq_device)", "language": "python", "code": "def pre_fork(self, process_manager):\n        '''\n        Pre-fork we need to create the zmq router device\n\n        :param func process_manager: An instance of salt.utils.process.ProcessManager\n        '''\n        salt.transport.mixins.auth.AESReqServerMixin.pre_fork(self, process_manager)\n        process_manager.add_process(self.zmq_device)", "code_tokens": ["def", "pre_fork", "(", "self", ",", "process_manager", ")", ":", "salt", ".", "transport", ".", "mixins", ".", "auth", ".", "AESReqServerMixin", ".", "pre_fork", "(", "self", ",", "process_manager", ")", "process_manager", ".", "add_process", "(", "self", ".", "zmq_device", ")"], "docstring": "Pre-fork we need to create the zmq router device\n\n        :param func process_manager: An instance of salt.utils.process.ProcessManager", "docstring_tokens": ["Pre", "-", "fork", "we", "need", "to", "create", "the", "zmq", "router", "device"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/transport/zeromq.py#L651-L658", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/transport/zeromq.py", "func_name": "ZeroMQReqServerChannel._start_zmq_monitor", "original_string": "def _start_zmq_monitor(self):\n        '''\n        Starts ZMQ monitor for debugging purposes.\n        :return:\n        '''\n        # Socket monitor shall be used the only for debug\n        # purposes so using threading doesn't look too bad here\n\n        if HAS_ZMQ_MONITOR and self.opts['zmq_monitor']:\n            log.debug('Starting ZMQ monitor')\n            import threading\n            self._w_monitor = ZeroMQSocketMonitor(self._socket)\n            threading.Thread(target=self._w_monitor.start_poll).start()\n            log.debug('ZMQ monitor has been started started')", "language": "python", "code": "def _start_zmq_monitor(self):\n        '''\n        Starts ZMQ monitor for debugging purposes.\n        :return:\n        '''\n        # Socket monitor shall be used the only for debug\n        # purposes so using threading doesn't look too bad here\n\n        if HAS_ZMQ_MONITOR and self.opts['zmq_monitor']:\n            log.debug('Starting ZMQ monitor')\n            import threading\n            self._w_monitor = ZeroMQSocketMonitor(self._socket)\n            threading.Thread(target=self._w_monitor.start_poll).start()\n            log.debug('ZMQ monitor has been started started')", "code_tokens": ["def", "_start_zmq_monitor", "(", "self", ")", ":", "# Socket monitor shall be used the only for debug", "# purposes so using threading doesn't look too bad here", "if", "HAS_ZMQ_MONITOR", "and", "self", ".", "opts", "[", "'zmq_monitor'", "]", ":", "log", ".", "debug", "(", "'Starting ZMQ monitor'", ")", "import", "threading", "self", ".", "_w_monitor", "=", "ZeroMQSocketMonitor", "(", "self", ".", "_socket", ")", "threading", ".", "Thread", "(", "target", "=", "self", ".", "_w_monitor", ".", "start_poll", ")", ".", "start", "(", ")", "log", ".", "debug", "(", "'ZMQ monitor has been started started'", ")"], "docstring": "Starts ZMQ monitor for debugging purposes.\n        :return:", "docstring_tokens": ["Starts", "ZMQ", "monitor", "for", "debugging", "purposes", ".", ":", "return", ":"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/transport/zeromq.py#L660-L673", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/transport/zeromq.py", "func_name": "ZeroMQReqServerChannel.post_fork", "original_string": "def post_fork(self, payload_handler, io_loop):\n        '''\n        After forking we need to create all of the local sockets to listen to the\n        router\n\n        :param func payload_handler: A function to called to handle incoming payloads as\n                                     they are picked up off the wire\n        :param IOLoop io_loop: An instance of a Tornado IOLoop, to handle event scheduling\n        '''\n        self.payload_handler = payload_handler\n        self.io_loop = io_loop\n\n        self.context = zmq.Context(1)\n        self._socket = self.context.socket(zmq.REP)\n        self._start_zmq_monitor()\n\n        if self.opts.get('ipc_mode', '') == 'tcp':\n            self.w_uri = 'tcp://127.0.0.1:{0}'.format(\n                self.opts.get('tcp_master_workers', 4515)\n                )\n        else:\n            self.w_uri = 'ipc://{0}'.format(\n                os.path.join(self.opts['sock_dir'], 'workers.ipc')\n                )\n        log.info('Worker binding to socket %s', self.w_uri)\n        self._socket.connect(self.w_uri)\n\n        salt.transport.mixins.auth.AESReqServerMixin.post_fork(self, payload_handler, io_loop)\n\n        self.stream = zmq.eventloop.zmqstream.ZMQStream(self._socket, io_loop=self.io_loop)\n        self.stream.on_recv_stream(self.handle_message)", "language": "python", "code": "def post_fork(self, payload_handler, io_loop):\n        '''\n        After forking we need to create all of the local sockets to listen to the\n        router\n\n        :param func payload_handler: A function to called to handle incoming payloads as\n                                     they are picked up off the wire\n        :param IOLoop io_loop: An instance of a Tornado IOLoop, to handle event scheduling\n        '''\n        self.payload_handler = payload_handler\n        self.io_loop = io_loop\n\n        self.context = zmq.Context(1)\n        self._socket = self.context.socket(zmq.REP)\n        self._start_zmq_monitor()\n\n        if self.opts.get('ipc_mode', '') == 'tcp':\n            self.w_uri = 'tcp://127.0.0.1:{0}'.format(\n                self.opts.get('tcp_master_workers', 4515)\n                )\n        else:\n            self.w_uri = 'ipc://{0}'.format(\n                os.path.join(self.opts['sock_dir'], 'workers.ipc')\n                )\n        log.info('Worker binding to socket %s', self.w_uri)\n        self._socket.connect(self.w_uri)\n\n        salt.transport.mixins.auth.AESReqServerMixin.post_fork(self, payload_handler, io_loop)\n\n        self.stream = zmq.eventloop.zmqstream.ZMQStream(self._socket, io_loop=self.io_loop)\n        self.stream.on_recv_stream(self.handle_message)", "code_tokens": ["def", "post_fork", "(", "self", ",", "payload_handler", ",", "io_loop", ")", ":", "self", ".", "payload_handler", "=", "payload_handler", "self", ".", "io_loop", "=", "io_loop", "self", ".", "context", "=", "zmq", ".", "Context", "(", "1", ")", "self", ".", "_socket", "=", "self", ".", "context", ".", "socket", "(", "zmq", ".", "REP", ")", "self", ".", "_start_zmq_monitor", "(", ")", "if", "self", ".", "opts", ".", "get", "(", "'ipc_mode'", ",", "''", ")", "==", "'tcp'", ":", "self", ".", "w_uri", "=", "'tcp://127.0.0.1:{0}'", ".", "format", "(", "self", ".", "opts", ".", "get", "(", "'tcp_master_workers'", ",", "4515", ")", ")", "else", ":", "self", ".", "w_uri", "=", "'ipc://{0}'", ".", "format", "(", "os", ".", "path", ".", "join", "(", "self", ".", "opts", "[", "'sock_dir'", "]", ",", "'workers.ipc'", ")", ")", "log", ".", "info", "(", "'Worker binding to socket %s'", ",", "self", ".", "w_uri", ")", "self", ".", "_socket", ".", "connect", "(", "self", ".", "w_uri", ")", "salt", ".", "transport", ".", "mixins", ".", "auth", ".", "AESReqServerMixin", ".", "post_fork", "(", "self", ",", "payload_handler", ",", "io_loop", ")", "self", ".", "stream", "=", "zmq", ".", "eventloop", ".", "zmqstream", ".", "ZMQStream", "(", "self", ".", "_socket", ",", "io_loop", "=", "self", ".", "io_loop", ")", "self", ".", "stream", ".", "on_recv_stream", "(", "self", ".", "handle_message", ")"], "docstring": "After forking we need to create all of the local sockets to listen to the\n        router\n\n        :param func payload_handler: A function to called to handle incoming payloads as\n                                     they are picked up off the wire\n        :param IOLoop io_loop: An instance of a Tornado IOLoop, to handle event scheduling", "docstring_tokens": ["After", "forking", "we", "need", "to", "create", "all", "of", "the", "local", "sockets", "to", "listen", "to", "the", "router"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/transport/zeromq.py#L675-L705", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/transport/zeromq.py", "func_name": "ZeroMQReqServerChannel.handle_message", "original_string": "def handle_message(self, stream, payload):\n        '''\n        Handle incoming messages from underlying TCP streams\n\n        :stream ZMQStream stream: A ZeroMQ stream.\n        See http://zeromq.github.io/pyzmq/api/generated/zmq.eventloop.zmqstream.html\n\n        :param dict payload: A payload to process\n        '''\n        try:\n            payload = self.serial.loads(payload[0])\n            payload = self._decode_payload(payload)\n        except Exception as exc:\n            exc_type = type(exc).__name__\n            if exc_type == 'AuthenticationError':\n                log.debug(\n                    'Minion failed to auth to master. Since the payload is '\n                    'encrypted, it is not known which minion failed to '\n                    'authenticate. It is likely that this is a transient '\n                    'failure due to the master rotating its public key.'\n                )\n            else:\n                log.error('Bad load from minion: %s: %s', exc_type, exc)\n            stream.send(self.serial.dumps('bad load'))\n            raise tornado.gen.Return()\n\n        # TODO helper functions to normalize payload?\n        if not isinstance(payload, dict) or not isinstance(payload.get('load'), dict):\n            log.error('payload and load must be a dict. Payload was: %s and load was %s', payload, payload.get('load'))\n            stream.send(self.serial.dumps('payload and load must be a dict'))\n            raise tornado.gen.Return()\n\n        try:\n            id_ = payload['load'].get('id', '')\n            if str('\\0') in id_:\n                log.error('Payload contains an id with a null byte: %s', payload)\n                stream.send(self.serial.dumps('bad load: id contains a null byte'))\n                raise tornado.gen.Return()\n        except TypeError:\n            log.error('Payload contains non-string id: %s', payload)\n            stream.send(self.serial.dumps('bad load: id {0} is not a string'.format(id_)))\n            raise tornado.gen.Return()\n\n        # intercept the \"_auth\" commands, since the main daemon shouldn't know\n        # anything about our key auth\n        if payload['enc'] == 'clear' and payload.get('load', {}).get('cmd') == '_auth':\n            stream.send(self.serial.dumps(self._auth(payload['load'])))\n            raise tornado.gen.Return()\n\n        # TODO: test\n        try:\n            # Take the payload_handler function that was registered when we created the channel\n            # and call it, returning control to the caller until it completes\n            ret, req_opts = yield self.payload_handler(payload)\n        except Exception as e:\n            # always attempt to return an error to the minion\n            stream.send(self.serial.dumps('Some exception handling minion payload'))\n            log.error('Some exception handling a payload from minion', exc_info=True)\n            raise tornado.gen.Return()\n\n        req_fun = req_opts.get('fun', 'send')\n        if req_fun == 'send_clear':\n            stream.send(self.serial.dumps(ret))\n        elif req_fun == 'send':\n            stream.send(self.serial.dumps(self.crypticle.dumps(ret)))\n        elif req_fun == 'send_private':\n            stream.send(self.serial.dumps(self._encrypt_private(ret,\n                                                                req_opts['key'],\n                                                                req_opts['tgt'],\n                                                                )))\n        else:\n            log.error('Unknown req_fun %s', req_fun)\n            # always attempt to return an error to the minion\n            stream.send(self.serial.dumps('Server-side exception handling payload'))\n        raise tornado.gen.Return()", "language": "python", "code": "def handle_message(self, stream, payload):\n        '''\n        Handle incoming messages from underlying TCP streams\n\n        :stream ZMQStream stream: A ZeroMQ stream.\n        See http://zeromq.github.io/pyzmq/api/generated/zmq.eventloop.zmqstream.html\n\n        :param dict payload: A payload to process\n        '''\n        try:\n            payload = self.serial.loads(payload[0])\n            payload = self._decode_payload(payload)\n        except Exception as exc:\n            exc_type = type(exc).__name__\n            if exc_type == 'AuthenticationError':\n                log.debug(\n                    'Minion failed to auth to master. Since the payload is '\n                    'encrypted, it is not known which minion failed to '\n                    'authenticate. It is likely that this is a transient '\n                    'failure due to the master rotating its public key.'\n                )\n            else:\n                log.error('Bad load from minion: %s: %s', exc_type, exc)\n            stream.send(self.serial.dumps('bad load'))\n            raise tornado.gen.Return()\n\n        # TODO helper functions to normalize payload?\n        if not isinstance(payload, dict) or not isinstance(payload.get('load'), dict):\n            log.error('payload and load must be a dict. Payload was: %s and load was %s', payload, payload.get('load'))\n            stream.send(self.serial.dumps('payload and load must be a dict'))\n            raise tornado.gen.Return()\n\n        try:\n            id_ = payload['load'].get('id', '')\n            if str('\\0') in id_:\n                log.error('Payload contains an id with a null byte: %s', payload)\n                stream.send(self.serial.dumps('bad load: id contains a null byte'))\n                raise tornado.gen.Return()\n        except TypeError:\n            log.error('Payload contains non-string id: %s', payload)\n            stream.send(self.serial.dumps('bad load: id {0} is not a string'.format(id_)))\n            raise tornado.gen.Return()\n\n        # intercept the \"_auth\" commands, since the main daemon shouldn't know\n        # anything about our key auth\n        if payload['enc'] == 'clear' and payload.get('load', {}).get('cmd') == '_auth':\n            stream.send(self.serial.dumps(self._auth(payload['load'])))\n            raise tornado.gen.Return()\n\n        # TODO: test\n        try:\n            # Take the payload_handler function that was registered when we created the channel\n            # and call it, returning control to the caller until it completes\n            ret, req_opts = yield self.payload_handler(payload)\n        except Exception as e:\n            # always attempt to return an error to the minion\n            stream.send(self.serial.dumps('Some exception handling minion payload'))\n            log.error('Some exception handling a payload from minion', exc_info=True)\n            raise tornado.gen.Return()\n\n        req_fun = req_opts.get('fun', 'send')\n        if req_fun == 'send_clear':\n            stream.send(self.serial.dumps(ret))\n        elif req_fun == 'send':\n            stream.send(self.serial.dumps(self.crypticle.dumps(ret)))\n        elif req_fun == 'send_private':\n            stream.send(self.serial.dumps(self._encrypt_private(ret,\n                                                                req_opts['key'],\n                                                                req_opts['tgt'],\n                                                                )))\n        else:\n            log.error('Unknown req_fun %s', req_fun)\n            # always attempt to return an error to the minion\n            stream.send(self.serial.dumps('Server-side exception handling payload'))\n        raise tornado.gen.Return()", "code_tokens": ["def", "handle_message", "(", "self", ",", "stream", ",", "payload", ")", ":", "try", ":", "payload", "=", "self", ".", "serial", ".", "loads", "(", "payload", "[", "0", "]", ")", "payload", "=", "self", ".", "_decode_payload", "(", "payload", ")", "except", "Exception", "as", "exc", ":", "exc_type", "=", "type", "(", "exc", ")", ".", "__name__", "if", "exc_type", "==", "'AuthenticationError'", ":", "log", ".", "debug", "(", "'Minion failed to auth to master. Since the payload is '", "'encrypted, it is not known which minion failed to '", "'authenticate. It is likely that this is a transient '", "'failure due to the master rotating its public key.'", ")", "else", ":", "log", ".", "error", "(", "'Bad load from minion: %s: %s'", ",", "exc_type", ",", "exc", ")", "stream", ".", "send", "(", "self", ".", "serial", ".", "dumps", "(", "'bad load'", ")", ")", "raise", "tornado", ".", "gen", ".", "Return", "(", ")", "# TODO helper functions to normalize payload?", "if", "not", "isinstance", "(", "payload", ",", "dict", ")", "or", "not", "isinstance", "(", "payload", ".", "get", "(", "'load'", ")", ",", "dict", ")", ":", "log", ".", "error", "(", "'payload and load must be a dict. Payload was: %s and load was %s'", ",", "payload", ",", "payload", ".", "get", "(", "'load'", ")", ")", "stream", ".", "send", "(", "self", ".", "serial", ".", "dumps", "(", "'payload and load must be a dict'", ")", ")", "raise", "tornado", ".", "gen", ".", "Return", "(", ")", "try", ":", "id_", "=", "payload", "[", "'load'", "]", ".", "get", "(", "'id'", ",", "''", ")", "if", "str", "(", "'\\0'", ")", "in", "id_", ":", "log", ".", "error", "(", "'Payload contains an id with a null byte: %s'", ",", "payload", ")", "stream", ".", "send", "(", "self", ".", "serial", ".", "dumps", "(", "'bad load: id contains a null byte'", ")", ")", "raise", "tornado", ".", "gen", ".", "Return", "(", ")", "except", "TypeError", ":", "log", ".", "error", "(", "'Payload contains non-string id: %s'", ",", "payload", ")", "stream", ".", "send", "(", "self", ".", "serial", ".", "dumps", "(", "'bad load: id {0} is not a string'", ".", "format", "(", "id_", ")", ")", ")", "raise", "tornado", ".", "gen", ".", "Return", "(", ")", "# intercept the \"_auth\" commands, since the main daemon shouldn't know", "# anything about our key auth", "if", "payload", "[", "'enc'", "]", "==", "'clear'", "and", "payload", ".", "get", "(", "'load'", ",", "{", "}", ")", ".", "get", "(", "'cmd'", ")", "==", "'_auth'", ":", "stream", ".", "send", "(", "self", ".", "serial", ".", "dumps", "(", "self", ".", "_auth", "(", "payload", "[", "'load'", "]", ")", ")", ")", "raise", "tornado", ".", "gen", ".", "Return", "(", ")", "# TODO: test", "try", ":", "# Take the payload_handler function that was registered when we created the channel", "# and call it, returning control to the caller until it completes", "ret", ",", "req_opts", "=", "yield", "self", ".", "payload_handler", "(", "payload", ")", "except", "Exception", "as", "e", ":", "# always attempt to return an error to the minion", "stream", ".", "send", "(", "self", ".", "serial", ".", "dumps", "(", "'Some exception handling minion payload'", ")", ")", "log", ".", "error", "(", "'Some exception handling a payload from minion'", ",", "exc_info", "=", "True", ")", "raise", "tornado", ".", "gen", ".", "Return", "(", ")", "req_fun", "=", "req_opts", ".", "get", "(", "'fun'", ",", "'send'", ")", "if", "req_fun", "==", "'send_clear'", ":", "stream", ".", "send", "(", "self", ".", "serial", ".", "dumps", "(", "ret", ")", ")", "elif", "req_fun", "==", "'send'", ":", "stream", ".", "send", "(", "self", ".", "serial", ".", "dumps", "(", "self", ".", "crypticle", ".", "dumps", "(", "ret", ")", ")", ")", "elif", "req_fun", "==", "'send_private'", ":", "stream", ".", "send", "(", "self", ".", "serial", ".", "dumps", "(", "self", ".", "_encrypt_private", "(", "ret", ",", "req_opts", "[", "'key'", "]", ",", "req_opts", "[", "'tgt'", "]", ",", ")", ")", ")", "else", ":", "log", ".", "error", "(", "'Unknown req_fun %s'", ",", "req_fun", ")", "# always attempt to return an error to the minion", "stream", ".", "send", "(", "self", ".", "serial", ".", "dumps", "(", "'Server-side exception handling payload'", ")", ")", "raise", "tornado", ".", "gen", ".", "Return", "(", ")"], "docstring": "Handle incoming messages from underlying TCP streams\n\n        :stream ZMQStream stream: A ZeroMQ stream.\n        See http://zeromq.github.io/pyzmq/api/generated/zmq.eventloop.zmqstream.html\n\n        :param dict payload: A payload to process", "docstring_tokens": ["Handle", "incoming", "messages", "from", "underlying", "TCP", "streams"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/transport/zeromq.py#L708-L782", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/transport/zeromq.py", "func_name": "ZeroMQPubServerChannel._publish_daemon", "original_string": "def _publish_daemon(self, log_queue=None):\n        '''\n        Bind to the interface specified in the configuration file\n        '''\n        salt.utils.process.appendproctitle(self.__class__.__name__)\n        if log_queue:\n            salt.log.setup.set_multiprocessing_logging_queue(log_queue)\n            salt.log.setup.setup_multiprocessing_logging(log_queue)\n\n        # Set up the context\n        context = zmq.Context(1)\n        # Prepare minion publish socket\n        pub_sock = context.socket(zmq.PUB)\n        _set_tcp_keepalive(pub_sock, self.opts)\n        # if 2.1 >= zmq < 3.0, we only have one HWM setting\n        try:\n            pub_sock.setsockopt(zmq.HWM, self.opts.get('pub_hwm', 1000))\n        # in zmq >= 3.0, there are separate send and receive HWM settings\n        except AttributeError:\n            # Set the High Water Marks. For more information on HWM, see:\n            # http://api.zeromq.org/4-1:zmq-setsockopt\n            pub_sock.setsockopt(zmq.SNDHWM, self.opts.get('pub_hwm', 1000))\n            pub_sock.setsockopt(zmq.RCVHWM, self.opts.get('pub_hwm', 1000))\n        if self.opts['ipv6'] is True and hasattr(zmq, 'IPV4ONLY'):\n            # IPv6 sockets work for both IPv6 and IPv4 addresses\n            pub_sock.setsockopt(zmq.IPV4ONLY, 0)\n        pub_sock.setsockopt(zmq.BACKLOG, self.opts.get('zmq_backlog', 1000))\n        pub_sock.setsockopt(zmq.LINGER, -1)\n        pub_uri = 'tcp://{interface}:{publish_port}'.format(**self.opts)\n        # Prepare minion pull socket\n        pull_sock = context.socket(zmq.PULL)\n        pull_sock.setsockopt(zmq.LINGER, -1)\n\n        if self.opts.get('ipc_mode', '') == 'tcp':\n            pull_uri = 'tcp://127.0.0.1:{0}'.format(\n                self.opts.get('tcp_master_publish_pull', 4514)\n                )\n        else:\n            pull_uri = 'ipc://{0}'.format(\n                os.path.join(self.opts['sock_dir'], 'publish_pull.ipc')\n                )\n        salt.utils.zeromq.check_ipc_path_max_len(pull_uri)\n\n        # Start the minion command publisher\n        log.info('Starting the Salt Publisher on %s', pub_uri)\n        pub_sock.bind(pub_uri)\n\n        # Securely create socket\n        log.info('Starting the Salt Puller on %s', pull_uri)\n        with salt.utils.files.set_umask(0o177):\n            pull_sock.bind(pull_uri)\n\n        try:\n            while True:\n                # Catch and handle EINTR from when this process is sent\n                # SIGUSR1 gracefully so we don't choke and die horribly\n                try:\n                    log.debug('Publish daemon getting data from puller %s', pull_uri)\n                    package = pull_sock.recv()\n                    log.debug('Publish daemon received payload. size=%d', len(package))\n\n                    unpacked_package = salt.payload.unpackage(package)\n                    if six.PY3:\n                        unpacked_package = salt.transport.frame.decode_embedded_strs(unpacked_package)\n                    payload = unpacked_package['payload']\n                    log.trace('Accepted unpacked package from puller')\n                    if self.opts['zmq_filtering']:\n                        # if you have a specific topic list, use that\n                        if 'topic_lst' in unpacked_package:\n                            for topic in unpacked_package['topic_lst']:\n                                log.trace('Sending filtered data over publisher %s', pub_uri)\n                                # zmq filters are substring match, hash the topic\n                                # to avoid collisions\n                                htopic = salt.utils.stringutils.to_bytes(hashlib.sha1(topic).hexdigest())\n                                pub_sock.send(htopic, flags=zmq.SNDMORE)\n                                pub_sock.send(payload)\n                                log.trace('Filtered data has been sent')\n\n                            # Syndic broadcast\n                            if self.opts.get('order_masters'):\n                                log.trace('Sending filtered data to syndic')\n                                pub_sock.send(b'syndic', flags=zmq.SNDMORE)\n                                pub_sock.send(payload)\n                                log.trace('Filtered data has been sent to syndic')\n                        # otherwise its a broadcast\n                        else:\n                            # TODO: constants file for \"broadcast\"\n                            log.trace('Sending broadcasted data over publisher %s', pub_uri)\n                            pub_sock.send(b'broadcast', flags=zmq.SNDMORE)\n                            pub_sock.send(payload)\n                            log.trace('Broadcasted data has been sent')\n                    else:\n                        log.trace('Sending ZMQ-unfiltered data over publisher %s', pub_uri)\n                        pub_sock.send(payload)\n                        log.trace('Unfiltered data has been sent')\n                except zmq.ZMQError as exc:\n                    if exc.errno == errno.EINTR:\n                        continue\n                    raise exc\n\n        except KeyboardInterrupt:\n            log.trace('Publish daemon caught Keyboard interupt, tearing down')\n        # Cleanly close the sockets if we're shutting down\n        if pub_sock.closed is False:\n            pub_sock.close()\n        if pull_sock.closed is False:\n            pull_sock.close()\n        if context.closed is False:\n            context.term()", "language": "python", "code": "def _publish_daemon(self, log_queue=None):\n        '''\n        Bind to the interface specified in the configuration file\n        '''\n        salt.utils.process.appendproctitle(self.__class__.__name__)\n        if log_queue:\n            salt.log.setup.set_multiprocessing_logging_queue(log_queue)\n            salt.log.setup.setup_multiprocessing_logging(log_queue)\n\n        # Set up the context\n        context = zmq.Context(1)\n        # Prepare minion publish socket\n        pub_sock = context.socket(zmq.PUB)\n        _set_tcp_keepalive(pub_sock, self.opts)\n        # if 2.1 >= zmq < 3.0, we only have one HWM setting\n        try:\n            pub_sock.setsockopt(zmq.HWM, self.opts.get('pub_hwm', 1000))\n        # in zmq >= 3.0, there are separate send and receive HWM settings\n        except AttributeError:\n            # Set the High Water Marks. For more information on HWM, see:\n            # http://api.zeromq.org/4-1:zmq-setsockopt\n            pub_sock.setsockopt(zmq.SNDHWM, self.opts.get('pub_hwm', 1000))\n            pub_sock.setsockopt(zmq.RCVHWM, self.opts.get('pub_hwm', 1000))\n        if self.opts['ipv6'] is True and hasattr(zmq, 'IPV4ONLY'):\n            # IPv6 sockets work for both IPv6 and IPv4 addresses\n            pub_sock.setsockopt(zmq.IPV4ONLY, 0)\n        pub_sock.setsockopt(zmq.BACKLOG, self.opts.get('zmq_backlog', 1000))\n        pub_sock.setsockopt(zmq.LINGER, -1)\n        pub_uri = 'tcp://{interface}:{publish_port}'.format(**self.opts)\n        # Prepare minion pull socket\n        pull_sock = context.socket(zmq.PULL)\n        pull_sock.setsockopt(zmq.LINGER, -1)\n\n        if self.opts.get('ipc_mode', '') == 'tcp':\n            pull_uri = 'tcp://127.0.0.1:{0}'.format(\n                self.opts.get('tcp_master_publish_pull', 4514)\n                )\n        else:\n            pull_uri = 'ipc://{0}'.format(\n                os.path.join(self.opts['sock_dir'], 'publish_pull.ipc')\n                )\n        salt.utils.zeromq.check_ipc_path_max_len(pull_uri)\n\n        # Start the minion command publisher\n        log.info('Starting the Salt Publisher on %s', pub_uri)\n        pub_sock.bind(pub_uri)\n\n        # Securely create socket\n        log.info('Starting the Salt Puller on %s', pull_uri)\n        with salt.utils.files.set_umask(0o177):\n            pull_sock.bind(pull_uri)\n\n        try:\n            while True:\n                # Catch and handle EINTR from when this process is sent\n                # SIGUSR1 gracefully so we don't choke and die horribly\n                try:\n                    log.debug('Publish daemon getting data from puller %s', pull_uri)\n                    package = pull_sock.recv()\n                    log.debug('Publish daemon received payload. size=%d', len(package))\n\n                    unpacked_package = salt.payload.unpackage(package)\n                    if six.PY3:\n                        unpacked_package = salt.transport.frame.decode_embedded_strs(unpacked_package)\n                    payload = unpacked_package['payload']\n                    log.trace('Accepted unpacked package from puller')\n                    if self.opts['zmq_filtering']:\n                        # if you have a specific topic list, use that\n                        if 'topic_lst' in unpacked_package:\n                            for topic in unpacked_package['topic_lst']:\n                                log.trace('Sending filtered data over publisher %s', pub_uri)\n                                # zmq filters are substring match, hash the topic\n                                # to avoid collisions\n                                htopic = salt.utils.stringutils.to_bytes(hashlib.sha1(topic).hexdigest())\n                                pub_sock.send(htopic, flags=zmq.SNDMORE)\n                                pub_sock.send(payload)\n                                log.trace('Filtered data has been sent')\n\n                            # Syndic broadcast\n                            if self.opts.get('order_masters'):\n                                log.trace('Sending filtered data to syndic')\n                                pub_sock.send(b'syndic', flags=zmq.SNDMORE)\n                                pub_sock.send(payload)\n                                log.trace('Filtered data has been sent to syndic')\n                        # otherwise its a broadcast\n                        else:\n                            # TODO: constants file for \"broadcast\"\n                            log.trace('Sending broadcasted data over publisher %s', pub_uri)\n                            pub_sock.send(b'broadcast', flags=zmq.SNDMORE)\n                            pub_sock.send(payload)\n                            log.trace('Broadcasted data has been sent')\n                    else:\n                        log.trace('Sending ZMQ-unfiltered data over publisher %s', pub_uri)\n                        pub_sock.send(payload)\n                        log.trace('Unfiltered data has been sent')\n                except zmq.ZMQError as exc:\n                    if exc.errno == errno.EINTR:\n                        continue\n                    raise exc\n\n        except KeyboardInterrupt:\n            log.trace('Publish daemon caught Keyboard interupt, tearing down')\n        # Cleanly close the sockets if we're shutting down\n        if pub_sock.closed is False:\n            pub_sock.close()\n        if pull_sock.closed is False:\n            pull_sock.close()\n        if context.closed is False:\n            context.term()", "code_tokens": ["def", "_publish_daemon", "(", "self", ",", "log_queue", "=", "None", ")", ":", "salt", ".", "utils", ".", "process", ".", "appendproctitle", "(", "self", ".", "__class__", ".", "__name__", ")", "if", "log_queue", ":", "salt", ".", "log", ".", "setup", ".", "set_multiprocessing_logging_queue", "(", "log_queue", ")", "salt", ".", "log", ".", "setup", ".", "setup_multiprocessing_logging", "(", "log_queue", ")", "# Set up the context", "context", "=", "zmq", ".", "Context", "(", "1", ")", "# Prepare minion publish socket", "pub_sock", "=", "context", ".", "socket", "(", "zmq", ".", "PUB", ")", "_set_tcp_keepalive", "(", "pub_sock", ",", "self", ".", "opts", ")", "# if 2.1 >= zmq < 3.0, we only have one HWM setting", "try", ":", "pub_sock", ".", "setsockopt", "(", "zmq", ".", "HWM", ",", "self", ".", "opts", ".", "get", "(", "'pub_hwm'", ",", "1000", ")", ")", "# in zmq >= 3.0, there are separate send and receive HWM settings", "except", "AttributeError", ":", "# Set the High Water Marks. For more information on HWM, see:", "# http://api.zeromq.org/4-1:zmq-setsockopt", "pub_sock", ".", "setsockopt", "(", "zmq", ".", "SNDHWM", ",", "self", ".", "opts", ".", "get", "(", "'pub_hwm'", ",", "1000", ")", ")", "pub_sock", ".", "setsockopt", "(", "zmq", ".", "RCVHWM", ",", "self", ".", "opts", ".", "get", "(", "'pub_hwm'", ",", "1000", ")", ")", "if", "self", ".", "opts", "[", "'ipv6'", "]", "is", "True", "and", "hasattr", "(", "zmq", ",", "'IPV4ONLY'", ")", ":", "# IPv6 sockets work for both IPv6 and IPv4 addresses", "pub_sock", ".", "setsockopt", "(", "zmq", ".", "IPV4ONLY", ",", "0", ")", "pub_sock", ".", "setsockopt", "(", "zmq", ".", "BACKLOG", ",", "self", ".", "opts", ".", "get", "(", "'zmq_backlog'", ",", "1000", ")", ")", "pub_sock", ".", "setsockopt", "(", "zmq", ".", "LINGER", ",", "-", "1", ")", "pub_uri", "=", "'tcp://{interface}:{publish_port}'", ".", "format", "(", "*", "*", "self", ".", "opts", ")", "# Prepare minion pull socket", "pull_sock", "=", "context", ".", "socket", "(", "zmq", ".", "PULL", ")", "pull_sock", ".", "setsockopt", "(", "zmq", ".", "LINGER", ",", "-", "1", ")", "if", "self", ".", "opts", ".", "get", "(", "'ipc_mode'", ",", "''", ")", "==", "'tcp'", ":", "pull_uri", "=", "'tcp://127.0.0.1:{0}'", ".", "format", "(", "self", ".", "opts", ".", "get", "(", "'tcp_master_publish_pull'", ",", "4514", ")", ")", "else", ":", "pull_uri", "=", "'ipc://{0}'", ".", "format", "(", "os", ".", "path", ".", "join", "(", "self", ".", "opts", "[", "'sock_dir'", "]", ",", "'publish_pull.ipc'", ")", ")", "salt", ".", "utils", ".", "zeromq", ".", "check_ipc_path_max_len", "(", "pull_uri", ")", "# Start the minion command publisher", "log", ".", "info", "(", "'Starting the Salt Publisher on %s'", ",", "pub_uri", ")", "pub_sock", ".", "bind", "(", "pub_uri", ")", "# Securely create socket", "log", ".", "info", "(", "'Starting the Salt Puller on %s'", ",", "pull_uri", ")", "with", "salt", ".", "utils", ".", "files", ".", "set_umask", "(", "0o177", ")", ":", "pull_sock", ".", "bind", "(", "pull_uri", ")", "try", ":", "while", "True", ":", "# Catch and handle EINTR from when this process is sent", "# SIGUSR1 gracefully so we don't choke and die horribly", "try", ":", "log", ".", "debug", "(", "'Publish daemon getting data from puller %s'", ",", "pull_uri", ")", "package", "=", "pull_sock", ".", "recv", "(", ")", "log", ".", "debug", "(", "'Publish daemon received payload. size=%d'", ",", "len", "(", "package", ")", ")", "unpacked_package", "=", "salt", ".", "payload", ".", "unpackage", "(", "package", ")", "if", "six", ".", "PY3", ":", "unpacked_package", "=", "salt", ".", "transport", ".", "frame", ".", "decode_embedded_strs", "(", "unpacked_package", ")", "payload", "=", "unpacked_package", "[", "'payload'", "]", "log", ".", "trace", "(", "'Accepted unpacked package from puller'", ")", "if", "self", ".", "opts", "[", "'zmq_filtering'", "]", ":", "# if you have a specific topic list, use that", "if", "'topic_lst'", "in", "unpacked_package", ":", "for", "topic", "in", "unpacked_package", "[", "'topic_lst'", "]", ":", "log", ".", "trace", "(", "'Sending filtered data over publisher %s'", ",", "pub_uri", ")", "# zmq filters are substring match, hash the topic", "# to avoid collisions", "htopic", "=", "salt", ".", "utils", ".", "stringutils", ".", "to_bytes", "(", "hashlib", ".", "sha1", "(", "topic", ")", ".", "hexdigest", "(", ")", ")", "pub_sock", ".", "send", "(", "htopic", ",", "flags", "=", "zmq", ".", "SNDMORE", ")", "pub_sock", ".", "send", "(", "payload", ")", "log", ".", "trace", "(", "'Filtered data has been sent'", ")", "# Syndic broadcast", "if", "self", ".", "opts", ".", "get", "(", "'order_masters'", ")", ":", "log", ".", "trace", "(", "'Sending filtered data to syndic'", ")", "pub_sock", ".", "send", "(", "b'syndic'", ",", "flags", "=", "zmq", ".", "SNDMORE", ")", "pub_sock", ".", "send", "(", "payload", ")", "log", ".", "trace", "(", "'Filtered data has been sent to syndic'", ")", "# otherwise its a broadcast", "else", ":", "# TODO: constants file for \"broadcast\"", "log", ".", "trace", "(", "'Sending broadcasted data over publisher %s'", ",", "pub_uri", ")", "pub_sock", ".", "send", "(", "b'broadcast'", ",", "flags", "=", "zmq", ".", "SNDMORE", ")", "pub_sock", ".", "send", "(", "payload", ")", "log", ".", "trace", "(", "'Broadcasted data has been sent'", ")", "else", ":", "log", ".", "trace", "(", "'Sending ZMQ-unfiltered data over publisher %s'", ",", "pub_uri", ")", "pub_sock", ".", "send", "(", "payload", ")", "log", ".", "trace", "(", "'Unfiltered data has been sent'", ")", "except", "zmq", ".", "ZMQError", "as", "exc", ":", "if", "exc", ".", "errno", "==", "errno", ".", "EINTR", ":", "continue", "raise", "exc", "except", "KeyboardInterrupt", ":", "log", ".", "trace", "(", "'Publish daemon caught Keyboard interupt, tearing down'", ")", "# Cleanly close the sockets if we're shutting down", "if", "pub_sock", ".", "closed", "is", "False", ":", "pub_sock", ".", "close", "(", ")", "if", "pull_sock", ".", "closed", "is", "False", ":", "pull_sock", ".", "close", "(", ")", "if", "context", ".", "closed", "is", "False", ":", "context", ".", "term", "(", ")"], "docstring": "Bind to the interface specified in the configuration file", "docstring_tokens": ["Bind", "to", "the", "interface", "specified", "in", "the", "configuration", "file"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/transport/zeromq.py#L847-L955", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/transport/zeromq.py", "func_name": "ZeroMQPubServerChannel.pub_connect", "original_string": "def pub_connect(self):\n        '''\n        Create and connect this thread's zmq socket. If a publisher socket\n        already exists \"pub_close\" is called before creating and connecting a\n        new socket.\n        '''\n        if self.pub_sock:\n            self.pub_close()\n        ctx = zmq.Context.instance()\n        self._sock_data.sock = ctx.socket(zmq.PUSH)\n        self.pub_sock.setsockopt(zmq.LINGER, -1)\n        if self.opts.get('ipc_mode', '') == 'tcp':\n            pull_uri = 'tcp://127.0.0.1:{0}'.format(\n                self.opts.get('tcp_master_publish_pull', 4514)\n                )\n        else:\n            pull_uri = 'ipc://{0}'.format(\n                os.path.join(self.opts['sock_dir'], 'publish_pull.ipc')\n                )\n        log.debug(\"Connecting to pub server: %s\", pull_uri)\n        self.pub_sock.connect(pull_uri)\n        return self._sock_data.sock", "language": "python", "code": "def pub_connect(self):\n        '''\n        Create and connect this thread's zmq socket. If a publisher socket\n        already exists \"pub_close\" is called before creating and connecting a\n        new socket.\n        '''\n        if self.pub_sock:\n            self.pub_close()\n        ctx = zmq.Context.instance()\n        self._sock_data.sock = ctx.socket(zmq.PUSH)\n        self.pub_sock.setsockopt(zmq.LINGER, -1)\n        if self.opts.get('ipc_mode', '') == 'tcp':\n            pull_uri = 'tcp://127.0.0.1:{0}'.format(\n                self.opts.get('tcp_master_publish_pull', 4514)\n                )\n        else:\n            pull_uri = 'ipc://{0}'.format(\n                os.path.join(self.opts['sock_dir'], 'publish_pull.ipc')\n                )\n        log.debug(\"Connecting to pub server: %s\", pull_uri)\n        self.pub_sock.connect(pull_uri)\n        return self._sock_data.sock", "code_tokens": ["def", "pub_connect", "(", "self", ")", ":", "if", "self", ".", "pub_sock", ":", "self", ".", "pub_close", "(", ")", "ctx", "=", "zmq", ".", "Context", ".", "instance", "(", ")", "self", ".", "_sock_data", ".", "sock", "=", "ctx", ".", "socket", "(", "zmq", ".", "PUSH", ")", "self", ".", "pub_sock", ".", "setsockopt", "(", "zmq", ".", "LINGER", ",", "-", "1", ")", "if", "self", ".", "opts", ".", "get", "(", "'ipc_mode'", ",", "''", ")", "==", "'tcp'", ":", "pull_uri", "=", "'tcp://127.0.0.1:{0}'", ".", "format", "(", "self", ".", "opts", ".", "get", "(", "'tcp_master_publish_pull'", ",", "4514", ")", ")", "else", ":", "pull_uri", "=", "'ipc://{0}'", ".", "format", "(", "os", ".", "path", ".", "join", "(", "self", ".", "opts", "[", "'sock_dir'", "]", ",", "'publish_pull.ipc'", ")", ")", "log", ".", "debug", "(", "\"Connecting to pub server: %s\"", ",", "pull_uri", ")", "self", ".", "pub_sock", ".", "connect", "(", "pull_uri", ")", "return", "self", ".", "_sock_data", ".", "sock"], "docstring": "Create and connect this thread's zmq socket. If a publisher socket\n        already exists \"pub_close\" is called before creating and connecting a\n        new socket.", "docstring_tokens": ["Create", "and", "connect", "this", "thread", "s", "zmq", "socket", ".", "If", "a", "publisher", "socket", "already", "exists", "pub_close", "is", "called", "before", "creating", "and", "connecting", "a", "new", "socket", "."], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/transport/zeromq.py#L979-L1000", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/transport/zeromq.py", "func_name": "ZeroMQPubServerChannel.pub_close", "original_string": "def pub_close(self):\n        '''\n        Disconnect an existing publisher socket and remove it from the local\n        thread's cache.\n        '''\n        if hasattr(self._sock_data, 'sock'):\n            self._sock_data.sock.close()\n            delattr(self._sock_data, 'sock')", "language": "python", "code": "def pub_close(self):\n        '''\n        Disconnect an existing publisher socket and remove it from the local\n        thread's cache.\n        '''\n        if hasattr(self._sock_data, 'sock'):\n            self._sock_data.sock.close()\n            delattr(self._sock_data, 'sock')", "code_tokens": ["def", "pub_close", "(", "self", ")", ":", "if", "hasattr", "(", "self", ".", "_sock_data", ",", "'sock'", ")", ":", "self", ".", "_sock_data", ".", "sock", ".", "close", "(", ")", "delattr", "(", "self", ".", "_sock_data", ",", "'sock'", ")"], "docstring": "Disconnect an existing publisher socket and remove it from the local\n        thread's cache.", "docstring_tokens": ["Disconnect", "an", "existing", "publisher", "socket", "and", "remove", "it", "from", "the", "local", "thread", "s", "cache", "."], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/transport/zeromq.py#L1002-L1009", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/transport/zeromq.py", "func_name": "ZeroMQPubServerChannel.publish", "original_string": "def publish(self, load):\n        '''\n        Publish \"load\" to minions. This send the load to the publisher daemon\n        process with does the actual sending to minions.\n\n        :param dict load: A load to be sent across the wire to minions\n        '''\n        payload = {'enc': 'aes'}\n        crypticle = salt.crypt.Crypticle(self.opts, salt.master.SMaster.secrets['aes']['secret'].value)\n        payload['load'] = crypticle.dumps(load)\n        if self.opts['sign_pub_messages']:\n            master_pem_path = os.path.join(self.opts['pki_dir'], 'master.pem')\n            log.debug(\"Signing data packet\")\n            payload['sig'] = salt.crypt.sign_message(master_pem_path, payload['load'])\n        int_payload = {'payload': self.serial.dumps(payload)}\n\n        # add some targeting stuff for lists only (for now)\n        if load['tgt_type'] == 'list':\n            int_payload['topic_lst'] = load['tgt']\n\n        # If zmq_filtering is enabled, target matching has to happen master side\n        match_targets = [\"pcre\", \"glob\", \"list\"]\n        if self.opts['zmq_filtering'] and load['tgt_type'] in match_targets:\n            # Fetch a list of minions that match\n            _res = self.ckminions.check_minions(load['tgt'],\n                                                tgt_type=load['tgt_type'])\n            match_ids = _res['minions']\n\n            log.debug(\"Publish Side Match: %s\", match_ids)\n            # Send list of miions thru so zmq can target them\n            int_payload['topic_lst'] = match_ids\n        payload = self.serial.dumps(int_payload)\n        log.debug(\n            'Sending payload to publish daemon. jid=%s size=%d',\n            load.get('jid', None), len(payload),\n        )\n        if not self.pub_sock:\n            self.pub_connect()\n        self.pub_sock.send(payload)\n        log.debug('Sent payload to publish daemon.')", "language": "python", "code": "def publish(self, load):\n        '''\n        Publish \"load\" to minions. This send the load to the publisher daemon\n        process with does the actual sending to minions.\n\n        :param dict load: A load to be sent across the wire to minions\n        '''\n        payload = {'enc': 'aes'}\n        crypticle = salt.crypt.Crypticle(self.opts, salt.master.SMaster.secrets['aes']['secret'].value)\n        payload['load'] = crypticle.dumps(load)\n        if self.opts['sign_pub_messages']:\n            master_pem_path = os.path.join(self.opts['pki_dir'], 'master.pem')\n            log.debug(\"Signing data packet\")\n            payload['sig'] = salt.crypt.sign_message(master_pem_path, payload['load'])\n        int_payload = {'payload': self.serial.dumps(payload)}\n\n        # add some targeting stuff for lists only (for now)\n        if load['tgt_type'] == 'list':\n            int_payload['topic_lst'] = load['tgt']\n\n        # If zmq_filtering is enabled, target matching has to happen master side\n        match_targets = [\"pcre\", \"glob\", \"list\"]\n        if self.opts['zmq_filtering'] and load['tgt_type'] in match_targets:\n            # Fetch a list of minions that match\n            _res = self.ckminions.check_minions(load['tgt'],\n                                                tgt_type=load['tgt_type'])\n            match_ids = _res['minions']\n\n            log.debug(\"Publish Side Match: %s\", match_ids)\n            # Send list of miions thru so zmq can target them\n            int_payload['topic_lst'] = match_ids\n        payload = self.serial.dumps(int_payload)\n        log.debug(\n            'Sending payload to publish daemon. jid=%s size=%d',\n            load.get('jid', None), len(payload),\n        )\n        if not self.pub_sock:\n            self.pub_connect()\n        self.pub_sock.send(payload)\n        log.debug('Sent payload to publish daemon.')", "code_tokens": ["def", "publish", "(", "self", ",", "load", ")", ":", "payload", "=", "{", "'enc'", ":", "'aes'", "}", "crypticle", "=", "salt", ".", "crypt", ".", "Crypticle", "(", "self", ".", "opts", ",", "salt", ".", "master", ".", "SMaster", ".", "secrets", "[", "'aes'", "]", "[", "'secret'", "]", ".", "value", ")", "payload", "[", "'load'", "]", "=", "crypticle", ".", "dumps", "(", "load", ")", "if", "self", ".", "opts", "[", "'sign_pub_messages'", "]", ":", "master_pem_path", "=", "os", ".", "path", ".", "join", "(", "self", ".", "opts", "[", "'pki_dir'", "]", ",", "'master.pem'", ")", "log", ".", "debug", "(", "\"Signing data packet\"", ")", "payload", "[", "'sig'", "]", "=", "salt", ".", "crypt", ".", "sign_message", "(", "master_pem_path", ",", "payload", "[", "'load'", "]", ")", "int_payload", "=", "{", "'payload'", ":", "self", ".", "serial", ".", "dumps", "(", "payload", ")", "}", "# add some targeting stuff for lists only (for now)", "if", "load", "[", "'tgt_type'", "]", "==", "'list'", ":", "int_payload", "[", "'topic_lst'", "]", "=", "load", "[", "'tgt'", "]", "# If zmq_filtering is enabled, target matching has to happen master side", "match_targets", "=", "[", "\"pcre\"", ",", "\"glob\"", ",", "\"list\"", "]", "if", "self", ".", "opts", "[", "'zmq_filtering'", "]", "and", "load", "[", "'tgt_type'", "]", "in", "match_targets", ":", "# Fetch a list of minions that match", "_res", "=", "self", ".", "ckminions", ".", "check_minions", "(", "load", "[", "'tgt'", "]", ",", "tgt_type", "=", "load", "[", "'tgt_type'", "]", ")", "match_ids", "=", "_res", "[", "'minions'", "]", "log", ".", "debug", "(", "\"Publish Side Match: %s\"", ",", "match_ids", ")", "# Send list of miions thru so zmq can target them", "int_payload", "[", "'topic_lst'", "]", "=", "match_ids", "payload", "=", "self", ".", "serial", ".", "dumps", "(", "int_payload", ")", "log", ".", "debug", "(", "'Sending payload to publish daemon. jid=%s size=%d'", ",", "load", ".", "get", "(", "'jid'", ",", "None", ")", ",", "len", "(", "payload", ")", ",", ")", "if", "not", "self", ".", "pub_sock", ":", "self", ".", "pub_connect", "(", ")", "self", ".", "pub_sock", ".", "send", "(", "payload", ")", "log", ".", "debug", "(", "'Sent payload to publish daemon.'", ")"], "docstring": "Publish \"load\" to minions. This send the load to the publisher daemon\n        process with does the actual sending to minions.\n\n        :param dict load: A load to be sent across the wire to minions", "docstring_tokens": ["Publish", "load", "to", "minions", ".", "This", "send", "the", "load", "to", "the", "publisher", "daemon", "process", "with", "does", "the", "actual", "sending", "to", "minions", "."], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/transport/zeromq.py#L1011-L1050", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/transport/zeromq.py", "func_name": "AsyncReqMessageClient.timeout_message", "original_string": "def timeout_message(self, message):\n        '''\n        Handle a message timeout by removing it from the sending queue\n        and informing the caller\n\n        :raises: SaltReqTimeoutError\n        '''\n        future = self.send_future_map.pop(message, None)\n        # In a race condition the message might have been sent by the time\n        # we're timing it out. Make sure the future is not None\n        if future is not None:\n            del self.send_timeout_map[message]\n            if future.attempts < future.tries:\n                future.attempts += 1\n                log.debug('SaltReqTimeoutError, retrying. (%s/%s)', future.attempts, future.tries)\n                self.send(\n                    message,\n                    timeout=future.timeout,\n                    tries=future.tries,\n                    future=future,\n                )\n\n            else:\n                future.set_exception(SaltReqTimeoutError('Message timed out'))", "language": "python", "code": "def timeout_message(self, message):\n        '''\n        Handle a message timeout by removing it from the sending queue\n        and informing the caller\n\n        :raises: SaltReqTimeoutError\n        '''\n        future = self.send_future_map.pop(message, None)\n        # In a race condition the message might have been sent by the time\n        # we're timing it out. Make sure the future is not None\n        if future is not None:\n            del self.send_timeout_map[message]\n            if future.attempts < future.tries:\n                future.attempts += 1\n                log.debug('SaltReqTimeoutError, retrying. (%s/%s)', future.attempts, future.tries)\n                self.send(\n                    message,\n                    timeout=future.timeout,\n                    tries=future.tries,\n                    future=future,\n                )\n\n            else:\n                future.set_exception(SaltReqTimeoutError('Message timed out'))", "code_tokens": ["def", "timeout_message", "(", "self", ",", "message", ")", ":", "future", "=", "self", ".", "send_future_map", ".", "pop", "(", "message", ",", "None", ")", "# In a race condition the message might have been sent by the time", "# we're timing it out. Make sure the future is not None", "if", "future", "is", "not", "None", ":", "del", "self", ".", "send_timeout_map", "[", "message", "]", "if", "future", ".", "attempts", "<", "future", ".", "tries", ":", "future", ".", "attempts", "+=", "1", "log", ".", "debug", "(", "'SaltReqTimeoutError, retrying. (%s/%s)'", ",", "future", ".", "attempts", ",", "future", ".", "tries", ")", "self", ".", "send", "(", "message", ",", "timeout", "=", "future", ".", "timeout", ",", "tries", "=", "future", ".", "tries", ",", "future", "=", "future", ",", ")", "else", ":", "future", ".", "set_exception", "(", "SaltReqTimeoutError", "(", "'Message timed out'", ")", ")"], "docstring": "Handle a message timeout by removing it from the sending queue\n        and informing the caller\n\n        :raises: SaltReqTimeoutError", "docstring_tokens": ["Handle", "a", "message", "timeout", "by", "removing", "it", "from", "the", "sending", "queue", "and", "informing", "the", "caller"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/transport/zeromq.py#L1230-L1253", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/transport/zeromq.py", "func_name": "AsyncReqMessageClient.send", "original_string": "def send(self, message, timeout=None, tries=3, future=None, callback=None, raw=False):\n        '''\n        Return a future which will be completed when the message has a response\n        '''\n        if future is None:\n            future = tornado.concurrent.Future()\n            future.tries = tries\n            future.attempts = 0\n            future.timeout = timeout\n            # if a future wasn't passed in, we need to serialize the message\n            message = self.serial.dumps(message)\n        if callback is not None:\n            def handle_future(future):\n                response = future.result()\n                self.io_loop.add_callback(callback, response)\n            future.add_done_callback(handle_future)\n        # Add this future to the mapping\n        self.send_future_map[message] = future\n\n        if self.opts.get('detect_mode') is True:\n            timeout = 1\n\n        if timeout is not None:\n            send_timeout = self.io_loop.call_later(timeout, self.timeout_message, message)\n            self.send_timeout_map[message] = send_timeout\n\n        if not self.send_queue:\n            self.io_loop.spawn_callback(self._internal_send_recv)\n\n        self.send_queue.append(message)\n\n        return future", "language": "python", "code": "def send(self, message, timeout=None, tries=3, future=None, callback=None, raw=False):\n        '''\n        Return a future which will be completed when the message has a response\n        '''\n        if future is None:\n            future = tornado.concurrent.Future()\n            future.tries = tries\n            future.attempts = 0\n            future.timeout = timeout\n            # if a future wasn't passed in, we need to serialize the message\n            message = self.serial.dumps(message)\n        if callback is not None:\n            def handle_future(future):\n                response = future.result()\n                self.io_loop.add_callback(callback, response)\n            future.add_done_callback(handle_future)\n        # Add this future to the mapping\n        self.send_future_map[message] = future\n\n        if self.opts.get('detect_mode') is True:\n            timeout = 1\n\n        if timeout is not None:\n            send_timeout = self.io_loop.call_later(timeout, self.timeout_message, message)\n            self.send_timeout_map[message] = send_timeout\n\n        if not self.send_queue:\n            self.io_loop.spawn_callback(self._internal_send_recv)\n\n        self.send_queue.append(message)\n\n        return future", "code_tokens": ["def", "send", "(", "self", ",", "message", ",", "timeout", "=", "None", ",", "tries", "=", "3", ",", "future", "=", "None", ",", "callback", "=", "None", ",", "raw", "=", "False", ")", ":", "if", "future", "is", "None", ":", "future", "=", "tornado", ".", "concurrent", ".", "Future", "(", ")", "future", ".", "tries", "=", "tries", "future", ".", "attempts", "=", "0", "future", ".", "timeout", "=", "timeout", "# if a future wasn't passed in, we need to serialize the message", "message", "=", "self", ".", "serial", ".", "dumps", "(", "message", ")", "if", "callback", "is", "not", "None", ":", "def", "handle_future", "(", "future", ")", ":", "response", "=", "future", ".", "result", "(", ")", "self", ".", "io_loop", ".", "add_callback", "(", "callback", ",", "response", ")", "future", ".", "add_done_callback", "(", "handle_future", ")", "# Add this future to the mapping", "self", ".", "send_future_map", "[", "message", "]", "=", "future", "if", "self", ".", "opts", ".", "get", "(", "'detect_mode'", ")", "is", "True", ":", "timeout", "=", "1", "if", "timeout", "is", "not", "None", ":", "send_timeout", "=", "self", ".", "io_loop", ".", "call_later", "(", "timeout", ",", "self", ".", "timeout_message", ",", "message", ")", "self", ".", "send_timeout_map", "[", "message", "]", "=", "send_timeout", "if", "not", "self", ".", "send_queue", ":", "self", ".", "io_loop", ".", "spawn_callback", "(", "self", ".", "_internal_send_recv", ")", "self", ".", "send_queue", ".", "append", "(", "message", ")", "return", "future"], "docstring": "Return a future which will be completed when the message has a response", "docstring_tokens": ["Return", "a", "future", "which", "will", "be", "completed", "when", "the", "message", "has", "a", "response"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/transport/zeromq.py#L1255-L1286", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/modules/elasticsearch.py", "func_name": "_get_instance", "original_string": "def _get_instance(hosts=None, profile=None):\n    '''\n    Return the elasticsearch instance\n    '''\n    es = None\n    proxies = None\n    use_ssl = False\n    ca_certs = None\n    verify_certs = True\n    http_auth = None\n    timeout = 10\n\n    if profile is None:\n        profile = 'elasticsearch'\n\n    if isinstance(profile, six.string_types):\n        _profile = __salt__['config.option'](profile, None)\n    elif isinstance(profile, dict):\n        _profile = profile\n    if _profile:\n        hosts = _profile.get('host', hosts)\n        if not hosts:\n            hosts = _profile.get('hosts', hosts)\n        proxies = _profile.get('proxies', None)\n        use_ssl = _profile.get('use_ssl', False)\n        ca_certs = _profile.get('ca_certs', None)\n        verify_certs = _profile.get('verify_certs', True)\n        username = _profile.get('username', None)\n        password = _profile.get('password', None)\n        timeout = _profile.get('timeout', 10)\n\n        if username and password:\n            http_auth = (username, password)\n\n    if not hosts:\n        hosts = ['127.0.0.1:9200']\n    if isinstance(hosts, six.string_types):\n        hosts = [hosts]\n    try:\n        if proxies:\n            # Custom connection class to use requests module with proxies\n            class ProxyConnection(RequestsHttpConnection):\n                def __init__(self, *args, **kwargs):\n                    proxies = kwargs.pop('proxies', {})\n                    super(ProxyConnection, self).__init__(*args, **kwargs)\n                    self.session.proxies = proxies\n\n            es = elasticsearch.Elasticsearch(\n                hosts,\n                connection_class=ProxyConnection,\n                proxies=proxies,\n                use_ssl=use_ssl,\n                ca_certs=ca_certs,\n                verify_certs=verify_certs,\n                http_auth=http_auth,\n                timeout=timeout,\n            )\n        else:\n            es = elasticsearch.Elasticsearch(\n                    hosts,\n                    use_ssl=use_ssl,\n                    ca_certs=ca_certs,\n                    verify_certs=verify_certs,\n                    http_auth=http_auth,\n                    timeout=timeout,\n                )\n\n        # Try the connection\n        es.info()\n    except elasticsearch.exceptions.TransportError as err:\n        raise CommandExecutionError(\n            'Could not connect to Elasticsearch host/ cluster {0} due to {1}'.format(hosts, err))\n    return es", "language": "python", "code": "def _get_instance(hosts=None, profile=None):\n    '''\n    Return the elasticsearch instance\n    '''\n    es = None\n    proxies = None\n    use_ssl = False\n    ca_certs = None\n    verify_certs = True\n    http_auth = None\n    timeout = 10\n\n    if profile is None:\n        profile = 'elasticsearch'\n\n    if isinstance(profile, six.string_types):\n        _profile = __salt__['config.option'](profile, None)\n    elif isinstance(profile, dict):\n        _profile = profile\n    if _profile:\n        hosts = _profile.get('host', hosts)\n        if not hosts:\n            hosts = _profile.get('hosts', hosts)\n        proxies = _profile.get('proxies', None)\n        use_ssl = _profile.get('use_ssl', False)\n        ca_certs = _profile.get('ca_certs', None)\n        verify_certs = _profile.get('verify_certs', True)\n        username = _profile.get('username', None)\n        password = _profile.get('password', None)\n        timeout = _profile.get('timeout', 10)\n\n        if username and password:\n            http_auth = (username, password)\n\n    if not hosts:\n        hosts = ['127.0.0.1:9200']\n    if isinstance(hosts, six.string_types):\n        hosts = [hosts]\n    try:\n        if proxies:\n            # Custom connection class to use requests module with proxies\n            class ProxyConnection(RequestsHttpConnection):\n                def __init__(self, *args, **kwargs):\n                    proxies = kwargs.pop('proxies', {})\n                    super(ProxyConnection, self).__init__(*args, **kwargs)\n                    self.session.proxies = proxies\n\n            es = elasticsearch.Elasticsearch(\n                hosts,\n                connection_class=ProxyConnection,\n                proxies=proxies,\n                use_ssl=use_ssl,\n                ca_certs=ca_certs,\n                verify_certs=verify_certs,\n                http_auth=http_auth,\n                timeout=timeout,\n            )\n        else:\n            es = elasticsearch.Elasticsearch(\n                    hosts,\n                    use_ssl=use_ssl,\n                    ca_certs=ca_certs,\n                    verify_certs=verify_certs,\n                    http_auth=http_auth,\n                    timeout=timeout,\n                )\n\n        # Try the connection\n        es.info()\n    except elasticsearch.exceptions.TransportError as err:\n        raise CommandExecutionError(\n            'Could not connect to Elasticsearch host/ cluster {0} due to {1}'.format(hosts, err))\n    return es", "code_tokens": ["def", "_get_instance", "(", "hosts", "=", "None", ",", "profile", "=", "None", ")", ":", "es", "=", "None", "proxies", "=", "None", "use_ssl", "=", "False", "ca_certs", "=", "None", "verify_certs", "=", "True", "http_auth", "=", "None", "timeout", "=", "10", "if", "profile", "is", "None", ":", "profile", "=", "'elasticsearch'", "if", "isinstance", "(", "profile", ",", "six", ".", "string_types", ")", ":", "_profile", "=", "__salt__", "[", "'config.option'", "]", "(", "profile", ",", "None", ")", "elif", "isinstance", "(", "profile", ",", "dict", ")", ":", "_profile", "=", "profile", "if", "_profile", ":", "hosts", "=", "_profile", ".", "get", "(", "'host'", ",", "hosts", ")", "if", "not", "hosts", ":", "hosts", "=", "_profile", ".", "get", "(", "'hosts'", ",", "hosts", ")", "proxies", "=", "_profile", ".", "get", "(", "'proxies'", ",", "None", ")", "use_ssl", "=", "_profile", ".", "get", "(", "'use_ssl'", ",", "False", ")", "ca_certs", "=", "_profile", ".", "get", "(", "'ca_certs'", ",", "None", ")", "verify_certs", "=", "_profile", ".", "get", "(", "'verify_certs'", ",", "True", ")", "username", "=", "_profile", ".", "get", "(", "'username'", ",", "None", ")", "password", "=", "_profile", ".", "get", "(", "'password'", ",", "None", ")", "timeout", "=", "_profile", ".", "get", "(", "'timeout'", ",", "10", ")", "if", "username", "and", "password", ":", "http_auth", "=", "(", "username", ",", "password", ")", "if", "not", "hosts", ":", "hosts", "=", "[", "'127.0.0.1:9200'", "]", "if", "isinstance", "(", "hosts", ",", "six", ".", "string_types", ")", ":", "hosts", "=", "[", "hosts", "]", "try", ":", "if", "proxies", ":", "# Custom connection class to use requests module with proxies", "class", "ProxyConnection", "(", "RequestsHttpConnection", ")", ":", "def", "__init__", "(", "self", ",", "*", "args", ",", "*", "*", "kwargs", ")", ":", "proxies", "=", "kwargs", ".", "pop", "(", "'proxies'", ",", "{", "}", ")", "super", "(", "ProxyConnection", ",", "self", ")", ".", "__init__", "(", "*", "args", ",", "*", "*", "kwargs", ")", "self", ".", "session", ".", "proxies", "=", "proxies", "es", "=", "elasticsearch", ".", "Elasticsearch", "(", "hosts", ",", "connection_class", "=", "ProxyConnection", ",", "proxies", "=", "proxies", ",", "use_ssl", "=", "use_ssl", ",", "ca_certs", "=", "ca_certs", ",", "verify_certs", "=", "verify_certs", ",", "http_auth", "=", "http_auth", ",", "timeout", "=", "timeout", ",", ")", "else", ":", "es", "=", "elasticsearch", ".", "Elasticsearch", "(", "hosts", ",", "use_ssl", "=", "use_ssl", ",", "ca_certs", "=", "ca_certs", ",", "verify_certs", "=", "verify_certs", ",", "http_auth", "=", "http_auth", ",", "timeout", "=", "timeout", ",", ")", "# Try the connection", "es", ".", "info", "(", ")", "except", "elasticsearch", ".", "exceptions", ".", "TransportError", "as", "err", ":", "raise", "CommandExecutionError", "(", "'Could not connect to Elasticsearch host/ cluster {0} due to {1}'", ".", "format", "(", "hosts", ",", "err", ")", ")", "return", "es"], "docstring": "Return the elasticsearch instance", "docstring_tokens": ["Return", "the", "elasticsearch", "instance"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/modules/elasticsearch.py#L81-L153", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/modules/elasticsearch.py", "func_name": "ping", "original_string": "def ping(allow_failure=False, hosts=None, profile=None):\n    '''\n    .. versionadded:: 2017.7.0\n\n    Test connection to Elasticsearch instance. This method does not fail if not explicitly specified.\n\n    allow_failure\n        Throw exception if ping fails\n\n    CLI example::\n\n        salt myminion elasticsearch.ping allow_failure=True\n        salt myminion elasticsearch.ping profile=elasticsearch-extra\n    '''\n    try:\n        _get_instance(hosts, profile)\n    except CommandExecutionError as e:\n        if allow_failure:\n            raise e\n        return False\n    return True", "language": "python", "code": "def ping(allow_failure=False, hosts=None, profile=None):\n    '''\n    .. versionadded:: 2017.7.0\n\n    Test connection to Elasticsearch instance. This method does not fail if not explicitly specified.\n\n    allow_failure\n        Throw exception if ping fails\n\n    CLI example::\n\n        salt myminion elasticsearch.ping allow_failure=True\n        salt myminion elasticsearch.ping profile=elasticsearch-extra\n    '''\n    try:\n        _get_instance(hosts, profile)\n    except CommandExecutionError as e:\n        if allow_failure:\n            raise e\n        return False\n    return True", "code_tokens": ["def", "ping", "(", "allow_failure", "=", "False", ",", "hosts", "=", "None", ",", "profile", "=", "None", ")", ":", "try", ":", "_get_instance", "(", "hosts", ",", "profile", ")", "except", "CommandExecutionError", "as", "e", ":", "if", "allow_failure", ":", "raise", "e", "return", "False", "return", "True"], "docstring": ".. versionadded:: 2017.7.0\n\n    Test connection to Elasticsearch instance. This method does not fail if not explicitly specified.\n\n    allow_failure\n        Throw exception if ping fails\n\n    CLI example::\n\n        salt myminion elasticsearch.ping allow_failure=True\n        salt myminion elasticsearch.ping profile=elasticsearch-extra", "docstring_tokens": ["..", "versionadded", "::", "2017", ".", "7", ".", "0"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/modules/elasticsearch.py#L156-L176", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/modules/elasticsearch.py", "func_name": "info", "original_string": "def info(hosts=None, profile=None):\n    '''\n    .. versionadded:: 2017.7.0\n\n    Return Elasticsearch information.\n\n    CLI example::\n\n        salt myminion elasticsearch.info\n        salt myminion elasticsearch.info profile=elasticsearch-extra\n    '''\n    es = _get_instance(hosts, profile)\n\n    try:\n        return es.info()\n    except elasticsearch.TransportError as e:\n        raise CommandExecutionError(\"Cannot retrieve server information, server returned code {0} with message {1}\".format(e.status_code, e.error))", "language": "python", "code": "def info(hosts=None, profile=None):\n    '''\n    .. versionadded:: 2017.7.0\n\n    Return Elasticsearch information.\n\n    CLI example::\n\n        salt myminion elasticsearch.info\n        salt myminion elasticsearch.info profile=elasticsearch-extra\n    '''\n    es = _get_instance(hosts, profile)\n\n    try:\n        return es.info()\n    except elasticsearch.TransportError as e:\n        raise CommandExecutionError(\"Cannot retrieve server information, server returned code {0} with message {1}\".format(e.status_code, e.error))", "code_tokens": ["def", "info", "(", "hosts", "=", "None", ",", "profile", "=", "None", ")", ":", "es", "=", "_get_instance", "(", "hosts", ",", "profile", ")", "try", ":", "return", "es", ".", "info", "(", ")", "except", "elasticsearch", ".", "TransportError", "as", "e", ":", "raise", "CommandExecutionError", "(", "\"Cannot retrieve server information, server returned code {0} with message {1}\"", ".", "format", "(", "e", ".", "status_code", ",", "e", ".", "error", ")", ")"], "docstring": ".. versionadded:: 2017.7.0\n\n    Return Elasticsearch information.\n\n    CLI example::\n\n        salt myminion elasticsearch.info\n        salt myminion elasticsearch.info profile=elasticsearch-extra", "docstring_tokens": ["..", "versionadded", "::", "2017", ".", "7", ".", "0"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/modules/elasticsearch.py#L179-L195", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/modules/elasticsearch.py", "func_name": "node_info", "original_string": "def node_info(nodes=None, flat_settings=False, hosts=None, profile=None):\n    '''\n    .. versionadded:: 2017.7.0\n\n    Return Elasticsearch node information.\n\n    nodes\n        List of cluster nodes (id or name) to display stats for. Use _local for connected node, empty for all\n    flat_settings\n        Flatten settings keys\n\n    CLI example::\n\n        salt myminion elasticsearch.node_info flat_settings=True\n    '''\n    es = _get_instance(hosts, profile)\n\n    try:\n        return es.nodes.info(node_id=nodes, flat_settings=flat_settings)\n    except elasticsearch.TransportError as e:\n        raise CommandExecutionError(\"Cannot retrieve node information, server returned code {0} with message {1}\".format(e.status_code, e.error))", "language": "python", "code": "def node_info(nodes=None, flat_settings=False, hosts=None, profile=None):\n    '''\n    .. versionadded:: 2017.7.0\n\n    Return Elasticsearch node information.\n\n    nodes\n        List of cluster nodes (id or name) to display stats for. Use _local for connected node, empty for all\n    flat_settings\n        Flatten settings keys\n\n    CLI example::\n\n        salt myminion elasticsearch.node_info flat_settings=True\n    '''\n    es = _get_instance(hosts, profile)\n\n    try:\n        return es.nodes.info(node_id=nodes, flat_settings=flat_settings)\n    except elasticsearch.TransportError as e:\n        raise CommandExecutionError(\"Cannot retrieve node information, server returned code {0} with message {1}\".format(e.status_code, e.error))", "code_tokens": ["def", "node_info", "(", "nodes", "=", "None", ",", "flat_settings", "=", "False", ",", "hosts", "=", "None", ",", "profile", "=", "None", ")", ":", "es", "=", "_get_instance", "(", "hosts", ",", "profile", ")", "try", ":", "return", "es", ".", "nodes", ".", "info", "(", "node_id", "=", "nodes", ",", "flat_settings", "=", "flat_settings", ")", "except", "elasticsearch", ".", "TransportError", "as", "e", ":", "raise", "CommandExecutionError", "(", "\"Cannot retrieve node information, server returned code {0} with message {1}\"", ".", "format", "(", "e", ".", "status_code", ",", "e", ".", "error", ")", ")"], "docstring": ".. versionadded:: 2017.7.0\n\n    Return Elasticsearch node information.\n\n    nodes\n        List of cluster nodes (id or name) to display stats for. Use _local for connected node, empty for all\n    flat_settings\n        Flatten settings keys\n\n    CLI example::\n\n        salt myminion elasticsearch.node_info flat_settings=True", "docstring_tokens": ["..", "versionadded", "::", "2017", ".", "7", ".", "0"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/modules/elasticsearch.py#L198-L218", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/modules/elasticsearch.py", "func_name": "cluster_health", "original_string": "def cluster_health(index=None, level='cluster', local=False, hosts=None, profile=None):\n    '''\n    .. versionadded:: 2017.7.0\n\n    Return Elasticsearch cluster health.\n\n    index\n        Limit the information returned to a specific index\n    level\n        Specify the level of detail for returned information, default 'cluster', valid choices are: 'cluster', 'indices', 'shards'\n    local\n        Return local information, do not retrieve the state from master node\n\n    CLI example::\n\n        salt myminion elasticsearch.cluster_health\n    '''\n    es = _get_instance(hosts, profile)\n\n    try:\n        return es.cluster.health(index=index, level=level, local=local)\n    except elasticsearch.TransportError as e:\n        raise CommandExecutionError(\"Cannot retrieve health information, server returned code {0} with message {1}\".format(e.status_code, e.error))", "language": "python", "code": "def cluster_health(index=None, level='cluster', local=False, hosts=None, profile=None):\n    '''\n    .. versionadded:: 2017.7.0\n\n    Return Elasticsearch cluster health.\n\n    index\n        Limit the information returned to a specific index\n    level\n        Specify the level of detail for returned information, default 'cluster', valid choices are: 'cluster', 'indices', 'shards'\n    local\n        Return local information, do not retrieve the state from master node\n\n    CLI example::\n\n        salt myminion elasticsearch.cluster_health\n    '''\n    es = _get_instance(hosts, profile)\n\n    try:\n        return es.cluster.health(index=index, level=level, local=local)\n    except elasticsearch.TransportError as e:\n        raise CommandExecutionError(\"Cannot retrieve health information, server returned code {0} with message {1}\".format(e.status_code, e.error))", "code_tokens": ["def", "cluster_health", "(", "index", "=", "None", ",", "level", "=", "'cluster'", ",", "local", "=", "False", ",", "hosts", "=", "None", ",", "profile", "=", "None", ")", ":", "es", "=", "_get_instance", "(", "hosts", ",", "profile", ")", "try", ":", "return", "es", ".", "cluster", ".", "health", "(", "index", "=", "index", ",", "level", "=", "level", ",", "local", "=", "local", ")", "except", "elasticsearch", ".", "TransportError", "as", "e", ":", "raise", "CommandExecutionError", "(", "\"Cannot retrieve health information, server returned code {0} with message {1}\"", ".", "format", "(", "e", ".", "status_code", ",", "e", ".", "error", ")", ")"], "docstring": ".. versionadded:: 2017.7.0\n\n    Return Elasticsearch cluster health.\n\n    index\n        Limit the information returned to a specific index\n    level\n        Specify the level of detail for returned information, default 'cluster', valid choices are: 'cluster', 'indices', 'shards'\n    local\n        Return local information, do not retrieve the state from master node\n\n    CLI example::\n\n        salt myminion elasticsearch.cluster_health", "docstring_tokens": ["..", "versionadded", "::", "2017", ".", "7", ".", "0"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/modules/elasticsearch.py#L221-L243", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/modules/elasticsearch.py", "func_name": "cluster_stats", "original_string": "def cluster_stats(nodes=None, hosts=None, profile=None):\n    '''\n    .. versionadded:: 2017.7.0\n\n    Return Elasticsearch cluster stats.\n\n    nodes\n        List of cluster nodes (id or name) to display stats for. Use _local for connected node, empty for all\n\n    CLI example::\n\n        salt myminion elasticsearch.cluster_stats\n    '''\n    es = _get_instance(hosts, profile)\n\n    try:\n        return es.cluster.stats(node_id=nodes)\n    except elasticsearch.TransportError as e:\n        raise CommandExecutionError(\"Cannot retrieve cluster stats, server returned code {0} with message {1}\".format(e.status_code, e.error))", "language": "python", "code": "def cluster_stats(nodes=None, hosts=None, profile=None):\n    '''\n    .. versionadded:: 2017.7.0\n\n    Return Elasticsearch cluster stats.\n\n    nodes\n        List of cluster nodes (id or name) to display stats for. Use _local for connected node, empty for all\n\n    CLI example::\n\n        salt myminion elasticsearch.cluster_stats\n    '''\n    es = _get_instance(hosts, profile)\n\n    try:\n        return es.cluster.stats(node_id=nodes)\n    except elasticsearch.TransportError as e:\n        raise CommandExecutionError(\"Cannot retrieve cluster stats, server returned code {0} with message {1}\".format(e.status_code, e.error))", "code_tokens": ["def", "cluster_stats", "(", "nodes", "=", "None", ",", "hosts", "=", "None", ",", "profile", "=", "None", ")", ":", "es", "=", "_get_instance", "(", "hosts", ",", "profile", ")", "try", ":", "return", "es", ".", "cluster", ".", "stats", "(", "node_id", "=", "nodes", ")", "except", "elasticsearch", ".", "TransportError", "as", "e", ":", "raise", "CommandExecutionError", "(", "\"Cannot retrieve cluster stats, server returned code {0} with message {1}\"", ".", "format", "(", "e", ".", "status_code", ",", "e", ".", "error", ")", ")"], "docstring": ".. versionadded:: 2017.7.0\n\n    Return Elasticsearch cluster stats.\n\n    nodes\n        List of cluster nodes (id or name) to display stats for. Use _local for connected node, empty for all\n\n    CLI example::\n\n        salt myminion elasticsearch.cluster_stats", "docstring_tokens": ["..", "versionadded", "::", "2017", ".", "7", ".", "0"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/modules/elasticsearch.py#L246-L264", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/modules/elasticsearch.py", "func_name": "alias_create", "original_string": "def alias_create(indices, alias, hosts=None, body=None, profile=None, source=None):\n    '''\n    Create an alias for a specific index/indices\n\n    indices\n        Single or multiple indices separated by comma, use _all to perform the operation on all indices.\n    alias\n        Alias name\n    body\n        Optional definition such as routing or filter as defined in https://www.elastic.co/guide/en/elasticsearch/reference/current/indices-aliases.html\n    source\n        URL of file specifying optional definition such as routing or filter. Cannot be used in combination with ``body``.\n\n    CLI example::\n\n        salt myminion elasticsearch.alias_create testindex_v1 testindex\n    '''\n    es = _get_instance(hosts, profile)\n    if source and body:\n        message = 'Either body or source should be specified but not both.'\n        raise SaltInvocationError(message)\n    if source:\n        body = __salt__['cp.get_file_str'](\n                  source,\n                  saltenv=__opts__.get('saltenv', 'base'))\n    try:\n        result = es.indices.put_alias(index=indices, name=alias, body=body)\n        return result.get('acknowledged', False)\n    except elasticsearch.TransportError as e:\n        raise CommandExecutionError(\"Cannot create alias {0} in index {1}, server returned code {2} with message {3}\".format(alias, indices, e.status_code, e.error))", "language": "python", "code": "def alias_create(indices, alias, hosts=None, body=None, profile=None, source=None):\n    '''\n    Create an alias for a specific index/indices\n\n    indices\n        Single or multiple indices separated by comma, use _all to perform the operation on all indices.\n    alias\n        Alias name\n    body\n        Optional definition such as routing or filter as defined in https://www.elastic.co/guide/en/elasticsearch/reference/current/indices-aliases.html\n    source\n        URL of file specifying optional definition such as routing or filter. Cannot be used in combination with ``body``.\n\n    CLI example::\n\n        salt myminion elasticsearch.alias_create testindex_v1 testindex\n    '''\n    es = _get_instance(hosts, profile)\n    if source and body:\n        message = 'Either body or source should be specified but not both.'\n        raise SaltInvocationError(message)\n    if source:\n        body = __salt__['cp.get_file_str'](\n                  source,\n                  saltenv=__opts__.get('saltenv', 'base'))\n    try:\n        result = es.indices.put_alias(index=indices, name=alias, body=body)\n        return result.get('acknowledged', False)\n    except elasticsearch.TransportError as e:\n        raise CommandExecutionError(\"Cannot create alias {0} in index {1}, server returned code {2} with message {3}\".format(alias, indices, e.status_code, e.error))", "code_tokens": ["def", "alias_create", "(", "indices", ",", "alias", ",", "hosts", "=", "None", ",", "body", "=", "None", ",", "profile", "=", "None", ",", "source", "=", "None", ")", ":", "es", "=", "_get_instance", "(", "hosts", ",", "profile", ")", "if", "source", "and", "body", ":", "message", "=", "'Either body or source should be specified but not both.'", "raise", "SaltInvocationError", "(", "message", ")", "if", "source", ":", "body", "=", "__salt__", "[", "'cp.get_file_str'", "]", "(", "source", ",", "saltenv", "=", "__opts__", ".", "get", "(", "'saltenv'", ",", "'base'", ")", ")", "try", ":", "result", "=", "es", ".", "indices", ".", "put_alias", "(", "index", "=", "indices", ",", "name", "=", "alias", ",", "body", "=", "body", ")", "return", "result", ".", "get", "(", "'acknowledged'", ",", "False", ")", "except", "elasticsearch", ".", "TransportError", "as", "e", ":", "raise", "CommandExecutionError", "(", "\"Cannot create alias {0} in index {1}, server returned code {2} with message {3}\"", ".", "format", "(", "alias", ",", "indices", ",", "e", ".", "status_code", ",", "e", ".", "error", ")", ")"], "docstring": "Create an alias for a specific index/indices\n\n    indices\n        Single or multiple indices separated by comma, use _all to perform the operation on all indices.\n    alias\n        Alias name\n    body\n        Optional definition such as routing or filter as defined in https://www.elastic.co/guide/en/elasticsearch/reference/current/indices-aliases.html\n    source\n        URL of file specifying optional definition such as routing or filter. Cannot be used in combination with ``body``.\n\n    CLI example::\n\n        salt myminion elasticsearch.alias_create testindex_v1 testindex", "docstring_tokens": ["Create", "an", "alias", "for", "a", "specific", "index", "/", "indices"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/modules/elasticsearch.py#L267-L296", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/modules/elasticsearch.py", "func_name": "alias_delete", "original_string": "def alias_delete(indices, aliases, hosts=None, body=None, profile=None, source=None):\n    '''\n    Delete an alias of an index\n\n    indices\n        Single or multiple indices separated by comma, use _all to perform the operation on all indices.\n    aliases\n        Alias names separated by comma\n\n    CLI example::\n\n        salt myminion elasticsearch.alias_delete testindex_v1 testindex\n    '''\n    es = _get_instance(hosts, profile)\n    if source and body:\n        message = 'Either body or source should be specified but not both.'\n        raise SaltInvocationError(message)\n    if source:\n        body = __salt__['cp.get_file_str'](\n                  source,\n                  saltenv=__opts__.get('saltenv', 'base'))\n    try:\n        result = es.indices.delete_alias(index=indices, name=aliases)\n\n        return result.get('acknowledged', False)\n    except elasticsearch.exceptions.NotFoundError:\n        return True\n    except elasticsearch.TransportError as e:\n        raise CommandExecutionError(\"Cannot delete alias {0} in index {1}, server returned code {2} with message {3}\".format(aliases, indices, e.status_code, e.error))", "language": "python", "code": "def alias_delete(indices, aliases, hosts=None, body=None, profile=None, source=None):\n    '''\n    Delete an alias of an index\n\n    indices\n        Single or multiple indices separated by comma, use _all to perform the operation on all indices.\n    aliases\n        Alias names separated by comma\n\n    CLI example::\n\n        salt myminion elasticsearch.alias_delete testindex_v1 testindex\n    '''\n    es = _get_instance(hosts, profile)\n    if source and body:\n        message = 'Either body or source should be specified but not both.'\n        raise SaltInvocationError(message)\n    if source:\n        body = __salt__['cp.get_file_str'](\n                  source,\n                  saltenv=__opts__.get('saltenv', 'base'))\n    try:\n        result = es.indices.delete_alias(index=indices, name=aliases)\n\n        return result.get('acknowledged', False)\n    except elasticsearch.exceptions.NotFoundError:\n        return True\n    except elasticsearch.TransportError as e:\n        raise CommandExecutionError(\"Cannot delete alias {0} in index {1}, server returned code {2} with message {3}\".format(aliases, indices, e.status_code, e.error))", "code_tokens": ["def", "alias_delete", "(", "indices", ",", "aliases", ",", "hosts", "=", "None", ",", "body", "=", "None", ",", "profile", "=", "None", ",", "source", "=", "None", ")", ":", "es", "=", "_get_instance", "(", "hosts", ",", "profile", ")", "if", "source", "and", "body", ":", "message", "=", "'Either body or source should be specified but not both.'", "raise", "SaltInvocationError", "(", "message", ")", "if", "source", ":", "body", "=", "__salt__", "[", "'cp.get_file_str'", "]", "(", "source", ",", "saltenv", "=", "__opts__", ".", "get", "(", "'saltenv'", ",", "'base'", ")", ")", "try", ":", "result", "=", "es", ".", "indices", ".", "delete_alias", "(", "index", "=", "indices", ",", "name", "=", "aliases", ")", "return", "result", ".", "get", "(", "'acknowledged'", ",", "False", ")", "except", "elasticsearch", ".", "exceptions", ".", "NotFoundError", ":", "return", "True", "except", "elasticsearch", ".", "TransportError", "as", "e", ":", "raise", "CommandExecutionError", "(", "\"Cannot delete alias {0} in index {1}, server returned code {2} with message {3}\"", ".", "format", "(", "aliases", ",", "indices", ",", "e", ".", "status_code", ",", "e", ".", "error", ")", ")"], "docstring": "Delete an alias of an index\n\n    indices\n        Single or multiple indices separated by comma, use _all to perform the operation on all indices.\n    aliases\n        Alias names separated by comma\n\n    CLI example::\n\n        salt myminion elasticsearch.alias_delete testindex_v1 testindex", "docstring_tokens": ["Delete", "an", "alias", "of", "an", "index"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/modules/elasticsearch.py#L299-L327", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/modules/elasticsearch.py", "func_name": "alias_exists", "original_string": "def alias_exists(aliases, indices=None, hosts=None, profile=None):\n    '''\n    Return a boolean indicating whether given alias exists\n\n    indices\n        Single or multiple indices separated by comma, use _all to perform the operation on all indices.\n    aliases\n        Alias names separated by comma\n\n    CLI example::\n\n        salt myminion elasticsearch.alias_exists None testindex\n    '''\n    es = _get_instance(hosts, profile)\n    try:\n        return es.indices.exists_alias(name=aliases, index=indices)\n    except elasticsearch.exceptions.NotFoundError:\n        return False\n    except elasticsearch.TransportError as e:\n        raise CommandExecutionError(\"Cannot get alias {0} in index {1}, server returned code {2} with message {3}\".format(aliases, indices, e.status_code, e.error))", "language": "python", "code": "def alias_exists(aliases, indices=None, hosts=None, profile=None):\n    '''\n    Return a boolean indicating whether given alias exists\n\n    indices\n        Single or multiple indices separated by comma, use _all to perform the operation on all indices.\n    aliases\n        Alias names separated by comma\n\n    CLI example::\n\n        salt myminion elasticsearch.alias_exists None testindex\n    '''\n    es = _get_instance(hosts, profile)\n    try:\n        return es.indices.exists_alias(name=aliases, index=indices)\n    except elasticsearch.exceptions.NotFoundError:\n        return False\n    except elasticsearch.TransportError as e:\n        raise CommandExecutionError(\"Cannot get alias {0} in index {1}, server returned code {2} with message {3}\".format(aliases, indices, e.status_code, e.error))", "code_tokens": ["def", "alias_exists", "(", "aliases", ",", "indices", "=", "None", ",", "hosts", "=", "None", ",", "profile", "=", "None", ")", ":", "es", "=", "_get_instance", "(", "hosts", ",", "profile", ")", "try", ":", "return", "es", ".", "indices", ".", "exists_alias", "(", "name", "=", "aliases", ",", "index", "=", "indices", ")", "except", "elasticsearch", ".", "exceptions", ".", "NotFoundError", ":", "return", "False", "except", "elasticsearch", ".", "TransportError", "as", "e", ":", "raise", "CommandExecutionError", "(", "\"Cannot get alias {0} in index {1}, server returned code {2} with message {3}\"", ".", "format", "(", "aliases", ",", "indices", ",", "e", ".", "status_code", ",", "e", ".", "error", ")", ")"], "docstring": "Return a boolean indicating whether given alias exists\n\n    indices\n        Single or multiple indices separated by comma, use _all to perform the operation on all indices.\n    aliases\n        Alias names separated by comma\n\n    CLI example::\n\n        salt myminion elasticsearch.alias_exists None testindex", "docstring_tokens": ["Return", "a", "boolean", "indicating", "whether", "given", "alias", "exists"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/modules/elasticsearch.py#L330-L349", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/modules/elasticsearch.py", "func_name": "alias_get", "original_string": "def alias_get(indices=None, aliases=None, hosts=None, profile=None):\n    '''\n    Check for the existence of an alias and if it exists, return it\n\n    indices\n        Single or multiple indices separated by comma, use _all to perform the operation on all indices.\n    aliases\n        Alias names separated by comma\n\n    CLI example::\n\n        salt myminion elasticsearch.alias_get testindex\n    '''\n    es = _get_instance(hosts, profile)\n\n    try:\n        return es.indices.get_alias(index=indices, name=aliases)\n    except elasticsearch.exceptions.NotFoundError:\n        return None\n    except elasticsearch.TransportError as e:\n        raise CommandExecutionError(\"Cannot get alias {0} in index {1}, server returned code {2} with message {3}\".format(aliases, indices, e.status_code, e.error))", "language": "python", "code": "def alias_get(indices=None, aliases=None, hosts=None, profile=None):\n    '''\n    Check for the existence of an alias and if it exists, return it\n\n    indices\n        Single or multiple indices separated by comma, use _all to perform the operation on all indices.\n    aliases\n        Alias names separated by comma\n\n    CLI example::\n\n        salt myminion elasticsearch.alias_get testindex\n    '''\n    es = _get_instance(hosts, profile)\n\n    try:\n        return es.indices.get_alias(index=indices, name=aliases)\n    except elasticsearch.exceptions.NotFoundError:\n        return None\n    except elasticsearch.TransportError as e:\n        raise CommandExecutionError(\"Cannot get alias {0} in index {1}, server returned code {2} with message {3}\".format(aliases, indices, e.status_code, e.error))", "code_tokens": ["def", "alias_get", "(", "indices", "=", "None", ",", "aliases", "=", "None", ",", "hosts", "=", "None", ",", "profile", "=", "None", ")", ":", "es", "=", "_get_instance", "(", "hosts", ",", "profile", ")", "try", ":", "return", "es", ".", "indices", ".", "get_alias", "(", "index", "=", "indices", ",", "name", "=", "aliases", ")", "except", "elasticsearch", ".", "exceptions", ".", "NotFoundError", ":", "return", "None", "except", "elasticsearch", ".", "TransportError", "as", "e", ":", "raise", "CommandExecutionError", "(", "\"Cannot get alias {0} in index {1}, server returned code {2} with message {3}\"", ".", "format", "(", "aliases", ",", "indices", ",", "e", ".", "status_code", ",", "e", ".", "error", ")", ")"], "docstring": "Check for the existence of an alias and if it exists, return it\n\n    indices\n        Single or multiple indices separated by comma, use _all to perform the operation on all indices.\n    aliases\n        Alias names separated by comma\n\n    CLI example::\n\n        salt myminion elasticsearch.alias_get testindex", "docstring_tokens": ["Check", "for", "the", "existence", "of", "an", "alias", "and", "if", "it", "exists", "return", "it"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/modules/elasticsearch.py#L352-L372", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/modules/elasticsearch.py", "func_name": "document_create", "original_string": "def document_create(index, doc_type, body=None, id=None, hosts=None, profile=None, source=None):\n    '''\n    Create a document in a specified index\n\n    index\n        Index name where the document should reside\n    doc_type\n        Type of the document\n    body\n        Document to store\n    source\n        URL of file specifying document to store. Cannot be used in combination with ``body``.\n    id\n        Optional unique document identifier for specified doc_type (empty for random)\n\n    CLI example::\n\n        salt myminion elasticsearch.document_create testindex doctype1 '{}'\n    '''\n    es = _get_instance(hosts, profile)\n    if source and body:\n        message = 'Either body or source should be specified but not both.'\n        raise SaltInvocationError(message)\n    if source:\n        body = __salt__['cp.get_file_str'](\n                  source,\n                  saltenv=__opts__.get('saltenv', 'base'))\n    try:\n        return es.index(index=index, doc_type=doc_type, body=body, id=id)\n    except elasticsearch.TransportError as e:\n        raise CommandExecutionError(\"Cannot create document in index {0}, server returned code {1} with message {2}\".format(index, e.status_code, e.error))", "language": "python", "code": "def document_create(index, doc_type, body=None, id=None, hosts=None, profile=None, source=None):\n    '''\n    Create a document in a specified index\n\n    index\n        Index name where the document should reside\n    doc_type\n        Type of the document\n    body\n        Document to store\n    source\n        URL of file specifying document to store. Cannot be used in combination with ``body``.\n    id\n        Optional unique document identifier for specified doc_type (empty for random)\n\n    CLI example::\n\n        salt myminion elasticsearch.document_create testindex doctype1 '{}'\n    '''\n    es = _get_instance(hosts, profile)\n    if source and body:\n        message = 'Either body or source should be specified but not both.'\n        raise SaltInvocationError(message)\n    if source:\n        body = __salt__['cp.get_file_str'](\n                  source,\n                  saltenv=__opts__.get('saltenv', 'base'))\n    try:\n        return es.index(index=index, doc_type=doc_type, body=body, id=id)\n    except elasticsearch.TransportError as e:\n        raise CommandExecutionError(\"Cannot create document in index {0}, server returned code {1} with message {2}\".format(index, e.status_code, e.error))", "code_tokens": ["def", "document_create", "(", "index", ",", "doc_type", ",", "body", "=", "None", ",", "id", "=", "None", ",", "hosts", "=", "None", ",", "profile", "=", "None", ",", "source", "=", "None", ")", ":", "es", "=", "_get_instance", "(", "hosts", ",", "profile", ")", "if", "source", "and", "body", ":", "message", "=", "'Either body or source should be specified but not both.'", "raise", "SaltInvocationError", "(", "message", ")", "if", "source", ":", "body", "=", "__salt__", "[", "'cp.get_file_str'", "]", "(", "source", ",", "saltenv", "=", "__opts__", ".", "get", "(", "'saltenv'", ",", "'base'", ")", ")", "try", ":", "return", "es", ".", "index", "(", "index", "=", "index", ",", "doc_type", "=", "doc_type", ",", "body", "=", "body", ",", "id", "=", "id", ")", "except", "elasticsearch", ".", "TransportError", "as", "e", ":", "raise", "CommandExecutionError", "(", "\"Cannot create document in index {0}, server returned code {1} with message {2}\"", ".", "format", "(", "index", ",", "e", ".", "status_code", ",", "e", ".", "error", ")", ")"], "docstring": "Create a document in a specified index\n\n    index\n        Index name where the document should reside\n    doc_type\n        Type of the document\n    body\n        Document to store\n    source\n        URL of file specifying document to store. Cannot be used in combination with ``body``.\n    id\n        Optional unique document identifier for specified doc_type (empty for random)\n\n    CLI example::\n\n        salt myminion elasticsearch.document_create testindex doctype1 '{}'", "docstring_tokens": ["Create", "a", "document", "in", "a", "specified", "index"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/modules/elasticsearch.py#L375-L405", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/modules/elasticsearch.py", "func_name": "document_delete", "original_string": "def document_delete(index, doc_type, id, hosts=None, profile=None):\n    '''\n    Delete a document from an index\n\n    index\n        Index name where the document resides\n    doc_type\n        Type of the document\n    id\n        Document identifier\n\n    CLI example::\n\n        salt myminion elasticsearch.document_delete testindex doctype1 AUx-384m0Bug_8U80wQZ\n    '''\n    es = _get_instance(hosts, profile)\n\n    try:\n        return es.delete(index=index, doc_type=doc_type, id=id)\n    except elasticsearch.exceptions.NotFoundError:\n        return None\n    except elasticsearch.TransportError as e:\n        raise CommandExecutionError(\"Cannot delete document {0} in index {1}, server returned code {2} with message {3}\".format(id, index, e.status_code, e.error))", "language": "python", "code": "def document_delete(index, doc_type, id, hosts=None, profile=None):\n    '''\n    Delete a document from an index\n\n    index\n        Index name where the document resides\n    doc_type\n        Type of the document\n    id\n        Document identifier\n\n    CLI example::\n\n        salt myminion elasticsearch.document_delete testindex doctype1 AUx-384m0Bug_8U80wQZ\n    '''\n    es = _get_instance(hosts, profile)\n\n    try:\n        return es.delete(index=index, doc_type=doc_type, id=id)\n    except elasticsearch.exceptions.NotFoundError:\n        return None\n    except elasticsearch.TransportError as e:\n        raise CommandExecutionError(\"Cannot delete document {0} in index {1}, server returned code {2} with message {3}\".format(id, index, e.status_code, e.error))", "code_tokens": ["def", "document_delete", "(", "index", ",", "doc_type", ",", "id", ",", "hosts", "=", "None", ",", "profile", "=", "None", ")", ":", "es", "=", "_get_instance", "(", "hosts", ",", "profile", ")", "try", ":", "return", "es", ".", "delete", "(", "index", "=", "index", ",", "doc_type", "=", "doc_type", ",", "id", "=", "id", ")", "except", "elasticsearch", ".", "exceptions", ".", "NotFoundError", ":", "return", "None", "except", "elasticsearch", ".", "TransportError", "as", "e", ":", "raise", "CommandExecutionError", "(", "\"Cannot delete document {0} in index {1}, server returned code {2} with message {3}\"", ".", "format", "(", "id", ",", "index", ",", "e", ".", "status_code", ",", "e", ".", "error", ")", ")"], "docstring": "Delete a document from an index\n\n    index\n        Index name where the document resides\n    doc_type\n        Type of the document\n    id\n        Document identifier\n\n    CLI example::\n\n        salt myminion elasticsearch.document_delete testindex doctype1 AUx-384m0Bug_8U80wQZ", "docstring_tokens": ["Delete", "a", "document", "from", "an", "index"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/modules/elasticsearch.py#L408-L430", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/modules/elasticsearch.py", "func_name": "document_exists", "original_string": "def document_exists(index, id, doc_type='_all', hosts=None, profile=None):\n    '''\n    Return a boolean indicating whether given document exists\n\n    index\n        Index name where the document resides\n    id\n        Document identifier\n    doc_type\n        Type of the document, use _all to fetch the first document matching the ID across all types\n\n    CLI example::\n\n        salt myminion elasticsearch.document_exists testindex AUx-384m0Bug_8U80wQZ\n    '''\n    es = _get_instance(hosts, profile)\n\n    try:\n        return es.exists(index=index, id=id, doc_type=doc_type)\n    except elasticsearch.exceptions.NotFoundError:\n        return False\n    except elasticsearch.TransportError as e:\n        raise CommandExecutionError(\"Cannot retrieve document {0} from index {1}, server returned code {2} with message {3}\".format(id, index, e.status_code, e.error))", "language": "python", "code": "def document_exists(index, id, doc_type='_all', hosts=None, profile=None):\n    '''\n    Return a boolean indicating whether given document exists\n\n    index\n        Index name where the document resides\n    id\n        Document identifier\n    doc_type\n        Type of the document, use _all to fetch the first document matching the ID across all types\n\n    CLI example::\n\n        salt myminion elasticsearch.document_exists testindex AUx-384m0Bug_8U80wQZ\n    '''\n    es = _get_instance(hosts, profile)\n\n    try:\n        return es.exists(index=index, id=id, doc_type=doc_type)\n    except elasticsearch.exceptions.NotFoundError:\n        return False\n    except elasticsearch.TransportError as e:\n        raise CommandExecutionError(\"Cannot retrieve document {0} from index {1}, server returned code {2} with message {3}\".format(id, index, e.status_code, e.error))", "code_tokens": ["def", "document_exists", "(", "index", ",", "id", ",", "doc_type", "=", "'_all'", ",", "hosts", "=", "None", ",", "profile", "=", "None", ")", ":", "es", "=", "_get_instance", "(", "hosts", ",", "profile", ")", "try", ":", "return", "es", ".", "exists", "(", "index", "=", "index", ",", "id", "=", "id", ",", "doc_type", "=", "doc_type", ")", "except", "elasticsearch", ".", "exceptions", ".", "NotFoundError", ":", "return", "False", "except", "elasticsearch", ".", "TransportError", "as", "e", ":", "raise", "CommandExecutionError", "(", "\"Cannot retrieve document {0} from index {1}, server returned code {2} with message {3}\"", ".", "format", "(", "id", ",", "index", ",", "e", ".", "status_code", ",", "e", ".", "error", ")", ")"], "docstring": "Return a boolean indicating whether given document exists\n\n    index\n        Index name where the document resides\n    id\n        Document identifier\n    doc_type\n        Type of the document, use _all to fetch the first document matching the ID across all types\n\n    CLI example::\n\n        salt myminion elasticsearch.document_exists testindex AUx-384m0Bug_8U80wQZ", "docstring_tokens": ["Return", "a", "boolean", "indicating", "whether", "given", "document", "exists"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/modules/elasticsearch.py#L433-L455", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/modules/elasticsearch.py", "func_name": "index_create", "original_string": "def index_create(index, body=None, hosts=None, profile=None, source=None):\n    '''\n    Create an index\n\n    index\n        Index name\n    body\n        Index definition, such as settings and mappings as defined in https://www.elastic.co/guide/en/elasticsearch/reference/current/indices-create-index.html\n    source\n        URL to file specifying index definition. Cannot be used in combination with ``body``.\n\n    CLI example::\n\n        salt myminion elasticsearch.index_create testindex\n        salt myminion elasticsearch.index_create testindex2 '{\"settings\" : {\"index\" : {\"number_of_shards\" : 3, \"number_of_replicas\" : 2}}}'\n    '''\n    es = _get_instance(hosts, profile)\n    if source and body:\n        message = 'Either body or source should be specified but not both.'\n        raise SaltInvocationError(message)\n    if source:\n        body = __salt__['cp.get_file_str'](\n                  source,\n                  saltenv=__opts__.get('saltenv', 'base'))\n    try:\n        result = es.indices.create(index=index, body=body)\n        return result.get('acknowledged', False) and result.get(\"shards_acknowledged\", True)\n    except elasticsearch.TransportError as e:\n        if \"index_already_exists_exception\" == e.error:\n            return True\n\n        raise CommandExecutionError(\"Cannot create index {0}, server returned code {1} with message {2}\".format(index, e.status_code, e.error))", "language": "python", "code": "def index_create(index, body=None, hosts=None, profile=None, source=None):\n    '''\n    Create an index\n\n    index\n        Index name\n    body\n        Index definition, such as settings and mappings as defined in https://www.elastic.co/guide/en/elasticsearch/reference/current/indices-create-index.html\n    source\n        URL to file specifying index definition. Cannot be used in combination with ``body``.\n\n    CLI example::\n\n        salt myminion elasticsearch.index_create testindex\n        salt myminion elasticsearch.index_create testindex2 '{\"settings\" : {\"index\" : {\"number_of_shards\" : 3, \"number_of_replicas\" : 2}}}'\n    '''\n    es = _get_instance(hosts, profile)\n    if source and body:\n        message = 'Either body or source should be specified but not both.'\n        raise SaltInvocationError(message)\n    if source:\n        body = __salt__['cp.get_file_str'](\n                  source,\n                  saltenv=__opts__.get('saltenv', 'base'))\n    try:\n        result = es.indices.create(index=index, body=body)\n        return result.get('acknowledged', False) and result.get(\"shards_acknowledged\", True)\n    except elasticsearch.TransportError as e:\n        if \"index_already_exists_exception\" == e.error:\n            return True\n\n        raise CommandExecutionError(\"Cannot create index {0}, server returned code {1} with message {2}\".format(index, e.status_code, e.error))", "code_tokens": ["def", "index_create", "(", "index", ",", "body", "=", "None", ",", "hosts", "=", "None", ",", "profile", "=", "None", ",", "source", "=", "None", ")", ":", "es", "=", "_get_instance", "(", "hosts", ",", "profile", ")", "if", "source", "and", "body", ":", "message", "=", "'Either body or source should be specified but not both.'", "raise", "SaltInvocationError", "(", "message", ")", "if", "source", ":", "body", "=", "__salt__", "[", "'cp.get_file_str'", "]", "(", "source", ",", "saltenv", "=", "__opts__", ".", "get", "(", "'saltenv'", ",", "'base'", ")", ")", "try", ":", "result", "=", "es", ".", "indices", ".", "create", "(", "index", "=", "index", ",", "body", "=", "body", ")", "return", "result", ".", "get", "(", "'acknowledged'", ",", "False", ")", "and", "result", ".", "get", "(", "\"shards_acknowledged\"", ",", "True", ")", "except", "elasticsearch", ".", "TransportError", "as", "e", ":", "if", "\"index_already_exists_exception\"", "==", "e", ".", "error", ":", "return", "True", "raise", "CommandExecutionError", "(", "\"Cannot create index {0}, server returned code {1} with message {2}\"", ".", "format", "(", "index", ",", "e", ".", "status_code", ",", "e", ".", "error", ")", ")"], "docstring": "Create an index\n\n    index\n        Index name\n    body\n        Index definition, such as settings and mappings as defined in https://www.elastic.co/guide/en/elasticsearch/reference/current/indices-create-index.html\n    source\n        URL to file specifying index definition. Cannot be used in combination with ``body``.\n\n    CLI example::\n\n        salt myminion elasticsearch.index_create testindex\n        salt myminion elasticsearch.index_create testindex2 '{\"settings\" : {\"index\" : {\"number_of_shards\" : 3, \"number_of_replicas\" : 2}}}'", "docstring_tokens": ["Create", "an", "index"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/modules/elasticsearch.py#L483-L514", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/modules/elasticsearch.py", "func_name": "index_delete", "original_string": "def index_delete(index, hosts=None, profile=None):\n    '''\n    Delete an index\n\n    index\n        Index name\n\n    CLI example::\n\n        salt myminion elasticsearch.index_delete testindex\n    '''\n    es = _get_instance(hosts, profile)\n\n    try:\n        result = es.indices.delete(index=index)\n\n        return result.get('acknowledged', False)\n    except elasticsearch.exceptions.NotFoundError:\n        return True\n    except elasticsearch.TransportError as e:\n        raise CommandExecutionError(\"Cannot delete index {0}, server returned code {1} with message {2}\".format(index, e.status_code, e.error))", "language": "python", "code": "def index_delete(index, hosts=None, profile=None):\n    '''\n    Delete an index\n\n    index\n        Index name\n\n    CLI example::\n\n        salt myminion elasticsearch.index_delete testindex\n    '''\n    es = _get_instance(hosts, profile)\n\n    try:\n        result = es.indices.delete(index=index)\n\n        return result.get('acknowledged', False)\n    except elasticsearch.exceptions.NotFoundError:\n        return True\n    except elasticsearch.TransportError as e:\n        raise CommandExecutionError(\"Cannot delete index {0}, server returned code {1} with message {2}\".format(index, e.status_code, e.error))", "code_tokens": ["def", "index_delete", "(", "index", ",", "hosts", "=", "None", ",", "profile", "=", "None", ")", ":", "es", "=", "_get_instance", "(", "hosts", ",", "profile", ")", "try", ":", "result", "=", "es", ".", "indices", ".", "delete", "(", "index", "=", "index", ")", "return", "result", ".", "get", "(", "'acknowledged'", ",", "False", ")", "except", "elasticsearch", ".", "exceptions", ".", "NotFoundError", ":", "return", "True", "except", "elasticsearch", ".", "TransportError", "as", "e", ":", "raise", "CommandExecutionError", "(", "\"Cannot delete index {0}, server returned code {1} with message {2}\"", ".", "format", "(", "index", ",", "e", ".", "status_code", ",", "e", ".", "error", ")", ")"], "docstring": "Delete an index\n\n    index\n        Index name\n\n    CLI example::\n\n        salt myminion elasticsearch.index_delete testindex", "docstring_tokens": ["Delete", "an", "index"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/modules/elasticsearch.py#L517-L537", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/modules/elasticsearch.py", "func_name": "index_exists", "original_string": "def index_exists(index, hosts=None, profile=None):\n    '''\n    Return a boolean indicating whether given index exists\n\n    index\n        Index name\n\n    CLI example::\n\n        salt myminion elasticsearch.index_exists testindex\n    '''\n    es = _get_instance(hosts, profile)\n\n    try:\n        return es.indices.exists(index=index)\n    except elasticsearch.exceptions.NotFoundError:\n        return False\n    except elasticsearch.TransportError as e:\n        raise CommandExecutionError(\"Cannot retrieve index {0}, server returned code {1} with message {2}\".format(index, e.status_code, e.error))", "language": "python", "code": "def index_exists(index, hosts=None, profile=None):\n    '''\n    Return a boolean indicating whether given index exists\n\n    index\n        Index name\n\n    CLI example::\n\n        salt myminion elasticsearch.index_exists testindex\n    '''\n    es = _get_instance(hosts, profile)\n\n    try:\n        return es.indices.exists(index=index)\n    except elasticsearch.exceptions.NotFoundError:\n        return False\n    except elasticsearch.TransportError as e:\n        raise CommandExecutionError(\"Cannot retrieve index {0}, server returned code {1} with message {2}\".format(index, e.status_code, e.error))", "code_tokens": ["def", "index_exists", "(", "index", ",", "hosts", "=", "None", ",", "profile", "=", "None", ")", ":", "es", "=", "_get_instance", "(", "hosts", ",", "profile", ")", "try", ":", "return", "es", ".", "indices", ".", "exists", "(", "index", "=", "index", ")", "except", "elasticsearch", ".", "exceptions", ".", "NotFoundError", ":", "return", "False", "except", "elasticsearch", ".", "TransportError", "as", "e", ":", "raise", "CommandExecutionError", "(", "\"Cannot retrieve index {0}, server returned code {1} with message {2}\"", ".", "format", "(", "index", ",", "e", ".", "status_code", ",", "e", ".", "error", ")", ")"], "docstring": "Return a boolean indicating whether given index exists\n\n    index\n        Index name\n\n    CLI example::\n\n        salt myminion elasticsearch.index_exists testindex", "docstring_tokens": ["Return", "a", "boolean", "indicating", "whether", "given", "index", "exists"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/modules/elasticsearch.py#L540-L558", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/modules/elasticsearch.py", "func_name": "index_get", "original_string": "def index_get(index, hosts=None, profile=None):\n    '''\n    Check for the existence of an index and if it exists, return it\n\n    index\n        Index name\n\n    CLI example::\n\n        salt myminion elasticsearch.index_get testindex\n    '''\n    es = _get_instance(hosts, profile)\n\n    try:\n        return es.indices.get(index=index)\n    except elasticsearch.exceptions.NotFoundError:\n        return None\n    except elasticsearch.TransportError as e:\n        raise CommandExecutionError(\"Cannot retrieve index {0}, server returned code {1} with message {2}\".format(index, e.status_code, e.error))", "language": "python", "code": "def index_get(index, hosts=None, profile=None):\n    '''\n    Check for the existence of an index and if it exists, return it\n\n    index\n        Index name\n\n    CLI example::\n\n        salt myminion elasticsearch.index_get testindex\n    '''\n    es = _get_instance(hosts, profile)\n\n    try:\n        return es.indices.get(index=index)\n    except elasticsearch.exceptions.NotFoundError:\n        return None\n    except elasticsearch.TransportError as e:\n        raise CommandExecutionError(\"Cannot retrieve index {0}, server returned code {1} with message {2}\".format(index, e.status_code, e.error))", "code_tokens": ["def", "index_get", "(", "index", ",", "hosts", "=", "None", ",", "profile", "=", "None", ")", ":", "es", "=", "_get_instance", "(", "hosts", ",", "profile", ")", "try", ":", "return", "es", ".", "indices", ".", "get", "(", "index", "=", "index", ")", "except", "elasticsearch", ".", "exceptions", ".", "NotFoundError", ":", "return", "None", "except", "elasticsearch", ".", "TransportError", "as", "e", ":", "raise", "CommandExecutionError", "(", "\"Cannot retrieve index {0}, server returned code {1} with message {2}\"", ".", "format", "(", "index", ",", "e", ".", "status_code", ",", "e", ".", "error", ")", ")"], "docstring": "Check for the existence of an index and if it exists, return it\n\n    index\n        Index name\n\n    CLI example::\n\n        salt myminion elasticsearch.index_get testindex", "docstring_tokens": ["Check", "for", "the", "existence", "of", "an", "index", "and", "if", "it", "exists", "return", "it"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/modules/elasticsearch.py#L561-L579", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/modules/elasticsearch.py", "func_name": "index_open", "original_string": "def index_open(index, allow_no_indices=True, expand_wildcards='closed', ignore_unavailable=True, hosts=None, profile=None):\n    '''\n    .. versionadded:: 2017.7.0\n\n    Open specified index.\n\n    index\n        Index to be opened\n    allow_no_indices\n        Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes _all string or when no indices have been specified)\n    expand_wildcards\n        Whether to expand wildcard expression to concrete indices that are open, closed or both., default \u2018closed\u2019, valid choices are: \u2018open\u2019, \u2018closed\u2019, \u2018none\u2019, \u2018all\u2019\n    ignore_unavailable\n        Whether specified concrete indices should be ignored when unavailable (missing or closed)\n\n    CLI example::\n\n        salt myminion elasticsearch.index_open testindex\n    '''\n    es = _get_instance(hosts, profile)\n\n    try:\n        result = es.indices.open(index=index, allow_no_indices=allow_no_indices, expand_wildcards=expand_wildcards, ignore_unavailable=ignore_unavailable)\n\n        return result.get('acknowledged', False)\n    except elasticsearch.TransportError as e:\n        raise CommandExecutionError(\"Cannot open index {0}, server returned code {1} with message {2}\".format(index, e.status_code, e.error))", "language": "python", "code": "def index_open(index, allow_no_indices=True, expand_wildcards='closed', ignore_unavailable=True, hosts=None, profile=None):\n    '''\n    .. versionadded:: 2017.7.0\n\n    Open specified index.\n\n    index\n        Index to be opened\n    allow_no_indices\n        Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes _all string or when no indices have been specified)\n    expand_wildcards\n        Whether to expand wildcard expression to concrete indices that are open, closed or both., default \u2018closed\u2019, valid choices are: \u2018open\u2019, \u2018closed\u2019, \u2018none\u2019, \u2018all\u2019\n    ignore_unavailable\n        Whether specified concrete indices should be ignored when unavailable (missing or closed)\n\n    CLI example::\n\n        salt myminion elasticsearch.index_open testindex\n    '''\n    es = _get_instance(hosts, profile)\n\n    try:\n        result = es.indices.open(index=index, allow_no_indices=allow_no_indices, expand_wildcards=expand_wildcards, ignore_unavailable=ignore_unavailable)\n\n        return result.get('acknowledged', False)\n    except elasticsearch.TransportError as e:\n        raise CommandExecutionError(\"Cannot open index {0}, server returned code {1} with message {2}\".format(index, e.status_code, e.error))", "code_tokens": ["def", "index_open", "(", "index", ",", "allow_no_indices", "=", "True", ",", "expand_wildcards", "=", "'closed'", ",", "ignore_unavailable", "=", "True", ",", "hosts", "=", "None", ",", "profile", "=", "None", ")", ":", "es", "=", "_get_instance", "(", "hosts", ",", "profile", ")", "try", ":", "result", "=", "es", ".", "indices", ".", "open", "(", "index", "=", "index", ",", "allow_no_indices", "=", "allow_no_indices", ",", "expand_wildcards", "=", "expand_wildcards", ",", "ignore_unavailable", "=", "ignore_unavailable", ")", "return", "result", ".", "get", "(", "'acknowledged'", ",", "False", ")", "except", "elasticsearch", ".", "TransportError", "as", "e", ":", "raise", "CommandExecutionError", "(", "\"Cannot open index {0}, server returned code {1} with message {2}\"", ".", "format", "(", "index", ",", "e", ".", "status_code", ",", "e", ".", "error", ")", ")"], "docstring": ".. versionadded:: 2017.7.0\n\n    Open specified index.\n\n    index\n        Index to be opened\n    allow_no_indices\n        Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes _all string or when no indices have been specified)\n    expand_wildcards\n        Whether to expand wildcard expression to concrete indices that are open, closed or both., default \u2018closed\u2019, valid choices are: \u2018open\u2019, \u2018closed\u2019, \u2018none\u2019, \u2018all\u2019\n    ignore_unavailable\n        Whether specified concrete indices should be ignored when unavailable (missing or closed)\n\n    CLI example::\n\n        salt myminion elasticsearch.index_open testindex", "docstring_tokens": ["..", "versionadded", "::", "2017", ".", "7", ".", "0"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/modules/elasticsearch.py#L582-L608", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/modules/elasticsearch.py", "func_name": "mapping_create", "original_string": "def mapping_create(index, doc_type, body=None, hosts=None, profile=None, source=None):\n    '''\n    Create a mapping in a given index\n\n    index\n        Index for the mapping\n    doc_type\n        Name of the document type\n    body\n        Mapping definition as specified in https://www.elastic.co/guide/en/elasticsearch/reference/current/indices-put-mapping.html\n    source\n        URL to file specifying mapping definition. Cannot be used in combination with ``body``.\n\n    CLI example::\n\n        salt myminion elasticsearch.mapping_create testindex user '{ \"user\" : { \"properties\" : { \"message\" : {\"type\" : \"string\", \"store\" : true } } } }'\n    '''\n    es = _get_instance(hosts, profile)\n    if source and body:\n        message = 'Either body or source should be specified but not both.'\n        raise SaltInvocationError(message)\n    if source:\n        body = __salt__['cp.get_file_str'](\n                  source,\n                  saltenv=__opts__.get('saltenv', 'base'))\n    try:\n        result = es.indices.put_mapping(index=index, doc_type=doc_type, body=body)\n\n        return result.get('acknowledged', False)\n    except elasticsearch.TransportError as e:\n        raise CommandExecutionError(\"Cannot create mapping {0}, server returned code {1} with message {2}\".format(index, e.status_code, e.error))", "language": "python", "code": "def mapping_create(index, doc_type, body=None, hosts=None, profile=None, source=None):\n    '''\n    Create a mapping in a given index\n\n    index\n        Index for the mapping\n    doc_type\n        Name of the document type\n    body\n        Mapping definition as specified in https://www.elastic.co/guide/en/elasticsearch/reference/current/indices-put-mapping.html\n    source\n        URL to file specifying mapping definition. Cannot be used in combination with ``body``.\n\n    CLI example::\n\n        salt myminion elasticsearch.mapping_create testindex user '{ \"user\" : { \"properties\" : { \"message\" : {\"type\" : \"string\", \"store\" : true } } } }'\n    '''\n    es = _get_instance(hosts, profile)\n    if source and body:\n        message = 'Either body or source should be specified but not both.'\n        raise SaltInvocationError(message)\n    if source:\n        body = __salt__['cp.get_file_str'](\n                  source,\n                  saltenv=__opts__.get('saltenv', 'base'))\n    try:\n        result = es.indices.put_mapping(index=index, doc_type=doc_type, body=body)\n\n        return result.get('acknowledged', False)\n    except elasticsearch.TransportError as e:\n        raise CommandExecutionError(\"Cannot create mapping {0}, server returned code {1} with message {2}\".format(index, e.status_code, e.error))", "code_tokens": ["def", "mapping_create", "(", "index", ",", "doc_type", ",", "body", "=", "None", ",", "hosts", "=", "None", ",", "profile", "=", "None", ",", "source", "=", "None", ")", ":", "es", "=", "_get_instance", "(", "hosts", ",", "profile", ")", "if", "source", "and", "body", ":", "message", "=", "'Either body or source should be specified but not both.'", "raise", "SaltInvocationError", "(", "message", ")", "if", "source", ":", "body", "=", "__salt__", "[", "'cp.get_file_str'", "]", "(", "source", ",", "saltenv", "=", "__opts__", ".", "get", "(", "'saltenv'", ",", "'base'", ")", ")", "try", ":", "result", "=", "es", ".", "indices", ".", "put_mapping", "(", "index", "=", "index", ",", "doc_type", "=", "doc_type", ",", "body", "=", "body", ")", "return", "result", ".", "get", "(", "'acknowledged'", ",", "False", ")", "except", "elasticsearch", ".", "TransportError", "as", "e", ":", "raise", "CommandExecutionError", "(", "\"Cannot create mapping {0}, server returned code {1} with message {2}\"", ".", "format", "(", "index", ",", "e", ".", "status_code", ",", "e", ".", "error", ")", ")"], "docstring": "Create a mapping in a given index\n\n    index\n        Index for the mapping\n    doc_type\n        Name of the document type\n    body\n        Mapping definition as specified in https://www.elastic.co/guide/en/elasticsearch/reference/current/indices-put-mapping.html\n    source\n        URL to file specifying mapping definition. Cannot be used in combination with ``body``.\n\n    CLI example::\n\n        salt myminion elasticsearch.mapping_create testindex user '{ \"user\" : { \"properties\" : { \"message\" : {\"type\" : \"string\", \"store\" : true } } } }'", "docstring_tokens": ["Create", "a", "mapping", "in", "a", "given", "index"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/modules/elasticsearch.py#L640-L670", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/modules/elasticsearch.py", "func_name": "mapping_delete", "original_string": "def mapping_delete(index, doc_type, hosts=None, profile=None):\n    '''\n    Delete a mapping (type) along with its data. As of Elasticsearch 5.0 this is no longer available.\n\n    index\n        Index for the mapping\n    doc_type\n        Name of the document type\n\n    CLI example::\n\n        salt myminion elasticsearch.mapping_delete testindex user\n    '''\n    es = _get_instance(hosts, profile)\n    try:\n        result = es.indices.delete_mapping(index=index, doc_type=doc_type)\n\n        return result.get('acknowledged', False)\n    except elasticsearch.exceptions.NotFoundError:\n        return True\n    except elasticsearch.TransportError as e:\n        raise CommandExecutionError(\"Cannot delete mapping {0}, server returned code {1} with message {2}\".format(index, e.status_code, e.error))\n    except AttributeError:\n        raise CommandExecutionError(\"Method is not applicable for Elasticsearch 5.0+\")", "language": "python", "code": "def mapping_delete(index, doc_type, hosts=None, profile=None):\n    '''\n    Delete a mapping (type) along with its data. As of Elasticsearch 5.0 this is no longer available.\n\n    index\n        Index for the mapping\n    doc_type\n        Name of the document type\n\n    CLI example::\n\n        salt myminion elasticsearch.mapping_delete testindex user\n    '''\n    es = _get_instance(hosts, profile)\n    try:\n        result = es.indices.delete_mapping(index=index, doc_type=doc_type)\n\n        return result.get('acknowledged', False)\n    except elasticsearch.exceptions.NotFoundError:\n        return True\n    except elasticsearch.TransportError as e:\n        raise CommandExecutionError(\"Cannot delete mapping {0}, server returned code {1} with message {2}\".format(index, e.status_code, e.error))\n    except AttributeError:\n        raise CommandExecutionError(\"Method is not applicable for Elasticsearch 5.0+\")", "code_tokens": ["def", "mapping_delete", "(", "index", ",", "doc_type", ",", "hosts", "=", "None", ",", "profile", "=", "None", ")", ":", "es", "=", "_get_instance", "(", "hosts", ",", "profile", ")", "try", ":", "result", "=", "es", ".", "indices", ".", "delete_mapping", "(", "index", "=", "index", ",", "doc_type", "=", "doc_type", ")", "return", "result", ".", "get", "(", "'acknowledged'", ",", "False", ")", "except", "elasticsearch", ".", "exceptions", ".", "NotFoundError", ":", "return", "True", "except", "elasticsearch", ".", "TransportError", "as", "e", ":", "raise", "CommandExecutionError", "(", "\"Cannot delete mapping {0}, server returned code {1} with message {2}\"", ".", "format", "(", "index", ",", "e", ".", "status_code", ",", "e", ".", "error", ")", ")", "except", "AttributeError", ":", "raise", "CommandExecutionError", "(", "\"Method is not applicable for Elasticsearch 5.0+\"", ")"], "docstring": "Delete a mapping (type) along with its data. As of Elasticsearch 5.0 this is no longer available.\n\n    index\n        Index for the mapping\n    doc_type\n        Name of the document type\n\n    CLI example::\n\n        salt myminion elasticsearch.mapping_delete testindex user", "docstring_tokens": ["Delete", "a", "mapping", "(", "type", ")", "along", "with", "its", "data", ".", "As", "of", "Elasticsearch", "5", ".", "0", "this", "is", "no", "longer", "available", "."], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/modules/elasticsearch.py#L673-L696", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/modules/elasticsearch.py", "func_name": "mapping_get", "original_string": "def mapping_get(index, doc_type, hosts=None, profile=None):\n    '''\n    Retrieve mapping definition of index or index/type\n\n    index\n        Index for the mapping\n    doc_type\n        Name of the document type\n\n    CLI example::\n\n        salt myminion elasticsearch.mapping_get testindex user\n    '''\n    es = _get_instance(hosts, profile)\n\n    try:\n        return es.indices.get_mapping(index=index, doc_type=doc_type)\n    except elasticsearch.exceptions.NotFoundError:\n        return None\n    except elasticsearch.TransportError as e:\n        raise CommandExecutionError(\"Cannot retrieve mapping {0}, server returned code {1} with message {2}\".format(index, e.status_code, e.error))", "language": "python", "code": "def mapping_get(index, doc_type, hosts=None, profile=None):\n    '''\n    Retrieve mapping definition of index or index/type\n\n    index\n        Index for the mapping\n    doc_type\n        Name of the document type\n\n    CLI example::\n\n        salt myminion elasticsearch.mapping_get testindex user\n    '''\n    es = _get_instance(hosts, profile)\n\n    try:\n        return es.indices.get_mapping(index=index, doc_type=doc_type)\n    except elasticsearch.exceptions.NotFoundError:\n        return None\n    except elasticsearch.TransportError as e:\n        raise CommandExecutionError(\"Cannot retrieve mapping {0}, server returned code {1} with message {2}\".format(index, e.status_code, e.error))", "code_tokens": ["def", "mapping_get", "(", "index", ",", "doc_type", ",", "hosts", "=", "None", ",", "profile", "=", "None", ")", ":", "es", "=", "_get_instance", "(", "hosts", ",", "profile", ")", "try", ":", "return", "es", ".", "indices", ".", "get_mapping", "(", "index", "=", "index", ",", "doc_type", "=", "doc_type", ")", "except", "elasticsearch", ".", "exceptions", ".", "NotFoundError", ":", "return", "None", "except", "elasticsearch", ".", "TransportError", "as", "e", ":", "raise", "CommandExecutionError", "(", "\"Cannot retrieve mapping {0}, server returned code {1} with message {2}\"", ".", "format", "(", "index", ",", "e", ".", "status_code", ",", "e", ".", "error", ")", ")"], "docstring": "Retrieve mapping definition of index or index/type\n\n    index\n        Index for the mapping\n    doc_type\n        Name of the document type\n\n    CLI example::\n\n        salt myminion elasticsearch.mapping_get testindex user", "docstring_tokens": ["Retrieve", "mapping", "definition", "of", "index", "or", "index", "/", "type"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/modules/elasticsearch.py#L699-L719", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/modules/elasticsearch.py", "func_name": "index_template_create", "original_string": "def index_template_create(name, body=None, hosts=None, profile=None, source=None):\n    '''\n    Create an index template\n\n    name\n        Index template name\n\n    body\n        Template definition as specified in http://www.elastic.co/guide/en/elasticsearch/reference/current/indices-templates.html\n\n    source\n        URL to file specifying template definition. Cannot be used in combination with ``body``.\n\n    CLI example::\n\n        salt myminion elasticsearch.index_template_create testindex_templ '{ \"template\": \"logstash-*\", \"order\": 1, \"settings\": { \"number_of_shards\": 1 } }'\n    '''\n    es = _get_instance(hosts, profile)\n    if source and body:\n        message = 'Either body or source should be specified but not both.'\n        raise SaltInvocationError(message)\n    if source:\n        body = __salt__['cp.get_file_str'](\n                  source,\n                  saltenv=__opts__.get('saltenv', 'base'))\n    try:\n        result = es.indices.put_template(name=name, body=body)\n        return result.get('acknowledged', False)\n    except elasticsearch.TransportError as e:\n        raise CommandExecutionError(\"Cannot create template {0}, server returned code {1} with message {2}\".format(name, e.status_code, e.error))", "language": "python", "code": "def index_template_create(name, body=None, hosts=None, profile=None, source=None):\n    '''\n    Create an index template\n\n    name\n        Index template name\n\n    body\n        Template definition as specified in http://www.elastic.co/guide/en/elasticsearch/reference/current/indices-templates.html\n\n    source\n        URL to file specifying template definition. Cannot be used in combination with ``body``.\n\n    CLI example::\n\n        salt myminion elasticsearch.index_template_create testindex_templ '{ \"template\": \"logstash-*\", \"order\": 1, \"settings\": { \"number_of_shards\": 1 } }'\n    '''\n    es = _get_instance(hosts, profile)\n    if source and body:\n        message = 'Either body or source should be specified but not both.'\n        raise SaltInvocationError(message)\n    if source:\n        body = __salt__['cp.get_file_str'](\n                  source,\n                  saltenv=__opts__.get('saltenv', 'base'))\n    try:\n        result = es.indices.put_template(name=name, body=body)\n        return result.get('acknowledged', False)\n    except elasticsearch.TransportError as e:\n        raise CommandExecutionError(\"Cannot create template {0}, server returned code {1} with message {2}\".format(name, e.status_code, e.error))", "code_tokens": ["def", "index_template_create", "(", "name", ",", "body", "=", "None", ",", "hosts", "=", "None", ",", "profile", "=", "None", ",", "source", "=", "None", ")", ":", "es", "=", "_get_instance", "(", "hosts", ",", "profile", ")", "if", "source", "and", "body", ":", "message", "=", "'Either body or source should be specified but not both.'", "raise", "SaltInvocationError", "(", "message", ")", "if", "source", ":", "body", "=", "__salt__", "[", "'cp.get_file_str'", "]", "(", "source", ",", "saltenv", "=", "__opts__", ".", "get", "(", "'saltenv'", ",", "'base'", ")", ")", "try", ":", "result", "=", "es", ".", "indices", ".", "put_template", "(", "name", "=", "name", ",", "body", "=", "body", ")", "return", "result", ".", "get", "(", "'acknowledged'", ",", "False", ")", "except", "elasticsearch", ".", "TransportError", "as", "e", ":", "raise", "CommandExecutionError", "(", "\"Cannot create template {0}, server returned code {1} with message {2}\"", ".", "format", "(", "name", ",", "e", ".", "status_code", ",", "e", ".", "error", ")", ")"], "docstring": "Create an index template\n\n    name\n        Index template name\n\n    body\n        Template definition as specified in http://www.elastic.co/guide/en/elasticsearch/reference/current/indices-templates.html\n\n    source\n        URL to file specifying template definition. Cannot be used in combination with ``body``.\n\n    CLI example::\n\n        salt myminion elasticsearch.index_template_create testindex_templ '{ \"template\": \"logstash-*\", \"order\": 1, \"settings\": { \"number_of_shards\": 1 } }'", "docstring_tokens": ["Create", "an", "index", "template"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/modules/elasticsearch.py#L722-L751", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/modules/elasticsearch.py", "func_name": "index_template_delete", "original_string": "def index_template_delete(name, hosts=None, profile=None):\n    '''\n    Delete an index template (type) along with its data\n\n    name\n        Index template name\n\n    CLI example::\n\n        salt myminion elasticsearch.index_template_delete testindex_templ user\n    '''\n    es = _get_instance(hosts, profile)\n    try:\n        result = es.indices.delete_template(name=name)\n\n        return result.get('acknowledged', False)\n    except elasticsearch.exceptions.NotFoundError:\n        return True\n    except elasticsearch.TransportError as e:\n        raise CommandExecutionError(\"Cannot delete template {0}, server returned code {1} with message {2}\".format(name, e.status_code, e.error))", "language": "python", "code": "def index_template_delete(name, hosts=None, profile=None):\n    '''\n    Delete an index template (type) along with its data\n\n    name\n        Index template name\n\n    CLI example::\n\n        salt myminion elasticsearch.index_template_delete testindex_templ user\n    '''\n    es = _get_instance(hosts, profile)\n    try:\n        result = es.indices.delete_template(name=name)\n\n        return result.get('acknowledged', False)\n    except elasticsearch.exceptions.NotFoundError:\n        return True\n    except elasticsearch.TransportError as e:\n        raise CommandExecutionError(\"Cannot delete template {0}, server returned code {1} with message {2}\".format(name, e.status_code, e.error))", "code_tokens": ["def", "index_template_delete", "(", "name", ",", "hosts", "=", "None", ",", "profile", "=", "None", ")", ":", "es", "=", "_get_instance", "(", "hosts", ",", "profile", ")", "try", ":", "result", "=", "es", ".", "indices", ".", "delete_template", "(", "name", "=", "name", ")", "return", "result", ".", "get", "(", "'acknowledged'", ",", "False", ")", "except", "elasticsearch", ".", "exceptions", ".", "NotFoundError", ":", "return", "True", "except", "elasticsearch", ".", "TransportError", "as", "e", ":", "raise", "CommandExecutionError", "(", "\"Cannot delete template {0}, server returned code {1} with message {2}\"", ".", "format", "(", "name", ",", "e", ".", "status_code", ",", "e", ".", "error", ")", ")"], "docstring": "Delete an index template (type) along with its data\n\n    name\n        Index template name\n\n    CLI example::\n\n        salt myminion elasticsearch.index_template_delete testindex_templ user", "docstring_tokens": ["Delete", "an", "index", "template", "(", "type", ")", "along", "with", "its", "data"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/modules/elasticsearch.py#L754-L773", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/modules/elasticsearch.py", "func_name": "index_template_exists", "original_string": "def index_template_exists(name, hosts=None, profile=None):\n    '''\n    Return a boolean indicating whether given index template exists\n\n    name\n        Index template name\n\n    CLI example::\n\n        salt myminion elasticsearch.index_template_exists testindex_templ\n    '''\n    es = _get_instance(hosts, profile)\n    try:\n        return es.indices.exists_template(name=name)\n    except elasticsearch.TransportError as e:\n        raise CommandExecutionError(\"Cannot retrieve template {0}, server returned code {1} with message {2}\".format(name, e.status_code, e.error))", "language": "python", "code": "def index_template_exists(name, hosts=None, profile=None):\n    '''\n    Return a boolean indicating whether given index template exists\n\n    name\n        Index template name\n\n    CLI example::\n\n        salt myminion elasticsearch.index_template_exists testindex_templ\n    '''\n    es = _get_instance(hosts, profile)\n    try:\n        return es.indices.exists_template(name=name)\n    except elasticsearch.TransportError as e:\n        raise CommandExecutionError(\"Cannot retrieve template {0}, server returned code {1} with message {2}\".format(name, e.status_code, e.error))", "code_tokens": ["def", "index_template_exists", "(", "name", ",", "hosts", "=", "None", ",", "profile", "=", "None", ")", ":", "es", "=", "_get_instance", "(", "hosts", ",", "profile", ")", "try", ":", "return", "es", ".", "indices", ".", "exists_template", "(", "name", "=", "name", ")", "except", "elasticsearch", ".", "TransportError", "as", "e", ":", "raise", "CommandExecutionError", "(", "\"Cannot retrieve template {0}, server returned code {1} with message {2}\"", ".", "format", "(", "name", ",", "e", ".", "status_code", ",", "e", ".", "error", ")", ")"], "docstring": "Return a boolean indicating whether given index template exists\n\n    name\n        Index template name\n\n    CLI example::\n\n        salt myminion elasticsearch.index_template_exists testindex_templ", "docstring_tokens": ["Return", "a", "boolean", "indicating", "whether", "given", "index", "template", "exists"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/modules/elasticsearch.py#L776-L791", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/modules/elasticsearch.py", "func_name": "index_template_get", "original_string": "def index_template_get(name, hosts=None, profile=None):\n    '''\n    Retrieve template definition of index or index/type\n\n    name\n        Index template name\n\n    CLI example::\n\n        salt myminion elasticsearch.index_template_get testindex_templ\n    '''\n    es = _get_instance(hosts, profile)\n\n    try:\n        return es.indices.get_template(name=name)\n    except elasticsearch.exceptions.NotFoundError:\n        return None\n    except elasticsearch.TransportError as e:\n        raise CommandExecutionError(\"Cannot retrieve template {0}, server returned code {1} with message {2}\".format(name, e.status_code, e.error))", "language": "python", "code": "def index_template_get(name, hosts=None, profile=None):\n    '''\n    Retrieve template definition of index or index/type\n\n    name\n        Index template name\n\n    CLI example::\n\n        salt myminion elasticsearch.index_template_get testindex_templ\n    '''\n    es = _get_instance(hosts, profile)\n\n    try:\n        return es.indices.get_template(name=name)\n    except elasticsearch.exceptions.NotFoundError:\n        return None\n    except elasticsearch.TransportError as e:\n        raise CommandExecutionError(\"Cannot retrieve template {0}, server returned code {1} with message {2}\".format(name, e.status_code, e.error))", "code_tokens": ["def", "index_template_get", "(", "name", ",", "hosts", "=", "None", ",", "profile", "=", "None", ")", ":", "es", "=", "_get_instance", "(", "hosts", ",", "profile", ")", "try", ":", "return", "es", ".", "indices", ".", "get_template", "(", "name", "=", "name", ")", "except", "elasticsearch", ".", "exceptions", ".", "NotFoundError", ":", "return", "None", "except", "elasticsearch", ".", "TransportError", "as", "e", ":", "raise", "CommandExecutionError", "(", "\"Cannot retrieve template {0}, server returned code {1} with message {2}\"", ".", "format", "(", "name", ",", "e", ".", "status_code", ",", "e", ".", "error", ")", ")"], "docstring": "Retrieve template definition of index or index/type\n\n    name\n        Index template name\n\n    CLI example::\n\n        salt myminion elasticsearch.index_template_get testindex_templ", "docstring_tokens": ["Retrieve", "template", "definition", "of", "index", "or", "index", "/", "type"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/modules/elasticsearch.py#L794-L812", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/modules/elasticsearch.py", "func_name": "pipeline_get", "original_string": "def pipeline_get(id, hosts=None, profile=None):\n    '''\n    .. versionadded:: 2017.7.0\n\n    Retrieve Ingest pipeline definition. Available since Elasticsearch 5.0.\n\n    id\n        Pipeline id\n\n    CLI example::\n\n        salt myminion elasticsearch.pipeline_get mypipeline\n    '''\n    es = _get_instance(hosts, profile)\n\n    try:\n        return es.ingest.get_pipeline(id=id)\n    except elasticsearch.NotFoundError:\n        return None\n    except elasticsearch.TransportError as e:\n        raise CommandExecutionError(\"Cannot create pipeline {0}, server returned code {1} with message {2}\".format(id, e.status_code, e.error))\n    except AttributeError:\n        raise CommandExecutionError(\"Method is applicable only for Elasticsearch 5.0+\")", "language": "python", "code": "def pipeline_get(id, hosts=None, profile=None):\n    '''\n    .. versionadded:: 2017.7.0\n\n    Retrieve Ingest pipeline definition. Available since Elasticsearch 5.0.\n\n    id\n        Pipeline id\n\n    CLI example::\n\n        salt myminion elasticsearch.pipeline_get mypipeline\n    '''\n    es = _get_instance(hosts, profile)\n\n    try:\n        return es.ingest.get_pipeline(id=id)\n    except elasticsearch.NotFoundError:\n        return None\n    except elasticsearch.TransportError as e:\n        raise CommandExecutionError(\"Cannot create pipeline {0}, server returned code {1} with message {2}\".format(id, e.status_code, e.error))\n    except AttributeError:\n        raise CommandExecutionError(\"Method is applicable only for Elasticsearch 5.0+\")", "code_tokens": ["def", "pipeline_get", "(", "id", ",", "hosts", "=", "None", ",", "profile", "=", "None", ")", ":", "es", "=", "_get_instance", "(", "hosts", ",", "profile", ")", "try", ":", "return", "es", ".", "ingest", ".", "get_pipeline", "(", "id", "=", "id", ")", "except", "elasticsearch", ".", "NotFoundError", ":", "return", "None", "except", "elasticsearch", ".", "TransportError", "as", "e", ":", "raise", "CommandExecutionError", "(", "\"Cannot create pipeline {0}, server returned code {1} with message {2}\"", ".", "format", "(", "id", ",", "e", ".", "status_code", ",", "e", ".", "error", ")", ")", "except", "AttributeError", ":", "raise", "CommandExecutionError", "(", "\"Method is applicable only for Elasticsearch 5.0+\"", ")"], "docstring": ".. versionadded:: 2017.7.0\n\n    Retrieve Ingest pipeline definition. Available since Elasticsearch 5.0.\n\n    id\n        Pipeline id\n\n    CLI example::\n\n        salt myminion elasticsearch.pipeline_get mypipeline", "docstring_tokens": ["..", "versionadded", "::", "2017", ".", "7", ".", "0"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/modules/elasticsearch.py#L815-L837", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/modules/elasticsearch.py", "func_name": "pipeline_delete", "original_string": "def pipeline_delete(id, hosts=None, profile=None):\n    '''\n    .. versionadded:: 2017.7.0\n\n    Delete Ingest pipeline. Available since Elasticsearch 5.0.\n\n    id\n        Pipeline id\n\n    CLI example::\n\n        salt myminion elasticsearch.pipeline_delete mypipeline\n    '''\n    es = _get_instance(hosts, profile)\n\n    try:\n        ret = es.ingest.delete_pipeline(id=id)\n        return ret.get('acknowledged', False)\n    except elasticsearch.NotFoundError:\n        return True\n    except elasticsearch.TransportError as e:\n        raise CommandExecutionError(\"Cannot delete pipeline {0}, server returned code {1} with message {2}\".format(id, e.status_code, e.error))\n    except AttributeError:\n        raise CommandExecutionError(\"Method is applicable only for Elasticsearch 5.0+\")", "language": "python", "code": "def pipeline_delete(id, hosts=None, profile=None):\n    '''\n    .. versionadded:: 2017.7.0\n\n    Delete Ingest pipeline. Available since Elasticsearch 5.0.\n\n    id\n        Pipeline id\n\n    CLI example::\n\n        salt myminion elasticsearch.pipeline_delete mypipeline\n    '''\n    es = _get_instance(hosts, profile)\n\n    try:\n        ret = es.ingest.delete_pipeline(id=id)\n        return ret.get('acknowledged', False)\n    except elasticsearch.NotFoundError:\n        return True\n    except elasticsearch.TransportError as e:\n        raise CommandExecutionError(\"Cannot delete pipeline {0}, server returned code {1} with message {2}\".format(id, e.status_code, e.error))\n    except AttributeError:\n        raise CommandExecutionError(\"Method is applicable only for Elasticsearch 5.0+\")", "code_tokens": ["def", "pipeline_delete", "(", "id", ",", "hosts", "=", "None", ",", "profile", "=", "None", ")", ":", "es", "=", "_get_instance", "(", "hosts", ",", "profile", ")", "try", ":", "ret", "=", "es", ".", "ingest", ".", "delete_pipeline", "(", "id", "=", "id", ")", "return", "ret", ".", "get", "(", "'acknowledged'", ",", "False", ")", "except", "elasticsearch", ".", "NotFoundError", ":", "return", "True", "except", "elasticsearch", ".", "TransportError", "as", "e", ":", "raise", "CommandExecutionError", "(", "\"Cannot delete pipeline {0}, server returned code {1} with message {2}\"", ".", "format", "(", "id", ",", "e", ".", "status_code", ",", "e", ".", "error", ")", ")", "except", "AttributeError", ":", "raise", "CommandExecutionError", "(", "\"Method is applicable only for Elasticsearch 5.0+\"", ")"], "docstring": ".. versionadded:: 2017.7.0\n\n    Delete Ingest pipeline. Available since Elasticsearch 5.0.\n\n    id\n        Pipeline id\n\n    CLI example::\n\n        salt myminion elasticsearch.pipeline_delete mypipeline", "docstring_tokens": ["..", "versionadded", "::", "2017", ".", "7", ".", "0"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/modules/elasticsearch.py#L840-L863", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/modules/elasticsearch.py", "func_name": "pipeline_create", "original_string": "def pipeline_create(id, body, hosts=None, profile=None):\n    '''\n    .. versionadded:: 2017.7.0\n\n    Create Ingest pipeline by supplied definition. Available since Elasticsearch 5.0.\n\n    id\n        Pipeline id\n    body\n        Pipeline definition as specified in https://www.elastic.co/guide/en/elasticsearch/reference/master/pipeline.html\n\n    CLI example::\n\n        salt myminion elasticsearch.pipeline_create mypipeline '{\"description\": \"my custom pipeline\", \"processors\": [{\"set\" : {\"field\": \"collector_timestamp_millis\", \"value\": \"{{_ingest.timestamp}}\"}}]}'\n    '''\n    es = _get_instance(hosts, profile)\n    try:\n        out = es.ingest.put_pipeline(id=id, body=body)\n        return out.get('acknowledged', False)\n    except elasticsearch.TransportError as e:\n        raise CommandExecutionError(\"Cannot create pipeline {0}, server returned code {1} with message {2}\".format(id, e.status_code, e.error))\n    except AttributeError:\n        raise CommandExecutionError(\"Method is applicable only for Elasticsearch 5.0+\")", "language": "python", "code": "def pipeline_create(id, body, hosts=None, profile=None):\n    '''\n    .. versionadded:: 2017.7.0\n\n    Create Ingest pipeline by supplied definition. Available since Elasticsearch 5.0.\n\n    id\n        Pipeline id\n    body\n        Pipeline definition as specified in https://www.elastic.co/guide/en/elasticsearch/reference/master/pipeline.html\n\n    CLI example::\n\n        salt myminion elasticsearch.pipeline_create mypipeline '{\"description\": \"my custom pipeline\", \"processors\": [{\"set\" : {\"field\": \"collector_timestamp_millis\", \"value\": \"{{_ingest.timestamp}}\"}}]}'\n    '''\n    es = _get_instance(hosts, profile)\n    try:\n        out = es.ingest.put_pipeline(id=id, body=body)\n        return out.get('acknowledged', False)\n    except elasticsearch.TransportError as e:\n        raise CommandExecutionError(\"Cannot create pipeline {0}, server returned code {1} with message {2}\".format(id, e.status_code, e.error))\n    except AttributeError:\n        raise CommandExecutionError(\"Method is applicable only for Elasticsearch 5.0+\")", "code_tokens": ["def", "pipeline_create", "(", "id", ",", "body", ",", "hosts", "=", "None", ",", "profile", "=", "None", ")", ":", "es", "=", "_get_instance", "(", "hosts", ",", "profile", ")", "try", ":", "out", "=", "es", ".", "ingest", ".", "put_pipeline", "(", "id", "=", "id", ",", "body", "=", "body", ")", "return", "out", ".", "get", "(", "'acknowledged'", ",", "False", ")", "except", "elasticsearch", ".", "TransportError", "as", "e", ":", "raise", "CommandExecutionError", "(", "\"Cannot create pipeline {0}, server returned code {1} with message {2}\"", ".", "format", "(", "id", ",", "e", ".", "status_code", ",", "e", ".", "error", ")", ")", "except", "AttributeError", ":", "raise", "CommandExecutionError", "(", "\"Method is applicable only for Elasticsearch 5.0+\"", ")"], "docstring": ".. versionadded:: 2017.7.0\n\n    Create Ingest pipeline by supplied definition. Available since Elasticsearch 5.0.\n\n    id\n        Pipeline id\n    body\n        Pipeline definition as specified in https://www.elastic.co/guide/en/elasticsearch/reference/master/pipeline.html\n\n    CLI example::\n\n        salt myminion elasticsearch.pipeline_create mypipeline '{\"description\": \"my custom pipeline\", \"processors\": [{\"set\" : {\"field\": \"collector_timestamp_millis\", \"value\": \"{{_ingest.timestamp}}\"}}]}'", "docstring_tokens": ["..", "versionadded", "::", "2017", ".", "7", ".", "0"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/modules/elasticsearch.py#L866-L888", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/modules/elasticsearch.py", "func_name": "pipeline_simulate", "original_string": "def pipeline_simulate(id, body, verbose=False, hosts=None, profile=None):\n    '''\n    .. versionadded:: 2017.7.0\n\n    Simulate existing Ingest pipeline on provided data. Available since Elasticsearch 5.0.\n\n    id\n        Pipeline id\n    body\n        Pipeline definition as specified in https://www.elastic.co/guide/en/elasticsearch/reference/master/pipeline.html\n    verbose\n        Specify if the output should be more verbose\n\n    CLI example::\n\n        salt myminion elasticsearch.pipeline_simulate mypipeline '{\"docs\":[{\"_index\":\"index\",\"_type\":\"type\",\"_id\":\"id\",\"_source\":{\"foo\":\"bar\"}},{\"_index\":\"index\",\"_type\":\"type\",\"_id\":\"id\",\"_source\":{\"foo\":\"rab\"}}]}' verbose=True\n    '''\n    es = _get_instance(hosts, profile)\n    try:\n        return es.ingest.simulate(id=id, body=body, verbose=verbose)\n    except elasticsearch.TransportError as e:\n        raise CommandExecutionError(\"Cannot simulate pipeline {0}, server returned code {1} with message {2}\".format(id, e.status_code, e.error))\n    except AttributeError:\n        raise CommandExecutionError(\"Method is applicable only for Elasticsearch 5.0+\")", "language": "python", "code": "def pipeline_simulate(id, body, verbose=False, hosts=None, profile=None):\n    '''\n    .. versionadded:: 2017.7.0\n\n    Simulate existing Ingest pipeline on provided data. Available since Elasticsearch 5.0.\n\n    id\n        Pipeline id\n    body\n        Pipeline definition as specified in https://www.elastic.co/guide/en/elasticsearch/reference/master/pipeline.html\n    verbose\n        Specify if the output should be more verbose\n\n    CLI example::\n\n        salt myminion elasticsearch.pipeline_simulate mypipeline '{\"docs\":[{\"_index\":\"index\",\"_type\":\"type\",\"_id\":\"id\",\"_source\":{\"foo\":\"bar\"}},{\"_index\":\"index\",\"_type\":\"type\",\"_id\":\"id\",\"_source\":{\"foo\":\"rab\"}}]}' verbose=True\n    '''\n    es = _get_instance(hosts, profile)\n    try:\n        return es.ingest.simulate(id=id, body=body, verbose=verbose)\n    except elasticsearch.TransportError as e:\n        raise CommandExecutionError(\"Cannot simulate pipeline {0}, server returned code {1} with message {2}\".format(id, e.status_code, e.error))\n    except AttributeError:\n        raise CommandExecutionError(\"Method is applicable only for Elasticsearch 5.0+\")", "code_tokens": ["def", "pipeline_simulate", "(", "id", ",", "body", ",", "verbose", "=", "False", ",", "hosts", "=", "None", ",", "profile", "=", "None", ")", ":", "es", "=", "_get_instance", "(", "hosts", ",", "profile", ")", "try", ":", "return", "es", ".", "ingest", ".", "simulate", "(", "id", "=", "id", ",", "body", "=", "body", ",", "verbose", "=", "verbose", ")", "except", "elasticsearch", ".", "TransportError", "as", "e", ":", "raise", "CommandExecutionError", "(", "\"Cannot simulate pipeline {0}, server returned code {1} with message {2}\"", ".", "format", "(", "id", ",", "e", ".", "status_code", ",", "e", ".", "error", ")", ")", "except", "AttributeError", ":", "raise", "CommandExecutionError", "(", "\"Method is applicable only for Elasticsearch 5.0+\"", ")"], "docstring": ".. versionadded:: 2017.7.0\n\n    Simulate existing Ingest pipeline on provided data. Available since Elasticsearch 5.0.\n\n    id\n        Pipeline id\n    body\n        Pipeline definition as specified in https://www.elastic.co/guide/en/elasticsearch/reference/master/pipeline.html\n    verbose\n        Specify if the output should be more verbose\n\n    CLI example::\n\n        salt myminion elasticsearch.pipeline_simulate mypipeline '{\"docs\":[{\"_index\":\"index\",\"_type\":\"type\",\"_id\":\"id\",\"_source\":{\"foo\":\"bar\"}},{\"_index\":\"index\",\"_type\":\"type\",\"_id\":\"id\",\"_source\":{\"foo\":\"rab\"}}]}' verbose=True", "docstring_tokens": ["..", "versionadded", "::", "2017", ".", "7", ".", "0"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/modules/elasticsearch.py#L891-L914", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/modules/elasticsearch.py", "func_name": "search_template_get", "original_string": "def search_template_get(id, hosts=None, profile=None):\n    '''\n    .. versionadded:: 2017.7.0\n\n    Obtain existing search template definition.\n\n    id\n        Template ID\n\n    CLI example::\n\n        salt myminion elasticsearch.search_template_get mytemplate\n    '''\n    es = _get_instance(hosts, profile)\n\n    try:\n        return es.get_template(id=id)\n    except elasticsearch.NotFoundError:\n        return None\n    except elasticsearch.TransportError as e:\n        raise CommandExecutionError(\"Cannot obtain search template {0}, server returned code {1} with message {2}\".format(id, e.status_code, e.error))", "language": "python", "code": "def search_template_get(id, hosts=None, profile=None):\n    '''\n    .. versionadded:: 2017.7.0\n\n    Obtain existing search template definition.\n\n    id\n        Template ID\n\n    CLI example::\n\n        salt myminion elasticsearch.search_template_get mytemplate\n    '''\n    es = _get_instance(hosts, profile)\n\n    try:\n        return es.get_template(id=id)\n    except elasticsearch.NotFoundError:\n        return None\n    except elasticsearch.TransportError as e:\n        raise CommandExecutionError(\"Cannot obtain search template {0}, server returned code {1} with message {2}\".format(id, e.status_code, e.error))", "code_tokens": ["def", "search_template_get", "(", "id", ",", "hosts", "=", "None", ",", "profile", "=", "None", ")", ":", "es", "=", "_get_instance", "(", "hosts", ",", "profile", ")", "try", ":", "return", "es", ".", "get_template", "(", "id", "=", "id", ")", "except", "elasticsearch", ".", "NotFoundError", ":", "return", "None", "except", "elasticsearch", ".", "TransportError", "as", "e", ":", "raise", "CommandExecutionError", "(", "\"Cannot obtain search template {0}, server returned code {1} with message {2}\"", ".", "format", "(", "id", ",", "e", ".", "status_code", ",", "e", ".", "error", ")", ")"], "docstring": ".. versionadded:: 2017.7.0\n\n    Obtain existing search template definition.\n\n    id\n        Template ID\n\n    CLI example::\n\n        salt myminion elasticsearch.search_template_get mytemplate", "docstring_tokens": ["..", "versionadded", "::", "2017", ".", "7", ".", "0"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/modules/elasticsearch.py#L917-L937", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/modules/elasticsearch.py", "func_name": "search_template_create", "original_string": "def search_template_create(id, body, hosts=None, profile=None):\n    '''\n    .. versionadded:: 2017.7.0\n\n    Create search template by supplied definition\n\n    id\n        Template ID\n    body\n        Search template definition\n\n    CLI example::\n\n        salt myminion elasticsearch.search_template_create mytemplate '{\"template\":{\"query\":{\"match\":{\"title\":\"{{query_string}}\"}}}}'\n    '''\n    es = _get_instance(hosts, profile)\n\n    try:\n        result = es.put_template(id=id, body=body)\n\n        return result.get('acknowledged', False)\n    except elasticsearch.TransportError as e:\n        raise CommandExecutionError(\"Cannot create search template {0}, server returned code {1} with message {2}\".format(id, e.status_code, e.error))", "language": "python", "code": "def search_template_create(id, body, hosts=None, profile=None):\n    '''\n    .. versionadded:: 2017.7.0\n\n    Create search template by supplied definition\n\n    id\n        Template ID\n    body\n        Search template definition\n\n    CLI example::\n\n        salt myminion elasticsearch.search_template_create mytemplate '{\"template\":{\"query\":{\"match\":{\"title\":\"{{query_string}}\"}}}}'\n    '''\n    es = _get_instance(hosts, profile)\n\n    try:\n        result = es.put_template(id=id, body=body)\n\n        return result.get('acknowledged', False)\n    except elasticsearch.TransportError as e:\n        raise CommandExecutionError(\"Cannot create search template {0}, server returned code {1} with message {2}\".format(id, e.status_code, e.error))", "code_tokens": ["def", "search_template_create", "(", "id", ",", "body", ",", "hosts", "=", "None", ",", "profile", "=", "None", ")", ":", "es", "=", "_get_instance", "(", "hosts", ",", "profile", ")", "try", ":", "result", "=", "es", ".", "put_template", "(", "id", "=", "id", ",", "body", "=", "body", ")", "return", "result", ".", "get", "(", "'acknowledged'", ",", "False", ")", "except", "elasticsearch", ".", "TransportError", "as", "e", ":", "raise", "CommandExecutionError", "(", "\"Cannot create search template {0}, server returned code {1} with message {2}\"", ".", "format", "(", "id", ",", "e", ".", "status_code", ",", "e", ".", "error", ")", ")"], "docstring": ".. versionadded:: 2017.7.0\n\n    Create search template by supplied definition\n\n    id\n        Template ID\n    body\n        Search template definition\n\n    CLI example::\n\n        salt myminion elasticsearch.search_template_create mytemplate '{\"template\":{\"query\":{\"match\":{\"title\":\"{{query_string}}\"}}}}'", "docstring_tokens": ["..", "versionadded", "::", "2017", ".", "7", ".", "0"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/modules/elasticsearch.py#L940-L962", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/modules/elasticsearch.py", "func_name": "search_template_delete", "original_string": "def search_template_delete(id, hosts=None, profile=None):\n    '''\n    .. versionadded:: 2017.7.0\n\n    Delete existing search template definition.\n\n    id\n        Template ID\n\n    CLI example::\n\n        salt myminion elasticsearch.search_template_delete mytemplate\n    '''\n    es = _get_instance(hosts, profile)\n\n    try:\n        result = es.delete_template(id=id)\n\n        return result.get('acknowledged', False)\n    except elasticsearch.NotFoundError:\n        return True\n    except elasticsearch.TransportError as e:\n        raise CommandExecutionError(\"Cannot delete search template {0}, server returned code {1} with message {2}\".format(id, e.status_code, e.error))", "language": "python", "code": "def search_template_delete(id, hosts=None, profile=None):\n    '''\n    .. versionadded:: 2017.7.0\n\n    Delete existing search template definition.\n\n    id\n        Template ID\n\n    CLI example::\n\n        salt myminion elasticsearch.search_template_delete mytemplate\n    '''\n    es = _get_instance(hosts, profile)\n\n    try:\n        result = es.delete_template(id=id)\n\n        return result.get('acknowledged', False)\n    except elasticsearch.NotFoundError:\n        return True\n    except elasticsearch.TransportError as e:\n        raise CommandExecutionError(\"Cannot delete search template {0}, server returned code {1} with message {2}\".format(id, e.status_code, e.error))", "code_tokens": ["def", "search_template_delete", "(", "id", ",", "hosts", "=", "None", ",", "profile", "=", "None", ")", ":", "es", "=", "_get_instance", "(", "hosts", ",", "profile", ")", "try", ":", "result", "=", "es", ".", "delete_template", "(", "id", "=", "id", ")", "return", "result", ".", "get", "(", "'acknowledged'", ",", "False", ")", "except", "elasticsearch", ".", "NotFoundError", ":", "return", "True", "except", "elasticsearch", ".", "TransportError", "as", "e", ":", "raise", "CommandExecutionError", "(", "\"Cannot delete search template {0}, server returned code {1} with message {2}\"", ".", "format", "(", "id", ",", "e", ".", "status_code", ",", "e", ".", "error", ")", ")"], "docstring": ".. versionadded:: 2017.7.0\n\n    Delete existing search template definition.\n\n    id\n        Template ID\n\n    CLI example::\n\n        salt myminion elasticsearch.search_template_delete mytemplate", "docstring_tokens": ["..", "versionadded", "::", "2017", ".", "7", ".", "0"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/modules/elasticsearch.py#L965-L987", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/modules/elasticsearch.py", "func_name": "repository_get", "original_string": "def repository_get(name, local=False, hosts=None, profile=None):\n    '''\n    .. versionadded:: 2017.7.0\n\n    Get existing repository details.\n\n    name\n        Repository name\n    local\n        Retrieve only local information, default is false\n\n    CLI example::\n\n        salt myminion elasticsearch.repository_get testrepo\n    '''\n    es = _get_instance(hosts, profile)\n\n    try:\n        return es.snapshot.get_repository(repository=name, local=local)\n    except elasticsearch.NotFoundError:\n        return None\n    except elasticsearch.TransportError as e:\n        raise CommandExecutionError(\"Cannot obtain repository {0}, server returned code {1} with message {2}\".format(name, e.status_code, e.error))", "language": "python", "code": "def repository_get(name, local=False, hosts=None, profile=None):\n    '''\n    .. versionadded:: 2017.7.0\n\n    Get existing repository details.\n\n    name\n        Repository name\n    local\n        Retrieve only local information, default is false\n\n    CLI example::\n\n        salt myminion elasticsearch.repository_get testrepo\n    '''\n    es = _get_instance(hosts, profile)\n\n    try:\n        return es.snapshot.get_repository(repository=name, local=local)\n    except elasticsearch.NotFoundError:\n        return None\n    except elasticsearch.TransportError as e:\n        raise CommandExecutionError(\"Cannot obtain repository {0}, server returned code {1} with message {2}\".format(name, e.status_code, e.error))", "code_tokens": ["def", "repository_get", "(", "name", ",", "local", "=", "False", ",", "hosts", "=", "None", ",", "profile", "=", "None", ")", ":", "es", "=", "_get_instance", "(", "hosts", ",", "profile", ")", "try", ":", "return", "es", ".", "snapshot", ".", "get_repository", "(", "repository", "=", "name", ",", "local", "=", "local", ")", "except", "elasticsearch", ".", "NotFoundError", ":", "return", "None", "except", "elasticsearch", ".", "TransportError", "as", "e", ":", "raise", "CommandExecutionError", "(", "\"Cannot obtain repository {0}, server returned code {1} with message {2}\"", ".", "format", "(", "name", ",", "e", ".", "status_code", ",", "e", ".", "error", ")", ")"], "docstring": ".. versionadded:: 2017.7.0\n\n    Get existing repository details.\n\n    name\n        Repository name\n    local\n        Retrieve only local information, default is false\n\n    CLI example::\n\n        salt myminion elasticsearch.repository_get testrepo", "docstring_tokens": ["..", "versionadded", "::", "2017", ".", "7", ".", "0"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/modules/elasticsearch.py#L990-L1012", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/modules/elasticsearch.py", "func_name": "repository_create", "original_string": "def repository_create(name, body, hosts=None, profile=None):\n    '''\n    .. versionadded:: 2017.7.0\n\n    Create repository for storing snapshots. Note that shared repository paths have to be specified in path.repo Elasticsearch configuration option.\n\n    name\n        Repository name\n    body\n        Repository definition as in https://www.elastic.co/guide/en/elasticsearch/reference/current/modules-snapshots.html\n\n    CLI example::\n\n        salt myminion elasticsearch.repository_create testrepo '{\"type\":\"fs\",\"settings\":{\"location\":\"/tmp/test\",\"compress\":true}}'\n    '''\n    es = _get_instance(hosts, profile)\n\n    try:\n        result = es.snapshot.create_repository(repository=name, body=body)\n\n        return result.get('acknowledged', False)\n    except elasticsearch.TransportError as e:\n        raise CommandExecutionError(\"Cannot create repository {0}, server returned code {1} with message {2}\".format(name, e.status_code, e.error))", "language": "python", "code": "def repository_create(name, body, hosts=None, profile=None):\n    '''\n    .. versionadded:: 2017.7.0\n\n    Create repository for storing snapshots. Note that shared repository paths have to be specified in path.repo Elasticsearch configuration option.\n\n    name\n        Repository name\n    body\n        Repository definition as in https://www.elastic.co/guide/en/elasticsearch/reference/current/modules-snapshots.html\n\n    CLI example::\n\n        salt myminion elasticsearch.repository_create testrepo '{\"type\":\"fs\",\"settings\":{\"location\":\"/tmp/test\",\"compress\":true}}'\n    '''\n    es = _get_instance(hosts, profile)\n\n    try:\n        result = es.snapshot.create_repository(repository=name, body=body)\n\n        return result.get('acknowledged', False)\n    except elasticsearch.TransportError as e:\n        raise CommandExecutionError(\"Cannot create repository {0}, server returned code {1} with message {2}\".format(name, e.status_code, e.error))", "code_tokens": ["def", "repository_create", "(", "name", ",", "body", ",", "hosts", "=", "None", ",", "profile", "=", "None", ")", ":", "es", "=", "_get_instance", "(", "hosts", ",", "profile", ")", "try", ":", "result", "=", "es", ".", "snapshot", ".", "create_repository", "(", "repository", "=", "name", ",", "body", "=", "body", ")", "return", "result", ".", "get", "(", "'acknowledged'", ",", "False", ")", "except", "elasticsearch", ".", "TransportError", "as", "e", ":", "raise", "CommandExecutionError", "(", "\"Cannot create repository {0}, server returned code {1} with message {2}\"", ".", "format", "(", "name", ",", "e", ".", "status_code", ",", "e", ".", "error", ")", ")"], "docstring": ".. versionadded:: 2017.7.0\n\n    Create repository for storing snapshots. Note that shared repository paths have to be specified in path.repo Elasticsearch configuration option.\n\n    name\n        Repository name\n    body\n        Repository definition as in https://www.elastic.co/guide/en/elasticsearch/reference/current/modules-snapshots.html\n\n    CLI example::\n\n        salt myminion elasticsearch.repository_create testrepo '{\"type\":\"fs\",\"settings\":{\"location\":\"/tmp/test\",\"compress\":true}}'", "docstring_tokens": ["..", "versionadded", "::", "2017", ".", "7", ".", "0"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/modules/elasticsearch.py#L1015-L1037", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/modules/elasticsearch.py", "func_name": "repository_delete", "original_string": "def repository_delete(name, hosts=None, profile=None):\n    '''\n    .. versionadded:: 2017.7.0\n\n    Delete existing repository.\n\n    name\n        Repository name\n\n    CLI example::\n\n        salt myminion elasticsearch.repository_delete testrepo\n    '''\n    es = _get_instance(hosts, profile)\n\n    try:\n        result = es.snapshot.delete_repository(repository=name)\n\n        return result.get('acknowledged', False)\n    except elasticsearch.NotFoundError:\n        return True\n    except elasticsearch.TransportError as e:\n        raise CommandExecutionError(\"Cannot delete repository {0}, server returned code {1} with message {2}\".format(name, e.status_code, e.error))", "language": "python", "code": "def repository_delete(name, hosts=None, profile=None):\n    '''\n    .. versionadded:: 2017.7.0\n\n    Delete existing repository.\n\n    name\n        Repository name\n\n    CLI example::\n\n        salt myminion elasticsearch.repository_delete testrepo\n    '''\n    es = _get_instance(hosts, profile)\n\n    try:\n        result = es.snapshot.delete_repository(repository=name)\n\n        return result.get('acknowledged', False)\n    except elasticsearch.NotFoundError:\n        return True\n    except elasticsearch.TransportError as e:\n        raise CommandExecutionError(\"Cannot delete repository {0}, server returned code {1} with message {2}\".format(name, e.status_code, e.error))", "code_tokens": ["def", "repository_delete", "(", "name", ",", "hosts", "=", "None", ",", "profile", "=", "None", ")", ":", "es", "=", "_get_instance", "(", "hosts", ",", "profile", ")", "try", ":", "result", "=", "es", ".", "snapshot", ".", "delete_repository", "(", "repository", "=", "name", ")", "return", "result", ".", "get", "(", "'acknowledged'", ",", "False", ")", "except", "elasticsearch", ".", "NotFoundError", ":", "return", "True", "except", "elasticsearch", ".", "TransportError", "as", "e", ":", "raise", "CommandExecutionError", "(", "\"Cannot delete repository {0}, server returned code {1} with message {2}\"", ".", "format", "(", "name", ",", "e", ".", "status_code", ",", "e", ".", "error", ")", ")"], "docstring": ".. versionadded:: 2017.7.0\n\n    Delete existing repository.\n\n    name\n        Repository name\n\n    CLI example::\n\n        salt myminion elasticsearch.repository_delete testrepo", "docstring_tokens": ["..", "versionadded", "::", "2017", ".", "7", ".", "0"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/modules/elasticsearch.py#L1040-L1062", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/modules/elasticsearch.py", "func_name": "repository_verify", "original_string": "def repository_verify(name, hosts=None, profile=None):\n    '''\n    .. versionadded:: 2017.7.0\n\n    Obtain list of cluster nodes which successfully verified this repository.\n\n    name\n        Repository name\n\n    CLI example::\n\n        salt myminion elasticsearch.repository_verify testrepo\n    '''\n    es = _get_instance(hosts, profile)\n\n    try:\n        return es.snapshot.verify_repository(repository=name)\n    except elasticsearch.NotFoundError:\n        return None\n    except elasticsearch.TransportError as e:\n        raise CommandExecutionError(\"Cannot verify repository {0}, server returned code {1} with message {2}\".format(name, e.status_code, e.error))", "language": "python", "code": "def repository_verify(name, hosts=None, profile=None):\n    '''\n    .. versionadded:: 2017.7.0\n\n    Obtain list of cluster nodes which successfully verified this repository.\n\n    name\n        Repository name\n\n    CLI example::\n\n        salt myminion elasticsearch.repository_verify testrepo\n    '''\n    es = _get_instance(hosts, profile)\n\n    try:\n        return es.snapshot.verify_repository(repository=name)\n    except elasticsearch.NotFoundError:\n        return None\n    except elasticsearch.TransportError as e:\n        raise CommandExecutionError(\"Cannot verify repository {0}, server returned code {1} with message {2}\".format(name, e.status_code, e.error))", "code_tokens": ["def", "repository_verify", "(", "name", ",", "hosts", "=", "None", ",", "profile", "=", "None", ")", ":", "es", "=", "_get_instance", "(", "hosts", ",", "profile", ")", "try", ":", "return", "es", ".", "snapshot", ".", "verify_repository", "(", "repository", "=", "name", ")", "except", "elasticsearch", ".", "NotFoundError", ":", "return", "None", "except", "elasticsearch", ".", "TransportError", "as", "e", ":", "raise", "CommandExecutionError", "(", "\"Cannot verify repository {0}, server returned code {1} with message {2}\"", ".", "format", "(", "name", ",", "e", ".", "status_code", ",", "e", ".", "error", ")", ")"], "docstring": ".. versionadded:: 2017.7.0\n\n    Obtain list of cluster nodes which successfully verified this repository.\n\n    name\n        Repository name\n\n    CLI example::\n\n        salt myminion elasticsearch.repository_verify testrepo", "docstring_tokens": ["..", "versionadded", "::", "2017", ".", "7", ".", "0"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/modules/elasticsearch.py#L1065-L1085", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/modules/elasticsearch.py", "func_name": "snapshot_status", "original_string": "def snapshot_status(repository=None, snapshot=None, ignore_unavailable=False, hosts=None, profile=None):\n    '''\n    .. versionadded:: 2017.7.0\n\n    Obtain status of all currently running snapshots.\n\n    repository\n        Particular repository to look for snapshots\n    snapshot\n        Snapshot name\n    ignore_unavailable\n        Ignore unavailable snapshots\n\n    CLI example::\n\n        salt myminion elasticsearch.snapshot_status ignore_unavailable=True\n    '''\n    es = _get_instance(hosts, profile)\n\n    try:\n        return es.snapshot.status(repository=repository, snapshot=snapshot, ignore_unavailable=ignore_unavailable)\n    except elasticsearch.TransportError as e:\n        raise CommandExecutionError(\"Cannot obtain snapshot status, server returned code {0} with message {1}\".format(e.status_code, e.error))", "language": "python", "code": "def snapshot_status(repository=None, snapshot=None, ignore_unavailable=False, hosts=None, profile=None):\n    '''\n    .. versionadded:: 2017.7.0\n\n    Obtain status of all currently running snapshots.\n\n    repository\n        Particular repository to look for snapshots\n    snapshot\n        Snapshot name\n    ignore_unavailable\n        Ignore unavailable snapshots\n\n    CLI example::\n\n        salt myminion elasticsearch.snapshot_status ignore_unavailable=True\n    '''\n    es = _get_instance(hosts, profile)\n\n    try:\n        return es.snapshot.status(repository=repository, snapshot=snapshot, ignore_unavailable=ignore_unavailable)\n    except elasticsearch.TransportError as e:\n        raise CommandExecutionError(\"Cannot obtain snapshot status, server returned code {0} with message {1}\".format(e.status_code, e.error))", "code_tokens": ["def", "snapshot_status", "(", "repository", "=", "None", ",", "snapshot", "=", "None", ",", "ignore_unavailable", "=", "False", ",", "hosts", "=", "None", ",", "profile", "=", "None", ")", ":", "es", "=", "_get_instance", "(", "hosts", ",", "profile", ")", "try", ":", "return", "es", ".", "snapshot", ".", "status", "(", "repository", "=", "repository", ",", "snapshot", "=", "snapshot", ",", "ignore_unavailable", "=", "ignore_unavailable", ")", "except", "elasticsearch", ".", "TransportError", "as", "e", ":", "raise", "CommandExecutionError", "(", "\"Cannot obtain snapshot status, server returned code {0} with message {1}\"", ".", "format", "(", "e", ".", "status_code", ",", "e", ".", "error", ")", ")"], "docstring": ".. versionadded:: 2017.7.0\n\n    Obtain status of all currently running snapshots.\n\n    repository\n        Particular repository to look for snapshots\n    snapshot\n        Snapshot name\n    ignore_unavailable\n        Ignore unavailable snapshots\n\n    CLI example::\n\n        salt myminion elasticsearch.snapshot_status ignore_unavailable=True", "docstring_tokens": ["..", "versionadded", "::", "2017", ".", "7", ".", "0"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/modules/elasticsearch.py#L1088-L1110", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/modules/elasticsearch.py", "func_name": "snapshot_get", "original_string": "def snapshot_get(repository, snapshot, ignore_unavailable=False, hosts=None, profile=None):\n    '''\n    .. versionadded:: 2017.7.0\n\n    Obtain snapshot residing in specified repository.\n\n    repository\n        Repository name\n    snapshot\n        Snapshot name, use _all to obtain all snapshots in specified repository\n    ignore_unavailable\n        Ignore unavailable snapshots\n\n    CLI example::\n\n        salt myminion elasticsearch.snapshot_get testrepo testsnapshot\n    '''\n    es = _get_instance(hosts, profile)\n\n    try:\n        return es.snapshot.get(repository=repository, snapshot=snapshot, ignore_unavailable=ignore_unavailable)\n    except elasticsearch.TransportError as e:\n        raise CommandExecutionError(\"Cannot obtain details of snapshot {0} in repository {1}, server returned code {2} with message {3}\".format(snapshot, repository, e.status_code, e.error))", "language": "python", "code": "def snapshot_get(repository, snapshot, ignore_unavailable=False, hosts=None, profile=None):\n    '''\n    .. versionadded:: 2017.7.0\n\n    Obtain snapshot residing in specified repository.\n\n    repository\n        Repository name\n    snapshot\n        Snapshot name, use _all to obtain all snapshots in specified repository\n    ignore_unavailable\n        Ignore unavailable snapshots\n\n    CLI example::\n\n        salt myminion elasticsearch.snapshot_get testrepo testsnapshot\n    '''\n    es = _get_instance(hosts, profile)\n\n    try:\n        return es.snapshot.get(repository=repository, snapshot=snapshot, ignore_unavailable=ignore_unavailable)\n    except elasticsearch.TransportError as e:\n        raise CommandExecutionError(\"Cannot obtain details of snapshot {0} in repository {1}, server returned code {2} with message {3}\".format(snapshot, repository, e.status_code, e.error))", "code_tokens": ["def", "snapshot_get", "(", "repository", ",", "snapshot", ",", "ignore_unavailable", "=", "False", ",", "hosts", "=", "None", ",", "profile", "=", "None", ")", ":", "es", "=", "_get_instance", "(", "hosts", ",", "profile", ")", "try", ":", "return", "es", ".", "snapshot", ".", "get", "(", "repository", "=", "repository", ",", "snapshot", "=", "snapshot", ",", "ignore_unavailable", "=", "ignore_unavailable", ")", "except", "elasticsearch", ".", "TransportError", "as", "e", ":", "raise", "CommandExecutionError", "(", "\"Cannot obtain details of snapshot {0} in repository {1}, server returned code {2} with message {3}\"", ".", "format", "(", "snapshot", ",", "repository", ",", "e", ".", "status_code", ",", "e", ".", "error", ")", ")"], "docstring": ".. versionadded:: 2017.7.0\n\n    Obtain snapshot residing in specified repository.\n\n    repository\n        Repository name\n    snapshot\n        Snapshot name, use _all to obtain all snapshots in specified repository\n    ignore_unavailable\n        Ignore unavailable snapshots\n\n    CLI example::\n\n        salt myminion elasticsearch.snapshot_get testrepo testsnapshot", "docstring_tokens": ["..", "versionadded", "::", "2017", ".", "7", ".", "0"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/modules/elasticsearch.py#L1113-L1135", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/modules/elasticsearch.py", "func_name": "snapshot_create", "original_string": "def snapshot_create(repository, snapshot, body=None, hosts=None, profile=None):\n    '''\n    .. versionadded:: 2017.7.0\n\n    Create snapshot in specified repository by supplied definition.\n\n    repository\n        Repository name\n    snapshot\n        Snapshot name\n    body\n        Snapshot definition as in https://www.elastic.co/guide/en/elasticsearch/reference/current/modules-snapshots.html\n\n    CLI example::\n\n        salt myminion elasticsearch.snapshot_create testrepo testsnapshot '{\"indices\":\"index_1,index_2\",\"ignore_unavailable\":true,\"include_global_state\":false}'\n    '''\n    es = _get_instance(hosts, profile)\n\n    try:\n        response = es.snapshot.create(repository=repository, snapshot=snapshot, body=body)\n\n        return response.get('accepted', False)\n    except elasticsearch.TransportError as e:\n        raise CommandExecutionError(\"Cannot create snapshot {0} in repository {1}, server returned code {2} with message {3}\".format(snapshot, repository, e.status_code, e.error))", "language": "python", "code": "def snapshot_create(repository, snapshot, body=None, hosts=None, profile=None):\n    '''\n    .. versionadded:: 2017.7.0\n\n    Create snapshot in specified repository by supplied definition.\n\n    repository\n        Repository name\n    snapshot\n        Snapshot name\n    body\n        Snapshot definition as in https://www.elastic.co/guide/en/elasticsearch/reference/current/modules-snapshots.html\n\n    CLI example::\n\n        salt myminion elasticsearch.snapshot_create testrepo testsnapshot '{\"indices\":\"index_1,index_2\",\"ignore_unavailable\":true,\"include_global_state\":false}'\n    '''\n    es = _get_instance(hosts, profile)\n\n    try:\n        response = es.snapshot.create(repository=repository, snapshot=snapshot, body=body)\n\n        return response.get('accepted', False)\n    except elasticsearch.TransportError as e:\n        raise CommandExecutionError(\"Cannot create snapshot {0} in repository {1}, server returned code {2} with message {3}\".format(snapshot, repository, e.status_code, e.error))", "code_tokens": ["def", "snapshot_create", "(", "repository", ",", "snapshot", ",", "body", "=", "None", ",", "hosts", "=", "None", ",", "profile", "=", "None", ")", ":", "es", "=", "_get_instance", "(", "hosts", ",", "profile", ")", "try", ":", "response", "=", "es", ".", "snapshot", ".", "create", "(", "repository", "=", "repository", ",", "snapshot", "=", "snapshot", ",", "body", "=", "body", ")", "return", "response", ".", "get", "(", "'accepted'", ",", "False", ")", "except", "elasticsearch", ".", "TransportError", "as", "e", ":", "raise", "CommandExecutionError", "(", "\"Cannot create snapshot {0} in repository {1}, server returned code {2} with message {3}\"", ".", "format", "(", "snapshot", ",", "repository", ",", "e", ".", "status_code", ",", "e", ".", "error", ")", ")"], "docstring": ".. versionadded:: 2017.7.0\n\n    Create snapshot in specified repository by supplied definition.\n\n    repository\n        Repository name\n    snapshot\n        Snapshot name\n    body\n        Snapshot definition as in https://www.elastic.co/guide/en/elasticsearch/reference/current/modules-snapshots.html\n\n    CLI example::\n\n        salt myminion elasticsearch.snapshot_create testrepo testsnapshot '{\"indices\":\"index_1,index_2\",\"ignore_unavailable\":true,\"include_global_state\":false}'", "docstring_tokens": ["..", "versionadded", "::", "2017", ".", "7", ".", "0"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/modules/elasticsearch.py#L1138-L1162", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/modules/elasticsearch.py", "func_name": "snapshot_delete", "original_string": "def snapshot_delete(repository, snapshot, hosts=None, profile=None):\n    '''\n    .. versionadded:: 2017.7.0\n\n    Delete snapshot from specified repository.\n\n    repository\n        Repository name\n    snapshot\n        Snapshot name\n\n    CLI example::\n\n        salt myminion elasticsearch.snapshot_delete testrepo testsnapshot\n    '''\n    es = _get_instance(hosts, profile)\n\n    try:\n        result = es.snapshot.delete(repository=repository, snapshot=snapshot)\n\n        return result.get('acknowledged', False)\n    except elasticsearch.NotFoundError:\n        return True\n    except elasticsearch.TransportError as e:\n        raise CommandExecutionError(\"Cannot delete snapshot {0} from repository {1}, server returned code {2} with message {3}\".format(snapshot, repository, e.status_code, e.error))", "language": "python", "code": "def snapshot_delete(repository, snapshot, hosts=None, profile=None):\n    '''\n    .. versionadded:: 2017.7.0\n\n    Delete snapshot from specified repository.\n\n    repository\n        Repository name\n    snapshot\n        Snapshot name\n\n    CLI example::\n\n        salt myminion elasticsearch.snapshot_delete testrepo testsnapshot\n    '''\n    es = _get_instance(hosts, profile)\n\n    try:\n        result = es.snapshot.delete(repository=repository, snapshot=snapshot)\n\n        return result.get('acknowledged', False)\n    except elasticsearch.NotFoundError:\n        return True\n    except elasticsearch.TransportError as e:\n        raise CommandExecutionError(\"Cannot delete snapshot {0} from repository {1}, server returned code {2} with message {3}\".format(snapshot, repository, e.status_code, e.error))", "code_tokens": ["def", "snapshot_delete", "(", "repository", ",", "snapshot", ",", "hosts", "=", "None", ",", "profile", "=", "None", ")", ":", "es", "=", "_get_instance", "(", "hosts", ",", "profile", ")", "try", ":", "result", "=", "es", ".", "snapshot", ".", "delete", "(", "repository", "=", "repository", ",", "snapshot", "=", "snapshot", ")", "return", "result", ".", "get", "(", "'acknowledged'", ",", "False", ")", "except", "elasticsearch", ".", "NotFoundError", ":", "return", "True", "except", "elasticsearch", ".", "TransportError", "as", "e", ":", "raise", "CommandExecutionError", "(", "\"Cannot delete snapshot {0} from repository {1}, server returned code {2} with message {3}\"", ".", "format", "(", "snapshot", ",", "repository", ",", "e", ".", "status_code", ",", "e", ".", "error", ")", ")"], "docstring": ".. versionadded:: 2017.7.0\n\n    Delete snapshot from specified repository.\n\n    repository\n        Repository name\n    snapshot\n        Snapshot name\n\n    CLI example::\n\n        salt myminion elasticsearch.snapshot_delete testrepo testsnapshot", "docstring_tokens": ["..", "versionadded", "::", "2017", ".", "7", ".", "0"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/modules/elasticsearch.py#L1192-L1216", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/states/snap.py", "func_name": "installed", "original_string": "def installed(name, channel=None):\n    '''\n    Ensure that the named snap package is installed\n\n    name\n        The snap package\n\n    channel\n        Optional. The channel to install the package from.\n    '''\n    ret = {'name': name,\n           'changes': {},\n           'pchanges': {},\n           'result': None,\n           'comment': ''}\n\n    old = __salt__['snap.versions_installed'](name)\n    if not old:\n        if __opts__['test']:\n            ret['comment'] = 'Package \"{0}\" would have been installed'.format(name)\n            ret['pchanges']['new'] = name\n            ret['pchanges']['old'] = None\n            ret['result'] = None\n            return ret\n\n        install = __salt__['snap.install'](name, channel=channel)\n        if install['result']:\n            ret['comment'] = 'Package \"{0}\" was installed'.format(name)\n            ret['changes']['new'] = name\n            ret['changes']['old'] = None\n            ret['result'] = True\n            return ret\n\n        ret['comment'] = 'Package \"{0}\" failed to install'.format(name)\n        ret['comment'] += '\\noutput:\\n' + install['output']\n        ret['result'] = False\n        return ret\n\n    # Currently snap always returns only one line?\n    old_channel = old[0]['tracking']\n    if old_channel != channel and channel is not None:\n        if __opts__['test']:\n            ret['comment'] = 'Package \"{0}\" would have been switched to channel {1}'.format(name, channel)\n            ret['pchanges']['old_channel'] = old_channel\n            ret['pchanges']['new_channel'] = channel\n            ret['result'] = None\n            return ret\n\n        refresh = __salt__['snap.install'](name, channel=channel, refresh=True)\n        if refresh['result']:\n            ret['comment'] = 'Package \"{0}\" was switched to channel {1}'.format(name, channel)\n            ret['pchanges']['old_channel'] = old_channel\n            ret['pchanges']['new_channel'] = channel\n            ret['result'] = True\n            return ret\n\n        ret['comment'] = 'Failed to switch Package \"{0}\" to channel {1}'.format(name, channel)\n        ret['comment'] += '\\noutput:\\n' + install['output']\n        ret['result'] = False\n        return ret\n\n    ret['comment'] = 'Package \"{0}\" is already installed'.format(name)\n    if __opts__['test']:\n        ret['result'] = None\n        return ret\n\n    ret['result'] = True\n    return ret", "language": "python", "code": "def installed(name, channel=None):\n    '''\n    Ensure that the named snap package is installed\n\n    name\n        The snap package\n\n    channel\n        Optional. The channel to install the package from.\n    '''\n    ret = {'name': name,\n           'changes': {},\n           'pchanges': {},\n           'result': None,\n           'comment': ''}\n\n    old = __salt__['snap.versions_installed'](name)\n    if not old:\n        if __opts__['test']:\n            ret['comment'] = 'Package \"{0}\" would have been installed'.format(name)\n            ret['pchanges']['new'] = name\n            ret['pchanges']['old'] = None\n            ret['result'] = None\n            return ret\n\n        install = __salt__['snap.install'](name, channel=channel)\n        if install['result']:\n            ret['comment'] = 'Package \"{0}\" was installed'.format(name)\n            ret['changes']['new'] = name\n            ret['changes']['old'] = None\n            ret['result'] = True\n            return ret\n\n        ret['comment'] = 'Package \"{0}\" failed to install'.format(name)\n        ret['comment'] += '\\noutput:\\n' + install['output']\n        ret['result'] = False\n        return ret\n\n    # Currently snap always returns only one line?\n    old_channel = old[0]['tracking']\n    if old_channel != channel and channel is not None:\n        if __opts__['test']:\n            ret['comment'] = 'Package \"{0}\" would have been switched to channel {1}'.format(name, channel)\n            ret['pchanges']['old_channel'] = old_channel\n            ret['pchanges']['new_channel'] = channel\n            ret['result'] = None\n            return ret\n\n        refresh = __salt__['snap.install'](name, channel=channel, refresh=True)\n        if refresh['result']:\n            ret['comment'] = 'Package \"{0}\" was switched to channel {1}'.format(name, channel)\n            ret['pchanges']['old_channel'] = old_channel\n            ret['pchanges']['new_channel'] = channel\n            ret['result'] = True\n            return ret\n\n        ret['comment'] = 'Failed to switch Package \"{0}\" to channel {1}'.format(name, channel)\n        ret['comment'] += '\\noutput:\\n' + install['output']\n        ret['result'] = False\n        return ret\n\n    ret['comment'] = 'Package \"{0}\" is already installed'.format(name)\n    if __opts__['test']:\n        ret['result'] = None\n        return ret\n\n    ret['result'] = True\n    return ret", "code_tokens": ["def", "installed", "(", "name", ",", "channel", "=", "None", ")", ":", "ret", "=", "{", "'name'", ":", "name", ",", "'changes'", ":", "{", "}", ",", "'pchanges'", ":", "{", "}", ",", "'result'", ":", "None", ",", "'comment'", ":", "''", "}", "old", "=", "__salt__", "[", "'snap.versions_installed'", "]", "(", "name", ")", "if", "not", "old", ":", "if", "__opts__", "[", "'test'", "]", ":", "ret", "[", "'comment'", "]", "=", "'Package \"{0}\" would have been installed'", ".", "format", "(", "name", ")", "ret", "[", "'pchanges'", "]", "[", "'new'", "]", "=", "name", "ret", "[", "'pchanges'", "]", "[", "'old'", "]", "=", "None", "ret", "[", "'result'", "]", "=", "None", "return", "ret", "install", "=", "__salt__", "[", "'snap.install'", "]", "(", "name", ",", "channel", "=", "channel", ")", "if", "install", "[", "'result'", "]", ":", "ret", "[", "'comment'", "]", "=", "'Package \"{0}\" was installed'", ".", "format", "(", "name", ")", "ret", "[", "'changes'", "]", "[", "'new'", "]", "=", "name", "ret", "[", "'changes'", "]", "[", "'old'", "]", "=", "None", "ret", "[", "'result'", "]", "=", "True", "return", "ret", "ret", "[", "'comment'", "]", "=", "'Package \"{0}\" failed to install'", ".", "format", "(", "name", ")", "ret", "[", "'comment'", "]", "+=", "'\\noutput:\\n'", "+", "install", "[", "'output'", "]", "ret", "[", "'result'", "]", "=", "False", "return", "ret", "# Currently snap always returns only one line?", "old_channel", "=", "old", "[", "0", "]", "[", "'tracking'", "]", "if", "old_channel", "!=", "channel", "and", "channel", "is", "not", "None", ":", "if", "__opts__", "[", "'test'", "]", ":", "ret", "[", "'comment'", "]", "=", "'Package \"{0}\" would have been switched to channel {1}'", ".", "format", "(", "name", ",", "channel", ")", "ret", "[", "'pchanges'", "]", "[", "'old_channel'", "]", "=", "old_channel", "ret", "[", "'pchanges'", "]", "[", "'new_channel'", "]", "=", "channel", "ret", "[", "'result'", "]", "=", "None", "return", "ret", "refresh", "=", "__salt__", "[", "'snap.install'", "]", "(", "name", ",", "channel", "=", "channel", ",", "refresh", "=", "True", ")", "if", "refresh", "[", "'result'", "]", ":", "ret", "[", "'comment'", "]", "=", "'Package \"{0}\" was switched to channel {1}'", ".", "format", "(", "name", ",", "channel", ")", "ret", "[", "'pchanges'", "]", "[", "'old_channel'", "]", "=", "old_channel", "ret", "[", "'pchanges'", "]", "[", "'new_channel'", "]", "=", "channel", "ret", "[", "'result'", "]", "=", "True", "return", "ret", "ret", "[", "'comment'", "]", "=", "'Failed to switch Package \"{0}\" to channel {1}'", ".", "format", "(", "name", ",", "channel", ")", "ret", "[", "'comment'", "]", "+=", "'\\noutput:\\n'", "+", "install", "[", "'output'", "]", "ret", "[", "'result'", "]", "=", "False", "return", "ret", "ret", "[", "'comment'", "]", "=", "'Package \"{0}\" is already installed'", ".", "format", "(", "name", ")", "if", "__opts__", "[", "'test'", "]", ":", "ret", "[", "'result'", "]", "=", "None", "return", "ret", "ret", "[", "'result'", "]", "=", "True", "return", "ret"], "docstring": "Ensure that the named snap package is installed\n\n    name\n        The snap package\n\n    channel\n        Optional. The channel to install the package from.", "docstring_tokens": ["Ensure", "that", "the", "named", "snap", "package", "is", "installed"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/states/snap.py#L19-L86", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/states/snap.py", "func_name": "removed", "original_string": "def removed(name):\n    '''\n    Ensure that the named snap package is not installed\n\n    name\n        The snap package\n    '''\n\n    ret = {'name': name,\n           'changes': {},\n           'pchanges': {},\n           'result': None,\n           'comment': ''}\n\n    old = __salt__['snap.versions_installed'](name)\n    if not old:\n        ret['comment'] = 'Package {0} is not installed'.format(name)\n        ret['result'] = True\n        return ret\n\n    if __opts__['test']:\n        ret['comment'] = 'Package {0} would have been removed'.format(name)\n        ret['result'] = None\n        ret['pchanges']['old'] = old[0]['version']\n        ret['pchanges']['new'] = None\n        return ret\n\n    remove = __salt__['snap.remove'](name)\n    ret['comment'] = 'Package {0} removed'.format(name)\n    ret['result'] = True\n    ret['changes']['old'] = old[0]['version']\n    ret['changes']['new'] = None\n    return ret", "language": "python", "code": "def removed(name):\n    '''\n    Ensure that the named snap package is not installed\n\n    name\n        The snap package\n    '''\n\n    ret = {'name': name,\n           'changes': {},\n           'pchanges': {},\n           'result': None,\n           'comment': ''}\n\n    old = __salt__['snap.versions_installed'](name)\n    if not old:\n        ret['comment'] = 'Package {0} is not installed'.format(name)\n        ret['result'] = True\n        return ret\n\n    if __opts__['test']:\n        ret['comment'] = 'Package {0} would have been removed'.format(name)\n        ret['result'] = None\n        ret['pchanges']['old'] = old[0]['version']\n        ret['pchanges']['new'] = None\n        return ret\n\n    remove = __salt__['snap.remove'](name)\n    ret['comment'] = 'Package {0} removed'.format(name)\n    ret['result'] = True\n    ret['changes']['old'] = old[0]['version']\n    ret['changes']['new'] = None\n    return ret", "code_tokens": ["def", "removed", "(", "name", ")", ":", "ret", "=", "{", "'name'", ":", "name", ",", "'changes'", ":", "{", "}", ",", "'pchanges'", ":", "{", "}", ",", "'result'", ":", "None", ",", "'comment'", ":", "''", "}", "old", "=", "__salt__", "[", "'snap.versions_installed'", "]", "(", "name", ")", "if", "not", "old", ":", "ret", "[", "'comment'", "]", "=", "'Package {0} is not installed'", ".", "format", "(", "name", ")", "ret", "[", "'result'", "]", "=", "True", "return", "ret", "if", "__opts__", "[", "'test'", "]", ":", "ret", "[", "'comment'", "]", "=", "'Package {0} would have been removed'", ".", "format", "(", "name", ")", "ret", "[", "'result'", "]", "=", "None", "ret", "[", "'pchanges'", "]", "[", "'old'", "]", "=", "old", "[", "0", "]", "[", "'version'", "]", "ret", "[", "'pchanges'", "]", "[", "'new'", "]", "=", "None", "return", "ret", "remove", "=", "__salt__", "[", "'snap.remove'", "]", "(", "name", ")", "ret", "[", "'comment'", "]", "=", "'Package {0} removed'", ".", "format", "(", "name", ")", "ret", "[", "'result'", "]", "=", "True", "ret", "[", "'changes'", "]", "[", "'old'", "]", "=", "old", "[", "0", "]", "[", "'version'", "]", "ret", "[", "'changes'", "]", "[", "'new'", "]", "=", "None", "return", "ret"], "docstring": "Ensure that the named snap package is not installed\n\n    name\n        The snap package", "docstring_tokens": ["Ensure", "that", "the", "named", "snap", "package", "is", "not", "installed"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/states/snap.py#L89-L121", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/beacons/watchdog.py", "func_name": "_get_queue", "original_string": "def _get_queue(config):\n    '''\n    Check the context for the notifier and construct it if not present\n    '''\n\n    if 'watchdog.observer' not in __context__:\n        queue = collections.deque()\n        observer = Observer()\n        for path in config.get('directories', {}):\n            path_params = config.get('directories').get(path)\n            masks = path_params.get('mask', DEFAULT_MASK)\n            event_handler = Handler(queue, masks)\n            observer.schedule(event_handler, path)\n\n        observer.start()\n\n        __context__['watchdog.observer'] = observer\n        __context__['watchdog.queue'] = queue\n\n    return __context__['watchdog.queue']", "language": "python", "code": "def _get_queue(config):\n    '''\n    Check the context for the notifier and construct it if not present\n    '''\n\n    if 'watchdog.observer' not in __context__:\n        queue = collections.deque()\n        observer = Observer()\n        for path in config.get('directories', {}):\n            path_params = config.get('directories').get(path)\n            masks = path_params.get('mask', DEFAULT_MASK)\n            event_handler = Handler(queue, masks)\n            observer.schedule(event_handler, path)\n\n        observer.start()\n\n        __context__['watchdog.observer'] = observer\n        __context__['watchdog.queue'] = queue\n\n    return __context__['watchdog.queue']", "code_tokens": ["def", "_get_queue", "(", "config", ")", ":", "if", "'watchdog.observer'", "not", "in", "__context__", ":", "queue", "=", "collections", ".", "deque", "(", ")", "observer", "=", "Observer", "(", ")", "for", "path", "in", "config", ".", "get", "(", "'directories'", ",", "{", "}", ")", ":", "path_params", "=", "config", ".", "get", "(", "'directories'", ")", ".", "get", "(", "path", ")", "masks", "=", "path_params", ".", "get", "(", "'mask'", ",", "DEFAULT_MASK", ")", "event_handler", "=", "Handler", "(", "queue", ",", "masks", ")", "observer", ".", "schedule", "(", "event_handler", ",", "path", ")", "observer", ".", "start", "(", ")", "__context__", "[", "'watchdog.observer'", "]", "=", "observer", "__context__", "[", "'watchdog.queue'", "]", "=", "queue", "return", "__context__", "[", "'watchdog.queue'", "]"], "docstring": "Check the context for the notifier and construct it if not present", "docstring_tokens": ["Check", "the", "context", "for", "the", "notifier", "and", "construct", "it", "if", "not", "present"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/beacons/watchdog.py#L80-L99", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/beacons/watchdog.py", "func_name": "validate", "original_string": "def validate(config):\n    '''\n    Validate the beacon configuration\n    '''\n\n    try:\n        _validate(config)\n        return True, 'Valid beacon configuration'\n    except ValidationError as error:\n        return False, str(error)", "language": "python", "code": "def validate(config):\n    '''\n    Validate the beacon configuration\n    '''\n\n    try:\n        _validate(config)\n        return True, 'Valid beacon configuration'\n    except ValidationError as error:\n        return False, str(error)", "code_tokens": ["def", "validate", "(", "config", ")", ":", "try", ":", "_validate", "(", "config", ")", "return", "True", ",", "'Valid beacon configuration'", "except", "ValidationError", "as", "error", ":", "return", "False", ",", "str", "(", "error", ")"], "docstring": "Validate the beacon configuration", "docstring_tokens": ["Validate", "the", "beacon", "configuration"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/beacons/watchdog.py#L106-L115", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/beacons/watchdog.py", "func_name": "beacon", "original_string": "def beacon(config):\n    '''\n    Watch the configured directories\n\n    Example Config\n\n    .. code-block:: yaml\n\n        beacons:\n          watchdog:\n            - directories:\n                /path/to/dir:\n                  mask:\n                    - create\n                    - modify\n                    - delete\n                    - move\n\n    The mask list can contain the following events (the default mask is create,\n    modify delete, and move):\n    * create  - File or directory is created in watched directory\n    * modify  - The watched directory is modified\n    * delete  - File or directory is deleted from watched directory\n    * move    - File or directory is moved or renamed in the watched directory\n    '''\n\n    _config = {}\n    list(map(_config.update, config))\n\n    queue = _get_queue(_config)\n\n    ret = []\n    while queue:\n        ret.append(to_salt_event(queue.popleft()))\n\n    return ret", "language": "python", "code": "def beacon(config):\n    '''\n    Watch the configured directories\n\n    Example Config\n\n    .. code-block:: yaml\n\n        beacons:\n          watchdog:\n            - directories:\n                /path/to/dir:\n                  mask:\n                    - create\n                    - modify\n                    - delete\n                    - move\n\n    The mask list can contain the following events (the default mask is create,\n    modify delete, and move):\n    * create  - File or directory is created in watched directory\n    * modify  - The watched directory is modified\n    * delete  - File or directory is deleted from watched directory\n    * move    - File or directory is moved or renamed in the watched directory\n    '''\n\n    _config = {}\n    list(map(_config.update, config))\n\n    queue = _get_queue(_config)\n\n    ret = []\n    while queue:\n        ret.append(to_salt_event(queue.popleft()))\n\n    return ret", "code_tokens": ["def", "beacon", "(", "config", ")", ":", "_config", "=", "{", "}", "list", "(", "map", "(", "_config", ".", "update", ",", "config", ")", ")", "queue", "=", "_get_queue", "(", "_config", ")", "ret", "=", "[", "]", "while", "queue", ":", "ret", ".", "append", "(", "to_salt_event", "(", "queue", ".", "popleft", "(", ")", ")", ")", "return", "ret"], "docstring": "Watch the configured directories\n\n    Example Config\n\n    .. code-block:: yaml\n\n        beacons:\n          watchdog:\n            - directories:\n                /path/to/dir:\n                  mask:\n                    - create\n                    - modify\n                    - delete\n                    - move\n\n    The mask list can contain the following events (the default mask is create,\n    modify delete, and move):\n    * create  - File or directory is created in watched directory\n    * modify  - The watched directory is modified\n    * delete  - File or directory is deleted from watched directory\n    * move    - File or directory is moved or renamed in the watched directory", "docstring_tokens": ["Watch", "the", "configured", "directories"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/beacons/watchdog.py#L175-L210", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/states/trafficserver.py", "func_name": "bounce_cluster", "original_string": "def bounce_cluster(name):\n    '''\n    Bounce all Traffic Server nodes in the cluster. Bouncing Traffic Server\n    shuts down and immediately restarts Traffic Server, node-by-node.\n\n    .. code-block:: yaml\n\n        bounce_ats_cluster:\n          trafficserver.bounce_cluster\n    '''\n    ret = {'name': name,\n           'changes': {},\n           'result': None,\n           'comment': ''}\n\n    if __opts__['test']:\n        ret['comment'] = 'Bouncing cluster'\n        return ret\n\n    __salt__['trafficserver.bounce_cluster']()\n\n    ret['result'] = True\n    ret['comment'] = 'Bounced cluster'\n    return ret", "language": "python", "code": "def bounce_cluster(name):\n    '''\n    Bounce all Traffic Server nodes in the cluster. Bouncing Traffic Server\n    shuts down and immediately restarts Traffic Server, node-by-node.\n\n    .. code-block:: yaml\n\n        bounce_ats_cluster:\n          trafficserver.bounce_cluster\n    '''\n    ret = {'name': name,\n           'changes': {},\n           'result': None,\n           'comment': ''}\n\n    if __opts__['test']:\n        ret['comment'] = 'Bouncing cluster'\n        return ret\n\n    __salt__['trafficserver.bounce_cluster']()\n\n    ret['result'] = True\n    ret['comment'] = 'Bounced cluster'\n    return ret", "code_tokens": ["def", "bounce_cluster", "(", "name", ")", ":", "ret", "=", "{", "'name'", ":", "name", ",", "'changes'", ":", "{", "}", ",", "'result'", ":", "None", ",", "'comment'", ":", "''", "}", "if", "__opts__", "[", "'test'", "]", ":", "ret", "[", "'comment'", "]", "=", "'Bouncing cluster'", "return", "ret", "__salt__", "[", "'trafficserver.bounce_cluster'", "]", "(", ")", "ret", "[", "'result'", "]", "=", "True", "ret", "[", "'comment'", "]", "=", "'Bounced cluster'", "return", "ret"], "docstring": "Bounce all Traffic Server nodes in the cluster. Bouncing Traffic Server\n    shuts down and immediately restarts Traffic Server, node-by-node.\n\n    .. code-block:: yaml\n\n        bounce_ats_cluster:\n          trafficserver.bounce_cluster", "docstring_tokens": ["Bounce", "all", "Traffic", "Server", "nodes", "in", "the", "cluster", ".", "Bouncing", "Traffic", "Server", "shuts", "down", "and", "immediately", "restarts", "Traffic", "Server", "node", "-", "by", "-", "node", "."], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/states/trafficserver.py#L20-L43", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/states/trafficserver.py", "func_name": "bounce_local", "original_string": "def bounce_local(name, drain=False):\n    '''\n    Bounce Traffic Server on the local node. Bouncing Traffic Server shuts down\n    and immediately restarts the Traffic Server node.\n\n    This option modifies the behavior of traffic_line -b and traffic_line -L\n    such that traffic_server is not shut down until the number of active client\n    connections drops to the number given by the\n    proxy.config.restart.active_client_threshold configuration variable.\n\n    .. code-block:: yaml\n\n        bounce_ats_local:\n          trafficserver.bounce_local\n\n        bounce_ats_local:\n          trafficserver.bounce_local\n            - drain: True\n    '''\n    ret = {'name': name,\n           'changes': {},\n           'result': None,\n           'comment': ''}\n\n    if __opts__['test']:\n        ret['comment'] = 'Bouncing local node'\n        return ret\n\n    if drain:\n        __salt__['trafficserver.bounce_local'](drain=True)\n        ret['result'] = True\n        ret['comment'] = 'Bounced local node with drain option'\n        return ret\n    else:\n        __salt__['trafficserver.bounce_local']()\n        ret['result'] = True\n        ret['comment'] = 'Bounced local node'\n        return ret", "language": "python", "code": "def bounce_local(name, drain=False):\n    '''\n    Bounce Traffic Server on the local node. Bouncing Traffic Server shuts down\n    and immediately restarts the Traffic Server node.\n\n    This option modifies the behavior of traffic_line -b and traffic_line -L\n    such that traffic_server is not shut down until the number of active client\n    connections drops to the number given by the\n    proxy.config.restart.active_client_threshold configuration variable.\n\n    .. code-block:: yaml\n\n        bounce_ats_local:\n          trafficserver.bounce_local\n\n        bounce_ats_local:\n          trafficserver.bounce_local\n            - drain: True\n    '''\n    ret = {'name': name,\n           'changes': {},\n           'result': None,\n           'comment': ''}\n\n    if __opts__['test']:\n        ret['comment'] = 'Bouncing local node'\n        return ret\n\n    if drain:\n        __salt__['trafficserver.bounce_local'](drain=True)\n        ret['result'] = True\n        ret['comment'] = 'Bounced local node with drain option'\n        return ret\n    else:\n        __salt__['trafficserver.bounce_local']()\n        ret['result'] = True\n        ret['comment'] = 'Bounced local node'\n        return ret", "code_tokens": ["def", "bounce_local", "(", "name", ",", "drain", "=", "False", ")", ":", "ret", "=", "{", "'name'", ":", "name", ",", "'changes'", ":", "{", "}", ",", "'result'", ":", "None", ",", "'comment'", ":", "''", "}", "if", "__opts__", "[", "'test'", "]", ":", "ret", "[", "'comment'", "]", "=", "'Bouncing local node'", "return", "ret", "if", "drain", ":", "__salt__", "[", "'trafficserver.bounce_local'", "]", "(", "drain", "=", "True", ")", "ret", "[", "'result'", "]", "=", "True", "ret", "[", "'comment'", "]", "=", "'Bounced local node with drain option'", "return", "ret", "else", ":", "__salt__", "[", "'trafficserver.bounce_local'", "]", "(", ")", "ret", "[", "'result'", "]", "=", "True", "ret", "[", "'comment'", "]", "=", "'Bounced local node'", "return", "ret"], "docstring": "Bounce Traffic Server on the local node. Bouncing Traffic Server shuts down\n    and immediately restarts the Traffic Server node.\n\n    This option modifies the behavior of traffic_line -b and traffic_line -L\n    such that traffic_server is not shut down until the number of active client\n    connections drops to the number given by the\n    proxy.config.restart.active_client_threshold configuration variable.\n\n    .. code-block:: yaml\n\n        bounce_ats_local:\n          trafficserver.bounce_local\n\n        bounce_ats_local:\n          trafficserver.bounce_local\n            - drain: True", "docstring_tokens": ["Bounce", "Traffic", "Server", "on", "the", "local", "node", ".", "Bouncing", "Traffic", "Server", "shuts", "down", "and", "immediately", "restarts", "the", "Traffic", "Server", "node", "."], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/states/trafficserver.py#L46-L83", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/states/trafficserver.py", "func_name": "clear_cluster", "original_string": "def clear_cluster(name):\n    '''\n    Clears accumulated statistics on all nodes in the cluster.\n\n    .. code-block:: yaml\n\n        clear_ats_cluster:\n          trafficserver.clear_cluster\n    '''\n    ret = {'name': name,\n           'changes': {},\n           'result': None,\n           'comment': ''}\n\n    if __opts__['test']:\n        ret['comment'] = 'Clearing cluster statistics'\n        return ret\n\n    __salt__['trafficserver.clear_cluster']()\n\n    ret['result'] = True\n    ret['comment'] = 'Cleared cluster statistics'\n    return ret", "language": "python", "code": "def clear_cluster(name):\n    '''\n    Clears accumulated statistics on all nodes in the cluster.\n\n    .. code-block:: yaml\n\n        clear_ats_cluster:\n          trafficserver.clear_cluster\n    '''\n    ret = {'name': name,\n           'changes': {},\n           'result': None,\n           'comment': ''}\n\n    if __opts__['test']:\n        ret['comment'] = 'Clearing cluster statistics'\n        return ret\n\n    __salt__['trafficserver.clear_cluster']()\n\n    ret['result'] = True\n    ret['comment'] = 'Cleared cluster statistics'\n    return ret", "code_tokens": ["def", "clear_cluster", "(", "name", ")", ":", "ret", "=", "{", "'name'", ":", "name", ",", "'changes'", ":", "{", "}", ",", "'result'", ":", "None", ",", "'comment'", ":", "''", "}", "if", "__opts__", "[", "'test'", "]", ":", "ret", "[", "'comment'", "]", "=", "'Clearing cluster statistics'", "return", "ret", "__salt__", "[", "'trafficserver.clear_cluster'", "]", "(", ")", "ret", "[", "'result'", "]", "=", "True", "ret", "[", "'comment'", "]", "=", "'Cleared cluster statistics'", "return", "ret"], "docstring": "Clears accumulated statistics on all nodes in the cluster.\n\n    .. code-block:: yaml\n\n        clear_ats_cluster:\n          trafficserver.clear_cluster", "docstring_tokens": ["Clears", "accumulated", "statistics", "on", "all", "nodes", "in", "the", "cluster", "."], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/states/trafficserver.py#L86-L108", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/states/trafficserver.py", "func_name": "clear_node", "original_string": "def clear_node(name):\n    '''\n    Clears accumulated statistics on the local node.\n\n    .. code-block:: yaml\n\n        clear_ats_node:\n          trafficserver.clear_node\n    '''\n    ret = {'name': name,\n           'changes': {},\n           'result': None,\n           'comment': ''}\n\n    if __opts__['test']:\n        ret['comment'] = 'Clearing local node statistics'\n        return ret\n\n    __salt__['trafficserver.clear_node']()\n\n    ret['result'] = True\n    ret['comment'] = 'Cleared local node statistics'\n    return ret", "language": "python", "code": "def clear_node(name):\n    '''\n    Clears accumulated statistics on the local node.\n\n    .. code-block:: yaml\n\n        clear_ats_node:\n          trafficserver.clear_node\n    '''\n    ret = {'name': name,\n           'changes': {},\n           'result': None,\n           'comment': ''}\n\n    if __opts__['test']:\n        ret['comment'] = 'Clearing local node statistics'\n        return ret\n\n    __salt__['trafficserver.clear_node']()\n\n    ret['result'] = True\n    ret['comment'] = 'Cleared local node statistics'\n    return ret", "code_tokens": ["def", "clear_node", "(", "name", ")", ":", "ret", "=", "{", "'name'", ":", "name", ",", "'changes'", ":", "{", "}", ",", "'result'", ":", "None", ",", "'comment'", ":", "''", "}", "if", "__opts__", "[", "'test'", "]", ":", "ret", "[", "'comment'", "]", "=", "'Clearing local node statistics'", "return", "ret", "__salt__", "[", "'trafficserver.clear_node'", "]", "(", ")", "ret", "[", "'result'", "]", "=", "True", "ret", "[", "'comment'", "]", "=", "'Cleared local node statistics'", "return", "ret"], "docstring": "Clears accumulated statistics on the local node.\n\n    .. code-block:: yaml\n\n        clear_ats_node:\n          trafficserver.clear_node", "docstring_tokens": ["Clears", "accumulated", "statistics", "on", "the", "local", "node", "."], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/states/trafficserver.py#L111-L133", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/states/trafficserver.py", "func_name": "restart_cluster", "original_string": "def restart_cluster(name):\n    '''\n    Restart the traffic_manager process and the traffic_server process on all\n    the nodes in a cluster.\n\n    .. code-block:: bash\n\n        restart_ats_cluster:\n          trafficserver.restart_cluster\n\n    '''\n    ret = {'name': name,\n           'changes': {},\n           'result': None,\n           'comment': ''}\n\n    if __opts__['test']:\n        ret['comment'] = 'Restarting cluster'\n        return ret\n\n    __salt__['trafficserver.restart_cluster']()\n\n    ret['result'] = True\n    ret['comment'] = 'Restarted cluster'\n    return ret", "language": "python", "code": "def restart_cluster(name):\n    '''\n    Restart the traffic_manager process and the traffic_server process on all\n    the nodes in a cluster.\n\n    .. code-block:: bash\n\n        restart_ats_cluster:\n          trafficserver.restart_cluster\n\n    '''\n    ret = {'name': name,\n           'changes': {},\n           'result': None,\n           'comment': ''}\n\n    if __opts__['test']:\n        ret['comment'] = 'Restarting cluster'\n        return ret\n\n    __salt__['trafficserver.restart_cluster']()\n\n    ret['result'] = True\n    ret['comment'] = 'Restarted cluster'\n    return ret", "code_tokens": ["def", "restart_cluster", "(", "name", ")", ":", "ret", "=", "{", "'name'", ":", "name", ",", "'changes'", ":", "{", "}", ",", "'result'", ":", "None", ",", "'comment'", ":", "''", "}", "if", "__opts__", "[", "'test'", "]", ":", "ret", "[", "'comment'", "]", "=", "'Restarting cluster'", "return", "ret", "__salt__", "[", "'trafficserver.restart_cluster'", "]", "(", ")", "ret", "[", "'result'", "]", "=", "True", "ret", "[", "'comment'", "]", "=", "'Restarted cluster'", "return", "ret"], "docstring": "Restart the traffic_manager process and the traffic_server process on all\n    the nodes in a cluster.\n\n    .. code-block:: bash\n\n        restart_ats_cluster:\n          trafficserver.restart_cluster", "docstring_tokens": ["Restart", "the", "traffic_manager", "process", "and", "the", "traffic_server", "process", "on", "all", "the", "nodes", "in", "a", "cluster", "."], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/states/trafficserver.py#L136-L160", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/states/trafficserver.py", "func_name": "restart_local", "original_string": "def restart_local(name, drain=False):\n    '''\n    Restart the traffic_manager and traffic_server processes on the local node.\n\n    This option modifies the behavior of traffic_line -b and traffic_line -L\n    such that traffic_server is not shut down until the number of active client\n    connections drops to the number given by the\n    proxy.config.restart.active_client_threshold configuration variable.\n\n    .. code-block:: yaml\n\n        restart_ats_local:\n          trafficserver.restart_local\n\n        restart_ats_local_drain:\n          trafficserver.restart_local\n            - drain: True\n    '''\n    ret = {'name': name,\n           'changes': {},\n           'result': None,\n           'comment': ''}\n\n    if __opts__['test']:\n        ret['comment'] = 'Restarting local node'\n        return ret\n\n    if drain:\n        __salt__['trafficserver.restart_local'](drain=True)\n        ret['result'] = True\n        ret['comment'] = 'Restarted local node with drain option'\n        return ret\n    else:\n        __salt__['trafficserver.restart_local']()\n        ret['result'] = True\n        ret['comment'] = 'Restarted local node'\n        return ret", "language": "python", "code": "def restart_local(name, drain=False):\n    '''\n    Restart the traffic_manager and traffic_server processes on the local node.\n\n    This option modifies the behavior of traffic_line -b and traffic_line -L\n    such that traffic_server is not shut down until the number of active client\n    connections drops to the number given by the\n    proxy.config.restart.active_client_threshold configuration variable.\n\n    .. code-block:: yaml\n\n        restart_ats_local:\n          trafficserver.restart_local\n\n        restart_ats_local_drain:\n          trafficserver.restart_local\n            - drain: True\n    '''\n    ret = {'name': name,\n           'changes': {},\n           'result': None,\n           'comment': ''}\n\n    if __opts__['test']:\n        ret['comment'] = 'Restarting local node'\n        return ret\n\n    if drain:\n        __salt__['trafficserver.restart_local'](drain=True)\n        ret['result'] = True\n        ret['comment'] = 'Restarted local node with drain option'\n        return ret\n    else:\n        __salt__['trafficserver.restart_local']()\n        ret['result'] = True\n        ret['comment'] = 'Restarted local node'\n        return ret", "code_tokens": ["def", "restart_local", "(", "name", ",", "drain", "=", "False", ")", ":", "ret", "=", "{", "'name'", ":", "name", ",", "'changes'", ":", "{", "}", ",", "'result'", ":", "None", ",", "'comment'", ":", "''", "}", "if", "__opts__", "[", "'test'", "]", ":", "ret", "[", "'comment'", "]", "=", "'Restarting local node'", "return", "ret", "if", "drain", ":", "__salt__", "[", "'trafficserver.restart_local'", "]", "(", "drain", "=", "True", ")", "ret", "[", "'result'", "]", "=", "True", "ret", "[", "'comment'", "]", "=", "'Restarted local node with drain option'", "return", "ret", "else", ":", "__salt__", "[", "'trafficserver.restart_local'", "]", "(", ")", "ret", "[", "'result'", "]", "=", "True", "ret", "[", "'comment'", "]", "=", "'Restarted local node'", "return", "ret"], "docstring": "Restart the traffic_manager and traffic_server processes on the local node.\n\n    This option modifies the behavior of traffic_line -b and traffic_line -L\n    such that traffic_server is not shut down until the number of active client\n    connections drops to the number given by the\n    proxy.config.restart.active_client_threshold configuration variable.\n\n    .. code-block:: yaml\n\n        restart_ats_local:\n          trafficserver.restart_local\n\n        restart_ats_local_drain:\n          trafficserver.restart_local\n            - drain: True", "docstring_tokens": ["Restart", "the", "traffic_manager", "and", "traffic_server", "processes", "on", "the", "local", "node", "."], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/states/trafficserver.py#L163-L199", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/states/trafficserver.py", "func_name": "config", "original_string": "def config(name, value):\n    '''\n    Set Traffic Server configuration variable values.\n\n    .. code-block:: yaml\n\n        proxy.config.proxy_name:\n          trafficserver.config:\n            - value: cdn.site.domain.tld\n\n        OR\n\n        traffic_server_setting:\n          trafficserver.config:\n            - name: proxy.config.proxy_name\n            - value: cdn.site.domain.tld\n\n    '''\n    ret = {'name': name,\n           'changes': {},\n           'result': None,\n           'comment': ''}\n\n    if __opts__['test']:\n        ret['comment'] = 'Configuring {0} to {1}'.format(\n            name,\n            value,\n        )\n        return ret\n\n    __salt__['trafficserver.set_config'](name, value)\n\n    ret['result'] = True\n    ret['comment'] = 'Configured {0} to {1}'.format(name, value)\n    return ret", "language": "python", "code": "def config(name, value):\n    '''\n    Set Traffic Server configuration variable values.\n\n    .. code-block:: yaml\n\n        proxy.config.proxy_name:\n          trafficserver.config:\n            - value: cdn.site.domain.tld\n\n        OR\n\n        traffic_server_setting:\n          trafficserver.config:\n            - name: proxy.config.proxy_name\n            - value: cdn.site.domain.tld\n\n    '''\n    ret = {'name': name,\n           'changes': {},\n           'result': None,\n           'comment': ''}\n\n    if __opts__['test']:\n        ret['comment'] = 'Configuring {0} to {1}'.format(\n            name,\n            value,\n        )\n        return ret\n\n    __salt__['trafficserver.set_config'](name, value)\n\n    ret['result'] = True\n    ret['comment'] = 'Configured {0} to {1}'.format(name, value)\n    return ret", "code_tokens": ["def", "config", "(", "name", ",", "value", ")", ":", "ret", "=", "{", "'name'", ":", "name", ",", "'changes'", ":", "{", "}", ",", "'result'", ":", "None", ",", "'comment'", ":", "''", "}", "if", "__opts__", "[", "'test'", "]", ":", "ret", "[", "'comment'", "]", "=", "'Configuring {0} to {1}'", ".", "format", "(", "name", ",", "value", ",", ")", "return", "ret", "__salt__", "[", "'trafficserver.set_config'", "]", "(", "name", ",", "value", ")", "ret", "[", "'result'", "]", "=", "True", "ret", "[", "'comment'", "]", "=", "'Configured {0} to {1}'", ".", "format", "(", "name", ",", "value", ")", "return", "ret"], "docstring": "Set Traffic Server configuration variable values.\n\n    .. code-block:: yaml\n\n        proxy.config.proxy_name:\n          trafficserver.config:\n            - value: cdn.site.domain.tld\n\n        OR\n\n        traffic_server_setting:\n          trafficserver.config:\n            - name: proxy.config.proxy_name\n            - value: cdn.site.domain.tld", "docstring_tokens": ["Set", "Traffic", "Server", "configuration", "variable", "values", "."], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/states/trafficserver.py#L202-L236", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/states/trafficserver.py", "func_name": "shutdown", "original_string": "def shutdown(name):\n    '''\n    Shut down Traffic Server on the local node.\n\n    .. code-block:: yaml\n\n        shutdown_ats:\n          trafficserver.shutdown\n    '''\n    ret = {'name': name,\n           'changes': {},\n           'result': None,\n           'comment': ''}\n\n    if __opts__['test']:\n        ret['comment'] = 'Shutting down local node'\n        return ret\n\n    __salt__['trafficserver.shutdown']()\n\n    ret['result'] = True\n    ret['comment'] = 'Shutdown local node'\n    return ret", "language": "python", "code": "def shutdown(name):\n    '''\n    Shut down Traffic Server on the local node.\n\n    .. code-block:: yaml\n\n        shutdown_ats:\n          trafficserver.shutdown\n    '''\n    ret = {'name': name,\n           'changes': {},\n           'result': None,\n           'comment': ''}\n\n    if __opts__['test']:\n        ret['comment'] = 'Shutting down local node'\n        return ret\n\n    __salt__['trafficserver.shutdown']()\n\n    ret['result'] = True\n    ret['comment'] = 'Shutdown local node'\n    return ret", "code_tokens": ["def", "shutdown", "(", "name", ")", ":", "ret", "=", "{", "'name'", ":", "name", ",", "'changes'", ":", "{", "}", ",", "'result'", ":", "None", ",", "'comment'", ":", "''", "}", "if", "__opts__", "[", "'test'", "]", ":", "ret", "[", "'comment'", "]", "=", "'Shutting down local node'", "return", "ret", "__salt__", "[", "'trafficserver.shutdown'", "]", "(", ")", "ret", "[", "'result'", "]", "=", "True", "ret", "[", "'comment'", "]", "=", "'Shutdown local node'", "return", "ret"], "docstring": "Shut down Traffic Server on the local node.\n\n    .. code-block:: yaml\n\n        shutdown_ats:\n          trafficserver.shutdown", "docstring_tokens": ["Shut", "down", "Traffic", "Server", "on", "the", "local", "node", "."], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/states/trafficserver.py#L239-L261", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/states/trafficserver.py", "func_name": "startup", "original_string": "def startup(name):\n    '''\n    Start Traffic Server on the local node.\n\n    .. code-block:: yaml\n\n        startup_ats:\n          trafficserver.startup\n    '''\n    ret = {'name': name,\n           'changes': {},\n           'result': None,\n           'comment': ''}\n\n    if __opts__['test']:\n        ret['comment'] = 'Starting up local node'\n        return ret\n\n    __salt__['trafficserver.startup']()\n\n    ret['result'] = True\n    ret['comment'] = 'Starting up local node'\n    return ret", "language": "python", "code": "def startup(name):\n    '''\n    Start Traffic Server on the local node.\n\n    .. code-block:: yaml\n\n        startup_ats:\n          trafficserver.startup\n    '''\n    ret = {'name': name,\n           'changes': {},\n           'result': None,\n           'comment': ''}\n\n    if __opts__['test']:\n        ret['comment'] = 'Starting up local node'\n        return ret\n\n    __salt__['trafficserver.startup']()\n\n    ret['result'] = True\n    ret['comment'] = 'Starting up local node'\n    return ret", "code_tokens": ["def", "startup", "(", "name", ")", ":", "ret", "=", "{", "'name'", ":", "name", ",", "'changes'", ":", "{", "}", ",", "'result'", ":", "None", ",", "'comment'", ":", "''", "}", "if", "__opts__", "[", "'test'", "]", ":", "ret", "[", "'comment'", "]", "=", "'Starting up local node'", "return", "ret", "__salt__", "[", "'trafficserver.startup'", "]", "(", ")", "ret", "[", "'result'", "]", "=", "True", "ret", "[", "'comment'", "]", "=", "'Starting up local node'", "return", "ret"], "docstring": "Start Traffic Server on the local node.\n\n    .. code-block:: yaml\n\n        startup_ats:\n          trafficserver.startup", "docstring_tokens": ["Start", "Traffic", "Server", "on", "the", "local", "node", "."], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/states/trafficserver.py#L264-L286", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/states/trafficserver.py", "func_name": "refresh", "original_string": "def refresh(name):\n    '''\n    Initiate a Traffic Server configuration file reread. Use this command to\n    update the running configuration after any configuration file modification.\n\n    The timestamp of the last reconfiguration event (in seconds since epoch) is\n    published in the proxy.node.config.reconfigure_time metric.\n\n    .. code-block:: yaml\n\n        refresh_ats:\n          trafficserver.refresh\n    '''\n    ret = {'name': name,\n           'changes': {},\n           'result': None,\n           'comment': ''}\n\n    if __opts__['test']:\n        ret['comment'] = 'Refreshing local node configuration'\n        return ret\n\n    __salt__['trafficserver.refresh']()\n\n    ret['result'] = True\n    ret['comment'] = 'Refreshed local node configuration'\n    return ret", "language": "python", "code": "def refresh(name):\n    '''\n    Initiate a Traffic Server configuration file reread. Use this command to\n    update the running configuration after any configuration file modification.\n\n    The timestamp of the last reconfiguration event (in seconds since epoch) is\n    published in the proxy.node.config.reconfigure_time metric.\n\n    .. code-block:: yaml\n\n        refresh_ats:\n          trafficserver.refresh\n    '''\n    ret = {'name': name,\n           'changes': {},\n           'result': None,\n           'comment': ''}\n\n    if __opts__['test']:\n        ret['comment'] = 'Refreshing local node configuration'\n        return ret\n\n    __salt__['trafficserver.refresh']()\n\n    ret['result'] = True\n    ret['comment'] = 'Refreshed local node configuration'\n    return ret", "code_tokens": ["def", "refresh", "(", "name", ")", ":", "ret", "=", "{", "'name'", ":", "name", ",", "'changes'", ":", "{", "}", ",", "'result'", ":", "None", ",", "'comment'", ":", "''", "}", "if", "__opts__", "[", "'test'", "]", ":", "ret", "[", "'comment'", "]", "=", "'Refreshing local node configuration'", "return", "ret", "__salt__", "[", "'trafficserver.refresh'", "]", "(", ")", "ret", "[", "'result'", "]", "=", "True", "ret", "[", "'comment'", "]", "=", "'Refreshed local node configuration'", "return", "ret"], "docstring": "Initiate a Traffic Server configuration file reread. Use this command to\n    update the running configuration after any configuration file modification.\n\n    The timestamp of the last reconfiguration event (in seconds since epoch) is\n    published in the proxy.node.config.reconfigure_time metric.\n\n    .. code-block:: yaml\n\n        refresh_ats:\n          trafficserver.refresh", "docstring_tokens": ["Initiate", "a", "Traffic", "Server", "configuration", "file", "reread", ".", "Use", "this", "command", "to", "update", "the", "running", "configuration", "after", "any", "configuration", "file", "modification", "."], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/states/trafficserver.py#L289-L315", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/states/trafficserver.py", "func_name": "zero_cluster", "original_string": "def zero_cluster(name):\n    '''\n    Reset performance statistics to zero across the cluster.\n\n    .. code-block:: yaml\n\n        zero_ats_cluster:\n          trafficserver.zero_cluster\n    '''\n    ret = {'name': name,\n           'changes': {},\n           'result': None,\n           'comment': ''}\n\n    if __opts__['test']:\n        ret['comment'] = 'Zeroing cluster statistics'\n        return ret\n\n    __salt__['trafficserver.zero_cluster']()\n\n    ret['result'] = True\n    ret['comment'] = 'Zeroed cluster statistics'\n    return ret", "language": "python", "code": "def zero_cluster(name):\n    '''\n    Reset performance statistics to zero across the cluster.\n\n    .. code-block:: yaml\n\n        zero_ats_cluster:\n          trafficserver.zero_cluster\n    '''\n    ret = {'name': name,\n           'changes': {},\n           'result': None,\n           'comment': ''}\n\n    if __opts__['test']:\n        ret['comment'] = 'Zeroing cluster statistics'\n        return ret\n\n    __salt__['trafficserver.zero_cluster']()\n\n    ret['result'] = True\n    ret['comment'] = 'Zeroed cluster statistics'\n    return ret", "code_tokens": ["def", "zero_cluster", "(", "name", ")", ":", "ret", "=", "{", "'name'", ":", "name", ",", "'changes'", ":", "{", "}", ",", "'result'", ":", "None", ",", "'comment'", ":", "''", "}", "if", "__opts__", "[", "'test'", "]", ":", "ret", "[", "'comment'", "]", "=", "'Zeroing cluster statistics'", "return", "ret", "__salt__", "[", "'trafficserver.zero_cluster'", "]", "(", ")", "ret", "[", "'result'", "]", "=", "True", "ret", "[", "'comment'", "]", "=", "'Zeroed cluster statistics'", "return", "ret"], "docstring": "Reset performance statistics to zero across the cluster.\n\n    .. code-block:: yaml\n\n        zero_ats_cluster:\n          trafficserver.zero_cluster", "docstring_tokens": ["Reset", "performance", "statistics", "to", "zero", "across", "the", "cluster", "."], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/states/trafficserver.py#L318-L340", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/states/trafficserver.py", "func_name": "zero_node", "original_string": "def zero_node(name):\n    '''\n    Reset performance statistics to zero on the local node.\n\n    .. code-block:: yaml\n\n        zero_ats_node:\n          trafficserver.zero_node\n    '''\n    ret = {'name': name,\n           'changes': {},\n           'result': None,\n           'comment': ''}\n\n    if __opts__['test']:\n        ret['comment'] = 'Zeroing local node statistics'\n        return ret\n\n    __salt__['trafficserver.zero_node']()\n\n    ret['result'] = True\n    ret['comment'] = 'Zeroed local node statistics'\n    return ret", "language": "python", "code": "def zero_node(name):\n    '''\n    Reset performance statistics to zero on the local node.\n\n    .. code-block:: yaml\n\n        zero_ats_node:\n          trafficserver.zero_node\n    '''\n    ret = {'name': name,\n           'changes': {},\n           'result': None,\n           'comment': ''}\n\n    if __opts__['test']:\n        ret['comment'] = 'Zeroing local node statistics'\n        return ret\n\n    __salt__['trafficserver.zero_node']()\n\n    ret['result'] = True\n    ret['comment'] = 'Zeroed local node statistics'\n    return ret", "code_tokens": ["def", "zero_node", "(", "name", ")", ":", "ret", "=", "{", "'name'", ":", "name", ",", "'changes'", ":", "{", "}", ",", "'result'", ":", "None", ",", "'comment'", ":", "''", "}", "if", "__opts__", "[", "'test'", "]", ":", "ret", "[", "'comment'", "]", "=", "'Zeroing local node statistics'", "return", "ret", "__salt__", "[", "'trafficserver.zero_node'", "]", "(", ")", "ret", "[", "'result'", "]", "=", "True", "ret", "[", "'comment'", "]", "=", "'Zeroed local node statistics'", "return", "ret"], "docstring": "Reset performance statistics to zero on the local node.\n\n    .. code-block:: yaml\n\n        zero_ats_node:\n          trafficserver.zero_node", "docstring_tokens": ["Reset", "performance", "statistics", "to", "zero", "on", "the", "local", "node", "."], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/states/trafficserver.py#L343-L365", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/states/trafficserver.py", "func_name": "offline", "original_string": "def offline(name, path):\n    '''\n    Mark a cache storage device as offline. The storage is identified by a path\n    which must match exactly a path specified in storage.config. This removes\n    the storage from the cache and redirects requests that would have used this\n    storage to other storage. This has exactly the same effect as a disk\n    failure for that storage. This does not persist across restarts of the\n    traffic_server process.\n\n    .. code-block:: yaml\n\n        offline_ats_path:\n          trafficserver.offline:\n            - path: /path/to/cache\n    '''\n    ret = {'name': name,\n           'changes': {},\n           'result': None,\n           'comment': ''}\n\n    if __opts__['test']:\n        ret['comment'] = 'Setting {0} to offline'.format(path)\n        return ret\n\n    __salt__['trafficserver.offline'](path)\n\n    ret['result'] = True\n    ret['comment'] = 'Set {0} as offline'.format(path)\n    return ret", "language": "python", "code": "def offline(name, path):\n    '''\n    Mark a cache storage device as offline. The storage is identified by a path\n    which must match exactly a path specified in storage.config. This removes\n    the storage from the cache and redirects requests that would have used this\n    storage to other storage. This has exactly the same effect as a disk\n    failure for that storage. This does not persist across restarts of the\n    traffic_server process.\n\n    .. code-block:: yaml\n\n        offline_ats_path:\n          trafficserver.offline:\n            - path: /path/to/cache\n    '''\n    ret = {'name': name,\n           'changes': {},\n           'result': None,\n           'comment': ''}\n\n    if __opts__['test']:\n        ret['comment'] = 'Setting {0} to offline'.format(path)\n        return ret\n\n    __salt__['trafficserver.offline'](path)\n\n    ret['result'] = True\n    ret['comment'] = 'Set {0} as offline'.format(path)\n    return ret", "code_tokens": ["def", "offline", "(", "name", ",", "path", ")", ":", "ret", "=", "{", "'name'", ":", "name", ",", "'changes'", ":", "{", "}", ",", "'result'", ":", "None", ",", "'comment'", ":", "''", "}", "if", "__opts__", "[", "'test'", "]", ":", "ret", "[", "'comment'", "]", "=", "'Setting {0} to offline'", ".", "format", "(", "path", ")", "return", "ret", "__salt__", "[", "'trafficserver.offline'", "]", "(", "path", ")", "ret", "[", "'result'", "]", "=", "True", "ret", "[", "'comment'", "]", "=", "'Set {0} as offline'", ".", "format", "(", "path", ")", "return", "ret"], "docstring": "Mark a cache storage device as offline. The storage is identified by a path\n    which must match exactly a path specified in storage.config. This removes\n    the storage from the cache and redirects requests that would have used this\n    storage to other storage. This has exactly the same effect as a disk\n    failure for that storage. This does not persist across restarts of the\n    traffic_server process.\n\n    .. code-block:: yaml\n\n        offline_ats_path:\n          trafficserver.offline:\n            - path: /path/to/cache", "docstring_tokens": ["Mark", "a", "cache", "storage", "device", "as", "offline", ".", "The", "storage", "is", "identified", "by", "a", "path", "which", "must", "match", "exactly", "a", "path", "specified", "in", "storage", ".", "config", ".", "This", "removes", "the", "storage", "from", "the", "cache", "and", "redirects", "requests", "that", "would", "have", "used", "this", "storage", "to", "other", "storage", ".", "This", "has", "exactly", "the", "same", "effect", "as", "a", "disk", "failure", "for", "that", "storage", ".", "This", "does", "not", "persist", "across", "restarts", "of", "the", "traffic_server", "process", "."], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/states/trafficserver.py#L368-L396", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/states/grafana_datasource.py", "func_name": "present", "original_string": "def present(name,\n            type,\n            url,\n            access='proxy',\n            user='',\n            password='',\n            database='',\n            basic_auth=False,\n            basic_auth_user='',\n            basic_auth_password='',\n            is_default=False,\n            json_data=None,\n            profile='grafana'):\n    '''\n    Ensure that a data source is present.\n\n    name\n        Name of the data source.\n\n    type\n        Which type of data source it is ('graphite', 'influxdb' etc.).\n\n    url\n        The URL to the data source API.\n\n    user\n        Optional - user to authenticate with the data source\n\n    password\n        Optional - password to authenticate with the data source\n\n    basic_auth\n        Optional - set to True to use HTTP basic auth to authenticate with the\n        data source.\n\n    basic_auth_user\n        Optional - HTTP basic auth username.\n\n    basic_auth_password\n        Optional - HTTP basic auth password.\n\n    is_default\n        Default: False\n    '''\n    if isinstance(profile, string_types):\n        profile = __salt__['config.option'](profile)\n\n    ret = {'name': name, 'result': None, 'comment': None, 'changes': {}}\n    datasource = _get_datasource(profile, name)\n    data = _get_json_data(name, type, url, access, user, password, database,\n        basic_auth, basic_auth_user, basic_auth_password, is_default, json_data)\n\n    if datasource:\n        requests.put(\n            _get_url(profile, datasource['id']),\n            data,\n            headers=_get_headers(profile),\n            timeout=profile.get('grafana_timeout', 3),\n        )\n        ret['result'] = True\n        ret['changes'] = _diff(datasource, data)\n        if ret['changes']['new'] or ret['changes']['old']:\n            ret['comment'] = 'Data source {0} updated'.format(name)\n        else:\n            ret['changes'] = {}\n            ret['comment'] = 'Data source {0} already up-to-date'.format(name)\n    else:\n        requests.post(\n            '{0}/api/datasources'.format(profile['grafana_url']),\n            data,\n            headers=_get_headers(profile),\n            timeout=profile.get('grafana_timeout', 3),\n        )\n        ret['result'] = True\n        ret['comment'] = 'New data source {0} added'.format(name)\n        ret['changes'] = data\n\n    return ret", "language": "python", "code": "def present(name,\n            type,\n            url,\n            access='proxy',\n            user='',\n            password='',\n            database='',\n            basic_auth=False,\n            basic_auth_user='',\n            basic_auth_password='',\n            is_default=False,\n            json_data=None,\n            profile='grafana'):\n    '''\n    Ensure that a data source is present.\n\n    name\n        Name of the data source.\n\n    type\n        Which type of data source it is ('graphite', 'influxdb' etc.).\n\n    url\n        The URL to the data source API.\n\n    user\n        Optional - user to authenticate with the data source\n\n    password\n        Optional - password to authenticate with the data source\n\n    basic_auth\n        Optional - set to True to use HTTP basic auth to authenticate with the\n        data source.\n\n    basic_auth_user\n        Optional - HTTP basic auth username.\n\n    basic_auth_password\n        Optional - HTTP basic auth password.\n\n    is_default\n        Default: False\n    '''\n    if isinstance(profile, string_types):\n        profile = __salt__['config.option'](profile)\n\n    ret = {'name': name, 'result': None, 'comment': None, 'changes': {}}\n    datasource = _get_datasource(profile, name)\n    data = _get_json_data(name, type, url, access, user, password, database,\n        basic_auth, basic_auth_user, basic_auth_password, is_default, json_data)\n\n    if datasource:\n        requests.put(\n            _get_url(profile, datasource['id']),\n            data,\n            headers=_get_headers(profile),\n            timeout=profile.get('grafana_timeout', 3),\n        )\n        ret['result'] = True\n        ret['changes'] = _diff(datasource, data)\n        if ret['changes']['new'] or ret['changes']['old']:\n            ret['comment'] = 'Data source {0} updated'.format(name)\n        else:\n            ret['changes'] = {}\n            ret['comment'] = 'Data source {0} already up-to-date'.format(name)\n    else:\n        requests.post(\n            '{0}/api/datasources'.format(profile['grafana_url']),\n            data,\n            headers=_get_headers(profile),\n            timeout=profile.get('grafana_timeout', 3),\n        )\n        ret['result'] = True\n        ret['comment'] = 'New data source {0} added'.format(name)\n        ret['changes'] = data\n\n    return ret", "code_tokens": ["def", "present", "(", "name", ",", "type", ",", "url", ",", "access", "=", "'proxy'", ",", "user", "=", "''", ",", "password", "=", "''", ",", "database", "=", "''", ",", "basic_auth", "=", "False", ",", "basic_auth_user", "=", "''", ",", "basic_auth_password", "=", "''", ",", "is_default", "=", "False", ",", "json_data", "=", "None", ",", "profile", "=", "'grafana'", ")", ":", "if", "isinstance", "(", "profile", ",", "string_types", ")", ":", "profile", "=", "__salt__", "[", "'config.option'", "]", "(", "profile", ")", "ret", "=", "{", "'name'", ":", "name", ",", "'result'", ":", "None", ",", "'comment'", ":", "None", ",", "'changes'", ":", "{", "}", "}", "datasource", "=", "_get_datasource", "(", "profile", ",", "name", ")", "data", "=", "_get_json_data", "(", "name", ",", "type", ",", "url", ",", "access", ",", "user", ",", "password", ",", "database", ",", "basic_auth", ",", "basic_auth_user", ",", "basic_auth_password", ",", "is_default", ",", "json_data", ")", "if", "datasource", ":", "requests", ".", "put", "(", "_get_url", "(", "profile", ",", "datasource", "[", "'id'", "]", ")", ",", "data", ",", "headers", "=", "_get_headers", "(", "profile", ")", ",", "timeout", "=", "profile", ".", "get", "(", "'grafana_timeout'", ",", "3", ")", ",", ")", "ret", "[", "'result'", "]", "=", "True", "ret", "[", "'changes'", "]", "=", "_diff", "(", "datasource", ",", "data", ")", "if", "ret", "[", "'changes'", "]", "[", "'new'", "]", "or", "ret", "[", "'changes'", "]", "[", "'old'", "]", ":", "ret", "[", "'comment'", "]", "=", "'Data source {0} updated'", ".", "format", "(", "name", ")", "else", ":", "ret", "[", "'changes'", "]", "=", "{", "}", "ret", "[", "'comment'", "]", "=", "'Data source {0} already up-to-date'", ".", "format", "(", "name", ")", "else", ":", "requests", ".", "post", "(", "'{0}/api/datasources'", ".", "format", "(", "profile", "[", "'grafana_url'", "]", ")", ",", "data", ",", "headers", "=", "_get_headers", "(", "profile", ")", ",", "timeout", "=", "profile", ".", "get", "(", "'grafana_timeout'", ",", "3", ")", ",", ")", "ret", "[", "'result'", "]", "=", "True", "ret", "[", "'comment'", "]", "=", "'New data source {0} added'", ".", "format", "(", "name", ")", "ret", "[", "'changes'", "]", "=", "data", "return", "ret"], "docstring": "Ensure that a data source is present.\n\n    name\n        Name of the data source.\n\n    type\n        Which type of data source it is ('graphite', 'influxdb' etc.).\n\n    url\n        The URL to the data source API.\n\n    user\n        Optional - user to authenticate with the data source\n\n    password\n        Optional - password to authenticate with the data source\n\n    basic_auth\n        Optional - set to True to use HTTP basic auth to authenticate with the\n        data source.\n\n    basic_auth_user\n        Optional - HTTP basic auth username.\n\n    basic_auth_password\n        Optional - HTTP basic auth password.\n\n    is_default\n        Default: False", "docstring_tokens": ["Ensure", "that", "a", "data", "source", "is", "present", "."], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/states/grafana_datasource.py#L39-L116", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/states/grafana_datasource.py", "func_name": "absent", "original_string": "def absent(name, profile='grafana'):\n    '''\n    Ensure that a data source is present.\n\n    name\n        Name of the data source to remove.\n    '''\n    if isinstance(profile, string_types):\n        profile = __salt__['config.option'](profile)\n\n    ret = {'result': None, 'comment': None, 'changes': {}}\n    datasource = _get_datasource(profile, name)\n\n    if not datasource:\n        ret['result'] = True\n        ret['comment'] = 'Data source {0} already absent'.format(name)\n        return ret\n\n    requests.delete(\n        _get_url(profile, datasource['id']),\n        headers=_get_headers(profile),\n        timeout=profile.get('grafana_timeout', 3),\n    )\n\n    ret['result'] = True\n    ret['comment'] = 'Data source {0} was deleted'.format(name)\n\n    return ret", "language": "python", "code": "def absent(name, profile='grafana'):\n    '''\n    Ensure that a data source is present.\n\n    name\n        Name of the data source to remove.\n    '''\n    if isinstance(profile, string_types):\n        profile = __salt__['config.option'](profile)\n\n    ret = {'result': None, 'comment': None, 'changes': {}}\n    datasource = _get_datasource(profile, name)\n\n    if not datasource:\n        ret['result'] = True\n        ret['comment'] = 'Data source {0} already absent'.format(name)\n        return ret\n\n    requests.delete(\n        _get_url(profile, datasource['id']),\n        headers=_get_headers(profile),\n        timeout=profile.get('grafana_timeout', 3),\n    )\n\n    ret['result'] = True\n    ret['comment'] = 'Data source {0} was deleted'.format(name)\n\n    return ret", "code_tokens": ["def", "absent", "(", "name", ",", "profile", "=", "'grafana'", ")", ":", "if", "isinstance", "(", "profile", ",", "string_types", ")", ":", "profile", "=", "__salt__", "[", "'config.option'", "]", "(", "profile", ")", "ret", "=", "{", "'result'", ":", "None", ",", "'comment'", ":", "None", ",", "'changes'", ":", "{", "}", "}", "datasource", "=", "_get_datasource", "(", "profile", ",", "name", ")", "if", "not", "datasource", ":", "ret", "[", "'result'", "]", "=", "True", "ret", "[", "'comment'", "]", "=", "'Data source {0} already absent'", ".", "format", "(", "name", ")", "return", "ret", "requests", ".", "delete", "(", "_get_url", "(", "profile", ",", "datasource", "[", "'id'", "]", ")", ",", "headers", "=", "_get_headers", "(", "profile", ")", ",", "timeout", "=", "profile", ".", "get", "(", "'grafana_timeout'", ",", "3", ")", ",", ")", "ret", "[", "'result'", "]", "=", "True", "ret", "[", "'comment'", "]", "=", "'Data source {0} was deleted'", ".", "format", "(", "name", ")", "return", "ret"], "docstring": "Ensure that a data source is present.\n\n    name\n        Name of the data source to remove.", "docstring_tokens": ["Ensure", "that", "a", "data", "source", "is", "present", "."], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/states/grafana_datasource.py#L119-L146", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/modules/neutronng.py", "func_name": "compare_changes", "original_string": "def compare_changes(obj, **kwargs):\n    '''\n    Compare two dicts returning only keys that exist in the first dict and are\n    different in the second one\n    '''\n    changes = {}\n    for key, value in obj.items():\n        if key in kwargs:\n            if value != kwargs[key]:\n                changes[key] = kwargs[key]\n    return changes", "language": "python", "code": "def compare_changes(obj, **kwargs):\n    '''\n    Compare two dicts returning only keys that exist in the first dict and are\n    different in the second one\n    '''\n    changes = {}\n    for key, value in obj.items():\n        if key in kwargs:\n            if value != kwargs[key]:\n                changes[key] = kwargs[key]\n    return changes", "code_tokens": ["def", "compare_changes", "(", "obj", ",", "*", "*", "kwargs", ")", ":", "changes", "=", "{", "}", "for", "key", ",", "value", "in", "obj", ".", "items", "(", ")", ":", "if", "key", "in", "kwargs", ":", "if", "value", "!=", "kwargs", "[", "key", "]", ":", "changes", "[", "key", "]", "=", "kwargs", "[", "key", "]", "return", "changes"], "docstring": "Compare two dicts returning only keys that exist in the first dict and are\n    different in the second one", "docstring_tokens": ["Compare", "two", "dicts", "returning", "only", "keys", "that", "exist", "in", "the", "first", "dict", "and", "are", "different", "in", "the", "second", "one"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/modules/neutronng.py#L51-L61", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/modules/neutronng.py", "func_name": "network_create", "original_string": "def network_create(auth=None, **kwargs):\n    '''\n    Create a network\n\n    name\n        Name of the network being created\n\n    shared : False\n        If ``True``, set the network as shared\n\n    admin_state_up : True\n        If ``True``, Set the network administrative state to \"up\"\n\n    external : False\n        Control whether or not this network is externally accessible\n\n    provider\n        An optional Python dictionary of network provider options\n\n    project_id\n        The project ID on which this network will be created\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' neutronng.network_create name=network2 \\\n          shared=True admin_state_up=True external=True\n\n        salt '*' neutronng.network_create name=network3 \\\n          provider='{\"network_type\": \"vlan\",\\\n                     \"segmentation_id\": \"4010\",\\\n                     \"physical_network\": \"provider\"}' \\\n          project_id=1dcac318a83b4610b7a7f7ba01465548\n\n    '''\n    cloud = get_operator_cloud(auth)\n    kwargs = _clean_kwargs(keep_name=True, **kwargs)\n    return cloud.create_network(**kwargs)", "language": "python", "code": "def network_create(auth=None, **kwargs):\n    '''\n    Create a network\n\n    name\n        Name of the network being created\n\n    shared : False\n        If ``True``, set the network as shared\n\n    admin_state_up : True\n        If ``True``, Set the network administrative state to \"up\"\n\n    external : False\n        Control whether or not this network is externally accessible\n\n    provider\n        An optional Python dictionary of network provider options\n\n    project_id\n        The project ID on which this network will be created\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' neutronng.network_create name=network2 \\\n          shared=True admin_state_up=True external=True\n\n        salt '*' neutronng.network_create name=network3 \\\n          provider='{\"network_type\": \"vlan\",\\\n                     \"segmentation_id\": \"4010\",\\\n                     \"physical_network\": \"provider\"}' \\\n          project_id=1dcac318a83b4610b7a7f7ba01465548\n\n    '''\n    cloud = get_operator_cloud(auth)\n    kwargs = _clean_kwargs(keep_name=True, **kwargs)\n    return cloud.create_network(**kwargs)", "code_tokens": ["def", "network_create", "(", "auth", "=", "None", ",", "*", "*", "kwargs", ")", ":", "cloud", "=", "get_operator_cloud", "(", "auth", ")", "kwargs", "=", "_clean_kwargs", "(", "keep_name", "=", "True", ",", "*", "*", "kwargs", ")", "return", "cloud", ".", "create_network", "(", "*", "*", "kwargs", ")"], "docstring": "Create a network\n\n    name\n        Name of the network being created\n\n    shared : False\n        If ``True``, set the network as shared\n\n    admin_state_up : True\n        If ``True``, Set the network administrative state to \"up\"\n\n    external : False\n        Control whether or not this network is externally accessible\n\n    provider\n        An optional Python dictionary of network provider options\n\n    project_id\n        The project ID on which this network will be created\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' neutronng.network_create name=network2 \\\n          shared=True admin_state_up=True external=True\n\n        salt '*' neutronng.network_create name=network3 \\\n          provider='{\"network_type\": \"vlan\",\\\n                     \"segmentation_id\": \"4010\",\\\n                     \"physical_network\": \"provider\"}' \\\n          project_id=1dcac318a83b4610b7a7f7ba01465548", "docstring_tokens": ["Create", "a", "network"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/modules/neutronng.py#L109-L147", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/modules/neutronng.py", "func_name": "network_delete", "original_string": "def network_delete(auth=None, **kwargs):\n    '''\n    Delete a network\n\n    name_or_id\n        Name or ID of the network being deleted\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' neutronng.network_delete name_or_id=network1\n        salt '*' neutronng.network_delete name_or_id=1dcac318a83b4610b7a7f7ba01465548\n\n    '''\n    cloud = get_operator_cloud(auth)\n    kwargs = _clean_kwargs(**kwargs)\n    return cloud.delete_network(**kwargs)", "language": "python", "code": "def network_delete(auth=None, **kwargs):\n    '''\n    Delete a network\n\n    name_or_id\n        Name or ID of the network being deleted\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' neutronng.network_delete name_or_id=network1\n        salt '*' neutronng.network_delete name_or_id=1dcac318a83b4610b7a7f7ba01465548\n\n    '''\n    cloud = get_operator_cloud(auth)\n    kwargs = _clean_kwargs(**kwargs)\n    return cloud.delete_network(**kwargs)", "code_tokens": ["def", "network_delete", "(", "auth", "=", "None", ",", "*", "*", "kwargs", ")", ":", "cloud", "=", "get_operator_cloud", "(", "auth", ")", "kwargs", "=", "_clean_kwargs", "(", "*", "*", "kwargs", ")", "return", "cloud", ".", "delete_network", "(", "*", "*", "kwargs", ")"], "docstring": "Delete a network\n\n    name_or_id\n        Name or ID of the network being deleted\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' neutronng.network_delete name_or_id=network1\n        salt '*' neutronng.network_delete name_or_id=1dcac318a83b4610b7a7f7ba01465548", "docstring_tokens": ["Delete", "a", "network"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/modules/neutronng.py#L150-L167", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/modules/neutronng.py", "func_name": "list_networks", "original_string": "def list_networks(auth=None, **kwargs):\n    '''\n    List networks\n\n    filters\n        A Python dictionary of filter conditions to push down\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' neutronng.list_networks\n        salt '*' neutronng.list_networks \\\n          filters='{\"tenant_id\": \"1dcac318a83b4610b7a7f7ba01465548\"}'\n\n    '''\n    cloud = get_operator_cloud(auth)\n    kwargs = _clean_kwargs(**kwargs)\n    return cloud.list_networks(**kwargs)", "language": "python", "code": "def list_networks(auth=None, **kwargs):\n    '''\n    List networks\n\n    filters\n        A Python dictionary of filter conditions to push down\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' neutronng.list_networks\n        salt '*' neutronng.list_networks \\\n          filters='{\"tenant_id\": \"1dcac318a83b4610b7a7f7ba01465548\"}'\n\n    '''\n    cloud = get_operator_cloud(auth)\n    kwargs = _clean_kwargs(**kwargs)\n    return cloud.list_networks(**kwargs)", "code_tokens": ["def", "list_networks", "(", "auth", "=", "None", ",", "*", "*", "kwargs", ")", ":", "cloud", "=", "get_operator_cloud", "(", "auth", ")", "kwargs", "=", "_clean_kwargs", "(", "*", "*", "kwargs", ")", "return", "cloud", ".", "list_networks", "(", "*", "*", "kwargs", ")"], "docstring": "List networks\n\n    filters\n        A Python dictionary of filter conditions to push down\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' neutronng.list_networks\n        salt '*' neutronng.list_networks \\\n          filters='{\"tenant_id\": \"1dcac318a83b4610b7a7f7ba01465548\"}'", "docstring_tokens": ["List", "networks"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/modules/neutronng.py#L170-L188", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/modules/neutronng.py", "func_name": "network_get", "original_string": "def network_get(auth=None, **kwargs):\n    '''\n    Get a single network\n\n    filters\n        A Python dictionary of filter conditions to push down\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' neutronng.network_get name=XLB4\n\n    '''\n    cloud = get_operator_cloud(auth)\n    kwargs = _clean_kwargs(**kwargs)\n    return cloud.get_network(**kwargs)", "language": "python", "code": "def network_get(auth=None, **kwargs):\n    '''\n    Get a single network\n\n    filters\n        A Python dictionary of filter conditions to push down\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' neutronng.network_get name=XLB4\n\n    '''\n    cloud = get_operator_cloud(auth)\n    kwargs = _clean_kwargs(**kwargs)\n    return cloud.get_network(**kwargs)", "code_tokens": ["def", "network_get", "(", "auth", "=", "None", ",", "*", "*", "kwargs", ")", ":", "cloud", "=", "get_operator_cloud", "(", "auth", ")", "kwargs", "=", "_clean_kwargs", "(", "*", "*", "kwargs", ")", "return", "cloud", ".", "get_network", "(", "*", "*", "kwargs", ")"], "docstring": "Get a single network\n\n    filters\n        A Python dictionary of filter conditions to push down\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' neutronng.network_get name=XLB4", "docstring_tokens": ["Get", "a", "single", "network"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/modules/neutronng.py#L191-L207", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/modules/neutronng.py", "func_name": "subnet_create", "original_string": "def subnet_create(auth=None, **kwargs):\n    '''\n    Create a subnet\n\n    network_name_or_id\n        The unique name or ID of the attached network. If a non-unique name is\n        supplied, an exception is raised.\n\n    cidr\n        The CIDR\n\n    ip_version\n        The IP version, which is 4 or 6.\n\n    enable_dhcp : False\n        Set to ``True`` if DHCP is enabled and ``False`` if disabled\n\n    subnet_name\n        The name of the subnet\n\n    tenant_id\n        The ID of the tenant who owns the network. Only administrative users\n        can specify a tenant ID other than their own.\n\n    allocation_pools\n        A list of dictionaries of the start and end addresses for the\n        allocation pools.\n\n    gateway_ip\n        The gateway IP address. When you specify both ``allocation_pools`` and\n        ``gateway_ip``, you must ensure that the gateway IP does not overlap\n        with the specified allocation pools.\n\n    disable_gateway_ip : False\n        Set to ``True`` if gateway IP address is disabled and ``False`` if\n        enabled. It is not allowed with ``gateway_ip``.\n\n    dns_nameservers\n        A list of DNS name servers for the subnet\n\n    host_routes\n        A list of host route dictionaries for the subnet\n\n    ipv6_ra_mode\n        IPv6 Router Advertisement mode. Valid values are ``dhcpv6-stateful``,\n        ``dhcpv6-stateless``, or ``slaac``.\n\n    ipv6_address_mode\n        IPv6 address mode. Valid values are ``dhcpv6-stateful``,\n        ``dhcpv6-stateless``, or ``slaac``.\n\n    use_default_subnetpool\n        If ``True``, use the default subnetpool for ``ip_version`` to obtain a\n        CIDR. It is required to pass ``None`` to the ``cidr`` argument when\n        enabling this option.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' neutronng.subnet_create network_name_or_id=network1\n          subnet_name=subnet1\n\n        salt '*' neutronng.subnet_create subnet_name=subnet2\\\n          network_name_or_id=network2 enable_dhcp=True \\\n          allocation_pools='[{\"start\": \"192.168.199.2\",\\\n                              \"end\": \"192.168.199.254\"}]'\\\n          gateway_ip='192.168.199.1' cidr=192.168.199.0/24\n\n        salt '*' neutronng.subnet_create network_name_or_id=network1 \\\n          subnet_name=subnet1 dns_nameservers='[\"8.8.8.8\", \"8.8.8.7\"]'\n\n    '''\n    cloud = get_operator_cloud(auth)\n    kwargs = _clean_kwargs(**kwargs)\n    return cloud.create_subnet(**kwargs)", "language": "python", "code": "def subnet_create(auth=None, **kwargs):\n    '''\n    Create a subnet\n\n    network_name_or_id\n        The unique name or ID of the attached network. If a non-unique name is\n        supplied, an exception is raised.\n\n    cidr\n        The CIDR\n\n    ip_version\n        The IP version, which is 4 or 6.\n\n    enable_dhcp : False\n        Set to ``True`` if DHCP is enabled and ``False`` if disabled\n\n    subnet_name\n        The name of the subnet\n\n    tenant_id\n        The ID of the tenant who owns the network. Only administrative users\n        can specify a tenant ID other than their own.\n\n    allocation_pools\n        A list of dictionaries of the start and end addresses for the\n        allocation pools.\n\n    gateway_ip\n        The gateway IP address. When you specify both ``allocation_pools`` and\n        ``gateway_ip``, you must ensure that the gateway IP does not overlap\n        with the specified allocation pools.\n\n    disable_gateway_ip : False\n        Set to ``True`` if gateway IP address is disabled and ``False`` if\n        enabled. It is not allowed with ``gateway_ip``.\n\n    dns_nameservers\n        A list of DNS name servers for the subnet\n\n    host_routes\n        A list of host route dictionaries for the subnet\n\n    ipv6_ra_mode\n        IPv6 Router Advertisement mode. Valid values are ``dhcpv6-stateful``,\n        ``dhcpv6-stateless``, or ``slaac``.\n\n    ipv6_address_mode\n        IPv6 address mode. Valid values are ``dhcpv6-stateful``,\n        ``dhcpv6-stateless``, or ``slaac``.\n\n    use_default_subnetpool\n        If ``True``, use the default subnetpool for ``ip_version`` to obtain a\n        CIDR. It is required to pass ``None`` to the ``cidr`` argument when\n        enabling this option.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' neutronng.subnet_create network_name_or_id=network1\n          subnet_name=subnet1\n\n        salt '*' neutronng.subnet_create subnet_name=subnet2\\\n          network_name_or_id=network2 enable_dhcp=True \\\n          allocation_pools='[{\"start\": \"192.168.199.2\",\\\n                              \"end\": \"192.168.199.254\"}]'\\\n          gateway_ip='192.168.199.1' cidr=192.168.199.0/24\n\n        salt '*' neutronng.subnet_create network_name_or_id=network1 \\\n          subnet_name=subnet1 dns_nameservers='[\"8.8.8.8\", \"8.8.8.7\"]'\n\n    '''\n    cloud = get_operator_cloud(auth)\n    kwargs = _clean_kwargs(**kwargs)\n    return cloud.create_subnet(**kwargs)", "code_tokens": ["def", "subnet_create", "(", "auth", "=", "None", ",", "*", "*", "kwargs", ")", ":", "cloud", "=", "get_operator_cloud", "(", "auth", ")", "kwargs", "=", "_clean_kwargs", "(", "*", "*", "kwargs", ")", "return", "cloud", ".", "create_subnet", "(", "*", "*", "kwargs", ")"], "docstring": "Create a subnet\n\n    network_name_or_id\n        The unique name or ID of the attached network. If a non-unique name is\n        supplied, an exception is raised.\n\n    cidr\n        The CIDR\n\n    ip_version\n        The IP version, which is 4 or 6.\n\n    enable_dhcp : False\n        Set to ``True`` if DHCP is enabled and ``False`` if disabled\n\n    subnet_name\n        The name of the subnet\n\n    tenant_id\n        The ID of the tenant who owns the network. Only administrative users\n        can specify a tenant ID other than their own.\n\n    allocation_pools\n        A list of dictionaries of the start and end addresses for the\n        allocation pools.\n\n    gateway_ip\n        The gateway IP address. When you specify both ``allocation_pools`` and\n        ``gateway_ip``, you must ensure that the gateway IP does not overlap\n        with the specified allocation pools.\n\n    disable_gateway_ip : False\n        Set to ``True`` if gateway IP address is disabled and ``False`` if\n        enabled. It is not allowed with ``gateway_ip``.\n\n    dns_nameservers\n        A list of DNS name servers for the subnet\n\n    host_routes\n        A list of host route dictionaries for the subnet\n\n    ipv6_ra_mode\n        IPv6 Router Advertisement mode. Valid values are ``dhcpv6-stateful``,\n        ``dhcpv6-stateless``, or ``slaac``.\n\n    ipv6_address_mode\n        IPv6 address mode. Valid values are ``dhcpv6-stateful``,\n        ``dhcpv6-stateless``, or ``slaac``.\n\n    use_default_subnetpool\n        If ``True``, use the default subnetpool for ``ip_version`` to obtain a\n        CIDR. It is required to pass ``None`` to the ``cidr`` argument when\n        enabling this option.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' neutronng.subnet_create network_name_or_id=network1\n          subnet_name=subnet1\n\n        salt '*' neutronng.subnet_create subnet_name=subnet2\\\n          network_name_or_id=network2 enable_dhcp=True \\\n          allocation_pools='[{\"start\": \"192.168.199.2\",\\\n                              \"end\": \"192.168.199.254\"}]'\\\n          gateway_ip='192.168.199.1' cidr=192.168.199.0/24\n\n        salt '*' neutronng.subnet_create network_name_or_id=network1 \\\n          subnet_name=subnet1 dns_nameservers='[\"8.8.8.8\", \"8.8.8.7\"]'", "docstring_tokens": ["Create", "a", "subnet"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/modules/neutronng.py#L210-L285", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/modules/neutronng.py", "func_name": "subnet_update", "original_string": "def subnet_update(auth=None, **kwargs):\n    '''\n    Update a subnet\n\n    name_or_id\n        Name or ID of the subnet to update\n\n    subnet_name\n        The new name of the subnet\n\n    enable_dhcp\n        Set to ``True`` if DHCP is enabled and ``False`` if disabled\n\n    gateway_ip\n        The gateway IP address. When you specify both allocation_pools and\n        gateway_ip, you must ensure that the gateway IP does not overlap with\n        the specified allocation pools.\n\n    disable_gateway_ip : False\n        Set to ``True`` if gateway IP address is disabled and False if enabled.\n        It is not allowed with ``gateway_ip``.\n\n    allocation_pools\n        A list of dictionaries of the start and end addresses for the\n        allocation pools.\n\n    dns_nameservers\n        A list of DNS name servers for the subnet\n\n    host_routes\n        A list of host route dictionaries for the subnet\n\n    .. code-block:: bash\n\n        salt '*' neutronng.subnet_update name=subnet1 subnet_name=subnet2\n        salt '*' neutronng.subnet_update name=subnet1 dns_nameservers='[\"8.8.8.8\", \"8.8.8.7\"]'\n\n    '''\n    cloud = get_operator_cloud(auth)\n    kwargs = _clean_kwargs(**kwargs)\n    return cloud.update_subnet(**kwargs)", "language": "python", "code": "def subnet_update(auth=None, **kwargs):\n    '''\n    Update a subnet\n\n    name_or_id\n        Name or ID of the subnet to update\n\n    subnet_name\n        The new name of the subnet\n\n    enable_dhcp\n        Set to ``True`` if DHCP is enabled and ``False`` if disabled\n\n    gateway_ip\n        The gateway IP address. When you specify both allocation_pools and\n        gateway_ip, you must ensure that the gateway IP does not overlap with\n        the specified allocation pools.\n\n    disable_gateway_ip : False\n        Set to ``True`` if gateway IP address is disabled and False if enabled.\n        It is not allowed with ``gateway_ip``.\n\n    allocation_pools\n        A list of dictionaries of the start and end addresses for the\n        allocation pools.\n\n    dns_nameservers\n        A list of DNS name servers for the subnet\n\n    host_routes\n        A list of host route dictionaries for the subnet\n\n    .. code-block:: bash\n\n        salt '*' neutronng.subnet_update name=subnet1 subnet_name=subnet2\n        salt '*' neutronng.subnet_update name=subnet1 dns_nameservers='[\"8.8.8.8\", \"8.8.8.7\"]'\n\n    '''\n    cloud = get_operator_cloud(auth)\n    kwargs = _clean_kwargs(**kwargs)\n    return cloud.update_subnet(**kwargs)", "code_tokens": ["def", "subnet_update", "(", "auth", "=", "None", ",", "*", "*", "kwargs", ")", ":", "cloud", "=", "get_operator_cloud", "(", "auth", ")", "kwargs", "=", "_clean_kwargs", "(", "*", "*", "kwargs", ")", "return", "cloud", ".", "update_subnet", "(", "*", "*", "kwargs", ")"], "docstring": "Update a subnet\n\n    name_or_id\n        Name or ID of the subnet to update\n\n    subnet_name\n        The new name of the subnet\n\n    enable_dhcp\n        Set to ``True`` if DHCP is enabled and ``False`` if disabled\n\n    gateway_ip\n        The gateway IP address. When you specify both allocation_pools and\n        gateway_ip, you must ensure that the gateway IP does not overlap with\n        the specified allocation pools.\n\n    disable_gateway_ip : False\n        Set to ``True`` if gateway IP address is disabled and False if enabled.\n        It is not allowed with ``gateway_ip``.\n\n    allocation_pools\n        A list of dictionaries of the start and end addresses for the\n        allocation pools.\n\n    dns_nameservers\n        A list of DNS name servers for the subnet\n\n    host_routes\n        A list of host route dictionaries for the subnet\n\n    .. code-block:: bash\n\n        salt '*' neutronng.subnet_update name=subnet1 subnet_name=subnet2\n        salt '*' neutronng.subnet_update name=subnet1 dns_nameservers='[\"8.8.8.8\", \"8.8.8.7\"]'", "docstring_tokens": ["Update", "a", "subnet"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/modules/neutronng.py#L288-L328", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/modules/neutronng.py", "func_name": "subnet_delete", "original_string": "def subnet_delete(auth=None, **kwargs):\n    '''\n    Delete a subnet\n\n    name\n        Name or ID of the subnet to update\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' neutronng.subnet_delete name=subnet1\n        salt '*' neutronng.subnet_delete \\\n          name=1dcac318a83b4610b7a7f7ba01465548\n\n    '''\n    cloud = get_operator_cloud(auth)\n    kwargs = _clean_kwargs(**kwargs)\n    return cloud.delete_subnet(**kwargs)", "language": "python", "code": "def subnet_delete(auth=None, **kwargs):\n    '''\n    Delete a subnet\n\n    name\n        Name or ID of the subnet to update\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' neutronng.subnet_delete name=subnet1\n        salt '*' neutronng.subnet_delete \\\n          name=1dcac318a83b4610b7a7f7ba01465548\n\n    '''\n    cloud = get_operator_cloud(auth)\n    kwargs = _clean_kwargs(**kwargs)\n    return cloud.delete_subnet(**kwargs)", "code_tokens": ["def", "subnet_delete", "(", "auth", "=", "None", ",", "*", "*", "kwargs", ")", ":", "cloud", "=", "get_operator_cloud", "(", "auth", ")", "kwargs", "=", "_clean_kwargs", "(", "*", "*", "kwargs", ")", "return", "cloud", ".", "delete_subnet", "(", "*", "*", "kwargs", ")"], "docstring": "Delete a subnet\n\n    name\n        Name or ID of the subnet to update\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' neutronng.subnet_delete name=subnet1\n        salt '*' neutronng.subnet_delete \\\n          name=1dcac318a83b4610b7a7f7ba01465548", "docstring_tokens": ["Delete", "a", "subnet"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/modules/neutronng.py#L331-L349", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/modules/neutronng.py", "func_name": "list_subnets", "original_string": "def list_subnets(auth=None, **kwargs):\n    '''\n    List subnets\n\n    filters\n        A Python dictionary of filter conditions to push down\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' neutronng.list_subnets\n        salt '*' neutronng.list_subnets \\\n          filters='{\"tenant_id\": \"1dcac318a83b4610b7a7f7ba01465548\"}'\n\n    '''\n    cloud = get_operator_cloud(auth)\n    kwargs = _clean_kwargs(**kwargs)\n    return cloud.list_subnets(**kwargs)", "language": "python", "code": "def list_subnets(auth=None, **kwargs):\n    '''\n    List subnets\n\n    filters\n        A Python dictionary of filter conditions to push down\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' neutronng.list_subnets\n        salt '*' neutronng.list_subnets \\\n          filters='{\"tenant_id\": \"1dcac318a83b4610b7a7f7ba01465548\"}'\n\n    '''\n    cloud = get_operator_cloud(auth)\n    kwargs = _clean_kwargs(**kwargs)\n    return cloud.list_subnets(**kwargs)", "code_tokens": ["def", "list_subnets", "(", "auth", "=", "None", ",", "*", "*", "kwargs", ")", ":", "cloud", "=", "get_operator_cloud", "(", "auth", ")", "kwargs", "=", "_clean_kwargs", "(", "*", "*", "kwargs", ")", "return", "cloud", ".", "list_subnets", "(", "*", "*", "kwargs", ")"], "docstring": "List subnets\n\n    filters\n        A Python dictionary of filter conditions to push down\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' neutronng.list_subnets\n        salt '*' neutronng.list_subnets \\\n          filters='{\"tenant_id\": \"1dcac318a83b4610b7a7f7ba01465548\"}'", "docstring_tokens": ["List", "subnets"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/modules/neutronng.py#L352-L370", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/modules/neutronng.py", "func_name": "subnet_get", "original_string": "def subnet_get(auth=None, **kwargs):\n    '''\n    Get a single subnet\n\n    filters\n        A Python dictionary of filter conditions to push down\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' neutronng.subnet_get name=subnet1\n\n    '''\n    cloud = get_operator_cloud(auth)\n    kwargs = _clean_kwargs(**kwargs)\n    return cloud.get_subnet(**kwargs)", "language": "python", "code": "def subnet_get(auth=None, **kwargs):\n    '''\n    Get a single subnet\n\n    filters\n        A Python dictionary of filter conditions to push down\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' neutronng.subnet_get name=subnet1\n\n    '''\n    cloud = get_operator_cloud(auth)\n    kwargs = _clean_kwargs(**kwargs)\n    return cloud.get_subnet(**kwargs)", "code_tokens": ["def", "subnet_get", "(", "auth", "=", "None", ",", "*", "*", "kwargs", ")", ":", "cloud", "=", "get_operator_cloud", "(", "auth", ")", "kwargs", "=", "_clean_kwargs", "(", "*", "*", "kwargs", ")", "return", "cloud", ".", "get_subnet", "(", "*", "*", "kwargs", ")"], "docstring": "Get a single subnet\n\n    filters\n        A Python dictionary of filter conditions to push down\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' neutronng.subnet_get name=subnet1", "docstring_tokens": ["Get", "a", "single", "subnet"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/modules/neutronng.py#L373-L389", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/modules/neutronng.py", "func_name": "security_group_create", "original_string": "def security_group_create(auth=None, **kwargs):\n    '''\n    Create a security group. Use security_group_get to create default.\n\n    project_id\n        The project ID on which this security group will be created\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' neutronng.security_group_create name=secgroup1 \\\n          description=\"Very secure security group\"\n        salt '*' neutronng.security_group_create name=secgroup1 \\\n          description=\"Very secure security group\" \\\n          project_id=1dcac318a83b4610b7a7f7ba01465548\n\n    '''\n    cloud = get_operator_cloud(auth)\n    kwargs = _clean_kwargs(keep_name=True, **kwargs)\n    return cloud.create_security_group(**kwargs)", "language": "python", "code": "def security_group_create(auth=None, **kwargs):\n    '''\n    Create a security group. Use security_group_get to create default.\n\n    project_id\n        The project ID on which this security group will be created\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' neutronng.security_group_create name=secgroup1 \\\n          description=\"Very secure security group\"\n        salt '*' neutronng.security_group_create name=secgroup1 \\\n          description=\"Very secure security group\" \\\n          project_id=1dcac318a83b4610b7a7f7ba01465548\n\n    '''\n    cloud = get_operator_cloud(auth)\n    kwargs = _clean_kwargs(keep_name=True, **kwargs)\n    return cloud.create_security_group(**kwargs)", "code_tokens": ["def", "security_group_create", "(", "auth", "=", "None", ",", "*", "*", "kwargs", ")", ":", "cloud", "=", "get_operator_cloud", "(", "auth", ")", "kwargs", "=", "_clean_kwargs", "(", "keep_name", "=", "True", ",", "*", "*", "kwargs", ")", "return", "cloud", ".", "create_security_group", "(", "*", "*", "kwargs", ")"], "docstring": "Create a security group. Use security_group_get to create default.\n\n    project_id\n        The project ID on which this security group will be created\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' neutronng.security_group_create name=secgroup1 \\\n          description=\"Very secure security group\"\n        salt '*' neutronng.security_group_create name=secgroup1 \\\n          description=\"Very secure security group\" \\\n          project_id=1dcac318a83b4610b7a7f7ba01465548", "docstring_tokens": ["Create", "a", "security", "group", ".", "Use", "security_group_get", "to", "create", "default", "."], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/modules/neutronng.py#L392-L412", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/modules/neutronng.py", "func_name": "security_group_update", "original_string": "def security_group_update(secgroup=None, auth=None, **kwargs):\n    '''\n    Update a security group\n\n    secgroup\n        Name, ID or Raw Object of the security group to update\n\n    name\n        New name for the security group\n\n    description\n        New description for the security group\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' neutronng.security_group_update secgroup=secgroup1 \\\n          description=\"Very secure security group\"\n        salt '*' neutronng.security_group_update secgroup=secgroup1 \\\n          description=\"Very secure security group\" \\\n          project_id=1dcac318a83b4610b7a7f7ba01465548\n\n    '''\n    cloud = get_operator_cloud(auth)\n    kwargs = _clean_kwargs(keep_name=True, **kwargs)\n    return cloud.update_security_group(secgroup, **kwargs)", "language": "python", "code": "def security_group_update(secgroup=None, auth=None, **kwargs):\n    '''\n    Update a security group\n\n    secgroup\n        Name, ID or Raw Object of the security group to update\n\n    name\n        New name for the security group\n\n    description\n        New description for the security group\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' neutronng.security_group_update secgroup=secgroup1 \\\n          description=\"Very secure security group\"\n        salt '*' neutronng.security_group_update secgroup=secgroup1 \\\n          description=\"Very secure security group\" \\\n          project_id=1dcac318a83b4610b7a7f7ba01465548\n\n    '''\n    cloud = get_operator_cloud(auth)\n    kwargs = _clean_kwargs(keep_name=True, **kwargs)\n    return cloud.update_security_group(secgroup, **kwargs)", "code_tokens": ["def", "security_group_update", "(", "secgroup", "=", "None", ",", "auth", "=", "None", ",", "*", "*", "kwargs", ")", ":", "cloud", "=", "get_operator_cloud", "(", "auth", ")", "kwargs", "=", "_clean_kwargs", "(", "keep_name", "=", "True", ",", "*", "*", "kwargs", ")", "return", "cloud", ".", "update_security_group", "(", "secgroup", ",", "*", "*", "kwargs", ")"], "docstring": "Update a security group\n\n    secgroup\n        Name, ID or Raw Object of the security group to update\n\n    name\n        New name for the security group\n\n    description\n        New description for the security group\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' neutronng.security_group_update secgroup=secgroup1 \\\n          description=\"Very secure security group\"\n        salt '*' neutronng.security_group_update secgroup=secgroup1 \\\n          description=\"Very secure security group\" \\\n          project_id=1dcac318a83b4610b7a7f7ba01465548", "docstring_tokens": ["Update", "a", "security", "group"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/modules/neutronng.py#L415-L441", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/modules/neutronng.py", "func_name": "security_group_delete", "original_string": "def security_group_delete(auth=None, **kwargs):\n    '''\n    Delete a security group\n\n    name_or_id\n        The name or unique ID of the security group\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' neutronng.security_group_delete name_or_id=secgroup1\n\n    '''\n    cloud = get_operator_cloud(auth)\n    kwargs = _clean_kwargs(**kwargs)\n    return cloud.delete_security_group(**kwargs)", "language": "python", "code": "def security_group_delete(auth=None, **kwargs):\n    '''\n    Delete a security group\n\n    name_or_id\n        The name or unique ID of the security group\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' neutronng.security_group_delete name_or_id=secgroup1\n\n    '''\n    cloud = get_operator_cloud(auth)\n    kwargs = _clean_kwargs(**kwargs)\n    return cloud.delete_security_group(**kwargs)", "code_tokens": ["def", "security_group_delete", "(", "auth", "=", "None", ",", "*", "*", "kwargs", ")", ":", "cloud", "=", "get_operator_cloud", "(", "auth", ")", "kwargs", "=", "_clean_kwargs", "(", "*", "*", "kwargs", ")", "return", "cloud", ".", "delete_security_group", "(", "*", "*", "kwargs", ")"], "docstring": "Delete a security group\n\n    name_or_id\n        The name or unique ID of the security group\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' neutronng.security_group_delete name_or_id=secgroup1", "docstring_tokens": ["Delete", "a", "security", "group"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/modules/neutronng.py#L444-L460", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/modules/neutronng.py", "func_name": "security_group_get", "original_string": "def security_group_get(auth=None, **kwargs):\n    '''\n    Get a single security group. This will create a default security group\n    if one does not exist yet for a particular project id.\n\n    filters\n        A Python dictionary of filter conditions to push down\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' neutronng.security_group_get \\\n          name=1dcac318a83b4610b7a7f7ba01465548\n\n        salt '*' neutronng.security_group_get \\\n          name=default\\\n          filters='{\"tenant_id\":\"2e778bb64ca64a199eb526b5958d8710\"}'\n    '''\n    cloud = get_operator_cloud(auth)\n    kwargs = _clean_kwargs(**kwargs)\n    return cloud.get_security_group(**kwargs)", "language": "python", "code": "def security_group_get(auth=None, **kwargs):\n    '''\n    Get a single security group. This will create a default security group\n    if one does not exist yet for a particular project id.\n\n    filters\n        A Python dictionary of filter conditions to push down\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' neutronng.security_group_get \\\n          name=1dcac318a83b4610b7a7f7ba01465548\n\n        salt '*' neutronng.security_group_get \\\n          name=default\\\n          filters='{\"tenant_id\":\"2e778bb64ca64a199eb526b5958d8710\"}'\n    '''\n    cloud = get_operator_cloud(auth)\n    kwargs = _clean_kwargs(**kwargs)\n    return cloud.get_security_group(**kwargs)", "code_tokens": ["def", "security_group_get", "(", "auth", "=", "None", ",", "*", "*", "kwargs", ")", ":", "cloud", "=", "get_operator_cloud", "(", "auth", ")", "kwargs", "=", "_clean_kwargs", "(", "*", "*", "kwargs", ")", "return", "cloud", ".", "get_security_group", "(", "*", "*", "kwargs", ")"], "docstring": "Get a single security group. This will create a default security group\n    if one does not exist yet for a particular project id.\n\n    filters\n        A Python dictionary of filter conditions to push down\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' neutronng.security_group_get \\\n          name=1dcac318a83b4610b7a7f7ba01465548\n\n        salt '*' neutronng.security_group_get \\\n          name=default\\\n          filters='{\"tenant_id\":\"2e778bb64ca64a199eb526b5958d8710\"}'", "docstring_tokens": ["Get", "a", "single", "security", "group", ".", "This", "will", "create", "a", "default", "security", "group", "if", "one", "does", "not", "exist", "yet", "for", "a", "particular", "project", "id", "."], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/modules/neutronng.py#L463-L484", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/modules/neutronng.py", "func_name": "security_group_rule_create", "original_string": "def security_group_rule_create(auth=None, **kwargs):\n    '''\n    Create a rule in a security group\n\n    secgroup_name_or_id\n        The security group name or ID to associate with this security group\n        rule. If a non-unique group name is given, an exception is raised.\n\n    port_range_min\n        The minimum port number in the range that is matched by the security\n        group rule. If the protocol is TCP or UDP, this value must be less than\n        or equal to the port_range_max attribute value. If nova is used by the\n        cloud provider for security groups, then a value of None will be\n        transformed to -1.\n\n    port_range_max\n        The maximum port number in the range that is matched by the security\n        group rule. The port_range_min attribute constrains the port_range_max\n        attribute. If nova is used by the cloud provider for security groups,\n        then a value of None will be transformed to -1.\n\n    protocol\n        The protocol that is matched by the security group rule.  Valid values\n        are ``None``, ``tcp``, ``udp``, and ``icmp``.\n\n    remote_ip_prefix\n        The remote IP prefix to be associated with this security group rule.\n        This attribute matches the specified IP prefix as the source IP address\n        of the IP packet.\n\n    remote_group_id\n        The remote group ID to be associated with this security group rule\n\n    direction\n        Either ``ingress`` or ``egress``; the direction in which the security\n        group rule is applied. For a compute instance, an ingress security\n        group rule is applied to incoming (ingress) traffic for that instance.\n        An egress rule is applied to traffic leaving the instance\n\n    ethertype\n        Must be IPv4 or IPv6, and addresses represented in CIDR must match the\n        ingress or egress rules\n\n    project_id\n        Specify the project ID this security group will be created on\n        (admin-only)\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' neutronng.security_group_rule_create\\\n          secgroup_name_or_id=secgroup1\n\n        salt '*' neutronng.security_group_rule_create\\\n          secgroup_name_or_id=secgroup2 port_range_min=8080\\\n          port_range_max=8080 direction='egress'\n\n        salt '*' neutronng.security_group_rule_create\\\n          secgroup_name_or_id=c0e1d1ce-7296-405e-919d-1c08217be529\\\n          protocol=icmp project_id=1dcac318a83b4610b7a7f7ba01465548\n\n    '''\n    cloud = get_operator_cloud(auth)\n    kwargs = _clean_kwargs(**kwargs)\n    return cloud.create_security_group_rule(**kwargs)", "language": "python", "code": "def security_group_rule_create(auth=None, **kwargs):\n    '''\n    Create a rule in a security group\n\n    secgroup_name_or_id\n        The security group name or ID to associate with this security group\n        rule. If a non-unique group name is given, an exception is raised.\n\n    port_range_min\n        The minimum port number in the range that is matched by the security\n        group rule. If the protocol is TCP or UDP, this value must be less than\n        or equal to the port_range_max attribute value. If nova is used by the\n        cloud provider for security groups, then a value of None will be\n        transformed to -1.\n\n    port_range_max\n        The maximum port number in the range that is matched by the security\n        group rule. The port_range_min attribute constrains the port_range_max\n        attribute. If nova is used by the cloud provider for security groups,\n        then a value of None will be transformed to -1.\n\n    protocol\n        The protocol that is matched by the security group rule.  Valid values\n        are ``None``, ``tcp``, ``udp``, and ``icmp``.\n\n    remote_ip_prefix\n        The remote IP prefix to be associated with this security group rule.\n        This attribute matches the specified IP prefix as the source IP address\n        of the IP packet.\n\n    remote_group_id\n        The remote group ID to be associated with this security group rule\n\n    direction\n        Either ``ingress`` or ``egress``; the direction in which the security\n        group rule is applied. For a compute instance, an ingress security\n        group rule is applied to incoming (ingress) traffic for that instance.\n        An egress rule is applied to traffic leaving the instance\n\n    ethertype\n        Must be IPv4 or IPv6, and addresses represented in CIDR must match the\n        ingress or egress rules\n\n    project_id\n        Specify the project ID this security group will be created on\n        (admin-only)\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' neutronng.security_group_rule_create\\\n          secgroup_name_or_id=secgroup1\n\n        salt '*' neutronng.security_group_rule_create\\\n          secgroup_name_or_id=secgroup2 port_range_min=8080\\\n          port_range_max=8080 direction='egress'\n\n        salt '*' neutronng.security_group_rule_create\\\n          secgroup_name_or_id=c0e1d1ce-7296-405e-919d-1c08217be529\\\n          protocol=icmp project_id=1dcac318a83b4610b7a7f7ba01465548\n\n    '''\n    cloud = get_operator_cloud(auth)\n    kwargs = _clean_kwargs(**kwargs)\n    return cloud.create_security_group_rule(**kwargs)", "code_tokens": ["def", "security_group_rule_create", "(", "auth", "=", "None", ",", "*", "*", "kwargs", ")", ":", "cloud", "=", "get_operator_cloud", "(", "auth", ")", "kwargs", "=", "_clean_kwargs", "(", "*", "*", "kwargs", ")", "return", "cloud", ".", "create_security_group_rule", "(", "*", "*", "kwargs", ")"], "docstring": "Create a rule in a security group\n\n    secgroup_name_or_id\n        The security group name or ID to associate with this security group\n        rule. If a non-unique group name is given, an exception is raised.\n\n    port_range_min\n        The minimum port number in the range that is matched by the security\n        group rule. If the protocol is TCP or UDP, this value must be less than\n        or equal to the port_range_max attribute value. If nova is used by the\n        cloud provider for security groups, then a value of None will be\n        transformed to -1.\n\n    port_range_max\n        The maximum port number in the range that is matched by the security\n        group rule. The port_range_min attribute constrains the port_range_max\n        attribute. If nova is used by the cloud provider for security groups,\n        then a value of None will be transformed to -1.\n\n    protocol\n        The protocol that is matched by the security group rule.  Valid values\n        are ``None``, ``tcp``, ``udp``, and ``icmp``.\n\n    remote_ip_prefix\n        The remote IP prefix to be associated with this security group rule.\n        This attribute matches the specified IP prefix as the source IP address\n        of the IP packet.\n\n    remote_group_id\n        The remote group ID to be associated with this security group rule\n\n    direction\n        Either ``ingress`` or ``egress``; the direction in which the security\n        group rule is applied. For a compute instance, an ingress security\n        group rule is applied to incoming (ingress) traffic for that instance.\n        An egress rule is applied to traffic leaving the instance\n\n    ethertype\n        Must be IPv4 or IPv6, and addresses represented in CIDR must match the\n        ingress or egress rules\n\n    project_id\n        Specify the project ID this security group will be created on\n        (admin-only)\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' neutronng.security_group_rule_create\\\n          secgroup_name_or_id=secgroup1\n\n        salt '*' neutronng.security_group_rule_create\\\n          secgroup_name_or_id=secgroup2 port_range_min=8080\\\n          port_range_max=8080 direction='egress'\n\n        salt '*' neutronng.security_group_rule_create\\\n          secgroup_name_or_id=c0e1d1ce-7296-405e-919d-1c08217be529\\\n          protocol=icmp project_id=1dcac318a83b4610b7a7f7ba01465548", "docstring_tokens": ["Create", "a", "rule", "in", "a", "security", "group"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/modules/neutronng.py#L487-L552", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/modules/neutronng.py", "func_name": "security_group_rule_delete", "original_string": "def security_group_rule_delete(auth=None, **kwargs):\n    '''\n    Delete a security group\n\n    name_or_id\n        The unique ID of the security group rule\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' neutronng.security_group_rule_delete name_or_id=1dcac318a83b4610b7a7f7ba01465548\n\n    '''\n    cloud = get_operator_cloud(auth)\n    kwargs = _clean_kwargs(**kwargs)\n    return cloud.delete_security_group_rule(**kwargs)", "language": "python", "code": "def security_group_rule_delete(auth=None, **kwargs):\n    '''\n    Delete a security group\n\n    name_or_id\n        The unique ID of the security group rule\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' neutronng.security_group_rule_delete name_or_id=1dcac318a83b4610b7a7f7ba01465548\n\n    '''\n    cloud = get_operator_cloud(auth)\n    kwargs = _clean_kwargs(**kwargs)\n    return cloud.delete_security_group_rule(**kwargs)", "code_tokens": ["def", "security_group_rule_delete", "(", "auth", "=", "None", ",", "*", "*", "kwargs", ")", ":", "cloud", "=", "get_operator_cloud", "(", "auth", ")", "kwargs", "=", "_clean_kwargs", "(", "*", "*", "kwargs", ")", "return", "cloud", ".", "delete_security_group_rule", "(", "*", "*", "kwargs", ")"], "docstring": "Delete a security group\n\n    name_or_id\n        The unique ID of the security group rule\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' neutronng.security_group_rule_delete name_or_id=1dcac318a83b4610b7a7f7ba01465548", "docstring_tokens": ["Delete", "a", "security", "group"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/modules/neutronng.py#L555-L571", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/cloud/clouds/aliyun.py", "func_name": "avail_locations", "original_string": "def avail_locations(call=None):\n    '''\n    Return a dict of all available VM locations on the cloud provider with\n    relevant data\n    '''\n    if call == 'action':\n        raise SaltCloudSystemExit(\n            'The avail_locations function must be called with '\n            '-f or --function, or with the --list-locations option'\n        )\n\n    params = {'Action': 'DescribeRegions'}\n    items = query(params=params)\n\n    ret = {}\n    for region in items['Regions']['Region']:\n        ret[region['RegionId']] = {}\n        for item in region:\n            ret[region['RegionId']][item] = six.text_type(region[item])\n\n    return ret", "language": "python", "code": "def avail_locations(call=None):\n    '''\n    Return a dict of all available VM locations on the cloud provider with\n    relevant data\n    '''\n    if call == 'action':\n        raise SaltCloudSystemExit(\n            'The avail_locations function must be called with '\n            '-f or --function, or with the --list-locations option'\n        )\n\n    params = {'Action': 'DescribeRegions'}\n    items = query(params=params)\n\n    ret = {}\n    for region in items['Regions']['Region']:\n        ret[region['RegionId']] = {}\n        for item in region:\n            ret[region['RegionId']][item] = six.text_type(region[item])\n\n    return ret", "code_tokens": ["def", "avail_locations", "(", "call", "=", "None", ")", ":", "if", "call", "==", "'action'", ":", "raise", "SaltCloudSystemExit", "(", "'The avail_locations function must be called with '", "'-f or --function, or with the --list-locations option'", ")", "params", "=", "{", "'Action'", ":", "'DescribeRegions'", "}", "items", "=", "query", "(", "params", "=", "params", ")", "ret", "=", "{", "}", "for", "region", "in", "items", "[", "'Regions'", "]", "[", "'Region'", "]", ":", "ret", "[", "region", "[", "'RegionId'", "]", "]", "=", "{", "}", "for", "item", "in", "region", ":", "ret", "[", "region", "[", "'RegionId'", "]", "]", "[", "item", "]", "=", "six", ".", "text_type", "(", "region", "[", "item", "]", ")", "return", "ret"], "docstring": "Return a dict of all available VM locations on the cloud provider with\n    relevant data", "docstring_tokens": ["Return", "a", "dict", "of", "all", "available", "VM", "locations", "on", "the", "cloud", "provider", "with", "relevant", "data"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/cloud/clouds/aliyun.py#L124-L144", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/cloud/clouds/aliyun.py", "func_name": "avail_images", "original_string": "def avail_images(kwargs=None, call=None):\n    '''\n    Return a list of the images that are on the provider\n    '''\n    if call == 'action':\n        raise SaltCloudSystemExit(\n            'The avail_images function must be called with '\n            '-f or --function, or with the --list-images option'\n        )\n\n    if not isinstance(kwargs, dict):\n        kwargs = {}\n\n    provider = get_configured_provider()\n    location = provider.get('location', DEFAULT_LOCATION)\n\n    if 'location' in kwargs:\n        location = kwargs['location']\n\n    params = {\n        'Action': 'DescribeImages',\n        'RegionId': location,\n        'PageSize': '100',\n    }\n    items = query(params=params)\n\n    ret = {}\n    for image in items['Images']['Image']:\n        ret[image['ImageId']] = {}\n        for item in image:\n            ret[image['ImageId']][item] = six.text_type(image[item])\n\n    return ret", "language": "python", "code": "def avail_images(kwargs=None, call=None):\n    '''\n    Return a list of the images that are on the provider\n    '''\n    if call == 'action':\n        raise SaltCloudSystemExit(\n            'The avail_images function must be called with '\n            '-f or --function, or with the --list-images option'\n        )\n\n    if not isinstance(kwargs, dict):\n        kwargs = {}\n\n    provider = get_configured_provider()\n    location = provider.get('location', DEFAULT_LOCATION)\n\n    if 'location' in kwargs:\n        location = kwargs['location']\n\n    params = {\n        'Action': 'DescribeImages',\n        'RegionId': location,\n        'PageSize': '100',\n    }\n    items = query(params=params)\n\n    ret = {}\n    for image in items['Images']['Image']:\n        ret[image['ImageId']] = {}\n        for item in image:\n            ret[image['ImageId']][item] = six.text_type(image[item])\n\n    return ret", "code_tokens": ["def", "avail_images", "(", "kwargs", "=", "None", ",", "call", "=", "None", ")", ":", "if", "call", "==", "'action'", ":", "raise", "SaltCloudSystemExit", "(", "'The avail_images function must be called with '", "'-f or --function, or with the --list-images option'", ")", "if", "not", "isinstance", "(", "kwargs", ",", "dict", ")", ":", "kwargs", "=", "{", "}", "provider", "=", "get_configured_provider", "(", ")", "location", "=", "provider", ".", "get", "(", "'location'", ",", "DEFAULT_LOCATION", ")", "if", "'location'", "in", "kwargs", ":", "location", "=", "kwargs", "[", "'location'", "]", "params", "=", "{", "'Action'", ":", "'DescribeImages'", ",", "'RegionId'", ":", "location", ",", "'PageSize'", ":", "'100'", ",", "}", "items", "=", "query", "(", "params", "=", "params", ")", "ret", "=", "{", "}", "for", "image", "in", "items", "[", "'Images'", "]", "[", "'Image'", "]", ":", "ret", "[", "image", "[", "'ImageId'", "]", "]", "=", "{", "}", "for", "item", "in", "image", ":", "ret", "[", "image", "[", "'ImageId'", "]", "]", "[", "item", "]", "=", "six", ".", "text_type", "(", "image", "[", "item", "]", ")", "return", "ret"], "docstring": "Return a list of the images that are on the provider", "docstring_tokens": ["Return", "a", "list", "of", "the", "images", "that", "are", "on", "the", "provider"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/cloud/clouds/aliyun.py#L147-L179", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/cloud/clouds/aliyun.py", "func_name": "avail_sizes", "original_string": "def avail_sizes(call=None):\n    '''\n    Return a list of the image sizes that are on the provider\n    '''\n    if call == 'action':\n        raise SaltCloudSystemExit(\n            'The avail_sizes function must be called with '\n            '-f or --function, or with the --list-sizes option'\n        )\n\n    params = {'Action': 'DescribeInstanceTypes'}\n    items = query(params=params)\n\n    ret = {}\n    for image in items['InstanceTypes']['InstanceType']:\n        ret[image['InstanceTypeId']] = {}\n        for item in image:\n            ret[image['InstanceTypeId']][item] = six.text_type(image[item])\n\n    return ret", "language": "python", "code": "def avail_sizes(call=None):\n    '''\n    Return a list of the image sizes that are on the provider\n    '''\n    if call == 'action':\n        raise SaltCloudSystemExit(\n            'The avail_sizes function must be called with '\n            '-f or --function, or with the --list-sizes option'\n        )\n\n    params = {'Action': 'DescribeInstanceTypes'}\n    items = query(params=params)\n\n    ret = {}\n    for image in items['InstanceTypes']['InstanceType']:\n        ret[image['InstanceTypeId']] = {}\n        for item in image:\n            ret[image['InstanceTypeId']][item] = six.text_type(image[item])\n\n    return ret", "code_tokens": ["def", "avail_sizes", "(", "call", "=", "None", ")", ":", "if", "call", "==", "'action'", ":", "raise", "SaltCloudSystemExit", "(", "'The avail_sizes function must be called with '", "'-f or --function, or with the --list-sizes option'", ")", "params", "=", "{", "'Action'", ":", "'DescribeInstanceTypes'", "}", "items", "=", "query", "(", "params", "=", "params", ")", "ret", "=", "{", "}", "for", "image", "in", "items", "[", "'InstanceTypes'", "]", "[", "'InstanceType'", "]", ":", "ret", "[", "image", "[", "'InstanceTypeId'", "]", "]", "=", "{", "}", "for", "item", "in", "image", ":", "ret", "[", "image", "[", "'InstanceTypeId'", "]", "]", "[", "item", "]", "=", "six", ".", "text_type", "(", "image", "[", "item", "]", ")", "return", "ret"], "docstring": "Return a list of the image sizes that are on the provider", "docstring_tokens": ["Return", "a", "list", "of", "the", "image", "sizes", "that", "are", "on", "the", "provider"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/cloud/clouds/aliyun.py#L182-L201", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/cloud/clouds/aliyun.py", "func_name": "list_availability_zones", "original_string": "def list_availability_zones(call=None):\n    '''\n    List all availability zones in the current region\n    '''\n    ret = {}\n\n    params = {'Action': 'DescribeZones',\n              'RegionId': get_location()}\n    items = query(params)\n\n    for zone in items['Zones']['Zone']:\n        ret[zone['ZoneId']] = {}\n        for item in zone:\n            ret[zone['ZoneId']][item] = six.text_type(zone[item])\n\n    return ret", "language": "python", "code": "def list_availability_zones(call=None):\n    '''\n    List all availability zones in the current region\n    '''\n    ret = {}\n\n    params = {'Action': 'DescribeZones',\n              'RegionId': get_location()}\n    items = query(params)\n\n    for zone in items['Zones']['Zone']:\n        ret[zone['ZoneId']] = {}\n        for item in zone:\n            ret[zone['ZoneId']][item] = six.text_type(zone[item])\n\n    return ret", "code_tokens": ["def", "list_availability_zones", "(", "call", "=", "None", ")", ":", "ret", "=", "{", "}", "params", "=", "{", "'Action'", ":", "'DescribeZones'", ",", "'RegionId'", ":", "get_location", "(", ")", "}", "items", "=", "query", "(", "params", ")", "for", "zone", "in", "items", "[", "'Zones'", "]", "[", "'Zone'", "]", ":", "ret", "[", "zone", "[", "'ZoneId'", "]", "]", "=", "{", "}", "for", "item", "in", "zone", ":", "ret", "[", "zone", "[", "'ZoneId'", "]", "]", "[", "item", "]", "=", "six", ".", "text_type", "(", "zone", "[", "item", "]", ")", "return", "ret"], "docstring": "List all availability zones in the current region", "docstring_tokens": ["List", "all", "availability", "zones", "in", "the", "current", "region"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/cloud/clouds/aliyun.py#L223-L238", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/cloud/clouds/aliyun.py", "func_name": "list_nodes_min", "original_string": "def list_nodes_min(call=None):\n    '''\n    Return a list of the VMs that are on the provider. Only a list of VM names,\n    and their state, is returned. This is the minimum amount of information\n    needed to check for existing VMs.\n    '''\n    if call == 'action':\n        raise SaltCloudSystemExit(\n            'The list_nodes_min function must be called with -f or --function.'\n        )\n\n    ret = {}\n    location = get_location()\n    params = {\n        'Action': 'DescribeInstanceStatus',\n        'RegionId': location,\n    }\n    nodes = query(params)\n\n    log.debug(\n        'Total %s instance found in Region %s',\n        nodes['TotalCount'], location\n    )\n    if 'Code' in nodes or nodes['TotalCount'] == 0:\n        return ret\n\n    for node in nodes['InstanceStatuses']['InstanceStatus']:\n        ret[node['InstanceId']] = {}\n        for item in node:\n            ret[node['InstanceId']][item] = node[item]\n\n    return ret", "language": "python", "code": "def list_nodes_min(call=None):\n    '''\n    Return a list of the VMs that are on the provider. Only a list of VM names,\n    and their state, is returned. This is the minimum amount of information\n    needed to check for existing VMs.\n    '''\n    if call == 'action':\n        raise SaltCloudSystemExit(\n            'The list_nodes_min function must be called with -f or --function.'\n        )\n\n    ret = {}\n    location = get_location()\n    params = {\n        'Action': 'DescribeInstanceStatus',\n        'RegionId': location,\n    }\n    nodes = query(params)\n\n    log.debug(\n        'Total %s instance found in Region %s',\n        nodes['TotalCount'], location\n    )\n    if 'Code' in nodes or nodes['TotalCount'] == 0:\n        return ret\n\n    for node in nodes['InstanceStatuses']['InstanceStatus']:\n        ret[node['InstanceId']] = {}\n        for item in node:\n            ret[node['InstanceId']][item] = node[item]\n\n    return ret", "code_tokens": ["def", "list_nodes_min", "(", "call", "=", "None", ")", ":", "if", "call", "==", "'action'", ":", "raise", "SaltCloudSystemExit", "(", "'The list_nodes_min function must be called with -f or --function.'", ")", "ret", "=", "{", "}", "location", "=", "get_location", "(", ")", "params", "=", "{", "'Action'", ":", "'DescribeInstanceStatus'", ",", "'RegionId'", ":", "location", ",", "}", "nodes", "=", "query", "(", "params", ")", "log", ".", "debug", "(", "'Total %s instance found in Region %s'", ",", "nodes", "[", "'TotalCount'", "]", ",", "location", ")", "if", "'Code'", "in", "nodes", "or", "nodes", "[", "'TotalCount'", "]", "==", "0", ":", "return", "ret", "for", "node", "in", "nodes", "[", "'InstanceStatuses'", "]", "[", "'InstanceStatus'", "]", ":", "ret", "[", "node", "[", "'InstanceId'", "]", "]", "=", "{", "}", "for", "item", "in", "node", ":", "ret", "[", "node", "[", "'InstanceId'", "]", "]", "[", "item", "]", "=", "node", "[", "item", "]", "return", "ret"], "docstring": "Return a list of the VMs that are on the provider. Only a list of VM names,\n    and their state, is returned. This is the minimum amount of information\n    needed to check for existing VMs.", "docstring_tokens": ["Return", "a", "list", "of", "the", "VMs", "that", "are", "on", "the", "provider", ".", "Only", "a", "list", "of", "VM", "names", "and", "their", "state", "is", "returned", ".", "This", "is", "the", "minimum", "amount", "of", "information", "needed", "to", "check", "for", "existing", "VMs", "."], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/cloud/clouds/aliyun.py#L241-L272", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/cloud/clouds/aliyun.py", "func_name": "list_nodes", "original_string": "def list_nodes(call=None):\n    '''\n    Return a list of the VMs that are on the provider\n    '''\n    if call == 'action':\n        raise SaltCloudSystemExit(\n            'The list_nodes function must be called with -f or --function.'\n        )\n\n    nodes = list_nodes_full()\n    ret = {}\n    for instanceId in nodes:\n        node = nodes[instanceId]\n        ret[node['name']] = {\n            'id': node['id'],\n            'name': node['name'],\n            'public_ips': node['public_ips'],\n            'private_ips': node['private_ips'],\n            'size': node['size'],\n            'state': six.text_type(node['state']),\n        }\n    return ret", "language": "python", "code": "def list_nodes(call=None):\n    '''\n    Return a list of the VMs that are on the provider\n    '''\n    if call == 'action':\n        raise SaltCloudSystemExit(\n            'The list_nodes function must be called with -f or --function.'\n        )\n\n    nodes = list_nodes_full()\n    ret = {}\n    for instanceId in nodes:\n        node = nodes[instanceId]\n        ret[node['name']] = {\n            'id': node['id'],\n            'name': node['name'],\n            'public_ips': node['public_ips'],\n            'private_ips': node['private_ips'],\n            'size': node['size'],\n            'state': six.text_type(node['state']),\n        }\n    return ret", "code_tokens": ["def", "list_nodes", "(", "call", "=", "None", ")", ":", "if", "call", "==", "'action'", ":", "raise", "SaltCloudSystemExit", "(", "'The list_nodes function must be called with -f or --function.'", ")", "nodes", "=", "list_nodes_full", "(", ")", "ret", "=", "{", "}", "for", "instanceId", "in", "nodes", ":", "node", "=", "nodes", "[", "instanceId", "]", "ret", "[", "node", "[", "'name'", "]", "]", "=", "{", "'id'", ":", "node", "[", "'id'", "]", ",", "'name'", ":", "node", "[", "'name'", "]", ",", "'public_ips'", ":", "node", "[", "'public_ips'", "]", ",", "'private_ips'", ":", "node", "[", "'private_ips'", "]", ",", "'size'", ":", "node", "[", "'size'", "]", ",", "'state'", ":", "six", ".", "text_type", "(", "node", "[", "'state'", "]", ")", ",", "}", "return", "ret"], "docstring": "Return a list of the VMs that are on the provider", "docstring_tokens": ["Return", "a", "list", "of", "the", "VMs", "that", "are", "on", "the", "provider"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/cloud/clouds/aliyun.py#L275-L296", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/cloud/clouds/aliyun.py", "func_name": "list_nodes_full", "original_string": "def list_nodes_full(call=None):\n    '''\n    Return a list of the VMs that are on the provider\n    '''\n    if call == 'action':\n        raise SaltCloudSystemExit(\n            'The list_nodes_full function must be called with -f '\n            'or --function.'\n        )\n\n    ret = {}\n    location = get_location()\n    params = {\n        'Action': 'DescribeInstanceStatus',\n        'RegionId': location,\n        'PageSize': '50'\n    }\n    result = query(params=params)\n\n    log.debug(\n        'Total %s instance found in Region %s',\n        result['TotalCount'], location\n    )\n    if 'Code' in result or result['TotalCount'] == 0:\n        return ret\n\n    # aliyun max 100 top instance in api\n    result_instancestatus = result['InstanceStatuses']['InstanceStatus']\n    if result['TotalCount'] > 50:\n        params['PageNumber'] = '2'\n        result = query(params=params)\n        result_instancestatus.update(result['InstanceStatuses']['InstanceStatus'])\n\n    for node in result_instancestatus:\n\n        instanceId = node.get('InstanceId', '')\n\n        params = {\n            'Action': 'DescribeInstanceAttribute',\n            'InstanceId': instanceId\n        }\n        items = query(params=params)\n        if 'Code' in items:\n            log.warning('Query instance:%s attribute failed', instanceId)\n            continue\n\n        name = items['InstanceName']\n        ret[name] = {\n            'id': items['InstanceId'],\n            'name': name,\n            'image': items['ImageId'],\n            'size': 'TODO',\n            'state': items['Status']\n        }\n        for item in items:\n            value = items[item]\n            if value is not None:\n                value = six.text_type(value)\n            if item == \"PublicIpAddress\":\n                ret[name]['public_ips'] = items[item]['IpAddress']\n            if item == \"InnerIpAddress\" and 'private_ips' not in ret[name]:\n                ret[name]['private_ips'] = items[item]['IpAddress']\n            if item == 'VpcAttributes':\n                vpc_ips = items[item]['PrivateIpAddress']['IpAddress']\n                if vpc_ips:\n                    ret[name]['private_ips'] = vpc_ips\n            ret[name][item] = value\n\n    provider = __active_provider_name__ or 'aliyun'\n    if ':' in provider:\n        comps = provider.split(':')\n        provider = comps[0]\n\n    __opts__['update_cachedir'] = True\n    __utils__['cloud.cache_node_list'](ret, provider, __opts__)\n\n    return ret", "language": "python", "code": "def list_nodes_full(call=None):\n    '''\n    Return a list of the VMs that are on the provider\n    '''\n    if call == 'action':\n        raise SaltCloudSystemExit(\n            'The list_nodes_full function must be called with -f '\n            'or --function.'\n        )\n\n    ret = {}\n    location = get_location()\n    params = {\n        'Action': 'DescribeInstanceStatus',\n        'RegionId': location,\n        'PageSize': '50'\n    }\n    result = query(params=params)\n\n    log.debug(\n        'Total %s instance found in Region %s',\n        result['TotalCount'], location\n    )\n    if 'Code' in result or result['TotalCount'] == 0:\n        return ret\n\n    # aliyun max 100 top instance in api\n    result_instancestatus = result['InstanceStatuses']['InstanceStatus']\n    if result['TotalCount'] > 50:\n        params['PageNumber'] = '2'\n        result = query(params=params)\n        result_instancestatus.update(result['InstanceStatuses']['InstanceStatus'])\n\n    for node in result_instancestatus:\n\n        instanceId = node.get('InstanceId', '')\n\n        params = {\n            'Action': 'DescribeInstanceAttribute',\n            'InstanceId': instanceId\n        }\n        items = query(params=params)\n        if 'Code' in items:\n            log.warning('Query instance:%s attribute failed', instanceId)\n            continue\n\n        name = items['InstanceName']\n        ret[name] = {\n            'id': items['InstanceId'],\n            'name': name,\n            'image': items['ImageId'],\n            'size': 'TODO',\n            'state': items['Status']\n        }\n        for item in items:\n            value = items[item]\n            if value is not None:\n                value = six.text_type(value)\n            if item == \"PublicIpAddress\":\n                ret[name]['public_ips'] = items[item]['IpAddress']\n            if item == \"InnerIpAddress\" and 'private_ips' not in ret[name]:\n                ret[name]['private_ips'] = items[item]['IpAddress']\n            if item == 'VpcAttributes':\n                vpc_ips = items[item]['PrivateIpAddress']['IpAddress']\n                if vpc_ips:\n                    ret[name]['private_ips'] = vpc_ips\n            ret[name][item] = value\n\n    provider = __active_provider_name__ or 'aliyun'\n    if ':' in provider:\n        comps = provider.split(':')\n        provider = comps[0]\n\n    __opts__['update_cachedir'] = True\n    __utils__['cloud.cache_node_list'](ret, provider, __opts__)\n\n    return ret", "code_tokens": ["def", "list_nodes_full", "(", "call", "=", "None", ")", ":", "if", "call", "==", "'action'", ":", "raise", "SaltCloudSystemExit", "(", "'The list_nodes_full function must be called with -f '", "'or --function.'", ")", "ret", "=", "{", "}", "location", "=", "get_location", "(", ")", "params", "=", "{", "'Action'", ":", "'DescribeInstanceStatus'", ",", "'RegionId'", ":", "location", ",", "'PageSize'", ":", "'50'", "}", "result", "=", "query", "(", "params", "=", "params", ")", "log", ".", "debug", "(", "'Total %s instance found in Region %s'", ",", "result", "[", "'TotalCount'", "]", ",", "location", ")", "if", "'Code'", "in", "result", "or", "result", "[", "'TotalCount'", "]", "==", "0", ":", "return", "ret", "# aliyun max 100 top instance in api", "result_instancestatus", "=", "result", "[", "'InstanceStatuses'", "]", "[", "'InstanceStatus'", "]", "if", "result", "[", "'TotalCount'", "]", ">", "50", ":", "params", "[", "'PageNumber'", "]", "=", "'2'", "result", "=", "query", "(", "params", "=", "params", ")", "result_instancestatus", ".", "update", "(", "result", "[", "'InstanceStatuses'", "]", "[", "'InstanceStatus'", "]", ")", "for", "node", "in", "result_instancestatus", ":", "instanceId", "=", "node", ".", "get", "(", "'InstanceId'", ",", "''", ")", "params", "=", "{", "'Action'", ":", "'DescribeInstanceAttribute'", ",", "'InstanceId'", ":", "instanceId", "}", "items", "=", "query", "(", "params", "=", "params", ")", "if", "'Code'", "in", "items", ":", "log", ".", "warning", "(", "'Query instance:%s attribute failed'", ",", "instanceId", ")", "continue", "name", "=", "items", "[", "'InstanceName'", "]", "ret", "[", "name", "]", "=", "{", "'id'", ":", "items", "[", "'InstanceId'", "]", ",", "'name'", ":", "name", ",", "'image'", ":", "items", "[", "'ImageId'", "]", ",", "'size'", ":", "'TODO'", ",", "'state'", ":", "items", "[", "'Status'", "]", "}", "for", "item", "in", "items", ":", "value", "=", "items", "[", "item", "]", "if", "value", "is", "not", "None", ":", "value", "=", "six", ".", "text_type", "(", "value", ")", "if", "item", "==", "\"PublicIpAddress\"", ":", "ret", "[", "name", "]", "[", "'public_ips'", "]", "=", "items", "[", "item", "]", "[", "'IpAddress'", "]", "if", "item", "==", "\"InnerIpAddress\"", "and", "'private_ips'", "not", "in", "ret", "[", "name", "]", ":", "ret", "[", "name", "]", "[", "'private_ips'", "]", "=", "items", "[", "item", "]", "[", "'IpAddress'", "]", "if", "item", "==", "'VpcAttributes'", ":", "vpc_ips", "=", "items", "[", "item", "]", "[", "'PrivateIpAddress'", "]", "[", "'IpAddress'", "]", "if", "vpc_ips", ":", "ret", "[", "name", "]", "[", "'private_ips'", "]", "=", "vpc_ips", "ret", "[", "name", "]", "[", "item", "]", "=", "value", "provider", "=", "__active_provider_name__", "or", "'aliyun'", "if", "':'", "in", "provider", ":", "comps", "=", "provider", ".", "split", "(", "':'", ")", "provider", "=", "comps", "[", "0", "]", "__opts__", "[", "'update_cachedir'", "]", "=", "True", "__utils__", "[", "'cloud.cache_node_list'", "]", "(", "ret", ",", "provider", ",", "__opts__", ")", "return", "ret"], "docstring": "Return a list of the VMs that are on the provider", "docstring_tokens": ["Return", "a", "list", "of", "the", "VMs", "that", "are", "on", "the", "provider"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/cloud/clouds/aliyun.py#L299-L375", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/cloud/clouds/aliyun.py", "func_name": "list_securitygroup", "original_string": "def list_securitygroup(call=None):\n    '''\n    Return a list of security group\n    '''\n    if call == 'action':\n        raise SaltCloudSystemExit(\n            'The list_nodes function must be called with -f or --function.'\n        )\n\n    params = {\n        'Action': 'DescribeSecurityGroups',\n        'RegionId': get_location(),\n        'PageSize': '50',\n    }\n\n    result = query(params)\n    if 'Code' in result:\n        return {}\n\n    ret = {}\n    for sg in result['SecurityGroups']['SecurityGroup']:\n        ret[sg['SecurityGroupId']] = {}\n        for item in sg:\n            ret[sg['SecurityGroupId']][item] = sg[item]\n\n    return ret", "language": "python", "code": "def list_securitygroup(call=None):\n    '''\n    Return a list of security group\n    '''\n    if call == 'action':\n        raise SaltCloudSystemExit(\n            'The list_nodes function must be called with -f or --function.'\n        )\n\n    params = {\n        'Action': 'DescribeSecurityGroups',\n        'RegionId': get_location(),\n        'PageSize': '50',\n    }\n\n    result = query(params)\n    if 'Code' in result:\n        return {}\n\n    ret = {}\n    for sg in result['SecurityGroups']['SecurityGroup']:\n        ret[sg['SecurityGroupId']] = {}\n        for item in sg:\n            ret[sg['SecurityGroupId']][item] = sg[item]\n\n    return ret", "code_tokens": ["def", "list_securitygroup", "(", "call", "=", "None", ")", ":", "if", "call", "==", "'action'", ":", "raise", "SaltCloudSystemExit", "(", "'The list_nodes function must be called with -f or --function.'", ")", "params", "=", "{", "'Action'", ":", "'DescribeSecurityGroups'", ",", "'RegionId'", ":", "get_location", "(", ")", ",", "'PageSize'", ":", "'50'", ",", "}", "result", "=", "query", "(", "params", ")", "if", "'Code'", "in", "result", ":", "return", "{", "}", "ret", "=", "{", "}", "for", "sg", "in", "result", "[", "'SecurityGroups'", "]", "[", "'SecurityGroup'", "]", ":", "ret", "[", "sg", "[", "'SecurityGroupId'", "]", "]", "=", "{", "}", "for", "item", "in", "sg", ":", "ret", "[", "sg", "[", "'SecurityGroupId'", "]", "]", "[", "item", "]", "=", "sg", "[", "item", "]", "return", "ret"], "docstring": "Return a list of security group", "docstring_tokens": ["Return", "a", "list", "of", "security", "group"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/cloud/clouds/aliyun.py#L387-L412", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/cloud/clouds/aliyun.py", "func_name": "get_image", "original_string": "def get_image(vm_):\n    '''\n    Return the image object to use\n    '''\n    images = avail_images()\n    vm_image = six.text_type(config.get_cloud_config_value(\n        'image', vm_, __opts__, search_global=False\n    ))\n\n    if not vm_image:\n        raise SaltCloudNotFound('No image specified for this VM.')\n\n    if vm_image and six.text_type(vm_image) in images:\n        return images[vm_image]['ImageId']\n    raise SaltCloudNotFound(\n        'The specified image, \\'{0}\\', could not be found.'.format(vm_image)\n    )", "language": "python", "code": "def get_image(vm_):\n    '''\n    Return the image object to use\n    '''\n    images = avail_images()\n    vm_image = six.text_type(config.get_cloud_config_value(\n        'image', vm_, __opts__, search_global=False\n    ))\n\n    if not vm_image:\n        raise SaltCloudNotFound('No image specified for this VM.')\n\n    if vm_image and six.text_type(vm_image) in images:\n        return images[vm_image]['ImageId']\n    raise SaltCloudNotFound(\n        'The specified image, \\'{0}\\', could not be found.'.format(vm_image)\n    )", "code_tokens": ["def", "get_image", "(", "vm_", ")", ":", "images", "=", "avail_images", "(", ")", "vm_image", "=", "six", ".", "text_type", "(", "config", ".", "get_cloud_config_value", "(", "'image'", ",", "vm_", ",", "__opts__", ",", "search_global", "=", "False", ")", ")", "if", "not", "vm_image", ":", "raise", "SaltCloudNotFound", "(", "'No image specified for this VM.'", ")", "if", "vm_image", "and", "six", ".", "text_type", "(", "vm_image", ")", "in", "images", ":", "return", "images", "[", "vm_image", "]", "[", "'ImageId'", "]", "raise", "SaltCloudNotFound", "(", "'The specified image, \\'{0}\\', could not be found.'", ".", "format", "(", "vm_image", ")", ")"], "docstring": "Return the image object to use", "docstring_tokens": ["Return", "the", "image", "object", "to", "use"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/cloud/clouds/aliyun.py#L415-L431", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/cloud/clouds/aliyun.py", "func_name": "get_securitygroup", "original_string": "def get_securitygroup(vm_):\n    '''\n    Return the security group\n    '''\n    sgs = list_securitygroup()\n    securitygroup = config.get_cloud_config_value(\n        'securitygroup', vm_, __opts__, search_global=False\n    )\n\n    if not securitygroup:\n        raise SaltCloudNotFound('No securitygroup ID specified for this VM.')\n\n    if securitygroup and six.text_type(securitygroup) in sgs:\n        return sgs[securitygroup]['SecurityGroupId']\n    raise SaltCloudNotFound(\n        'The specified security group, \\'{0}\\', could not be found.'.format(\n            securitygroup)\n    )", "language": "python", "code": "def get_securitygroup(vm_):\n    '''\n    Return the security group\n    '''\n    sgs = list_securitygroup()\n    securitygroup = config.get_cloud_config_value(\n        'securitygroup', vm_, __opts__, search_global=False\n    )\n\n    if not securitygroup:\n        raise SaltCloudNotFound('No securitygroup ID specified for this VM.')\n\n    if securitygroup and six.text_type(securitygroup) in sgs:\n        return sgs[securitygroup]['SecurityGroupId']\n    raise SaltCloudNotFound(\n        'The specified security group, \\'{0}\\', could not be found.'.format(\n            securitygroup)\n    )", "code_tokens": ["def", "get_securitygroup", "(", "vm_", ")", ":", "sgs", "=", "list_securitygroup", "(", ")", "securitygroup", "=", "config", ".", "get_cloud_config_value", "(", "'securitygroup'", ",", "vm_", ",", "__opts__", ",", "search_global", "=", "False", ")", "if", "not", "securitygroup", ":", "raise", "SaltCloudNotFound", "(", "'No securitygroup ID specified for this VM.'", ")", "if", "securitygroup", "and", "six", ".", "text_type", "(", "securitygroup", ")", "in", "sgs", ":", "return", "sgs", "[", "securitygroup", "]", "[", "'SecurityGroupId'", "]", "raise", "SaltCloudNotFound", "(", "'The specified security group, \\'{0}\\', could not be found.'", ".", "format", "(", "securitygroup", ")", ")"], "docstring": "Return the security group", "docstring_tokens": ["Return", "the", "security", "group"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/cloud/clouds/aliyun.py#L434-L451", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/cloud/clouds/aliyun.py", "func_name": "get_size", "original_string": "def get_size(vm_):\n    '''\n    Return the VM's size. Used by create_node().\n    '''\n    sizes = avail_sizes()\n    vm_size = six.text_type(config.get_cloud_config_value(\n        'size', vm_, __opts__, search_global=False\n    ))\n\n    if not vm_size:\n        raise SaltCloudNotFound('No size specified for this VM.')\n\n    if vm_size and six.text_type(vm_size) in sizes:\n        return sizes[vm_size]['InstanceTypeId']\n\n    raise SaltCloudNotFound(\n        'The specified size, \\'{0}\\', could not be found.'.format(vm_size)\n    )", "language": "python", "code": "def get_size(vm_):\n    '''\n    Return the VM's size. Used by create_node().\n    '''\n    sizes = avail_sizes()\n    vm_size = six.text_type(config.get_cloud_config_value(\n        'size', vm_, __opts__, search_global=False\n    ))\n\n    if not vm_size:\n        raise SaltCloudNotFound('No size specified for this VM.')\n\n    if vm_size and six.text_type(vm_size) in sizes:\n        return sizes[vm_size]['InstanceTypeId']\n\n    raise SaltCloudNotFound(\n        'The specified size, \\'{0}\\', could not be found.'.format(vm_size)\n    )", "code_tokens": ["def", "get_size", "(", "vm_", ")", ":", "sizes", "=", "avail_sizes", "(", ")", "vm_size", "=", "six", ".", "text_type", "(", "config", ".", "get_cloud_config_value", "(", "'size'", ",", "vm_", ",", "__opts__", ",", "search_global", "=", "False", ")", ")", "if", "not", "vm_size", ":", "raise", "SaltCloudNotFound", "(", "'No size specified for this VM.'", ")", "if", "vm_size", "and", "six", ".", "text_type", "(", "vm_size", ")", "in", "sizes", ":", "return", "sizes", "[", "vm_size", "]", "[", "'InstanceTypeId'", "]", "raise", "SaltCloudNotFound", "(", "'The specified size, \\'{0}\\', could not be found.'", ".", "format", "(", "vm_size", ")", ")"], "docstring": "Return the VM's size. Used by create_node().", "docstring_tokens": ["Return", "the", "VM", "s", "size", ".", "Used", "by", "create_node", "()", "."], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/cloud/clouds/aliyun.py#L454-L471", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/cloud/clouds/aliyun.py", "func_name": "__get_location", "original_string": "def __get_location(vm_):\n    '''\n    Return the VM's location\n    '''\n    locations = avail_locations()\n    vm_location = six.text_type(config.get_cloud_config_value(\n        'location', vm_, __opts__, search_global=False\n    ))\n\n    if not vm_location:\n        raise SaltCloudNotFound('No location specified for this VM.')\n\n    if vm_location and six.text_type(vm_location) in locations:\n        return locations[vm_location]['RegionId']\n    raise SaltCloudNotFound(\n        'The specified location, \\'{0}\\', could not be found.'.format(\n            vm_location\n        )\n    )", "language": "python", "code": "def __get_location(vm_):\n    '''\n    Return the VM's location\n    '''\n    locations = avail_locations()\n    vm_location = six.text_type(config.get_cloud_config_value(\n        'location', vm_, __opts__, search_global=False\n    ))\n\n    if not vm_location:\n        raise SaltCloudNotFound('No location specified for this VM.')\n\n    if vm_location and six.text_type(vm_location) in locations:\n        return locations[vm_location]['RegionId']\n    raise SaltCloudNotFound(\n        'The specified location, \\'{0}\\', could not be found.'.format(\n            vm_location\n        )\n    )", "code_tokens": ["def", "__get_location", "(", "vm_", ")", ":", "locations", "=", "avail_locations", "(", ")", "vm_location", "=", "six", ".", "text_type", "(", "config", ".", "get_cloud_config_value", "(", "'location'", ",", "vm_", ",", "__opts__", ",", "search_global", "=", "False", ")", ")", "if", "not", "vm_location", ":", "raise", "SaltCloudNotFound", "(", "'No location specified for this VM.'", ")", "if", "vm_location", "and", "six", ".", "text_type", "(", "vm_location", ")", "in", "locations", ":", "return", "locations", "[", "vm_location", "]", "[", "'RegionId'", "]", "raise", "SaltCloudNotFound", "(", "'The specified location, \\'{0}\\', could not be found.'", ".", "format", "(", "vm_location", ")", ")"], "docstring": "Return the VM's location", "docstring_tokens": ["Return", "the", "VM", "s", "location"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/cloud/clouds/aliyun.py#L474-L492", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/cloud/clouds/aliyun.py", "func_name": "start", "original_string": "def start(name, call=None):\n    '''\n    Start a node\n\n    CLI Examples:\n\n    .. code-block:: bash\n\n        salt-cloud -a start myinstance\n    '''\n    if call != 'action':\n        raise SaltCloudSystemExit(\n            'The stop action must be called with -a or --action.'\n        )\n\n    log.info('Starting node %s', name)\n\n    instanceId = _get_node(name)['InstanceId']\n\n    params = {'Action': 'StartInstance',\n              'InstanceId': instanceId}\n    result = query(params)\n\n    return result", "language": "python", "code": "def start(name, call=None):\n    '''\n    Start a node\n\n    CLI Examples:\n\n    .. code-block:: bash\n\n        salt-cloud -a start myinstance\n    '''\n    if call != 'action':\n        raise SaltCloudSystemExit(\n            'The stop action must be called with -a or --action.'\n        )\n\n    log.info('Starting node %s', name)\n\n    instanceId = _get_node(name)['InstanceId']\n\n    params = {'Action': 'StartInstance',\n              'InstanceId': instanceId}\n    result = query(params)\n\n    return result", "code_tokens": ["def", "start", "(", "name", ",", "call", "=", "None", ")", ":", "if", "call", "!=", "'action'", ":", "raise", "SaltCloudSystemExit", "(", "'The stop action must be called with -a or --action.'", ")", "log", ".", "info", "(", "'Starting node %s'", ",", "name", ")", "instanceId", "=", "_get_node", "(", "name", ")", "[", "'InstanceId'", "]", "params", "=", "{", "'Action'", ":", "'StartInstance'", ",", "'InstanceId'", ":", "instanceId", "}", "result", "=", "query", "(", "params", ")", "return", "result"], "docstring": "Start a node\n\n    CLI Examples:\n\n    .. code-block:: bash\n\n        salt-cloud -a start myinstance", "docstring_tokens": ["Start", "a", "node"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/cloud/clouds/aliyun.py#L495-L518", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/cloud/clouds/aliyun.py", "func_name": "stop", "original_string": "def stop(name, force=False, call=None):\n    '''\n    Stop a node\n\n    CLI Examples:\n\n    .. code-block:: bash\n\n        salt-cloud -a stop myinstance\n        salt-cloud -a stop myinstance force=True\n    '''\n    if call != 'action':\n        raise SaltCloudSystemExit(\n            'The stop action must be called with -a or --action.'\n        )\n\n    log.info('Stopping node %s', name)\n\n    instanceId = _get_node(name)['InstanceId']\n\n    params = {\n        'Action': 'StopInstance',\n        'InstanceId': instanceId,\n        'ForceStop': six.text_type(force).lower()\n    }\n    result = query(params)\n\n    return result", "language": "python", "code": "def stop(name, force=False, call=None):\n    '''\n    Stop a node\n\n    CLI Examples:\n\n    .. code-block:: bash\n\n        salt-cloud -a stop myinstance\n        salt-cloud -a stop myinstance force=True\n    '''\n    if call != 'action':\n        raise SaltCloudSystemExit(\n            'The stop action must be called with -a or --action.'\n        )\n\n    log.info('Stopping node %s', name)\n\n    instanceId = _get_node(name)['InstanceId']\n\n    params = {\n        'Action': 'StopInstance',\n        'InstanceId': instanceId,\n        'ForceStop': six.text_type(force).lower()\n    }\n    result = query(params)\n\n    return result", "code_tokens": ["def", "stop", "(", "name", ",", "force", "=", "False", ",", "call", "=", "None", ")", ":", "if", "call", "!=", "'action'", ":", "raise", "SaltCloudSystemExit", "(", "'The stop action must be called with -a or --action.'", ")", "log", ".", "info", "(", "'Stopping node %s'", ",", "name", ")", "instanceId", "=", "_get_node", "(", "name", ")", "[", "'InstanceId'", "]", "params", "=", "{", "'Action'", ":", "'StopInstance'", ",", "'InstanceId'", ":", "instanceId", ",", "'ForceStop'", ":", "six", ".", "text_type", "(", "force", ")", ".", "lower", "(", ")", "}", "result", "=", "query", "(", "params", ")", "return", "result"], "docstring": "Stop a node\n\n    CLI Examples:\n\n    .. code-block:: bash\n\n        salt-cloud -a stop myinstance\n        salt-cloud -a stop myinstance force=True", "docstring_tokens": ["Stop", "a", "node"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/cloud/clouds/aliyun.py#L521-L548", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/cloud/clouds/aliyun.py", "func_name": "reboot", "original_string": "def reboot(name, call=None):\n    '''\n    Reboot a node\n\n    CLI Examples:\n\n    .. code-block:: bash\n\n        salt-cloud -a reboot myinstance\n    '''\n    if call != 'action':\n        raise SaltCloudSystemExit(\n            'The stop action must be called with -a or --action.'\n        )\n\n    log.info('Rebooting node %s', name)\n\n    instance_id = _get_node(name)['InstanceId']\n\n    params = {'Action': 'RebootInstance',\n              'InstanceId': instance_id}\n    result = query(params)\n\n    return result", "language": "python", "code": "def reboot(name, call=None):\n    '''\n    Reboot a node\n\n    CLI Examples:\n\n    .. code-block:: bash\n\n        salt-cloud -a reboot myinstance\n    '''\n    if call != 'action':\n        raise SaltCloudSystemExit(\n            'The stop action must be called with -a or --action.'\n        )\n\n    log.info('Rebooting node %s', name)\n\n    instance_id = _get_node(name)['InstanceId']\n\n    params = {'Action': 'RebootInstance',\n              'InstanceId': instance_id}\n    result = query(params)\n\n    return result", "code_tokens": ["def", "reboot", "(", "name", ",", "call", "=", "None", ")", ":", "if", "call", "!=", "'action'", ":", "raise", "SaltCloudSystemExit", "(", "'The stop action must be called with -a or --action.'", ")", "log", ".", "info", "(", "'Rebooting node %s'", ",", "name", ")", "instance_id", "=", "_get_node", "(", "name", ")", "[", "'InstanceId'", "]", "params", "=", "{", "'Action'", ":", "'RebootInstance'", ",", "'InstanceId'", ":", "instance_id", "}", "result", "=", "query", "(", "params", ")", "return", "result"], "docstring": "Reboot a node\n\n    CLI Examples:\n\n    .. code-block:: bash\n\n        salt-cloud -a reboot myinstance", "docstring_tokens": ["Reboot", "a", "node"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/cloud/clouds/aliyun.py#L551-L574", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/cloud/clouds/aliyun.py", "func_name": "create_node", "original_string": "def create_node(kwargs):\n    '''\n    Convenience function to make the rest api call for node creation.\n    '''\n    if not isinstance(kwargs, dict):\n        kwargs = {}\n\n    # Required parameters\n    params = {\n        'Action': 'CreateInstance',\n        'InstanceType': kwargs.get('size_id', ''),\n        'RegionId': kwargs.get('region_id', DEFAULT_LOCATION),\n        'ImageId': kwargs.get('image_id', ''),\n        'SecurityGroupId': kwargs.get('securitygroup_id', ''),\n        'InstanceName': kwargs.get('name', ''),\n    }\n\n    # Optional parameters'\n    optional = [\n        'InstanceName', 'InternetChargeType',\n        'InternetMaxBandwidthIn', 'InternetMaxBandwidthOut',\n        'HostName', 'Password', 'SystemDisk.Category', 'VSwitchId'\n        # 'DataDisk.n.Size', 'DataDisk.n.Category', 'DataDisk.n.SnapshotId'\n    ]\n\n    for item in optional:\n        if item in kwargs:\n            params.update({item: kwargs[item]})\n\n    # invoke web call\n    result = query(params)\n    return result['InstanceId']", "language": "python", "code": "def create_node(kwargs):\n    '''\n    Convenience function to make the rest api call for node creation.\n    '''\n    if not isinstance(kwargs, dict):\n        kwargs = {}\n\n    # Required parameters\n    params = {\n        'Action': 'CreateInstance',\n        'InstanceType': kwargs.get('size_id', ''),\n        'RegionId': kwargs.get('region_id', DEFAULT_LOCATION),\n        'ImageId': kwargs.get('image_id', ''),\n        'SecurityGroupId': kwargs.get('securitygroup_id', ''),\n        'InstanceName': kwargs.get('name', ''),\n    }\n\n    # Optional parameters'\n    optional = [\n        'InstanceName', 'InternetChargeType',\n        'InternetMaxBandwidthIn', 'InternetMaxBandwidthOut',\n        'HostName', 'Password', 'SystemDisk.Category', 'VSwitchId'\n        # 'DataDisk.n.Size', 'DataDisk.n.Category', 'DataDisk.n.SnapshotId'\n    ]\n\n    for item in optional:\n        if item in kwargs:\n            params.update({item: kwargs[item]})\n\n    # invoke web call\n    result = query(params)\n    return result['InstanceId']", "code_tokens": ["def", "create_node", "(", "kwargs", ")", ":", "if", "not", "isinstance", "(", "kwargs", ",", "dict", ")", ":", "kwargs", "=", "{", "}", "# Required parameters", "params", "=", "{", "'Action'", ":", "'CreateInstance'", ",", "'InstanceType'", ":", "kwargs", ".", "get", "(", "'size_id'", ",", "''", ")", ",", "'RegionId'", ":", "kwargs", ".", "get", "(", "'region_id'", ",", "DEFAULT_LOCATION", ")", ",", "'ImageId'", ":", "kwargs", ".", "get", "(", "'image_id'", ",", "''", ")", ",", "'SecurityGroupId'", ":", "kwargs", ".", "get", "(", "'securitygroup_id'", ",", "''", ")", ",", "'InstanceName'", ":", "kwargs", ".", "get", "(", "'name'", ",", "''", ")", ",", "}", "# Optional parameters'", "optional", "=", "[", "'InstanceName'", ",", "'InternetChargeType'", ",", "'InternetMaxBandwidthIn'", ",", "'InternetMaxBandwidthOut'", ",", "'HostName'", ",", "'Password'", ",", "'SystemDisk.Category'", ",", "'VSwitchId'", "# 'DataDisk.n.Size', 'DataDisk.n.Category', 'DataDisk.n.SnapshotId'", "]", "for", "item", "in", "optional", ":", "if", "item", "in", "kwargs", ":", "params", ".", "update", "(", "{", "item", ":", "kwargs", "[", "item", "]", "}", ")", "# invoke web call", "result", "=", "query", "(", "params", ")", "return", "result", "[", "'InstanceId'", "]"], "docstring": "Convenience function to make the rest api call for node creation.", "docstring_tokens": ["Convenience", "function", "to", "make", "the", "rest", "api", "call", "for", "node", "creation", "."], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/cloud/clouds/aliyun.py#L577-L608", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/cloud/clouds/aliyun.py", "func_name": "create", "original_string": "def create(vm_):\n    '''\n    Create a single VM from a data dict\n    '''\n    try:\n        # Check for required profile parameters before sending any API calls.\n        if vm_['profile'] and config.is_profile_configured(__opts__,\n                                                           __active_provider_name__ or 'aliyun',\n                                                           vm_['profile'],\n                                                           vm_=vm_) is False:\n            return False\n    except AttributeError:\n        pass\n\n    __utils__['cloud.fire_event'](\n        'event',\n        'starting create',\n        'salt/cloud/{0}/creating'.format(vm_['name']),\n        args=__utils__['cloud.filter_event']('creating', vm_, ['name', 'profile', 'provider', 'driver']),\n        sock_dir=__opts__['sock_dir'],\n        transport=__opts__['transport']\n    )\n\n    log.info('Creating Cloud VM %s', vm_['name'])\n    kwargs = {\n        'name': vm_['name'],\n        'size_id': get_size(vm_),\n        'image_id': get_image(vm_),\n        'region_id': __get_location(vm_),\n        'securitygroup_id': get_securitygroup(vm_),\n    }\n    if 'vswitch_id' in vm_:\n        kwargs['VSwitchId'] = vm_['vswitch_id']\n    if 'internet_chargetype' in vm_:\n        kwargs['InternetChargeType'] = vm_['internet_chargetype']\n    if 'internet_maxbandwidthin' in vm_:\n        kwargs['InternetMaxBandwidthIn'] = six.text_type(vm_['internet_maxbandwidthin'])\n    if 'internet_maxbandwidthout' in vm_:\n        kwargs['InternetMaxBandwidthOut'] = six.text_type(vm_['internet_maxbandwidthOut'])\n    if 'hostname' in vm_:\n        kwargs['HostName'] = vm_['hostname']\n    if 'password' in vm_:\n        kwargs['Password'] = vm_['password']\n    if 'instance_name' in vm_:\n        kwargs['InstanceName'] = vm_['instance_name']\n    if 'systemdisk_category' in vm_:\n        kwargs['SystemDisk.Category'] = vm_['systemdisk_category']\n\n    __utils__['cloud.fire_event'](\n        'event',\n        'requesting instance',\n        'salt/cloud/{0}/requesting'.format(vm_['name']),\n        args=__utils__['cloud.filter_event']('requesting', kwargs, list(kwargs)),\n        sock_dir=__opts__['sock_dir'],\n        transport=__opts__['transport']\n    )\n\n    try:\n        ret = create_node(kwargs)\n    except Exception as exc:\n        log.error(\n            'Error creating %s on Aliyun ECS\\n\\n'\n            'The following exception was thrown when trying to '\n            'run the initial deployment: %s',\n            vm_['name'], six.text_type(exc),\n            # Show the traceback if the debug logging level is enabled\n            exc_info_on_loglevel=logging.DEBUG\n        )\n        return False\n    # repair ip address error and start vm\n    time.sleep(8)\n    params = {'Action': 'StartInstance',\n              'InstanceId': ret}\n    query(params)\n\n    def __query_node_data(vm_name):\n        data = show_instance(vm_name, call='action')\n        if not data:\n            # Trigger an error in the wait_for_ip function\n            return False\n        if data.get('PublicIpAddress', None) is not None:\n            return data\n\n    try:\n        data = salt.utils.cloud.wait_for_ip(\n            __query_node_data,\n            update_args=(vm_['name'],),\n            timeout=config.get_cloud_config_value(\n                'wait_for_ip_timeout', vm_, __opts__, default=10 * 60),\n            interval=config.get_cloud_config_value(\n                'wait_for_ip_interval', vm_, __opts__, default=10),\n        )\n    except (SaltCloudExecutionTimeout, SaltCloudExecutionFailure) as exc:\n        try:\n            # It might be already up, let's destroy it!\n            destroy(vm_['name'])\n        except SaltCloudSystemExit:\n            pass\n        finally:\n            raise SaltCloudSystemExit(six.text_type(exc))\n\n    if data['public_ips']:\n        ssh_ip = data['public_ips'][0]\n    elif data['private_ips']:\n        ssh_ip = data['private_ips'][0]\n    else:\n        log.info('No available ip:cant connect to salt')\n        return False\n    log.debug('VM %s is now running', ssh_ip)\n    vm_['ssh_host'] = ssh_ip\n\n    # The instance is booted and accessible, let's Salt it!\n    ret = __utils__['cloud.bootstrap'](vm_, __opts__)\n    ret.update(data)\n\n    log.info('Created Cloud VM \\'%s\\'', vm_['name'])\n    log.debug(\n        '\\'%s\\' VM creation details:\\n%s',\n        vm_['name'], pprint.pformat(data)\n    )\n\n    __utils__['cloud.fire_event'](\n        'event',\n        'created instance',\n        'salt/cloud/{0}/created'.format(vm_['name']),\n        args=__utils__['cloud.filter_event']('created', vm_, ['name', 'profile', 'provider', 'driver']),\n        sock_dir=__opts__['sock_dir'],\n        transport=__opts__['transport']\n    )\n\n    return ret", "language": "python", "code": "def create(vm_):\n    '''\n    Create a single VM from a data dict\n    '''\n    try:\n        # Check for required profile parameters before sending any API calls.\n        if vm_['profile'] and config.is_profile_configured(__opts__,\n                                                           __active_provider_name__ or 'aliyun',\n                                                           vm_['profile'],\n                                                           vm_=vm_) is False:\n            return False\n    except AttributeError:\n        pass\n\n    __utils__['cloud.fire_event'](\n        'event',\n        'starting create',\n        'salt/cloud/{0}/creating'.format(vm_['name']),\n        args=__utils__['cloud.filter_event']('creating', vm_, ['name', 'profile', 'provider', 'driver']),\n        sock_dir=__opts__['sock_dir'],\n        transport=__opts__['transport']\n    )\n\n    log.info('Creating Cloud VM %s', vm_['name'])\n    kwargs = {\n        'name': vm_['name'],\n        'size_id': get_size(vm_),\n        'image_id': get_image(vm_),\n        'region_id': __get_location(vm_),\n        'securitygroup_id': get_securitygroup(vm_),\n    }\n    if 'vswitch_id' in vm_:\n        kwargs['VSwitchId'] = vm_['vswitch_id']\n    if 'internet_chargetype' in vm_:\n        kwargs['InternetChargeType'] = vm_['internet_chargetype']\n    if 'internet_maxbandwidthin' in vm_:\n        kwargs['InternetMaxBandwidthIn'] = six.text_type(vm_['internet_maxbandwidthin'])\n    if 'internet_maxbandwidthout' in vm_:\n        kwargs['InternetMaxBandwidthOut'] = six.text_type(vm_['internet_maxbandwidthOut'])\n    if 'hostname' in vm_:\n        kwargs['HostName'] = vm_['hostname']\n    if 'password' in vm_:\n        kwargs['Password'] = vm_['password']\n    if 'instance_name' in vm_:\n        kwargs['InstanceName'] = vm_['instance_name']\n    if 'systemdisk_category' in vm_:\n        kwargs['SystemDisk.Category'] = vm_['systemdisk_category']\n\n    __utils__['cloud.fire_event'](\n        'event',\n        'requesting instance',\n        'salt/cloud/{0}/requesting'.format(vm_['name']),\n        args=__utils__['cloud.filter_event']('requesting', kwargs, list(kwargs)),\n        sock_dir=__opts__['sock_dir'],\n        transport=__opts__['transport']\n    )\n\n    try:\n        ret = create_node(kwargs)\n    except Exception as exc:\n        log.error(\n            'Error creating %s on Aliyun ECS\\n\\n'\n            'The following exception was thrown when trying to '\n            'run the initial deployment: %s',\n            vm_['name'], six.text_type(exc),\n            # Show the traceback if the debug logging level is enabled\n            exc_info_on_loglevel=logging.DEBUG\n        )\n        return False\n    # repair ip address error and start vm\n    time.sleep(8)\n    params = {'Action': 'StartInstance',\n              'InstanceId': ret}\n    query(params)\n\n    def __query_node_data(vm_name):\n        data = show_instance(vm_name, call='action')\n        if not data:\n            # Trigger an error in the wait_for_ip function\n            return False\n        if data.get('PublicIpAddress', None) is not None:\n            return data\n\n    try:\n        data = salt.utils.cloud.wait_for_ip(\n            __query_node_data,\n            update_args=(vm_['name'],),\n            timeout=config.get_cloud_config_value(\n                'wait_for_ip_timeout', vm_, __opts__, default=10 * 60),\n            interval=config.get_cloud_config_value(\n                'wait_for_ip_interval', vm_, __opts__, default=10),\n        )\n    except (SaltCloudExecutionTimeout, SaltCloudExecutionFailure) as exc:\n        try:\n            # It might be already up, let's destroy it!\n            destroy(vm_['name'])\n        except SaltCloudSystemExit:\n            pass\n        finally:\n            raise SaltCloudSystemExit(six.text_type(exc))\n\n    if data['public_ips']:\n        ssh_ip = data['public_ips'][0]\n    elif data['private_ips']:\n        ssh_ip = data['private_ips'][0]\n    else:\n        log.info('No available ip:cant connect to salt')\n        return False\n    log.debug('VM %s is now running', ssh_ip)\n    vm_['ssh_host'] = ssh_ip\n\n    # The instance is booted and accessible, let's Salt it!\n    ret = __utils__['cloud.bootstrap'](vm_, __opts__)\n    ret.update(data)\n\n    log.info('Created Cloud VM \\'%s\\'', vm_['name'])\n    log.debug(\n        '\\'%s\\' VM creation details:\\n%s',\n        vm_['name'], pprint.pformat(data)\n    )\n\n    __utils__['cloud.fire_event'](\n        'event',\n        'created instance',\n        'salt/cloud/{0}/created'.format(vm_['name']),\n        args=__utils__['cloud.filter_event']('created', vm_, ['name', 'profile', 'provider', 'driver']),\n        sock_dir=__opts__['sock_dir'],\n        transport=__opts__['transport']\n    )\n\n    return ret", "code_tokens": ["def", "create", "(", "vm_", ")", ":", "try", ":", "# Check for required profile parameters before sending any API calls.", "if", "vm_", "[", "'profile'", "]", "and", "config", ".", "is_profile_configured", "(", "__opts__", ",", "__active_provider_name__", "or", "'aliyun'", ",", "vm_", "[", "'profile'", "]", ",", "vm_", "=", "vm_", ")", "is", "False", ":", "return", "False", "except", "AttributeError", ":", "pass", "__utils__", "[", "'cloud.fire_event'", "]", "(", "'event'", ",", "'starting create'", ",", "'salt/cloud/{0}/creating'", ".", "format", "(", "vm_", "[", "'name'", "]", ")", ",", "args", "=", "__utils__", "[", "'cloud.filter_event'", "]", "(", "'creating'", ",", "vm_", ",", "[", "'name'", ",", "'profile'", ",", "'provider'", ",", "'driver'", "]", ")", ",", "sock_dir", "=", "__opts__", "[", "'sock_dir'", "]", ",", "transport", "=", "__opts__", "[", "'transport'", "]", ")", "log", ".", "info", "(", "'Creating Cloud VM %s'", ",", "vm_", "[", "'name'", "]", ")", "kwargs", "=", "{", "'name'", ":", "vm_", "[", "'name'", "]", ",", "'size_id'", ":", "get_size", "(", "vm_", ")", ",", "'image_id'", ":", "get_image", "(", "vm_", ")", ",", "'region_id'", ":", "__get_location", "(", "vm_", ")", ",", "'securitygroup_id'", ":", "get_securitygroup", "(", "vm_", ")", ",", "}", "if", "'vswitch_id'", "in", "vm_", ":", "kwargs", "[", "'VSwitchId'", "]", "=", "vm_", "[", "'vswitch_id'", "]", "if", "'internet_chargetype'", "in", "vm_", ":", "kwargs", "[", "'InternetChargeType'", "]", "=", "vm_", "[", "'internet_chargetype'", "]", "if", "'internet_maxbandwidthin'", "in", "vm_", ":", "kwargs", "[", "'InternetMaxBandwidthIn'", "]", "=", "six", ".", "text_type", "(", "vm_", "[", "'internet_maxbandwidthin'", "]", ")", "if", "'internet_maxbandwidthout'", "in", "vm_", ":", "kwargs", "[", "'InternetMaxBandwidthOut'", "]", "=", "six", ".", "text_type", "(", "vm_", "[", "'internet_maxbandwidthOut'", "]", ")", "if", "'hostname'", "in", "vm_", ":", "kwargs", "[", "'HostName'", "]", "=", "vm_", "[", "'hostname'", "]", "if", "'password'", "in", "vm_", ":", "kwargs", "[", "'Password'", "]", "=", "vm_", "[", "'password'", "]", "if", "'instance_name'", "in", "vm_", ":", "kwargs", "[", "'InstanceName'", "]", "=", "vm_", "[", "'instance_name'", "]", "if", "'systemdisk_category'", "in", "vm_", ":", "kwargs", "[", "'SystemDisk.Category'", "]", "=", "vm_", "[", "'systemdisk_category'", "]", "__utils__", "[", "'cloud.fire_event'", "]", "(", "'event'", ",", "'requesting instance'", ",", "'salt/cloud/{0}/requesting'", ".", "format", "(", "vm_", "[", "'name'", "]", ")", ",", "args", "=", "__utils__", "[", "'cloud.filter_event'", "]", "(", "'requesting'", ",", "kwargs", ",", "list", "(", "kwargs", ")", ")", ",", "sock_dir", "=", "__opts__", "[", "'sock_dir'", "]", ",", "transport", "=", "__opts__", "[", "'transport'", "]", ")", "try", ":", "ret", "=", "create_node", "(", "kwargs", ")", "except", "Exception", "as", "exc", ":", "log", ".", "error", "(", "'Error creating %s on Aliyun ECS\\n\\n'", "'The following exception was thrown when trying to '", "'run the initial deployment: %s'", ",", "vm_", "[", "'name'", "]", ",", "six", ".", "text_type", "(", "exc", ")", ",", "# Show the traceback if the debug logging level is enabled", "exc_info_on_loglevel", "=", "logging", ".", "DEBUG", ")", "return", "False", "# repair ip address error and start vm", "time", ".", "sleep", "(", "8", ")", "params", "=", "{", "'Action'", ":", "'StartInstance'", ",", "'InstanceId'", ":", "ret", "}", "query", "(", "params", ")", "def", "__query_node_data", "(", "vm_name", ")", ":", "data", "=", "show_instance", "(", "vm_name", ",", "call", "=", "'action'", ")", "if", "not", "data", ":", "# Trigger an error in the wait_for_ip function", "return", "False", "if", "data", ".", "get", "(", "'PublicIpAddress'", ",", "None", ")", "is", "not", "None", ":", "return", "data", "try", ":", "data", "=", "salt", ".", "utils", ".", "cloud", ".", "wait_for_ip", "(", "__query_node_data", ",", "update_args", "=", "(", "vm_", "[", "'name'", "]", ",", ")", ",", "timeout", "=", "config", ".", "get_cloud_config_value", "(", "'wait_for_ip_timeout'", ",", "vm_", ",", "__opts__", ",", "default", "=", "10", "*", "60", ")", ",", "interval", "=", "config", ".", "get_cloud_config_value", "(", "'wait_for_ip_interval'", ",", "vm_", ",", "__opts__", ",", "default", "=", "10", ")", ",", ")", "except", "(", "SaltCloudExecutionTimeout", ",", "SaltCloudExecutionFailure", ")", "as", "exc", ":", "try", ":", "# It might be already up, let's destroy it!", "destroy", "(", "vm_", "[", "'name'", "]", ")", "except", "SaltCloudSystemExit", ":", "pass", "finally", ":", "raise", "SaltCloudSystemExit", "(", "six", ".", "text_type", "(", "exc", ")", ")", "if", "data", "[", "'public_ips'", "]", ":", "ssh_ip", "=", "data", "[", "'public_ips'", "]", "[", "0", "]", "elif", "data", "[", "'private_ips'", "]", ":", "ssh_ip", "=", "data", "[", "'private_ips'", "]", "[", "0", "]", "else", ":", "log", ".", "info", "(", "'No available ip:cant connect to salt'", ")", "return", "False", "log", ".", "debug", "(", "'VM %s is now running'", ",", "ssh_ip", ")", "vm_", "[", "'ssh_host'", "]", "=", "ssh_ip", "# The instance is booted and accessible, let's Salt it!", "ret", "=", "__utils__", "[", "'cloud.bootstrap'", "]", "(", "vm_", ",", "__opts__", ")", "ret", ".", "update", "(", "data", ")", "log", ".", "info", "(", "'Created Cloud VM \\'%s\\''", ",", "vm_", "[", "'name'", "]", ")", "log", ".", "debug", "(", "'\\'%s\\' VM creation details:\\n%s'", ",", "vm_", "[", "'name'", "]", ",", "pprint", ".", "pformat", "(", "data", ")", ")", "__utils__", "[", "'cloud.fire_event'", "]", "(", "'event'", ",", "'created instance'", ",", "'salt/cloud/{0}/created'", ".", "format", "(", "vm_", "[", "'name'", "]", ")", ",", "args", "=", "__utils__", "[", "'cloud.filter_event'", "]", "(", "'created'", ",", "vm_", ",", "[", "'name'", ",", "'profile'", ",", "'provider'", ",", "'driver'", "]", ")", ",", "sock_dir", "=", "__opts__", "[", "'sock_dir'", "]", ",", "transport", "=", "__opts__", "[", "'transport'", "]", ")", "return", "ret"], "docstring": "Create a single VM from a data dict", "docstring_tokens": ["Create", "a", "single", "VM", "from", "a", "data", "dict"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/cloud/clouds/aliyun.py#L611-L741", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/cloud/clouds/aliyun.py", "func_name": "_compute_signature", "original_string": "def _compute_signature(parameters, access_key_secret):\n    '''\n    Generate aliyun request signature\n    '''\n\n    def percent_encode(line):\n        if not isinstance(line, six.string_types):\n            return line\n\n        s = line\n        if sys.stdin.encoding is None:\n            s = line.decode().encode('utf8')\n        else:\n            s = line.decode(sys.stdin.encoding).encode('utf8')\n        res = _quote(s, '')\n        res = res.replace('+', '%20')\n        res = res.replace('*', '%2A')\n        res = res.replace('%7E', '~')\n        return res\n\n    sortedParameters = sorted(list(parameters.items()), key=lambda items: items[0])\n\n    canonicalizedQueryString = ''\n    for k, v in sortedParameters:\n        canonicalizedQueryString += '&' + percent_encode(k) \\\n            + '=' + percent_encode(v)\n\n    # All aliyun API only support GET method\n    stringToSign = 'GET&%2F&' + percent_encode(canonicalizedQueryString[1:])\n\n    h = hmac.new(to_bytes(access_key_secret + \"&\"), stringToSign, sha1)\n    signature = base64.encodestring(h.digest()).strip()\n    return signature", "language": "python", "code": "def _compute_signature(parameters, access_key_secret):\n    '''\n    Generate aliyun request signature\n    '''\n\n    def percent_encode(line):\n        if not isinstance(line, six.string_types):\n            return line\n\n        s = line\n        if sys.stdin.encoding is None:\n            s = line.decode().encode('utf8')\n        else:\n            s = line.decode(sys.stdin.encoding).encode('utf8')\n        res = _quote(s, '')\n        res = res.replace('+', '%20')\n        res = res.replace('*', '%2A')\n        res = res.replace('%7E', '~')\n        return res\n\n    sortedParameters = sorted(list(parameters.items()), key=lambda items: items[0])\n\n    canonicalizedQueryString = ''\n    for k, v in sortedParameters:\n        canonicalizedQueryString += '&' + percent_encode(k) \\\n            + '=' + percent_encode(v)\n\n    # All aliyun API only support GET method\n    stringToSign = 'GET&%2F&' + percent_encode(canonicalizedQueryString[1:])\n\n    h = hmac.new(to_bytes(access_key_secret + \"&\"), stringToSign, sha1)\n    signature = base64.encodestring(h.digest()).strip()\n    return signature", "code_tokens": ["def", "_compute_signature", "(", "parameters", ",", "access_key_secret", ")", ":", "def", "percent_encode", "(", "line", ")", ":", "if", "not", "isinstance", "(", "line", ",", "six", ".", "string_types", ")", ":", "return", "line", "s", "=", "line", "if", "sys", ".", "stdin", ".", "encoding", "is", "None", ":", "s", "=", "line", ".", "decode", "(", ")", ".", "encode", "(", "'utf8'", ")", "else", ":", "s", "=", "line", ".", "decode", "(", "sys", ".", "stdin", ".", "encoding", ")", ".", "encode", "(", "'utf8'", ")", "res", "=", "_quote", "(", "s", ",", "''", ")", "res", "=", "res", ".", "replace", "(", "'+'", ",", "'%20'", ")", "res", "=", "res", ".", "replace", "(", "'*'", ",", "'%2A'", ")", "res", "=", "res", ".", "replace", "(", "'%7E'", ",", "'~'", ")", "return", "res", "sortedParameters", "=", "sorted", "(", "list", "(", "parameters", ".", "items", "(", ")", ")", ",", "key", "=", "lambda", "items", ":", "items", "[", "0", "]", ")", "canonicalizedQueryString", "=", "''", "for", "k", ",", "v", "in", "sortedParameters", ":", "canonicalizedQueryString", "+=", "'&'", "+", "percent_encode", "(", "k", ")", "+", "'='", "+", "percent_encode", "(", "v", ")", "# All aliyun API only support GET method", "stringToSign", "=", "'GET&%2F&'", "+", "percent_encode", "(", "canonicalizedQueryString", "[", "1", ":", "]", ")", "h", "=", "hmac", ".", "new", "(", "to_bytes", "(", "access_key_secret", "+", "\"&\"", ")", ",", "stringToSign", ",", "sha1", ")", "signature", "=", "base64", ".", "encodestring", "(", "h", ".", "digest", "(", ")", ")", ".", "strip", "(", ")", "return", "signature"], "docstring": "Generate aliyun request signature", "docstring_tokens": ["Generate", "aliyun", "request", "signature"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/cloud/clouds/aliyun.py#L744-L776", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/cloud/clouds/aliyun.py", "func_name": "query", "original_string": "def query(params=None):\n    '''\n    Make a web call to aliyun ECS REST API\n    '''\n    path = 'https://ecs-cn-hangzhou.aliyuncs.com'\n\n    access_key_id = config.get_cloud_config_value(\n        'id', get_configured_provider(), __opts__, search_global=False\n    )\n    access_key_secret = config.get_cloud_config_value(\n        'key', get_configured_provider(), __opts__, search_global=False\n    )\n\n    timestamp = time.strftime(\"%Y-%m-%dT%H:%M:%SZ\", time.gmtime())\n\n    # public interface parameters\n    parameters = {\n        'Format': 'JSON',\n        'Version': DEFAULT_ALIYUN_API_VERSION,\n        'AccessKeyId': access_key_id,\n        'SignatureVersion': '1.0',\n        'SignatureMethod': 'HMAC-SHA1',\n        'SignatureNonce': six.text_type(uuid.uuid1()),\n        'TimeStamp': timestamp,\n    }\n\n    # include action or function parameters\n    if params:\n        parameters.update(params)\n\n    # Calculate the string for Signature\n    signature = _compute_signature(parameters, access_key_secret)\n    parameters['Signature'] = signature\n\n    request = requests.get(path, params=parameters, verify=True)\n    if request.status_code != 200:\n        raise SaltCloudSystemExit(\n            'An error occurred while querying aliyun ECS. HTTP Code: {0}  '\n            'Error: \\'{1}\\''.format(\n                request.status_code,\n                request.text\n            )\n        )\n\n    log.debug(request.url)\n\n    content = request.text\n\n    result = salt.utils.json.loads(content)\n    if 'Code' in result:\n        raise SaltCloudSystemExit(\n            pprint.pformat(result.get('Message', {}))\n        )\n    return result", "language": "python", "code": "def query(params=None):\n    '''\n    Make a web call to aliyun ECS REST API\n    '''\n    path = 'https://ecs-cn-hangzhou.aliyuncs.com'\n\n    access_key_id = config.get_cloud_config_value(\n        'id', get_configured_provider(), __opts__, search_global=False\n    )\n    access_key_secret = config.get_cloud_config_value(\n        'key', get_configured_provider(), __opts__, search_global=False\n    )\n\n    timestamp = time.strftime(\"%Y-%m-%dT%H:%M:%SZ\", time.gmtime())\n\n    # public interface parameters\n    parameters = {\n        'Format': 'JSON',\n        'Version': DEFAULT_ALIYUN_API_VERSION,\n        'AccessKeyId': access_key_id,\n        'SignatureVersion': '1.0',\n        'SignatureMethod': 'HMAC-SHA1',\n        'SignatureNonce': six.text_type(uuid.uuid1()),\n        'TimeStamp': timestamp,\n    }\n\n    # include action or function parameters\n    if params:\n        parameters.update(params)\n\n    # Calculate the string for Signature\n    signature = _compute_signature(parameters, access_key_secret)\n    parameters['Signature'] = signature\n\n    request = requests.get(path, params=parameters, verify=True)\n    if request.status_code != 200:\n        raise SaltCloudSystemExit(\n            'An error occurred while querying aliyun ECS. HTTP Code: {0}  '\n            'Error: \\'{1}\\''.format(\n                request.status_code,\n                request.text\n            )\n        )\n\n    log.debug(request.url)\n\n    content = request.text\n\n    result = salt.utils.json.loads(content)\n    if 'Code' in result:\n        raise SaltCloudSystemExit(\n            pprint.pformat(result.get('Message', {}))\n        )\n    return result", "code_tokens": ["def", "query", "(", "params", "=", "None", ")", ":", "path", "=", "'https://ecs-cn-hangzhou.aliyuncs.com'", "access_key_id", "=", "config", ".", "get_cloud_config_value", "(", "'id'", ",", "get_configured_provider", "(", ")", ",", "__opts__", ",", "search_global", "=", "False", ")", "access_key_secret", "=", "config", ".", "get_cloud_config_value", "(", "'key'", ",", "get_configured_provider", "(", ")", ",", "__opts__", ",", "search_global", "=", "False", ")", "timestamp", "=", "time", ".", "strftime", "(", "\"%Y-%m-%dT%H:%M:%SZ\"", ",", "time", ".", "gmtime", "(", ")", ")", "# public interface parameters", "parameters", "=", "{", "'Format'", ":", "'JSON'", ",", "'Version'", ":", "DEFAULT_ALIYUN_API_VERSION", ",", "'AccessKeyId'", ":", "access_key_id", ",", "'SignatureVersion'", ":", "'1.0'", ",", "'SignatureMethod'", ":", "'HMAC-SHA1'", ",", "'SignatureNonce'", ":", "six", ".", "text_type", "(", "uuid", ".", "uuid1", "(", ")", ")", ",", "'TimeStamp'", ":", "timestamp", ",", "}", "# include action or function parameters", "if", "params", ":", "parameters", ".", "update", "(", "params", ")", "# Calculate the string for Signature", "signature", "=", "_compute_signature", "(", "parameters", ",", "access_key_secret", ")", "parameters", "[", "'Signature'", "]", "=", "signature", "request", "=", "requests", ".", "get", "(", "path", ",", "params", "=", "parameters", ",", "verify", "=", "True", ")", "if", "request", ".", "status_code", "!=", "200", ":", "raise", "SaltCloudSystemExit", "(", "'An error occurred while querying aliyun ECS. HTTP Code: {0}  '", "'Error: \\'{1}\\''", ".", "format", "(", "request", ".", "status_code", ",", "request", ".", "text", ")", ")", "log", ".", "debug", "(", "request", ".", "url", ")", "content", "=", "request", ".", "text", "result", "=", "salt", ".", "utils", ".", "json", ".", "loads", "(", "content", ")", "if", "'Code'", "in", "result", ":", "raise", "SaltCloudSystemExit", "(", "pprint", ".", "pformat", "(", "result", ".", "get", "(", "'Message'", ",", "{", "}", ")", ")", ")", "return", "result"], "docstring": "Make a web call to aliyun ECS REST API", "docstring_tokens": ["Make", "a", "web", "call", "to", "aliyun", "ECS", "REST", "API"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/cloud/clouds/aliyun.py#L779-L832", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/cloud/clouds/aliyun.py", "func_name": "show_disk", "original_string": "def show_disk(name, call=None):\n    '''\n    Show the disk details of the instance\n\n    CLI Examples:\n\n    .. code-block:: bash\n\n        salt-cloud -a show_disk aliyun myinstance\n    '''\n    if call != 'action':\n        raise SaltCloudSystemExit(\n            'The show_disks action must be called with -a or --action.'\n        )\n\n    ret = {}\n    params = {\n        'Action': 'DescribeInstanceDisks',\n        'InstanceId': name\n    }\n    items = query(params=params)\n\n    for disk in items['Disks']['Disk']:\n        ret[disk['DiskId']] = {}\n        for item in disk:\n            ret[disk['DiskId']][item] = six.text_type(disk[item])\n\n    return ret", "language": "python", "code": "def show_disk(name, call=None):\n    '''\n    Show the disk details of the instance\n\n    CLI Examples:\n\n    .. code-block:: bash\n\n        salt-cloud -a show_disk aliyun myinstance\n    '''\n    if call != 'action':\n        raise SaltCloudSystemExit(\n            'The show_disks action must be called with -a or --action.'\n        )\n\n    ret = {}\n    params = {\n        'Action': 'DescribeInstanceDisks',\n        'InstanceId': name\n    }\n    items = query(params=params)\n\n    for disk in items['Disks']['Disk']:\n        ret[disk['DiskId']] = {}\n        for item in disk:\n            ret[disk['DiskId']][item] = six.text_type(disk[item])\n\n    return ret", "code_tokens": ["def", "show_disk", "(", "name", ",", "call", "=", "None", ")", ":", "if", "call", "!=", "'action'", ":", "raise", "SaltCloudSystemExit", "(", "'The show_disks action must be called with -a or --action.'", ")", "ret", "=", "{", "}", "params", "=", "{", "'Action'", ":", "'DescribeInstanceDisks'", ",", "'InstanceId'", ":", "name", "}", "items", "=", "query", "(", "params", "=", "params", ")", "for", "disk", "in", "items", "[", "'Disks'", "]", "[", "'Disk'", "]", ":", "ret", "[", "disk", "[", "'DiskId'", "]", "]", "=", "{", "}", "for", "item", "in", "disk", ":", "ret", "[", "disk", "[", "'DiskId'", "]", "]", "[", "item", "]", "=", "six", ".", "text_type", "(", "disk", "[", "item", "]", ")", "return", "ret"], "docstring": "Show the disk details of the instance\n\n    CLI Examples:\n\n    .. code-block:: bash\n\n        salt-cloud -a show_disk aliyun myinstance", "docstring_tokens": ["Show", "the", "disk", "details", "of", "the", "instance"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/cloud/clouds/aliyun.py#L850-L877", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/cloud/clouds/aliyun.py", "func_name": "list_monitor_data", "original_string": "def list_monitor_data(kwargs=None, call=None):\n    '''\n    Get monitor data of the instance. If instance name is\n    missing, will show all the instance monitor data on the region.\n\n    CLI Examples:\n\n    .. code-block:: bash\n\n        salt-cloud -f list_monitor_data aliyun\n        salt-cloud -f list_monitor_data aliyun name=AY14051311071990225bd\n    '''\n    if call != 'function':\n        raise SaltCloudSystemExit(\n            'The list_monitor_data must be called with -f or --function.'\n        )\n\n    if not isinstance(kwargs, dict):\n        kwargs = {}\n\n    ret = {}\n    params = {\n        'Action': 'GetMonitorData',\n        'RegionId': get_location()\n    }\n    if 'name' in kwargs:\n        params['InstanceId'] = kwargs['name']\n\n    items = query(params=params)\n\n    monitorData = items['MonitorData']\n\n    for data in monitorData['InstanceMonitorData']:\n        ret[data['InstanceId']] = {}\n        for item in data:\n            ret[data['InstanceId']][item] = six.text_type(data[item])\n\n    return ret", "language": "python", "code": "def list_monitor_data(kwargs=None, call=None):\n    '''\n    Get monitor data of the instance. If instance name is\n    missing, will show all the instance monitor data on the region.\n\n    CLI Examples:\n\n    .. code-block:: bash\n\n        salt-cloud -f list_monitor_data aliyun\n        salt-cloud -f list_monitor_data aliyun name=AY14051311071990225bd\n    '''\n    if call != 'function':\n        raise SaltCloudSystemExit(\n            'The list_monitor_data must be called with -f or --function.'\n        )\n\n    if not isinstance(kwargs, dict):\n        kwargs = {}\n\n    ret = {}\n    params = {\n        'Action': 'GetMonitorData',\n        'RegionId': get_location()\n    }\n    if 'name' in kwargs:\n        params['InstanceId'] = kwargs['name']\n\n    items = query(params=params)\n\n    monitorData = items['MonitorData']\n\n    for data in monitorData['InstanceMonitorData']:\n        ret[data['InstanceId']] = {}\n        for item in data:\n            ret[data['InstanceId']][item] = six.text_type(data[item])\n\n    return ret", "code_tokens": ["def", "list_monitor_data", "(", "kwargs", "=", "None", ",", "call", "=", "None", ")", ":", "if", "call", "!=", "'function'", ":", "raise", "SaltCloudSystemExit", "(", "'The list_monitor_data must be called with -f or --function.'", ")", "if", "not", "isinstance", "(", "kwargs", ",", "dict", ")", ":", "kwargs", "=", "{", "}", "ret", "=", "{", "}", "params", "=", "{", "'Action'", ":", "'GetMonitorData'", ",", "'RegionId'", ":", "get_location", "(", ")", "}", "if", "'name'", "in", "kwargs", ":", "params", "[", "'InstanceId'", "]", "=", "kwargs", "[", "'name'", "]", "items", "=", "query", "(", "params", "=", "params", ")", "monitorData", "=", "items", "[", "'MonitorData'", "]", "for", "data", "in", "monitorData", "[", "'InstanceMonitorData'", "]", ":", "ret", "[", "data", "[", "'InstanceId'", "]", "]", "=", "{", "}", "for", "item", "in", "data", ":", "ret", "[", "data", "[", "'InstanceId'", "]", "]", "[", "item", "]", "=", "six", ".", "text_type", "(", "data", "[", "item", "]", ")", "return", "ret"], "docstring": "Get monitor data of the instance. If instance name is\n    missing, will show all the instance monitor data on the region.\n\n    CLI Examples:\n\n    .. code-block:: bash\n\n        salt-cloud -f list_monitor_data aliyun\n        salt-cloud -f list_monitor_data aliyun name=AY14051311071990225bd", "docstring_tokens": ["Get", "monitor", "data", "of", "the", "instance", ".", "If", "instance", "name", "is", "missing", "will", "show", "all", "the", "instance", "monitor", "data", "on", "the", "region", "."], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/cloud/clouds/aliyun.py#L880-L917", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/cloud/clouds/aliyun.py", "func_name": "show_image", "original_string": "def show_image(kwargs, call=None):\n    '''\n    Show the details from aliyun image\n    '''\n    if call != 'function':\n        raise SaltCloudSystemExit(\n            'The show_images function must be called with '\n            '-f or --function'\n        )\n\n    if not isinstance(kwargs, dict):\n        kwargs = {}\n\n    location = get_location()\n    if 'location' in kwargs:\n        location = kwargs['location']\n\n    params = {\n        'Action': 'DescribeImages',\n        'RegionId': location,\n        'ImageId': kwargs['image']\n    }\n\n    ret = {}\n    items = query(params=params)\n    # DescribeImages so far support input multi-image. And\n    # if not found certain image, the response will include\n    # blank image list other than 'not found' error message\n    if 'Code' in items or not items['Images']['Image']:\n        raise SaltCloudNotFound('The specified image could not be found.')\n\n    log.debug(\n        'Total %s image found in Region %s',\n        items['TotalCount'], location\n    )\n\n    for image in items['Images']['Image']:\n        ret[image['ImageId']] = {}\n        for item in image:\n            ret[image['ImageId']][item] = six.text_type(image[item])\n\n    return ret", "language": "python", "code": "def show_image(kwargs, call=None):\n    '''\n    Show the details from aliyun image\n    '''\n    if call != 'function':\n        raise SaltCloudSystemExit(\n            'The show_images function must be called with '\n            '-f or --function'\n        )\n\n    if not isinstance(kwargs, dict):\n        kwargs = {}\n\n    location = get_location()\n    if 'location' in kwargs:\n        location = kwargs['location']\n\n    params = {\n        'Action': 'DescribeImages',\n        'RegionId': location,\n        'ImageId': kwargs['image']\n    }\n\n    ret = {}\n    items = query(params=params)\n    # DescribeImages so far support input multi-image. And\n    # if not found certain image, the response will include\n    # blank image list other than 'not found' error message\n    if 'Code' in items or not items['Images']['Image']:\n        raise SaltCloudNotFound('The specified image could not be found.')\n\n    log.debug(\n        'Total %s image found in Region %s',\n        items['TotalCount'], location\n    )\n\n    for image in items['Images']['Image']:\n        ret[image['ImageId']] = {}\n        for item in image:\n            ret[image['ImageId']][item] = six.text_type(image[item])\n\n    return ret", "code_tokens": ["def", "show_image", "(", "kwargs", ",", "call", "=", "None", ")", ":", "if", "call", "!=", "'function'", ":", "raise", "SaltCloudSystemExit", "(", "'The show_images function must be called with '", "'-f or --function'", ")", "if", "not", "isinstance", "(", "kwargs", ",", "dict", ")", ":", "kwargs", "=", "{", "}", "location", "=", "get_location", "(", ")", "if", "'location'", "in", "kwargs", ":", "location", "=", "kwargs", "[", "'location'", "]", "params", "=", "{", "'Action'", ":", "'DescribeImages'", ",", "'RegionId'", ":", "location", ",", "'ImageId'", ":", "kwargs", "[", "'image'", "]", "}", "ret", "=", "{", "}", "items", "=", "query", "(", "params", "=", "params", ")", "# DescribeImages so far support input multi-image. And", "# if not found certain image, the response will include", "# blank image list other than 'not found' error message", "if", "'Code'", "in", "items", "or", "not", "items", "[", "'Images'", "]", "[", "'Image'", "]", ":", "raise", "SaltCloudNotFound", "(", "'The specified image could not be found.'", ")", "log", ".", "debug", "(", "'Total %s image found in Region %s'", ",", "items", "[", "'TotalCount'", "]", ",", "location", ")", "for", "image", "in", "items", "[", "'Images'", "]", "[", "'Image'", "]", ":", "ret", "[", "image", "[", "'ImageId'", "]", "]", "=", "{", "}", "for", "item", "in", "image", ":", "ret", "[", "image", "[", "'ImageId'", "]", "]", "[", "item", "]", "=", "six", ".", "text_type", "(", "image", "[", "item", "]", ")", "return", "ret"], "docstring": "Show the details from aliyun image", "docstring_tokens": ["Show", "the", "details", "from", "aliyun", "image"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/cloud/clouds/aliyun.py#L950-L991", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/cloud/clouds/aliyun.py", "func_name": "destroy", "original_string": "def destroy(name, call=None):\n    '''\n    Destroy a node.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt-cloud -a destroy myinstance\n        salt-cloud -d myinstance\n    '''\n    if call == 'function':\n        raise SaltCloudSystemExit(\n            'The destroy action must be called with -d, --destroy, '\n            '-a or --action.'\n        )\n\n    __utils__['cloud.fire_event'](\n        'event',\n        'destroying instance',\n        'salt/cloud/{0}/destroying'.format(name),\n        args={'name': name},\n        sock_dir=__opts__['sock_dir'],\n        transport=__opts__['transport']\n    )\n\n    instanceId = _get_node(name)['InstanceId']\n\n    # have to stop instance before del it\n    stop_params = {\n        'Action': 'StopInstance',\n        'InstanceId': instanceId\n    }\n    query(stop_params)\n\n    params = {\n        'Action': 'DeleteInstance',\n        'InstanceId': instanceId\n    }\n\n    node = query(params)\n\n    __utils__['cloud.fire_event'](\n        'event',\n        'destroyed instance',\n        'salt/cloud/{0}/destroyed'.format(name),\n        args={'name': name},\n        sock_dir=__opts__['sock_dir'],\n        transport=__opts__['transport']\n    )\n\n    return node", "language": "python", "code": "def destroy(name, call=None):\n    '''\n    Destroy a node.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt-cloud -a destroy myinstance\n        salt-cloud -d myinstance\n    '''\n    if call == 'function':\n        raise SaltCloudSystemExit(\n            'The destroy action must be called with -d, --destroy, '\n            '-a or --action.'\n        )\n\n    __utils__['cloud.fire_event'](\n        'event',\n        'destroying instance',\n        'salt/cloud/{0}/destroying'.format(name),\n        args={'name': name},\n        sock_dir=__opts__['sock_dir'],\n        transport=__opts__['transport']\n    )\n\n    instanceId = _get_node(name)['InstanceId']\n\n    # have to stop instance before del it\n    stop_params = {\n        'Action': 'StopInstance',\n        'InstanceId': instanceId\n    }\n    query(stop_params)\n\n    params = {\n        'Action': 'DeleteInstance',\n        'InstanceId': instanceId\n    }\n\n    node = query(params)\n\n    __utils__['cloud.fire_event'](\n        'event',\n        'destroyed instance',\n        'salt/cloud/{0}/destroyed'.format(name),\n        args={'name': name},\n        sock_dir=__opts__['sock_dir'],\n        transport=__opts__['transport']\n    )\n\n    return node", "code_tokens": ["def", "destroy", "(", "name", ",", "call", "=", "None", ")", ":", "if", "call", "==", "'function'", ":", "raise", "SaltCloudSystemExit", "(", "'The destroy action must be called with -d, --destroy, '", "'-a or --action.'", ")", "__utils__", "[", "'cloud.fire_event'", "]", "(", "'event'", ",", "'destroying instance'", ",", "'salt/cloud/{0}/destroying'", ".", "format", "(", "name", ")", ",", "args", "=", "{", "'name'", ":", "name", "}", ",", "sock_dir", "=", "__opts__", "[", "'sock_dir'", "]", ",", "transport", "=", "__opts__", "[", "'transport'", "]", ")", "instanceId", "=", "_get_node", "(", "name", ")", "[", "'InstanceId'", "]", "# have to stop instance before del it", "stop_params", "=", "{", "'Action'", ":", "'StopInstance'", ",", "'InstanceId'", ":", "instanceId", "}", "query", "(", "stop_params", ")", "params", "=", "{", "'Action'", ":", "'DeleteInstance'", ",", "'InstanceId'", ":", "instanceId", "}", "node", "=", "query", "(", "params", ")", "__utils__", "[", "'cloud.fire_event'", "]", "(", "'event'", ",", "'destroyed instance'", ",", "'salt/cloud/{0}/destroyed'", ".", "format", "(", "name", ")", ",", "args", "=", "{", "'name'", ":", "name", "}", ",", "sock_dir", "=", "__opts__", "[", "'sock_dir'", "]", ",", "transport", "=", "__opts__", "[", "'transport'", "]", ")", "return", "node"], "docstring": "Destroy a node.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt-cloud -a destroy myinstance\n        salt-cloud -d myinstance", "docstring_tokens": ["Destroy", "a", "node", "."], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/cloud/clouds/aliyun.py#L994-L1045", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/modules/solarispkg.py", "func_name": "_write_adminfile", "original_string": "def _write_adminfile(kwargs):\n    '''\n    Create a temporary adminfile based on the keyword arguments passed to\n    pkg.install.\n    '''\n    # Set the adminfile default variables\n    email = kwargs.get('email', '')\n    instance = kwargs.get('instance', 'quit')\n    partial = kwargs.get('partial', 'nocheck')\n    runlevel = kwargs.get('runlevel', 'nocheck')\n    idepend = kwargs.get('idepend', 'nocheck')\n    rdepend = kwargs.get('rdepend', 'nocheck')\n    space = kwargs.get('space', 'nocheck')\n    setuid = kwargs.get('setuid', 'nocheck')\n    conflict = kwargs.get('conflict', 'nocheck')\n    action = kwargs.get('action', 'nocheck')\n    basedir = kwargs.get('basedir', 'default')\n\n    # Make tempfile to hold the adminfile contents.\n    adminfile = salt.utils.files.mkstemp(prefix=\"salt-\")\n\n    def _write_line(fp_, line):\n        fp_.write(salt.utils.stringutils.to_str(line))\n\n    with salt.utils.files.fopen(adminfile, 'w') as fp_:\n        _write_line(fp_, 'email={0}\\n'.format(email))\n        _write_line(fp_, 'instance={0}\\n'.format(instance))\n        _write_line(fp_, 'partial={0}\\n'.format(partial))\n        _write_line(fp_, 'runlevel={0}\\n'.format(runlevel))\n        _write_line(fp_, 'idepend={0}\\n'.format(idepend))\n        _write_line(fp_, 'rdepend={0}\\n'.format(rdepend))\n        _write_line(fp_, 'space={0}\\n'.format(space))\n        _write_line(fp_, 'setuid={0}\\n'.format(setuid))\n        _write_line(fp_, 'conflict={0}\\n'.format(conflict))\n        _write_line(fp_, 'action={0}\\n'.format(action))\n        _write_line(fp_, 'basedir={0}\\n'.format(basedir))\n\n    return adminfile", "language": "python", "code": "def _write_adminfile(kwargs):\n    '''\n    Create a temporary adminfile based on the keyword arguments passed to\n    pkg.install.\n    '''\n    # Set the adminfile default variables\n    email = kwargs.get('email', '')\n    instance = kwargs.get('instance', 'quit')\n    partial = kwargs.get('partial', 'nocheck')\n    runlevel = kwargs.get('runlevel', 'nocheck')\n    idepend = kwargs.get('idepend', 'nocheck')\n    rdepend = kwargs.get('rdepend', 'nocheck')\n    space = kwargs.get('space', 'nocheck')\n    setuid = kwargs.get('setuid', 'nocheck')\n    conflict = kwargs.get('conflict', 'nocheck')\n    action = kwargs.get('action', 'nocheck')\n    basedir = kwargs.get('basedir', 'default')\n\n    # Make tempfile to hold the adminfile contents.\n    adminfile = salt.utils.files.mkstemp(prefix=\"salt-\")\n\n    def _write_line(fp_, line):\n        fp_.write(salt.utils.stringutils.to_str(line))\n\n    with salt.utils.files.fopen(adminfile, 'w') as fp_:\n        _write_line(fp_, 'email={0}\\n'.format(email))\n        _write_line(fp_, 'instance={0}\\n'.format(instance))\n        _write_line(fp_, 'partial={0}\\n'.format(partial))\n        _write_line(fp_, 'runlevel={0}\\n'.format(runlevel))\n        _write_line(fp_, 'idepend={0}\\n'.format(idepend))\n        _write_line(fp_, 'rdepend={0}\\n'.format(rdepend))\n        _write_line(fp_, 'space={0}\\n'.format(space))\n        _write_line(fp_, 'setuid={0}\\n'.format(setuid))\n        _write_line(fp_, 'conflict={0}\\n'.format(conflict))\n        _write_line(fp_, 'action={0}\\n'.format(action))\n        _write_line(fp_, 'basedir={0}\\n'.format(basedir))\n\n    return adminfile", "code_tokens": ["def", "_write_adminfile", "(", "kwargs", ")", ":", "# Set the adminfile default variables", "email", "=", "kwargs", ".", "get", "(", "'email'", ",", "''", ")", "instance", "=", "kwargs", ".", "get", "(", "'instance'", ",", "'quit'", ")", "partial", "=", "kwargs", ".", "get", "(", "'partial'", ",", "'nocheck'", ")", "runlevel", "=", "kwargs", ".", "get", "(", "'runlevel'", ",", "'nocheck'", ")", "idepend", "=", "kwargs", ".", "get", "(", "'idepend'", ",", "'nocheck'", ")", "rdepend", "=", "kwargs", ".", "get", "(", "'rdepend'", ",", "'nocheck'", ")", "space", "=", "kwargs", ".", "get", "(", "'space'", ",", "'nocheck'", ")", "setuid", "=", "kwargs", ".", "get", "(", "'setuid'", ",", "'nocheck'", ")", "conflict", "=", "kwargs", ".", "get", "(", "'conflict'", ",", "'nocheck'", ")", "action", "=", "kwargs", ".", "get", "(", "'action'", ",", "'nocheck'", ")", "basedir", "=", "kwargs", ".", "get", "(", "'basedir'", ",", "'default'", ")", "# Make tempfile to hold the adminfile contents.", "adminfile", "=", "salt", ".", "utils", ".", "files", ".", "mkstemp", "(", "prefix", "=", "\"salt-\"", ")", "def", "_write_line", "(", "fp_", ",", "line", ")", ":", "fp_", ".", "write", "(", "salt", ".", "utils", ".", "stringutils", ".", "to_str", "(", "line", ")", ")", "with", "salt", ".", "utils", ".", "files", ".", "fopen", "(", "adminfile", ",", "'w'", ")", "as", "fp_", ":", "_write_line", "(", "fp_", ",", "'email={0}\\n'", ".", "format", "(", "email", ")", ")", "_write_line", "(", "fp_", ",", "'instance={0}\\n'", ".", "format", "(", "instance", ")", ")", "_write_line", "(", "fp_", ",", "'partial={0}\\n'", ".", "format", "(", "partial", ")", ")", "_write_line", "(", "fp_", ",", "'runlevel={0}\\n'", ".", "format", "(", "runlevel", ")", ")", "_write_line", "(", "fp_", ",", "'idepend={0}\\n'", ".", "format", "(", "idepend", ")", ")", "_write_line", "(", "fp_", ",", "'rdepend={0}\\n'", ".", "format", "(", "rdepend", ")", ")", "_write_line", "(", "fp_", ",", "'space={0}\\n'", ".", "format", "(", "space", ")", ")", "_write_line", "(", "fp_", ",", "'setuid={0}\\n'", ".", "format", "(", "setuid", ")", ")", "_write_line", "(", "fp_", ",", "'conflict={0}\\n'", ".", "format", "(", "conflict", ")", ")", "_write_line", "(", "fp_", ",", "'action={0}\\n'", ".", "format", "(", "action", ")", ")", "_write_line", "(", "fp_", ",", "'basedir={0}\\n'", ".", "format", "(", "basedir", ")", ")", "return", "adminfile"], "docstring": "Create a temporary adminfile based on the keyword arguments passed to\n    pkg.install.", "docstring_tokens": ["Create", "a", "temporary", "adminfile", "based", "on", "the", "keyword", "arguments", "passed", "to", "pkg", ".", "install", "."], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/modules/solarispkg.py#L42-L79", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/modules/solarispkg.py", "func_name": "list_pkgs", "original_string": "def list_pkgs(versions_as_list=False, **kwargs):\n    '''\n    List the packages currently installed as a dict:\n\n    .. code-block:: python\n\n        {'<package_name>': '<version>'}\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' pkg.list_pkgs\n    '''\n    versions_as_list = salt.utils.data.is_true(versions_as_list)\n    # not yet implemented or not applicable\n    if any([salt.utils.data.is_true(kwargs.get(x))\n            for x in ('removed', 'purge_desired')]):\n        return {}\n\n    if 'pkg.list_pkgs' in __context__:\n        if versions_as_list:\n            return __context__['pkg.list_pkgs']\n        else:\n            ret = copy.deepcopy(__context__['pkg.list_pkgs'])\n            __salt__['pkg_resource.stringify'](ret)\n            return ret\n\n    ret = {}\n    cmd = '/usr/bin/pkginfo -x'\n\n    # Package information returned two lines per package. On even-offset\n    # lines, the package name is in the first column. On odd-offset lines, the\n    # package version is in the second column.\n    lines = __salt__['cmd.run'](\n            cmd,\n            output_loglevel='trace',\n            python_shell=False).splitlines()\n    for index, line in enumerate(lines):\n        if index % 2 == 0:\n            name = line.split()[0].strip()\n        if index % 2 == 1:\n            version_num = line.split()[1].strip()\n            __salt__['pkg_resource.add_pkg'](ret, name, version_num)\n\n    __salt__['pkg_resource.sort_pkglist'](ret)\n    __context__['pkg.list_pkgs'] = copy.deepcopy(ret)\n    if not versions_as_list:\n        __salt__['pkg_resource.stringify'](ret)\n    return ret", "language": "python", "code": "def list_pkgs(versions_as_list=False, **kwargs):\n    '''\n    List the packages currently installed as a dict:\n\n    .. code-block:: python\n\n        {'<package_name>': '<version>'}\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' pkg.list_pkgs\n    '''\n    versions_as_list = salt.utils.data.is_true(versions_as_list)\n    # not yet implemented or not applicable\n    if any([salt.utils.data.is_true(kwargs.get(x))\n            for x in ('removed', 'purge_desired')]):\n        return {}\n\n    if 'pkg.list_pkgs' in __context__:\n        if versions_as_list:\n            return __context__['pkg.list_pkgs']\n        else:\n            ret = copy.deepcopy(__context__['pkg.list_pkgs'])\n            __salt__['pkg_resource.stringify'](ret)\n            return ret\n\n    ret = {}\n    cmd = '/usr/bin/pkginfo -x'\n\n    # Package information returned two lines per package. On even-offset\n    # lines, the package name is in the first column. On odd-offset lines, the\n    # package version is in the second column.\n    lines = __salt__['cmd.run'](\n            cmd,\n            output_loglevel='trace',\n            python_shell=False).splitlines()\n    for index, line in enumerate(lines):\n        if index % 2 == 0:\n            name = line.split()[0].strip()\n        if index % 2 == 1:\n            version_num = line.split()[1].strip()\n            __salt__['pkg_resource.add_pkg'](ret, name, version_num)\n\n    __salt__['pkg_resource.sort_pkglist'](ret)\n    __context__['pkg.list_pkgs'] = copy.deepcopy(ret)\n    if not versions_as_list:\n        __salt__['pkg_resource.stringify'](ret)\n    return ret", "code_tokens": ["def", "list_pkgs", "(", "versions_as_list", "=", "False", ",", "*", "*", "kwargs", ")", ":", "versions_as_list", "=", "salt", ".", "utils", ".", "data", ".", "is_true", "(", "versions_as_list", ")", "# not yet implemented or not applicable", "if", "any", "(", "[", "salt", ".", "utils", ".", "data", ".", "is_true", "(", "kwargs", ".", "get", "(", "x", ")", ")", "for", "x", "in", "(", "'removed'", ",", "'purge_desired'", ")", "]", ")", ":", "return", "{", "}", "if", "'pkg.list_pkgs'", "in", "__context__", ":", "if", "versions_as_list", ":", "return", "__context__", "[", "'pkg.list_pkgs'", "]", "else", ":", "ret", "=", "copy", ".", "deepcopy", "(", "__context__", "[", "'pkg.list_pkgs'", "]", ")", "__salt__", "[", "'pkg_resource.stringify'", "]", "(", "ret", ")", "return", "ret", "ret", "=", "{", "}", "cmd", "=", "'/usr/bin/pkginfo -x'", "# Package information returned two lines per package. On even-offset", "# lines, the package name is in the first column. On odd-offset lines, the", "# package version is in the second column.", "lines", "=", "__salt__", "[", "'cmd.run'", "]", "(", "cmd", ",", "output_loglevel", "=", "'trace'", ",", "python_shell", "=", "False", ")", ".", "splitlines", "(", ")", "for", "index", ",", "line", "in", "enumerate", "(", "lines", ")", ":", "if", "index", "%", "2", "==", "0", ":", "name", "=", "line", ".", "split", "(", ")", "[", "0", "]", ".", "strip", "(", ")", "if", "index", "%", "2", "==", "1", ":", "version_num", "=", "line", ".", "split", "(", ")", "[", "1", "]", ".", "strip", "(", ")", "__salt__", "[", "'pkg_resource.add_pkg'", "]", "(", "ret", ",", "name", ",", "version_num", ")", "__salt__", "[", "'pkg_resource.sort_pkglist'", "]", "(", "ret", ")", "__context__", "[", "'pkg.list_pkgs'", "]", "=", "copy", ".", "deepcopy", "(", "ret", ")", "if", "not", "versions_as_list", ":", "__salt__", "[", "'pkg_resource.stringify'", "]", "(", "ret", ")", "return", "ret"], "docstring": "List the packages currently installed as a dict:\n\n    .. code-block:: python\n\n        {'<package_name>': '<version>'}\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' pkg.list_pkgs", "docstring_tokens": ["List", "the", "packages", "currently", "installed", "as", "a", "dict", ":"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/modules/solarispkg.py#L82-L131", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/modules/solarispkg.py", "func_name": "install", "original_string": "def install(name=None, sources=None, saltenv='base', **kwargs):\n    '''\n    Install the passed package. Can install packages from the following\n    sources:\n\n    * Locally (package already exists on the minion\n    * HTTP/HTTPS server\n    * FTP server\n    * Salt master\n\n    Returns a dict containing the new package names and versions:\n\n    .. code-block:: python\n\n        {'<package>': {'old': '<old-version>',\n                       'new': '<new-version>'}}\n\n    CLI Examples:\n\n    .. code-block:: bash\n\n        # Installing a data stream pkg that already exists on the minion\n\n        salt '*' pkg.install sources='[{\"<pkg name>\": \"/dir/on/minion/<pkg filename>\"}]'\n        salt '*' pkg.install sources='[{\"SMClgcc346\": \"/var/spool/pkg/gcc-3.4.6-sol10-sparc-local.pkg\"}]'\n\n        # Installing a data stream pkg that exists on the salt master\n\n        salt '*' pkg.install sources='[{\"<pkg name>\": \"salt://pkgs/<pkg filename>\"}]'\n        salt '*' pkg.install sources='[{\"SMClgcc346\": \"salt://pkgs/gcc-3.4.6-sol10-sparc-local.pkg\"}]'\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        # Installing a data stream pkg that exists on a HTTP server\n        salt '*' pkg.install sources='[{\"<pkg name>\": \"http://packages.server.com/<pkg filename>\"}]'\n        salt '*' pkg.install sources='[{\"SMClgcc346\": \"http://packages.server.com/gcc-3.4.6-sol10-sparc-local.pkg\"}]'\n\n    If working with solaris zones and you want to install a package only in the\n    global zone you can pass 'current_zone_only=True' to salt to have the\n    package only installed in the global zone. (Behind the scenes this is\n    passing '-G' to the pkgadd command.) Solaris default when installing a\n    package in the global zone is to install it in all zones. This overrides\n    that and installs the package only in the global.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        # Installing a data stream package only in the global zone:\n        salt 'global_zone' pkg.install sources='[{\"SMClgcc346\": \"/var/spool/pkg/gcc-3.4.6-sol10-sparc-local.pkg\"}]' current_zone_only=True\n\n    By default salt automatically provides an adminfile, to automate package\n    installation, with these options set::\n\n        email=\n        instance=quit\n        partial=nocheck\n        runlevel=nocheck\n        idepend=nocheck\n        rdepend=nocheck\n        space=nocheck\n        setuid=nocheck\n        conflict=nocheck\n        action=nocheck\n        basedir=default\n\n    You can override any of these options in two ways. First you can optionally\n    pass any of the options as a kwarg to the module/state to override the\n    default value or you can optionally pass the 'admin_source' option\n    providing your own adminfile to the minions.\n\n    Note: You can find all of the possible options to provide to the adminfile\n    by reading the admin man page:\n\n    .. code-block:: bash\n\n        man -s 4 admin\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        # Overriding the 'instance' adminfile option when calling the module directly\n        salt '*' pkg.install sources='[{\"<pkg name>\": \"salt://pkgs/<pkg filename>\"}]' instance=\"overwrite\"\n\n    SLS Example:\n\n    .. code-block:: yaml\n\n        # Overriding the 'instance' adminfile option when used in a state\n\n        SMClgcc346:\n          pkg.installed:\n            - sources:\n              - SMClgcc346: salt://srv/salt/pkgs/gcc-3.4.6-sol10-sparc-local.pkg\n            - instance: overwrite\n\n    .. note::\n        The ID declaration is ignored, as the package name is read from the\n        ``sources`` parameter.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        # Providing your own adminfile when calling the module directly\n\n        salt '*' pkg.install sources='[{\"<pkg name>\": \"salt://pkgs/<pkg filename>\"}]' admin_source='salt://pkgs/<adminfile filename>'\n\n        # Providing your own adminfile when using states\n\n        <pkg name>:\n          pkg.installed:\n            - sources:\n              - <pkg name>: salt://pkgs/<pkg filename>\n            - admin_source: salt://pkgs/<adminfile filename>\n\n    .. note::\n        The ID declaration is ignored, as the package name is read from the\n        ``sources`` parameter.\n    '''\n    if salt.utils.data.is_true(kwargs.get('refresh')):\n        log.warning('\\'refresh\\' argument not implemented for solarispkg '\n                    'module')\n\n    # pkgs is not supported, but must be passed here for API compatibility\n    pkgs = kwargs.pop('pkgs', None)\n    try:\n        pkg_params, pkg_type = __salt__['pkg_resource.parse_targets'](\n            name, pkgs, sources, **kwargs\n        )\n    except MinionError as exc:\n        raise CommandExecutionError(exc)\n\n    if not pkg_params:\n        return {}\n\n    if not sources:\n        log.error('\"sources\" param required for solaris pkg_add installs')\n        return {}\n\n    try:\n        if 'admin_source' in kwargs:\n            adminfile = __salt__['cp.cache_file'](kwargs['admin_source'], saltenv)\n        else:\n            adminfile = _write_adminfile(kwargs)\n\n        old = list_pkgs()\n        cmd_prefix = ['/usr/sbin/pkgadd', '-n', '-a', adminfile]\n\n        # Only makes sense in a global zone but works fine in non-globals.\n        if kwargs.get('current_zone_only') == 'True':\n            cmd_prefix += '-G '\n\n        errors = []\n        for pkg in pkg_params:\n            cmd = cmd_prefix + ['-d', pkg, 'all']\n            # Install the package{s}\n            out = __salt__['cmd.run_all'](cmd,\n                                          output_loglevel='trace',\n                                          python_shell=False)\n\n            if out['retcode'] != 0 and out['stderr']:\n                errors.append(out['stderr'])\n\n        __context__.pop('pkg.list_pkgs', None)\n        new = list_pkgs()\n        ret = salt.utils.data.compare_dicts(old, new)\n\n        if errors:\n            raise CommandExecutionError(\n                'Problem encountered installing package(s)',\n                info={'errors': errors, 'changes': ret}\n            )\n    finally:\n        # Remove the temp adminfile\n        if 'admin_source' not in kwargs:\n            try:\n                os.remove(adminfile)\n            except (NameError, OSError):\n                pass\n\n    return ret", "language": "python", "code": "def install(name=None, sources=None, saltenv='base', **kwargs):\n    '''\n    Install the passed package. Can install packages from the following\n    sources:\n\n    * Locally (package already exists on the minion\n    * HTTP/HTTPS server\n    * FTP server\n    * Salt master\n\n    Returns a dict containing the new package names and versions:\n\n    .. code-block:: python\n\n        {'<package>': {'old': '<old-version>',\n                       'new': '<new-version>'}}\n\n    CLI Examples:\n\n    .. code-block:: bash\n\n        # Installing a data stream pkg that already exists on the minion\n\n        salt '*' pkg.install sources='[{\"<pkg name>\": \"/dir/on/minion/<pkg filename>\"}]'\n        salt '*' pkg.install sources='[{\"SMClgcc346\": \"/var/spool/pkg/gcc-3.4.6-sol10-sparc-local.pkg\"}]'\n\n        # Installing a data stream pkg that exists on the salt master\n\n        salt '*' pkg.install sources='[{\"<pkg name>\": \"salt://pkgs/<pkg filename>\"}]'\n        salt '*' pkg.install sources='[{\"SMClgcc346\": \"salt://pkgs/gcc-3.4.6-sol10-sparc-local.pkg\"}]'\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        # Installing a data stream pkg that exists on a HTTP server\n        salt '*' pkg.install sources='[{\"<pkg name>\": \"http://packages.server.com/<pkg filename>\"}]'\n        salt '*' pkg.install sources='[{\"SMClgcc346\": \"http://packages.server.com/gcc-3.4.6-sol10-sparc-local.pkg\"}]'\n\n    If working with solaris zones and you want to install a package only in the\n    global zone you can pass 'current_zone_only=True' to salt to have the\n    package only installed in the global zone. (Behind the scenes this is\n    passing '-G' to the pkgadd command.) Solaris default when installing a\n    package in the global zone is to install it in all zones. This overrides\n    that and installs the package only in the global.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        # Installing a data stream package only in the global zone:\n        salt 'global_zone' pkg.install sources='[{\"SMClgcc346\": \"/var/spool/pkg/gcc-3.4.6-sol10-sparc-local.pkg\"}]' current_zone_only=True\n\n    By default salt automatically provides an adminfile, to automate package\n    installation, with these options set::\n\n        email=\n        instance=quit\n        partial=nocheck\n        runlevel=nocheck\n        idepend=nocheck\n        rdepend=nocheck\n        space=nocheck\n        setuid=nocheck\n        conflict=nocheck\n        action=nocheck\n        basedir=default\n\n    You can override any of these options in two ways. First you can optionally\n    pass any of the options as a kwarg to the module/state to override the\n    default value or you can optionally pass the 'admin_source' option\n    providing your own adminfile to the minions.\n\n    Note: You can find all of the possible options to provide to the adminfile\n    by reading the admin man page:\n\n    .. code-block:: bash\n\n        man -s 4 admin\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        # Overriding the 'instance' adminfile option when calling the module directly\n        salt '*' pkg.install sources='[{\"<pkg name>\": \"salt://pkgs/<pkg filename>\"}]' instance=\"overwrite\"\n\n    SLS Example:\n\n    .. code-block:: yaml\n\n        # Overriding the 'instance' adminfile option when used in a state\n\n        SMClgcc346:\n          pkg.installed:\n            - sources:\n              - SMClgcc346: salt://srv/salt/pkgs/gcc-3.4.6-sol10-sparc-local.pkg\n            - instance: overwrite\n\n    .. note::\n        The ID declaration is ignored, as the package name is read from the\n        ``sources`` parameter.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        # Providing your own adminfile when calling the module directly\n\n        salt '*' pkg.install sources='[{\"<pkg name>\": \"salt://pkgs/<pkg filename>\"}]' admin_source='salt://pkgs/<adminfile filename>'\n\n        # Providing your own adminfile when using states\n\n        <pkg name>:\n          pkg.installed:\n            - sources:\n              - <pkg name>: salt://pkgs/<pkg filename>\n            - admin_source: salt://pkgs/<adminfile filename>\n\n    .. note::\n        The ID declaration is ignored, as the package name is read from the\n        ``sources`` parameter.\n    '''\n    if salt.utils.data.is_true(kwargs.get('refresh')):\n        log.warning('\\'refresh\\' argument not implemented for solarispkg '\n                    'module')\n\n    # pkgs is not supported, but must be passed here for API compatibility\n    pkgs = kwargs.pop('pkgs', None)\n    try:\n        pkg_params, pkg_type = __salt__['pkg_resource.parse_targets'](\n            name, pkgs, sources, **kwargs\n        )\n    except MinionError as exc:\n        raise CommandExecutionError(exc)\n\n    if not pkg_params:\n        return {}\n\n    if not sources:\n        log.error('\"sources\" param required for solaris pkg_add installs')\n        return {}\n\n    try:\n        if 'admin_source' in kwargs:\n            adminfile = __salt__['cp.cache_file'](kwargs['admin_source'], saltenv)\n        else:\n            adminfile = _write_adminfile(kwargs)\n\n        old = list_pkgs()\n        cmd_prefix = ['/usr/sbin/pkgadd', '-n', '-a', adminfile]\n\n        # Only makes sense in a global zone but works fine in non-globals.\n        if kwargs.get('current_zone_only') == 'True':\n            cmd_prefix += '-G '\n\n        errors = []\n        for pkg in pkg_params:\n            cmd = cmd_prefix + ['-d', pkg, 'all']\n            # Install the package{s}\n            out = __salt__['cmd.run_all'](cmd,\n                                          output_loglevel='trace',\n                                          python_shell=False)\n\n            if out['retcode'] != 0 and out['stderr']:\n                errors.append(out['stderr'])\n\n        __context__.pop('pkg.list_pkgs', None)\n        new = list_pkgs()\n        ret = salt.utils.data.compare_dicts(old, new)\n\n        if errors:\n            raise CommandExecutionError(\n                'Problem encountered installing package(s)',\n                info={'errors': errors, 'changes': ret}\n            )\n    finally:\n        # Remove the temp adminfile\n        if 'admin_source' not in kwargs:\n            try:\n                os.remove(adminfile)\n            except (NameError, OSError):\n                pass\n\n    return ret", "code_tokens": ["def", "install", "(", "name", "=", "None", ",", "sources", "=", "None", ",", "saltenv", "=", "'base'", ",", "*", "*", "kwargs", ")", ":", "if", "salt", ".", "utils", ".", "data", ".", "is_true", "(", "kwargs", ".", "get", "(", "'refresh'", ")", ")", ":", "log", ".", "warning", "(", "'\\'refresh\\' argument not implemented for solarispkg '", "'module'", ")", "# pkgs is not supported, but must be passed here for API compatibility", "pkgs", "=", "kwargs", ".", "pop", "(", "'pkgs'", ",", "None", ")", "try", ":", "pkg_params", ",", "pkg_type", "=", "__salt__", "[", "'pkg_resource.parse_targets'", "]", "(", "name", ",", "pkgs", ",", "sources", ",", "*", "*", "kwargs", ")", "except", "MinionError", "as", "exc", ":", "raise", "CommandExecutionError", "(", "exc", ")", "if", "not", "pkg_params", ":", "return", "{", "}", "if", "not", "sources", ":", "log", ".", "error", "(", "'\"sources\" param required for solaris pkg_add installs'", ")", "return", "{", "}", "try", ":", "if", "'admin_source'", "in", "kwargs", ":", "adminfile", "=", "__salt__", "[", "'cp.cache_file'", "]", "(", "kwargs", "[", "'admin_source'", "]", ",", "saltenv", ")", "else", ":", "adminfile", "=", "_write_adminfile", "(", "kwargs", ")", "old", "=", "list_pkgs", "(", ")", "cmd_prefix", "=", "[", "'/usr/sbin/pkgadd'", ",", "'-n'", ",", "'-a'", ",", "adminfile", "]", "# Only makes sense in a global zone but works fine in non-globals.", "if", "kwargs", ".", "get", "(", "'current_zone_only'", ")", "==", "'True'", ":", "cmd_prefix", "+=", "'-G '", "errors", "=", "[", "]", "for", "pkg", "in", "pkg_params", ":", "cmd", "=", "cmd_prefix", "+", "[", "'-d'", ",", "pkg", ",", "'all'", "]", "# Install the package{s}", "out", "=", "__salt__", "[", "'cmd.run_all'", "]", "(", "cmd", ",", "output_loglevel", "=", "'trace'", ",", "python_shell", "=", "False", ")", "if", "out", "[", "'retcode'", "]", "!=", "0", "and", "out", "[", "'stderr'", "]", ":", "errors", ".", "append", "(", "out", "[", "'stderr'", "]", ")", "__context__", ".", "pop", "(", "'pkg.list_pkgs'", ",", "None", ")", "new", "=", "list_pkgs", "(", ")", "ret", "=", "salt", ".", "utils", ".", "data", ".", "compare_dicts", "(", "old", ",", "new", ")", "if", "errors", ":", "raise", "CommandExecutionError", "(", "'Problem encountered installing package(s)'", ",", "info", "=", "{", "'errors'", ":", "errors", ",", "'changes'", ":", "ret", "}", ")", "finally", ":", "# Remove the temp adminfile", "if", "'admin_source'", "not", "in", "kwargs", ":", "try", ":", "os", ".", "remove", "(", "adminfile", ")", "except", "(", "NameError", ",", "OSError", ")", ":", "pass", "return", "ret"], "docstring": "Install the passed package. Can install packages from the following\n    sources:\n\n    * Locally (package already exists on the minion\n    * HTTP/HTTPS server\n    * FTP server\n    * Salt master\n\n    Returns a dict containing the new package names and versions:\n\n    .. code-block:: python\n\n        {'<package>': {'old': '<old-version>',\n                       'new': '<new-version>'}}\n\n    CLI Examples:\n\n    .. code-block:: bash\n\n        # Installing a data stream pkg that already exists on the minion\n\n        salt '*' pkg.install sources='[{\"<pkg name>\": \"/dir/on/minion/<pkg filename>\"}]'\n        salt '*' pkg.install sources='[{\"SMClgcc346\": \"/var/spool/pkg/gcc-3.4.6-sol10-sparc-local.pkg\"}]'\n\n        # Installing a data stream pkg that exists on the salt master\n\n        salt '*' pkg.install sources='[{\"<pkg name>\": \"salt://pkgs/<pkg filename>\"}]'\n        salt '*' pkg.install sources='[{\"SMClgcc346\": \"salt://pkgs/gcc-3.4.6-sol10-sparc-local.pkg\"}]'\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        # Installing a data stream pkg that exists on a HTTP server\n        salt '*' pkg.install sources='[{\"<pkg name>\": \"http://packages.server.com/<pkg filename>\"}]'\n        salt '*' pkg.install sources='[{\"SMClgcc346\": \"http://packages.server.com/gcc-3.4.6-sol10-sparc-local.pkg\"}]'\n\n    If working with solaris zones and you want to install a package only in the\n    global zone you can pass 'current_zone_only=True' to salt to have the\n    package only installed in the global zone. (Behind the scenes this is\n    passing '-G' to the pkgadd command.) Solaris default when installing a\n    package in the global zone is to install it in all zones. This overrides\n    that and installs the package only in the global.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        # Installing a data stream package only in the global zone:\n        salt 'global_zone' pkg.install sources='[{\"SMClgcc346\": \"/var/spool/pkg/gcc-3.4.6-sol10-sparc-local.pkg\"}]' current_zone_only=True\n\n    By default salt automatically provides an adminfile, to automate package\n    installation, with these options set::\n\n        email=\n        instance=quit\n        partial=nocheck\n        runlevel=nocheck\n        idepend=nocheck\n        rdepend=nocheck\n        space=nocheck\n        setuid=nocheck\n        conflict=nocheck\n        action=nocheck\n        basedir=default\n\n    You can override any of these options in two ways. First you can optionally\n    pass any of the options as a kwarg to the module/state to override the\n    default value or you can optionally pass the 'admin_source' option\n    providing your own adminfile to the minions.\n\n    Note: You can find all of the possible options to provide to the adminfile\n    by reading the admin man page:\n\n    .. code-block:: bash\n\n        man -s 4 admin\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        # Overriding the 'instance' adminfile option when calling the module directly\n        salt '*' pkg.install sources='[{\"<pkg name>\": \"salt://pkgs/<pkg filename>\"}]' instance=\"overwrite\"\n\n    SLS Example:\n\n    .. code-block:: yaml\n\n        # Overriding the 'instance' adminfile option when used in a state\n\n        SMClgcc346:\n          pkg.installed:\n            - sources:\n              - SMClgcc346: salt://srv/salt/pkgs/gcc-3.4.6-sol10-sparc-local.pkg\n            - instance: overwrite\n\n    .. note::\n        The ID declaration is ignored, as the package name is read from the\n        ``sources`` parameter.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        # Providing your own adminfile when calling the module directly\n\n        salt '*' pkg.install sources='[{\"<pkg name>\": \"salt://pkgs/<pkg filename>\"}]' admin_source='salt://pkgs/<adminfile filename>'\n\n        # Providing your own adminfile when using states\n\n        <pkg name>:\n          pkg.installed:\n            - sources:\n              - <pkg name>: salt://pkgs/<pkg filename>\n            - admin_source: salt://pkgs/<adminfile filename>\n\n    .. note::\n        The ID declaration is ignored, as the package name is read from the\n        ``sources`` parameter.", "docstring_tokens": ["Install", "the", "passed", "package", ".", "Can", "install", "packages", "from", "the", "following", "sources", ":"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/modules/solarispkg.py#L201-L385", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/modules/solarispkg.py", "func_name": "remove", "original_string": "def remove(name=None, pkgs=None, saltenv='base', **kwargs):\n    '''\n    Remove packages with pkgrm\n\n    name\n        The name of the package to be deleted\n\n    By default salt automatically provides an adminfile, to automate package\n    removal, with these options set::\n\n        email=\n        instance=quit\n        partial=nocheck\n        runlevel=nocheck\n        idepend=nocheck\n        rdepend=nocheck\n        space=nocheck\n        setuid=nocheck\n        conflict=nocheck\n        action=nocheck\n        basedir=default\n\n    You can override any of these options in two ways. First you can optionally\n    pass any of the options as a kwarg to the module/state to override the\n    default value or you can optionally pass the 'admin_source' option\n    providing your own adminfile to the minions.\n\n    Note: You can find all of the possible options to provide to the adminfile\n    by reading the admin man page:\n\n    .. code-block:: bash\n\n        man -s 4 admin\n\n\n    Multiple Package Options:\n\n    pkgs\n        A list of packages to delete. Must be passed as a python list. The\n        ``name`` parameter will be ignored if this option is passed.\n\n    .. versionadded:: 0.16.0\n\n\n    Returns a dict containing the changes.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' pkg.remove <package name>\n        salt '*' pkg.remove SUNWgit\n        salt '*' pkg.remove <package1>,<package2>,<package3>\n        salt '*' pkg.remove pkgs='[\"foo\", \"bar\"]'\n    '''\n    try:\n        pkg_params = __salt__['pkg_resource.parse_targets'](name, pkgs)[0]\n    except MinionError as exc:\n        raise CommandExecutionError(exc)\n\n    old = list_pkgs()\n    targets = [x for x in pkg_params if x in old]\n    if not targets:\n        return {}\n\n    try:\n        if 'admin_source' in kwargs:\n            adminfile = __salt__['cp.cache_file'](kwargs['admin_source'], saltenv)\n        else:\n            # Make tempfile to hold the adminfile contents.\n            adminfile = _write_adminfile(kwargs)\n\n        # Remove the package\n        cmd = ['/usr/sbin/pkgrm', '-n', '-a', adminfile] + targets\n        out = __salt__['cmd.run_all'](cmd,\n                                      python_shell=False,\n                                      output_loglevel='trace')\n\n        if out['retcode'] != 0 and out['stderr']:\n            errors = [out['stderr']]\n        else:\n            errors = []\n\n        __context__.pop('pkg.list_pkgs', None)\n        new = list_pkgs()\n        ret = salt.utils.data.compare_dicts(old, new)\n\n        if errors:\n            raise CommandExecutionError(\n                'Problem encountered removing package(s)',\n                info={'errors': errors, 'changes': ret}\n            )\n    finally:\n        # Remove the temp adminfile\n        if 'admin_source' not in kwargs:\n            try:\n                os.remove(adminfile)\n            except (NameError, OSError):\n                pass\n\n    return ret", "language": "python", "code": "def remove(name=None, pkgs=None, saltenv='base', **kwargs):\n    '''\n    Remove packages with pkgrm\n\n    name\n        The name of the package to be deleted\n\n    By default salt automatically provides an adminfile, to automate package\n    removal, with these options set::\n\n        email=\n        instance=quit\n        partial=nocheck\n        runlevel=nocheck\n        idepend=nocheck\n        rdepend=nocheck\n        space=nocheck\n        setuid=nocheck\n        conflict=nocheck\n        action=nocheck\n        basedir=default\n\n    You can override any of these options in two ways. First you can optionally\n    pass any of the options as a kwarg to the module/state to override the\n    default value or you can optionally pass the 'admin_source' option\n    providing your own adminfile to the minions.\n\n    Note: You can find all of the possible options to provide to the adminfile\n    by reading the admin man page:\n\n    .. code-block:: bash\n\n        man -s 4 admin\n\n\n    Multiple Package Options:\n\n    pkgs\n        A list of packages to delete. Must be passed as a python list. The\n        ``name`` parameter will be ignored if this option is passed.\n\n    .. versionadded:: 0.16.0\n\n\n    Returns a dict containing the changes.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' pkg.remove <package name>\n        salt '*' pkg.remove SUNWgit\n        salt '*' pkg.remove <package1>,<package2>,<package3>\n        salt '*' pkg.remove pkgs='[\"foo\", \"bar\"]'\n    '''\n    try:\n        pkg_params = __salt__['pkg_resource.parse_targets'](name, pkgs)[0]\n    except MinionError as exc:\n        raise CommandExecutionError(exc)\n\n    old = list_pkgs()\n    targets = [x for x in pkg_params if x in old]\n    if not targets:\n        return {}\n\n    try:\n        if 'admin_source' in kwargs:\n            adminfile = __salt__['cp.cache_file'](kwargs['admin_source'], saltenv)\n        else:\n            # Make tempfile to hold the adminfile contents.\n            adminfile = _write_adminfile(kwargs)\n\n        # Remove the package\n        cmd = ['/usr/sbin/pkgrm', '-n', '-a', adminfile] + targets\n        out = __salt__['cmd.run_all'](cmd,\n                                      python_shell=False,\n                                      output_loglevel='trace')\n\n        if out['retcode'] != 0 and out['stderr']:\n            errors = [out['stderr']]\n        else:\n            errors = []\n\n        __context__.pop('pkg.list_pkgs', None)\n        new = list_pkgs()\n        ret = salt.utils.data.compare_dicts(old, new)\n\n        if errors:\n            raise CommandExecutionError(\n                'Problem encountered removing package(s)',\n                info={'errors': errors, 'changes': ret}\n            )\n    finally:\n        # Remove the temp adminfile\n        if 'admin_source' not in kwargs:\n            try:\n                os.remove(adminfile)\n            except (NameError, OSError):\n                pass\n\n    return ret", "code_tokens": ["def", "remove", "(", "name", "=", "None", ",", "pkgs", "=", "None", ",", "saltenv", "=", "'base'", ",", "*", "*", "kwargs", ")", ":", "try", ":", "pkg_params", "=", "__salt__", "[", "'pkg_resource.parse_targets'", "]", "(", "name", ",", "pkgs", ")", "[", "0", "]", "except", "MinionError", "as", "exc", ":", "raise", "CommandExecutionError", "(", "exc", ")", "old", "=", "list_pkgs", "(", ")", "targets", "=", "[", "x", "for", "x", "in", "pkg_params", "if", "x", "in", "old", "]", "if", "not", "targets", ":", "return", "{", "}", "try", ":", "if", "'admin_source'", "in", "kwargs", ":", "adminfile", "=", "__salt__", "[", "'cp.cache_file'", "]", "(", "kwargs", "[", "'admin_source'", "]", ",", "saltenv", ")", "else", ":", "# Make tempfile to hold the adminfile contents.", "adminfile", "=", "_write_adminfile", "(", "kwargs", ")", "# Remove the package", "cmd", "=", "[", "'/usr/sbin/pkgrm'", ",", "'-n'", ",", "'-a'", ",", "adminfile", "]", "+", "targets", "out", "=", "__salt__", "[", "'cmd.run_all'", "]", "(", "cmd", ",", "python_shell", "=", "False", ",", "output_loglevel", "=", "'trace'", ")", "if", "out", "[", "'retcode'", "]", "!=", "0", "and", "out", "[", "'stderr'", "]", ":", "errors", "=", "[", "out", "[", "'stderr'", "]", "]", "else", ":", "errors", "=", "[", "]", "__context__", ".", "pop", "(", "'pkg.list_pkgs'", ",", "None", ")", "new", "=", "list_pkgs", "(", ")", "ret", "=", "salt", ".", "utils", ".", "data", ".", "compare_dicts", "(", "old", ",", "new", ")", "if", "errors", ":", "raise", "CommandExecutionError", "(", "'Problem encountered removing package(s)'", ",", "info", "=", "{", "'errors'", ":", "errors", ",", "'changes'", ":", "ret", "}", ")", "finally", ":", "# Remove the temp adminfile", "if", "'admin_source'", "not", "in", "kwargs", ":", "try", ":", "os", ".", "remove", "(", "adminfile", ")", "except", "(", "NameError", ",", "OSError", ")", ":", "pass", "return", "ret"], "docstring": "Remove packages with pkgrm\n\n    name\n        The name of the package to be deleted\n\n    By default salt automatically provides an adminfile, to automate package\n    removal, with these options set::\n\n        email=\n        instance=quit\n        partial=nocheck\n        runlevel=nocheck\n        idepend=nocheck\n        rdepend=nocheck\n        space=nocheck\n        setuid=nocheck\n        conflict=nocheck\n        action=nocheck\n        basedir=default\n\n    You can override any of these options in two ways. First you can optionally\n    pass any of the options as a kwarg to the module/state to override the\n    default value or you can optionally pass the 'admin_source' option\n    providing your own adminfile to the minions.\n\n    Note: You can find all of the possible options to provide to the adminfile\n    by reading the admin man page:\n\n    .. code-block:: bash\n\n        man -s 4 admin\n\n\n    Multiple Package Options:\n\n    pkgs\n        A list of packages to delete. Must be passed as a python list. The\n        ``name`` parameter will be ignored if this option is passed.\n\n    .. versionadded:: 0.16.0\n\n\n    Returns a dict containing the changes.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' pkg.remove <package name>\n        salt '*' pkg.remove SUNWgit\n        salt '*' pkg.remove <package1>,<package2>,<package3>\n        salt '*' pkg.remove pkgs='[\"foo\", \"bar\"]'", "docstring_tokens": ["Remove", "packages", "with", "pkgrm"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/modules/solarispkg.py#L388-L488", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/states/boto_cloudtrail.py", "func_name": "present", "original_string": "def present(name, Name,\n           S3BucketName, S3KeyPrefix=None,\n           SnsTopicName=None,\n           IncludeGlobalServiceEvents=True,\n           IsMultiRegionTrail=None,\n           EnableLogFileValidation=False,\n           CloudWatchLogsLogGroupArn=None,\n           CloudWatchLogsRoleArn=None,\n           KmsKeyId=None,\n           LoggingEnabled=True,\n           Tags=None,\n           region=None, key=None, keyid=None, profile=None):\n    '''\n    Ensure trail exists.\n\n    name\n        The name of the state definition\n\n    Name\n        Name of the trail.\n\n    S3BucketName\n        Specifies the name of the Amazon S3 bucket designated for publishing log\n        files.\n\n    S3KeyPrefix\n        Specifies the Amazon S3 key prefix that comes after the name of the\n        bucket you have designated for log file delivery.\n\n    SnsTopicName\n        Specifies the name of the Amazon SNS topic defined for notification of\n        log file delivery. The maximum length is 256 characters.\n\n    IncludeGlobalServiceEvents\n        Specifies whether the trail is publishing events from global services\n        such as IAM to the log files.\n\n    EnableLogFileValidation\n        Specifies whether log file integrity validation is enabled. The default\n        is false.\n\n    CloudWatchLogsLogGroupArn\n        Specifies a log group name using an Amazon Resource Name (ARN), a unique\n        identifier that represents the log group to which CloudTrail logs will\n        be delivered. Not required unless you specify CloudWatchLogsRoleArn.\n\n    CloudWatchLogsRoleArn\n        Specifies the role for the CloudWatch Logs endpoint to assume to write\n        to a user's log group.\n\n    KmsKeyId\n        Specifies the KMS key ID to use to encrypt the logs delivered by\n        CloudTrail. The value can be a an alias name prefixed by \"alias/\", a\n        fully specified ARN to an alias, a fully specified ARN to a key, or a\n        globally unique identifier.\n\n    LoggingEnabled\n        Whether logging should be enabled for the trail\n\n    Tags\n        A dictionary of tags that should be set on the trail\n\n    region\n        Region to connect to.\n\n    key\n        Secret key to be used.\n\n    keyid\n        Access key to be used.\n\n    profile\n        A dict with region, key and keyid, or a pillar key (string) that\n        contains a dict with region, key and keyid.\n    '''\n    ret = {'name': Name,\n           'result': True,\n           'comment': '',\n           'changes': {}\n           }\n\n    r = __salt__['boto_cloudtrail.exists'](Name=Name,\n           region=region, key=key, keyid=keyid, profile=profile)\n\n    if 'error' in r:\n        ret['result'] = False\n        ret['comment'] = 'Failed to create trail: {0}.'.format(r['error']['message'])\n        return ret\n\n    if not r.get('exists'):\n        if __opts__['test']:\n            ret['comment'] = 'CloudTrail {0} is set to be created.'.format(Name)\n            ret['result'] = None\n            return ret\n        r = __salt__['boto_cloudtrail.create'](Name=Name,\n                   S3BucketName=S3BucketName,\n                   S3KeyPrefix=S3KeyPrefix,\n                   SnsTopicName=SnsTopicName,\n                   IncludeGlobalServiceEvents=IncludeGlobalServiceEvents,\n                   IsMultiRegionTrail=IsMultiRegionTrail,\n                   EnableLogFileValidation=EnableLogFileValidation,\n                   CloudWatchLogsLogGroupArn=CloudWatchLogsLogGroupArn,\n                   CloudWatchLogsRoleArn=CloudWatchLogsRoleArn,\n                   KmsKeyId=KmsKeyId,\n                   region=region, key=key, keyid=keyid, profile=profile)\n        if not r.get('created'):\n            ret['result'] = False\n            ret['comment'] = 'Failed to create trail: {0}.'.format(r['error']['message'])\n            return ret\n        _describe = __salt__['boto_cloudtrail.describe'](Name,\n                                   region=region, key=key, keyid=keyid, profile=profile)\n        ret['changes']['old'] = {'trail': None}\n        ret['changes']['new'] = _describe\n        ret['comment'] = 'CloudTrail {0} created.'.format(Name)\n\n        if LoggingEnabled:\n            r = __salt__['boto_cloudtrail.start_logging'](Name=Name,\n                   region=region, key=key, keyid=keyid, profile=profile)\n            if 'error' in r:\n                ret['result'] = False\n                ret['comment'] = 'Failed to create trail: {0}.'.format(r['error']['message'])\n                ret['changes'] = {}\n                return ret\n            ret['changes']['new']['trail']['LoggingEnabled'] = True\n        else:\n            ret['changes']['new']['trail']['LoggingEnabled'] = False\n\n        if bool(Tags):\n            r = __salt__['boto_cloudtrail.add_tags'](Name=Name,\n                   region=region, key=key, keyid=keyid, profile=profile, **Tags)\n            if not r.get('tagged'):\n                ret['result'] = False\n                ret['comment'] = 'Failed to create trail: {0}.'.format(r['error']['message'])\n                ret['changes'] = {}\n                return ret\n            ret['changes']['new']['trail']['Tags'] = Tags\n        return ret\n\n    ret['comment'] = os.linesep.join([ret['comment'], 'CloudTrail {0} is present.'.format(Name)])\n    ret['changes'] = {}\n    # trail exists, ensure config matches\n    _describe = __salt__['boto_cloudtrail.describe'](Name=Name,\n                                  region=region, key=key, keyid=keyid, profile=profile)\n    if 'error' in _describe:\n        ret['result'] = False\n        ret['comment'] = 'Failed to update trail: {0}.'.format(_describe['error']['message'])\n        ret['changes'] = {}\n        return ret\n    _describe = _describe.get('trail')\n\n    r = __salt__['boto_cloudtrail.status'](Name=Name,\n                   region=region, key=key, keyid=keyid, profile=profile)\n    _describe['LoggingEnabled'] = r.get('trail', {}).get('IsLogging', False)\n\n    need_update = False\n    bucket_vars = {'S3BucketName': 'S3BucketName',\n                   'S3KeyPrefix': 'S3KeyPrefix',\n                   'SnsTopicName': 'SnsTopicName',\n                   'IncludeGlobalServiceEvents': 'IncludeGlobalServiceEvents',\n                   'IsMultiRegionTrail': 'IsMultiRegionTrail',\n                   'EnableLogFileValidation': 'LogFileValidationEnabled',\n                   'CloudWatchLogsLogGroupArn': 'CloudWatchLogsLogGroupArn',\n                   'CloudWatchLogsRoleArn': 'CloudWatchLogsRoleArn',\n                   'KmsKeyId': 'KmsKeyId',\n                   'LoggingEnabled': 'LoggingEnabled'}\n\n    for invar, outvar in six.iteritems(bucket_vars):\n        if _describe[outvar] != locals()[invar]:\n            need_update = True\n            ret['changes'].setdefault('new', {})[invar] = locals()[invar]\n            ret['changes'].setdefault('old', {})[invar] = _describe[outvar]\n\n    r = __salt__['boto_cloudtrail.list_tags'](Name=Name,\n                   region=region, key=key, keyid=keyid, profile=profile)\n    _describe['Tags'] = r.get('tags', {})\n    tagchange = salt.utils.data.compare_dicts(_describe['Tags'], Tags)\n    if bool(tagchange):\n        need_update = True\n        ret['changes'].setdefault('new', {})['Tags'] = Tags\n        ret['changes'].setdefault('old', {})['Tags'] = _describe['Tags']\n\n    if need_update:\n        if __opts__['test']:\n            msg = 'CloudTrail {0} set to be modified.'.format(Name)\n            ret['comment'] = msg\n            ret['result'] = None\n            return ret\n\n        ret['comment'] = os.linesep.join([ret['comment'], 'CloudTrail to be modified'])\n        r = __salt__['boto_cloudtrail.update'](Name=Name,\n                   S3BucketName=S3BucketName,\n                   S3KeyPrefix=S3KeyPrefix,\n                   SnsTopicName=SnsTopicName,\n                   IncludeGlobalServiceEvents=IncludeGlobalServiceEvents,\n                   IsMultiRegionTrail=IsMultiRegionTrail,\n                   EnableLogFileValidation=EnableLogFileValidation,\n                   CloudWatchLogsLogGroupArn=CloudWatchLogsLogGroupArn,\n                   CloudWatchLogsRoleArn=CloudWatchLogsRoleArn,\n                   KmsKeyId=KmsKeyId,\n                   region=region, key=key, keyid=keyid, profile=profile)\n        if not r.get('updated'):\n            ret['result'] = False\n            ret['comment'] = 'Failed to update trail: {0}.'.format(r['error']['message'])\n            ret['changes'] = {}\n            return ret\n\n        if LoggingEnabled:\n            r = __salt__['boto_cloudtrail.start_logging'](Name=Name,\n                   region=region, key=key, keyid=keyid, profile=profile)\n            if not r.get('started'):\n                ret['result'] = False\n                ret['comment'] = 'Failed to update trail: {0}.'.format(r['error']['message'])\n                ret['changes'] = {}\n                return ret\n        else:\n            r = __salt__['boto_cloudtrail.stop_logging'](Name=Name,\n                   region=region, key=key, keyid=keyid, profile=profile)\n            if not r.get('stopped'):\n                ret['result'] = False\n                ret['comment'] = 'Failed to update trail: {0}.'.format(r['error']['message'])\n                ret['changes'] = {}\n                return ret\n\n        if bool(tagchange):\n            adds = {}\n            removes = {}\n            for k, diff in six.iteritems(tagchange):\n                if diff.get('new', '') != '':\n                    # there's an update for this key\n                    adds[k] = Tags[k]\n                elif diff.get('old', '') != '':\n                    removes[k] = _describe['Tags'][k]\n            if bool(adds):\n                r = __salt__['boto_cloudtrail.add_tags'](Name=Name,\n                   region=region, key=key, keyid=keyid, profile=profile, **adds)\n            if bool(removes):\n                r = __salt__['boto_cloudtrail.remove_tags'](Name=Name,\n                   region=region, key=key, keyid=keyid, profile=profile,\n                   **removes)\n\n    return ret", "language": "python", "code": "def present(name, Name,\n           S3BucketName, S3KeyPrefix=None,\n           SnsTopicName=None,\n           IncludeGlobalServiceEvents=True,\n           IsMultiRegionTrail=None,\n           EnableLogFileValidation=False,\n           CloudWatchLogsLogGroupArn=None,\n           CloudWatchLogsRoleArn=None,\n           KmsKeyId=None,\n           LoggingEnabled=True,\n           Tags=None,\n           region=None, key=None, keyid=None, profile=None):\n    '''\n    Ensure trail exists.\n\n    name\n        The name of the state definition\n\n    Name\n        Name of the trail.\n\n    S3BucketName\n        Specifies the name of the Amazon S3 bucket designated for publishing log\n        files.\n\n    S3KeyPrefix\n        Specifies the Amazon S3 key prefix that comes after the name of the\n        bucket you have designated for log file delivery.\n\n    SnsTopicName\n        Specifies the name of the Amazon SNS topic defined for notification of\n        log file delivery. The maximum length is 256 characters.\n\n    IncludeGlobalServiceEvents\n        Specifies whether the trail is publishing events from global services\n        such as IAM to the log files.\n\n    EnableLogFileValidation\n        Specifies whether log file integrity validation is enabled. The default\n        is false.\n\n    CloudWatchLogsLogGroupArn\n        Specifies a log group name using an Amazon Resource Name (ARN), a unique\n        identifier that represents the log group to which CloudTrail logs will\n        be delivered. Not required unless you specify CloudWatchLogsRoleArn.\n\n    CloudWatchLogsRoleArn\n        Specifies the role for the CloudWatch Logs endpoint to assume to write\n        to a user's log group.\n\n    KmsKeyId\n        Specifies the KMS key ID to use to encrypt the logs delivered by\n        CloudTrail. The value can be a an alias name prefixed by \"alias/\", a\n        fully specified ARN to an alias, a fully specified ARN to a key, or a\n        globally unique identifier.\n\n    LoggingEnabled\n        Whether logging should be enabled for the trail\n\n    Tags\n        A dictionary of tags that should be set on the trail\n\n    region\n        Region to connect to.\n\n    key\n        Secret key to be used.\n\n    keyid\n        Access key to be used.\n\n    profile\n        A dict with region, key and keyid, or a pillar key (string) that\n        contains a dict with region, key and keyid.\n    '''\n    ret = {'name': Name,\n           'result': True,\n           'comment': '',\n           'changes': {}\n           }\n\n    r = __salt__['boto_cloudtrail.exists'](Name=Name,\n           region=region, key=key, keyid=keyid, profile=profile)\n\n    if 'error' in r:\n        ret['result'] = False\n        ret['comment'] = 'Failed to create trail: {0}.'.format(r['error']['message'])\n        return ret\n\n    if not r.get('exists'):\n        if __opts__['test']:\n            ret['comment'] = 'CloudTrail {0} is set to be created.'.format(Name)\n            ret['result'] = None\n            return ret\n        r = __salt__['boto_cloudtrail.create'](Name=Name,\n                   S3BucketName=S3BucketName,\n                   S3KeyPrefix=S3KeyPrefix,\n                   SnsTopicName=SnsTopicName,\n                   IncludeGlobalServiceEvents=IncludeGlobalServiceEvents,\n                   IsMultiRegionTrail=IsMultiRegionTrail,\n                   EnableLogFileValidation=EnableLogFileValidation,\n                   CloudWatchLogsLogGroupArn=CloudWatchLogsLogGroupArn,\n                   CloudWatchLogsRoleArn=CloudWatchLogsRoleArn,\n                   KmsKeyId=KmsKeyId,\n                   region=region, key=key, keyid=keyid, profile=profile)\n        if not r.get('created'):\n            ret['result'] = False\n            ret['comment'] = 'Failed to create trail: {0}.'.format(r['error']['message'])\n            return ret\n        _describe = __salt__['boto_cloudtrail.describe'](Name,\n                                   region=region, key=key, keyid=keyid, profile=profile)\n        ret['changes']['old'] = {'trail': None}\n        ret['changes']['new'] = _describe\n        ret['comment'] = 'CloudTrail {0} created.'.format(Name)\n\n        if LoggingEnabled:\n            r = __salt__['boto_cloudtrail.start_logging'](Name=Name,\n                   region=region, key=key, keyid=keyid, profile=profile)\n            if 'error' in r:\n                ret['result'] = False\n                ret['comment'] = 'Failed to create trail: {0}.'.format(r['error']['message'])\n                ret['changes'] = {}\n                return ret\n            ret['changes']['new']['trail']['LoggingEnabled'] = True\n        else:\n            ret['changes']['new']['trail']['LoggingEnabled'] = False\n\n        if bool(Tags):\n            r = __salt__['boto_cloudtrail.add_tags'](Name=Name,\n                   region=region, key=key, keyid=keyid, profile=profile, **Tags)\n            if not r.get('tagged'):\n                ret['result'] = False\n                ret['comment'] = 'Failed to create trail: {0}.'.format(r['error']['message'])\n                ret['changes'] = {}\n                return ret\n            ret['changes']['new']['trail']['Tags'] = Tags\n        return ret\n\n    ret['comment'] = os.linesep.join([ret['comment'], 'CloudTrail {0} is present.'.format(Name)])\n    ret['changes'] = {}\n    # trail exists, ensure config matches\n    _describe = __salt__['boto_cloudtrail.describe'](Name=Name,\n                                  region=region, key=key, keyid=keyid, profile=profile)\n    if 'error' in _describe:\n        ret['result'] = False\n        ret['comment'] = 'Failed to update trail: {0}.'.format(_describe['error']['message'])\n        ret['changes'] = {}\n        return ret\n    _describe = _describe.get('trail')\n\n    r = __salt__['boto_cloudtrail.status'](Name=Name,\n                   region=region, key=key, keyid=keyid, profile=profile)\n    _describe['LoggingEnabled'] = r.get('trail', {}).get('IsLogging', False)\n\n    need_update = False\n    bucket_vars = {'S3BucketName': 'S3BucketName',\n                   'S3KeyPrefix': 'S3KeyPrefix',\n                   'SnsTopicName': 'SnsTopicName',\n                   'IncludeGlobalServiceEvents': 'IncludeGlobalServiceEvents',\n                   'IsMultiRegionTrail': 'IsMultiRegionTrail',\n                   'EnableLogFileValidation': 'LogFileValidationEnabled',\n                   'CloudWatchLogsLogGroupArn': 'CloudWatchLogsLogGroupArn',\n                   'CloudWatchLogsRoleArn': 'CloudWatchLogsRoleArn',\n                   'KmsKeyId': 'KmsKeyId',\n                   'LoggingEnabled': 'LoggingEnabled'}\n\n    for invar, outvar in six.iteritems(bucket_vars):\n        if _describe[outvar] != locals()[invar]:\n            need_update = True\n            ret['changes'].setdefault('new', {})[invar] = locals()[invar]\n            ret['changes'].setdefault('old', {})[invar] = _describe[outvar]\n\n    r = __salt__['boto_cloudtrail.list_tags'](Name=Name,\n                   region=region, key=key, keyid=keyid, profile=profile)\n    _describe['Tags'] = r.get('tags', {})\n    tagchange = salt.utils.data.compare_dicts(_describe['Tags'], Tags)\n    if bool(tagchange):\n        need_update = True\n        ret['changes'].setdefault('new', {})['Tags'] = Tags\n        ret['changes'].setdefault('old', {})['Tags'] = _describe['Tags']\n\n    if need_update:\n        if __opts__['test']:\n            msg = 'CloudTrail {0} set to be modified.'.format(Name)\n            ret['comment'] = msg\n            ret['result'] = None\n            return ret\n\n        ret['comment'] = os.linesep.join([ret['comment'], 'CloudTrail to be modified'])\n        r = __salt__['boto_cloudtrail.update'](Name=Name,\n                   S3BucketName=S3BucketName,\n                   S3KeyPrefix=S3KeyPrefix,\n                   SnsTopicName=SnsTopicName,\n                   IncludeGlobalServiceEvents=IncludeGlobalServiceEvents,\n                   IsMultiRegionTrail=IsMultiRegionTrail,\n                   EnableLogFileValidation=EnableLogFileValidation,\n                   CloudWatchLogsLogGroupArn=CloudWatchLogsLogGroupArn,\n                   CloudWatchLogsRoleArn=CloudWatchLogsRoleArn,\n                   KmsKeyId=KmsKeyId,\n                   region=region, key=key, keyid=keyid, profile=profile)\n        if not r.get('updated'):\n            ret['result'] = False\n            ret['comment'] = 'Failed to update trail: {0}.'.format(r['error']['message'])\n            ret['changes'] = {}\n            return ret\n\n        if LoggingEnabled:\n            r = __salt__['boto_cloudtrail.start_logging'](Name=Name,\n                   region=region, key=key, keyid=keyid, profile=profile)\n            if not r.get('started'):\n                ret['result'] = False\n                ret['comment'] = 'Failed to update trail: {0}.'.format(r['error']['message'])\n                ret['changes'] = {}\n                return ret\n        else:\n            r = __salt__['boto_cloudtrail.stop_logging'](Name=Name,\n                   region=region, key=key, keyid=keyid, profile=profile)\n            if not r.get('stopped'):\n                ret['result'] = False\n                ret['comment'] = 'Failed to update trail: {0}.'.format(r['error']['message'])\n                ret['changes'] = {}\n                return ret\n\n        if bool(tagchange):\n            adds = {}\n            removes = {}\n            for k, diff in six.iteritems(tagchange):\n                if diff.get('new', '') != '':\n                    # there's an update for this key\n                    adds[k] = Tags[k]\n                elif diff.get('old', '') != '':\n                    removes[k] = _describe['Tags'][k]\n            if bool(adds):\n                r = __salt__['boto_cloudtrail.add_tags'](Name=Name,\n                   region=region, key=key, keyid=keyid, profile=profile, **adds)\n            if bool(removes):\n                r = __salt__['boto_cloudtrail.remove_tags'](Name=Name,\n                   region=region, key=key, keyid=keyid, profile=profile,\n                   **removes)\n\n    return ret", "code_tokens": ["def", "present", "(", "name", ",", "Name", ",", "S3BucketName", ",", "S3KeyPrefix", "=", "None", ",", "SnsTopicName", "=", "None", ",", "IncludeGlobalServiceEvents", "=", "True", ",", "IsMultiRegionTrail", "=", "None", ",", "EnableLogFileValidation", "=", "False", ",", "CloudWatchLogsLogGroupArn", "=", "None", ",", "CloudWatchLogsRoleArn", "=", "None", ",", "KmsKeyId", "=", "None", ",", "LoggingEnabled", "=", "True", ",", "Tags", "=", "None", ",", "region", "=", "None", ",", "key", "=", "None", ",", "keyid", "=", "None", ",", "profile", "=", "None", ")", ":", "ret", "=", "{", "'name'", ":", "Name", ",", "'result'", ":", "True", ",", "'comment'", ":", "''", ",", "'changes'", ":", "{", "}", "}", "r", "=", "__salt__", "[", "'boto_cloudtrail.exists'", "]", "(", "Name", "=", "Name", ",", "region", "=", "region", ",", "key", "=", "key", ",", "keyid", "=", "keyid", ",", "profile", "=", "profile", ")", "if", "'error'", "in", "r", ":", "ret", "[", "'result'", "]", "=", "False", "ret", "[", "'comment'", "]", "=", "'Failed to create trail: {0}.'", ".", "format", "(", "r", "[", "'error'", "]", "[", "'message'", "]", ")", "return", "ret", "if", "not", "r", ".", "get", "(", "'exists'", ")", ":", "if", "__opts__", "[", "'test'", "]", ":", "ret", "[", "'comment'", "]", "=", "'CloudTrail {0} is set to be created.'", ".", "format", "(", "Name", ")", "ret", "[", "'result'", "]", "=", "None", "return", "ret", "r", "=", "__salt__", "[", "'boto_cloudtrail.create'", "]", "(", "Name", "=", "Name", ",", "S3BucketName", "=", "S3BucketName", ",", "S3KeyPrefix", "=", "S3KeyPrefix", ",", "SnsTopicName", "=", "SnsTopicName", ",", "IncludeGlobalServiceEvents", "=", "IncludeGlobalServiceEvents", ",", "IsMultiRegionTrail", "=", "IsMultiRegionTrail", ",", "EnableLogFileValidation", "=", "EnableLogFileValidation", ",", "CloudWatchLogsLogGroupArn", "=", "CloudWatchLogsLogGroupArn", ",", "CloudWatchLogsRoleArn", "=", "CloudWatchLogsRoleArn", ",", "KmsKeyId", "=", "KmsKeyId", ",", "region", "=", "region", ",", "key", "=", "key", ",", "keyid", "=", "keyid", ",", "profile", "=", "profile", ")", "if", "not", "r", ".", "get", "(", "'created'", ")", ":", "ret", "[", "'result'", "]", "=", "False", "ret", "[", "'comment'", "]", "=", "'Failed to create trail: {0}.'", ".", "format", "(", "r", "[", "'error'", "]", "[", "'message'", "]", ")", "return", "ret", "_describe", "=", "__salt__", "[", "'boto_cloudtrail.describe'", "]", "(", "Name", ",", "region", "=", "region", ",", "key", "=", "key", ",", "keyid", "=", "keyid", ",", "profile", "=", "profile", ")", "ret", "[", "'changes'", "]", "[", "'old'", "]", "=", "{", "'trail'", ":", "None", "}", "ret", "[", "'changes'", "]", "[", "'new'", "]", "=", "_describe", "ret", "[", "'comment'", "]", "=", "'CloudTrail {0} created.'", ".", "format", "(", "Name", ")", "if", "LoggingEnabled", ":", "r", "=", "__salt__", "[", "'boto_cloudtrail.start_logging'", "]", "(", "Name", "=", "Name", ",", "region", "=", "region", ",", "key", "=", "key", ",", "keyid", "=", "keyid", ",", "profile", "=", "profile", ")", "if", "'error'", "in", "r", ":", "ret", "[", "'result'", "]", "=", "False", "ret", "[", "'comment'", "]", "=", "'Failed to create trail: {0}.'", ".", "format", "(", "r", "[", "'error'", "]", "[", "'message'", "]", ")", "ret", "[", "'changes'", "]", "=", "{", "}", "return", "ret", "ret", "[", "'changes'", "]", "[", "'new'", "]", "[", "'trail'", "]", "[", "'LoggingEnabled'", "]", "=", "True", "else", ":", "ret", "[", "'changes'", "]", "[", "'new'", "]", "[", "'trail'", "]", "[", "'LoggingEnabled'", "]", "=", "False", "if", "bool", "(", "Tags", ")", ":", "r", "=", "__salt__", "[", "'boto_cloudtrail.add_tags'", "]", "(", "Name", "=", "Name", ",", "region", "=", "region", ",", "key", "=", "key", ",", "keyid", "=", "keyid", ",", "profile", "=", "profile", ",", "*", "*", "Tags", ")", "if", "not", "r", ".", "get", "(", "'tagged'", ")", ":", "ret", "[", "'result'", "]", "=", "False", "ret", "[", "'comment'", "]", "=", "'Failed to create trail: {0}.'", ".", "format", "(", "r", "[", "'error'", "]", "[", "'message'", "]", ")", "ret", "[", "'changes'", "]", "=", "{", "}", "return", "ret", "ret", "[", "'changes'", "]", "[", "'new'", "]", "[", "'trail'", "]", "[", "'Tags'", "]", "=", "Tags", "return", "ret", "ret", "[", "'comment'", "]", "=", "os", ".", "linesep", ".", "join", "(", "[", "ret", "[", "'comment'", "]", ",", "'CloudTrail {0} is present.'", ".", "format", "(", "Name", ")", "]", ")", "ret", "[", "'changes'", "]", "=", "{", "}", "# trail exists, ensure config matches", "_describe", "=", "__salt__", "[", "'boto_cloudtrail.describe'", "]", "(", "Name", "=", "Name", ",", "region", "=", "region", ",", "key", "=", "key", ",", "keyid", "=", "keyid", ",", "profile", "=", "profile", ")", "if", "'error'", "in", "_describe", ":", "ret", "[", "'result'", "]", "=", "False", "ret", "[", "'comment'", "]", "=", "'Failed to update trail: {0}.'", ".", "format", "(", "_describe", "[", "'error'", "]", "[", "'message'", "]", ")", "ret", "[", "'changes'", "]", "=", "{", "}", "return", "ret", "_describe", "=", "_describe", ".", "get", "(", "'trail'", ")", "r", "=", "__salt__", "[", "'boto_cloudtrail.status'", "]", "(", "Name", "=", "Name", ",", "region", "=", "region", ",", "key", "=", "key", ",", "keyid", "=", "keyid", ",", "profile", "=", "profile", ")", "_describe", "[", "'LoggingEnabled'", "]", "=", "r", ".", "get", "(", "'trail'", ",", "{", "}", ")", ".", "get", "(", "'IsLogging'", ",", "False", ")", "need_update", "=", "False", "bucket_vars", "=", "{", "'S3BucketName'", ":", "'S3BucketName'", ",", "'S3KeyPrefix'", ":", "'S3KeyPrefix'", ",", "'SnsTopicName'", ":", "'SnsTopicName'", ",", "'IncludeGlobalServiceEvents'", ":", "'IncludeGlobalServiceEvents'", ",", "'IsMultiRegionTrail'", ":", "'IsMultiRegionTrail'", ",", "'EnableLogFileValidation'", ":", "'LogFileValidationEnabled'", ",", "'CloudWatchLogsLogGroupArn'", ":", "'CloudWatchLogsLogGroupArn'", ",", "'CloudWatchLogsRoleArn'", ":", "'CloudWatchLogsRoleArn'", ",", "'KmsKeyId'", ":", "'KmsKeyId'", ",", "'LoggingEnabled'", ":", "'LoggingEnabled'", "}", "for", "invar", ",", "outvar", "in", "six", ".", "iteritems", "(", "bucket_vars", ")", ":", "if", "_describe", "[", "outvar", "]", "!=", "locals", "(", ")", "[", "invar", "]", ":", "need_update", "=", "True", "ret", "[", "'changes'", "]", ".", "setdefault", "(", "'new'", ",", "{", "}", ")", "[", "invar", "]", "=", "locals", "(", ")", "[", "invar", "]", "ret", "[", "'changes'", "]", ".", "setdefault", "(", "'old'", ",", "{", "}", ")", "[", "invar", "]", "=", "_describe", "[", "outvar", "]", "r", "=", "__salt__", "[", "'boto_cloudtrail.list_tags'", "]", "(", "Name", "=", "Name", ",", "region", "=", "region", ",", "key", "=", "key", ",", "keyid", "=", "keyid", ",", "profile", "=", "profile", ")", "_describe", "[", "'Tags'", "]", "=", "r", ".", "get", "(", "'tags'", ",", "{", "}", ")", "tagchange", "=", "salt", ".", "utils", ".", "data", ".", "compare_dicts", "(", "_describe", "[", "'Tags'", "]", ",", "Tags", ")", "if", "bool", "(", "tagchange", ")", ":", "need_update", "=", "True", "ret", "[", "'changes'", "]", ".", "setdefault", "(", "'new'", ",", "{", "}", ")", "[", "'Tags'", "]", "=", "Tags", "ret", "[", "'changes'", "]", ".", "setdefault", "(", "'old'", ",", "{", "}", ")", "[", "'Tags'", "]", "=", "_describe", "[", "'Tags'", "]", "if", "need_update", ":", "if", "__opts__", "[", "'test'", "]", ":", "msg", "=", "'CloudTrail {0} set to be modified.'", ".", "format", "(", "Name", ")", "ret", "[", "'comment'", "]", "=", "msg", "ret", "[", "'result'", "]", "=", "None", "return", "ret", "ret", "[", "'comment'", "]", "=", "os", ".", "linesep", ".", "join", "(", "[", "ret", "[", "'comment'", "]", ",", "'CloudTrail to be modified'", "]", ")", "r", "=", "__salt__", "[", "'boto_cloudtrail.update'", "]", "(", "Name", "=", "Name", ",", "S3BucketName", "=", "S3BucketName", ",", "S3KeyPrefix", "=", "S3KeyPrefix", ",", "SnsTopicName", "=", "SnsTopicName", ",", "IncludeGlobalServiceEvents", "=", "IncludeGlobalServiceEvents", ",", "IsMultiRegionTrail", "=", "IsMultiRegionTrail", ",", "EnableLogFileValidation", "=", "EnableLogFileValidation", ",", "CloudWatchLogsLogGroupArn", "=", "CloudWatchLogsLogGroupArn", ",", "CloudWatchLogsRoleArn", "=", "CloudWatchLogsRoleArn", ",", "KmsKeyId", "=", "KmsKeyId", ",", "region", "=", "region", ",", "key", "=", "key", ",", "keyid", "=", "keyid", ",", "profile", "=", "profile", ")", "if", "not", "r", ".", "get", "(", "'updated'", ")", ":", "ret", "[", "'result'", "]", "=", "False", "ret", "[", "'comment'", "]", "=", "'Failed to update trail: {0}.'", ".", "format", "(", "r", "[", "'error'", "]", "[", "'message'", "]", ")", "ret", "[", "'changes'", "]", "=", "{", "}", "return", "ret", "if", "LoggingEnabled", ":", "r", "=", "__salt__", "[", "'boto_cloudtrail.start_logging'", "]", "(", "Name", "=", "Name", ",", "region", "=", "region", ",", "key", "=", "key", ",", "keyid", "=", "keyid", ",", "profile", "=", "profile", ")", "if", "not", "r", ".", "get", "(", "'started'", ")", ":", "ret", "[", "'result'", "]", "=", "False", "ret", "[", "'comment'", "]", "=", "'Failed to update trail: {0}.'", ".", "format", "(", "r", "[", "'error'", "]", "[", "'message'", "]", ")", "ret", "[", "'changes'", "]", "=", "{", "}", "return", "ret", "else", ":", "r", "=", "__salt__", "[", "'boto_cloudtrail.stop_logging'", "]", "(", "Name", "=", "Name", ",", "region", "=", "region", ",", "key", "=", "key", ",", "keyid", "=", "keyid", ",", "profile", "=", "profile", ")", "if", "not", "r", ".", "get", "(", "'stopped'", ")", ":", "ret", "[", "'result'", "]", "=", "False", "ret", "[", "'comment'", "]", "=", "'Failed to update trail: {0}.'", ".", "format", "(", "r", "[", "'error'", "]", "[", "'message'", "]", ")", "ret", "[", "'changes'", "]", "=", "{", "}", "return", "ret", "if", "bool", "(", "tagchange", ")", ":", "adds", "=", "{", "}", "removes", "=", "{", "}", "for", "k", ",", "diff", "in", "six", ".", "iteritems", "(", "tagchange", ")", ":", "if", "diff", ".", "get", "(", "'new'", ",", "''", ")", "!=", "''", ":", "# there's an update for this key", "adds", "[", "k", "]", "=", "Tags", "[", "k", "]", "elif", "diff", ".", "get", "(", "'old'", ",", "''", ")", "!=", "''", ":", "removes", "[", "k", "]", "=", "_describe", "[", "'Tags'", "]", "[", "k", "]", "if", "bool", "(", "adds", ")", ":", "r", "=", "__salt__", "[", "'boto_cloudtrail.add_tags'", "]", "(", "Name", "=", "Name", ",", "region", "=", "region", ",", "key", "=", "key", ",", "keyid", "=", "keyid", ",", "profile", "=", "profile", ",", "*", "*", "adds", ")", "if", "bool", "(", "removes", ")", ":", "r", "=", "__salt__", "[", "'boto_cloudtrail.remove_tags'", "]", "(", "Name", "=", "Name", ",", "region", "=", "region", ",", "key", "=", "key", ",", "keyid", "=", "keyid", ",", "profile", "=", "profile", ",", "*", "*", "removes", ")", "return", "ret"], "docstring": "Ensure trail exists.\n\n    name\n        The name of the state definition\n\n    Name\n        Name of the trail.\n\n    S3BucketName\n        Specifies the name of the Amazon S3 bucket designated for publishing log\n        files.\n\n    S3KeyPrefix\n        Specifies the Amazon S3 key prefix that comes after the name of the\n        bucket you have designated for log file delivery.\n\n    SnsTopicName\n        Specifies the name of the Amazon SNS topic defined for notification of\n        log file delivery. The maximum length is 256 characters.\n\n    IncludeGlobalServiceEvents\n        Specifies whether the trail is publishing events from global services\n        such as IAM to the log files.\n\n    EnableLogFileValidation\n        Specifies whether log file integrity validation is enabled. The default\n        is false.\n\n    CloudWatchLogsLogGroupArn\n        Specifies a log group name using an Amazon Resource Name (ARN), a unique\n        identifier that represents the log group to which CloudTrail logs will\n        be delivered. Not required unless you specify CloudWatchLogsRoleArn.\n\n    CloudWatchLogsRoleArn\n        Specifies the role for the CloudWatch Logs endpoint to assume to write\n        to a user's log group.\n\n    KmsKeyId\n        Specifies the KMS key ID to use to encrypt the logs delivered by\n        CloudTrail. The value can be a an alias name prefixed by \"alias/\", a\n        fully specified ARN to an alias, a fully specified ARN to a key, or a\n        globally unique identifier.\n\n    LoggingEnabled\n        Whether logging should be enabled for the trail\n\n    Tags\n        A dictionary of tags that should be set on the trail\n\n    region\n        Region to connect to.\n\n    key\n        Secret key to be used.\n\n    keyid\n        Access key to be used.\n\n    profile\n        A dict with region, key and keyid, or a pillar key (string) that\n        contains a dict with region, key and keyid.", "docstring_tokens": ["Ensure", "trail", "exists", "."], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/states/boto_cloudtrail.py#L75-L315", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/states/boto_cloudtrail.py", "func_name": "absent", "original_string": "def absent(name, Name,\n                  region=None, key=None, keyid=None, profile=None):\n    '''\n    Ensure trail with passed properties is absent.\n\n    name\n        The name of the state definition.\n\n    Name\n        Name of the trail.\n\n    region\n        Region to connect to.\n\n    key\n        Secret key to be used.\n\n    keyid\n        Access key to be used.\n\n    profile\n        A dict with region, key and keyid, or a pillar key (string) that\n        contains a dict with region, key and keyid.\n    '''\n\n    ret = {'name': Name,\n           'result': True,\n           'comment': '',\n           'changes': {}\n           }\n\n    r = __salt__['boto_cloudtrail.exists'](Name,\n                       region=region, key=key, keyid=keyid, profile=profile)\n    if 'error' in r:\n        ret['result'] = False\n        ret['comment'] = 'Failed to delete trail: {0}.'.format(r['error']['message'])\n        return ret\n\n    if r and not r['exists']:\n        ret['comment'] = 'CloudTrail {0} does not exist.'.format(Name)\n        return ret\n\n    if __opts__['test']:\n        ret['comment'] = 'CloudTrail {0} is set to be removed.'.format(Name)\n        ret['result'] = None\n        return ret\n    r = __salt__['boto_cloudtrail.delete'](Name,\n                                    region=region, key=key,\n                                    keyid=keyid, profile=profile)\n    if not r['deleted']:\n        ret['result'] = False\n        ret['comment'] = 'Failed to delete trail: {0}.'.format(r['error']['message'])\n        return ret\n    ret['changes']['old'] = {'trail': Name}\n    ret['changes']['new'] = {'trail': None}\n    ret['comment'] = 'CloudTrail {0} deleted.'.format(Name)\n    return ret", "language": "python", "code": "def absent(name, Name,\n                  region=None, key=None, keyid=None, profile=None):\n    '''\n    Ensure trail with passed properties is absent.\n\n    name\n        The name of the state definition.\n\n    Name\n        Name of the trail.\n\n    region\n        Region to connect to.\n\n    key\n        Secret key to be used.\n\n    keyid\n        Access key to be used.\n\n    profile\n        A dict with region, key and keyid, or a pillar key (string) that\n        contains a dict with region, key and keyid.\n    '''\n\n    ret = {'name': Name,\n           'result': True,\n           'comment': '',\n           'changes': {}\n           }\n\n    r = __salt__['boto_cloudtrail.exists'](Name,\n                       region=region, key=key, keyid=keyid, profile=profile)\n    if 'error' in r:\n        ret['result'] = False\n        ret['comment'] = 'Failed to delete trail: {0}.'.format(r['error']['message'])\n        return ret\n\n    if r and not r['exists']:\n        ret['comment'] = 'CloudTrail {0} does not exist.'.format(Name)\n        return ret\n\n    if __opts__['test']:\n        ret['comment'] = 'CloudTrail {0} is set to be removed.'.format(Name)\n        ret['result'] = None\n        return ret\n    r = __salt__['boto_cloudtrail.delete'](Name,\n                                    region=region, key=key,\n                                    keyid=keyid, profile=profile)\n    if not r['deleted']:\n        ret['result'] = False\n        ret['comment'] = 'Failed to delete trail: {0}.'.format(r['error']['message'])\n        return ret\n    ret['changes']['old'] = {'trail': Name}\n    ret['changes']['new'] = {'trail': None}\n    ret['comment'] = 'CloudTrail {0} deleted.'.format(Name)\n    return ret", "code_tokens": ["def", "absent", "(", "name", ",", "Name", ",", "region", "=", "None", ",", "key", "=", "None", ",", "keyid", "=", "None", ",", "profile", "=", "None", ")", ":", "ret", "=", "{", "'name'", ":", "Name", ",", "'result'", ":", "True", ",", "'comment'", ":", "''", ",", "'changes'", ":", "{", "}", "}", "r", "=", "__salt__", "[", "'boto_cloudtrail.exists'", "]", "(", "Name", ",", "region", "=", "region", ",", "key", "=", "key", ",", "keyid", "=", "keyid", ",", "profile", "=", "profile", ")", "if", "'error'", "in", "r", ":", "ret", "[", "'result'", "]", "=", "False", "ret", "[", "'comment'", "]", "=", "'Failed to delete trail: {0}.'", ".", "format", "(", "r", "[", "'error'", "]", "[", "'message'", "]", ")", "return", "ret", "if", "r", "and", "not", "r", "[", "'exists'", "]", ":", "ret", "[", "'comment'", "]", "=", "'CloudTrail {0} does not exist.'", ".", "format", "(", "Name", ")", "return", "ret", "if", "__opts__", "[", "'test'", "]", ":", "ret", "[", "'comment'", "]", "=", "'CloudTrail {0} is set to be removed.'", ".", "format", "(", "Name", ")", "ret", "[", "'result'", "]", "=", "None", "return", "ret", "r", "=", "__salt__", "[", "'boto_cloudtrail.delete'", "]", "(", "Name", ",", "region", "=", "region", ",", "key", "=", "key", ",", "keyid", "=", "keyid", ",", "profile", "=", "profile", ")", "if", "not", "r", "[", "'deleted'", "]", ":", "ret", "[", "'result'", "]", "=", "False", "ret", "[", "'comment'", "]", "=", "'Failed to delete trail: {0}.'", ".", "format", "(", "r", "[", "'error'", "]", "[", "'message'", "]", ")", "return", "ret", "ret", "[", "'changes'", "]", "[", "'old'", "]", "=", "{", "'trail'", ":", "Name", "}", "ret", "[", "'changes'", "]", "[", "'new'", "]", "=", "{", "'trail'", ":", "None", "}", "ret", "[", "'comment'", "]", "=", "'CloudTrail {0} deleted.'", ".", "format", "(", "Name", ")", "return", "ret"], "docstring": "Ensure trail with passed properties is absent.\n\n    name\n        The name of the state definition.\n\n    Name\n        Name of the trail.\n\n    region\n        Region to connect to.\n\n    key\n        Secret key to be used.\n\n    keyid\n        Access key to be used.\n\n    profile\n        A dict with region, key and keyid, or a pillar key (string) that\n        contains a dict with region, key and keyid.", "docstring_tokens": ["Ensure", "trail", "with", "passed", "properties", "is", "absent", "."], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/states/boto_cloudtrail.py#L318-L374", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/transport/__init__.py", "func_name": "iter_transport_opts", "original_string": "def iter_transport_opts(opts):\n    '''\n    Yield transport, opts for all master configured transports\n    '''\n    transports = set()\n\n    for transport, opts_overrides in six.iteritems(opts.get('transport_opts', {})):\n        t_opts = dict(opts)\n        t_opts.update(opts_overrides)\n        t_opts['transport'] = transport\n        transports.add(transport)\n        yield transport, t_opts\n\n    if opts['transport'] not in transports:\n        yield opts['transport'], opts", "language": "python", "code": "def iter_transport_opts(opts):\n    '''\n    Yield transport, opts for all master configured transports\n    '''\n    transports = set()\n\n    for transport, opts_overrides in six.iteritems(opts.get('transport_opts', {})):\n        t_opts = dict(opts)\n        t_opts.update(opts_overrides)\n        t_opts['transport'] = transport\n        transports.add(transport)\n        yield transport, t_opts\n\n    if opts['transport'] not in transports:\n        yield opts['transport'], opts", "code_tokens": ["def", "iter_transport_opts", "(", "opts", ")", ":", "transports", "=", "set", "(", ")", "for", "transport", ",", "opts_overrides", "in", "six", ".", "iteritems", "(", "opts", ".", "get", "(", "'transport_opts'", ",", "{", "}", ")", ")", ":", "t_opts", "=", "dict", "(", "opts", ")", "t_opts", ".", "update", "(", "opts_overrides", ")", "t_opts", "[", "'transport'", "]", "=", "transport", "transports", ".", "add", "(", "transport", ")", "yield", "transport", ",", "t_opts", "if", "opts", "[", "'transport'", "]", "not", "in", "transports", ":", "yield", "opts", "[", "'transport'", "]", ",", "opts"], "docstring": "Yield transport, opts for all master configured transports", "docstring_tokens": ["Yield", "transport", "opts", "for", "all", "master", "configured", "transports"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/transport/__init__.py#L19-L33", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/thorium/check.py", "func_name": "gt", "original_string": "def gt(name, value):\n    '''\n    Only succeed if the value in the given register location is greater than\n    the given value\n\n    USAGE:\n\n    .. code-block:: yaml\n\n        foo:\n          check.gt:\n            - value: 42\n\n        run_remote_ex:\n          local.cmd:\n            - tgt: '*'\n            - func: test.ping\n            - require:\n              - check: foo\n    '''\n    ret = {'name': name,\n           'result': False,\n           'comment': '',\n           'changes': {}}\n    if name not in __reg__:\n        ret['result'] = False\n        ret['comment'] = 'Value {0} not in register'.format(name)\n        return ret\n    if __reg__[name]['val'] > value:\n        ret['result'] = True\n    return ret", "language": "python", "code": "def gt(name, value):\n    '''\n    Only succeed if the value in the given register location is greater than\n    the given value\n\n    USAGE:\n\n    .. code-block:: yaml\n\n        foo:\n          check.gt:\n            - value: 42\n\n        run_remote_ex:\n          local.cmd:\n            - tgt: '*'\n            - func: test.ping\n            - require:\n              - check: foo\n    '''\n    ret = {'name': name,\n           'result': False,\n           'comment': '',\n           'changes': {}}\n    if name not in __reg__:\n        ret['result'] = False\n        ret['comment'] = 'Value {0} not in register'.format(name)\n        return ret\n    if __reg__[name]['val'] > value:\n        ret['result'] = True\n    return ret", "code_tokens": ["def", "gt", "(", "name", ",", "value", ")", ":", "ret", "=", "{", "'name'", ":", "name", ",", "'result'", ":", "False", ",", "'comment'", ":", "''", ",", "'changes'", ":", "{", "}", "}", "if", "name", "not", "in", "__reg__", ":", "ret", "[", "'result'", "]", "=", "False", "ret", "[", "'comment'", "]", "=", "'Value {0} not in register'", ".", "format", "(", "name", ")", "return", "ret", "if", "__reg__", "[", "name", "]", "[", "'val'", "]", ">", "value", ":", "ret", "[", "'result'", "]", "=", "True", "return", "ret"], "docstring": "Only succeed if the value in the given register location is greater than\n    the given value\n\n    USAGE:\n\n    .. code-block:: yaml\n\n        foo:\n          check.gt:\n            - value: 42\n\n        run_remote_ex:\n          local.cmd:\n            - tgt: '*'\n            - func: test.ping\n            - require:\n              - check: foo", "docstring_tokens": ["Only", "succeed", "if", "the", "value", "in", "the", "given", "register", "location", "is", "greater", "than", "the", "given", "value"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/thorium/check.py#L17-L47", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/thorium/check.py", "func_name": "gte", "original_string": "def gte(name, value):\n    '''\n    Only succeed if the value in the given register location is greater or equal\n    than the given value\n\n    USAGE:\n\n    .. code-block:: yaml\n\n        foo:\n          check.gte:\n            - value: 42\n\n        run_remote_ex:\n          local.cmd:\n            - tgt: '*'\n            - func: test.ping\n            - require:\n              - check: foo\n    '''\n    ret = {'name': name,\n           'result': False,\n           'comment': '',\n           'changes': {}}\n    if name not in __reg__:\n        ret['result'] = False\n        ret['comment'] = 'Value {0} not in register'.format(name)\n        return ret\n    if __reg__[name]['val'] >= value:\n        ret['result'] = True\n    return ret", "language": "python", "code": "def gte(name, value):\n    '''\n    Only succeed if the value in the given register location is greater or equal\n    than the given value\n\n    USAGE:\n\n    .. code-block:: yaml\n\n        foo:\n          check.gte:\n            - value: 42\n\n        run_remote_ex:\n          local.cmd:\n            - tgt: '*'\n            - func: test.ping\n            - require:\n              - check: foo\n    '''\n    ret = {'name': name,\n           'result': False,\n           'comment': '',\n           'changes': {}}\n    if name not in __reg__:\n        ret['result'] = False\n        ret['comment'] = 'Value {0} not in register'.format(name)\n        return ret\n    if __reg__[name]['val'] >= value:\n        ret['result'] = True\n    return ret", "code_tokens": ["def", "gte", "(", "name", ",", "value", ")", ":", "ret", "=", "{", "'name'", ":", "name", ",", "'result'", ":", "False", ",", "'comment'", ":", "''", ",", "'changes'", ":", "{", "}", "}", "if", "name", "not", "in", "__reg__", ":", "ret", "[", "'result'", "]", "=", "False", "ret", "[", "'comment'", "]", "=", "'Value {0} not in register'", ".", "format", "(", "name", ")", "return", "ret", "if", "__reg__", "[", "name", "]", "[", "'val'", "]", ">=", "value", ":", "ret", "[", "'result'", "]", "=", "True", "return", "ret"], "docstring": "Only succeed if the value in the given register location is greater or equal\n    than the given value\n\n    USAGE:\n\n    .. code-block:: yaml\n\n        foo:\n          check.gte:\n            - value: 42\n\n        run_remote_ex:\n          local.cmd:\n            - tgt: '*'\n            - func: test.ping\n            - require:\n              - check: foo", "docstring_tokens": ["Only", "succeed", "if", "the", "value", "in", "the", "given", "register", "location", "is", "greater", "or", "equal", "than", "the", "given", "value"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/thorium/check.py#L50-L80", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/thorium/check.py", "func_name": "lt", "original_string": "def lt(name, value):\n    '''\n    Only succeed if the value in the given register location is less than\n    the given value\n\n    USAGE:\n\n    .. code-block:: yaml\n\n        foo:\n          check.lt:\n            - value: 42\n\n        run_remote_ex:\n          local.cmd:\n            - tgt: '*'\n            - func: test.ping\n            - require:\n              - check: foo\n    '''\n    ret = {'name': name,\n           'result': False,\n           'comment': '',\n           'changes': {}}\n    if name not in __reg__:\n        ret['result'] = False\n        ret['comment'] = 'Value {0} not in register'.format(name)\n        return ret\n    if __reg__[name]['val'] < value:\n        ret['result'] = True\n    return ret", "language": "python", "code": "def lt(name, value):\n    '''\n    Only succeed if the value in the given register location is less than\n    the given value\n\n    USAGE:\n\n    .. code-block:: yaml\n\n        foo:\n          check.lt:\n            - value: 42\n\n        run_remote_ex:\n          local.cmd:\n            - tgt: '*'\n            - func: test.ping\n            - require:\n              - check: foo\n    '''\n    ret = {'name': name,\n           'result': False,\n           'comment': '',\n           'changes': {}}\n    if name not in __reg__:\n        ret['result'] = False\n        ret['comment'] = 'Value {0} not in register'.format(name)\n        return ret\n    if __reg__[name]['val'] < value:\n        ret['result'] = True\n    return ret", "code_tokens": ["def", "lt", "(", "name", ",", "value", ")", ":", "ret", "=", "{", "'name'", ":", "name", ",", "'result'", ":", "False", ",", "'comment'", ":", "''", ",", "'changes'", ":", "{", "}", "}", "if", "name", "not", "in", "__reg__", ":", "ret", "[", "'result'", "]", "=", "False", "ret", "[", "'comment'", "]", "=", "'Value {0} not in register'", ".", "format", "(", "name", ")", "return", "ret", "if", "__reg__", "[", "name", "]", "[", "'val'", "]", "<", "value", ":", "ret", "[", "'result'", "]", "=", "True", "return", "ret"], "docstring": "Only succeed if the value in the given register location is less than\n    the given value\n\n    USAGE:\n\n    .. code-block:: yaml\n\n        foo:\n          check.lt:\n            - value: 42\n\n        run_remote_ex:\n          local.cmd:\n            - tgt: '*'\n            - func: test.ping\n            - require:\n              - check: foo", "docstring_tokens": ["Only", "succeed", "if", "the", "value", "in", "the", "given", "register", "location", "is", "less", "than", "the", "given", "value"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/thorium/check.py#L83-L113", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/thorium/check.py", "func_name": "lte", "original_string": "def lte(name, value):\n    '''\n    Only succeed if the value in the given register location is less than\n    or equal the given value\n\n    USAGE:\n\n    .. code-block:: yaml\n\n        foo:\n          check.lte:\n            - value: 42\n\n        run_remote_ex:\n          local.cmd:\n            - tgt: '*'\n            - func: test.ping\n            - require:\n              - check: foo\n    '''\n    ret = {'name': name,\n           'result': False,\n           'comment': '',\n           'changes': {}}\n    if name not in __reg__:\n        ret['result'] = False\n        ret['comment'] = 'Value {0} not in register'.format(name)\n        return ret\n    if __reg__[name]['val'] <= value:\n        ret['result'] = True\n    return ret", "language": "python", "code": "def lte(name, value):\n    '''\n    Only succeed if the value in the given register location is less than\n    or equal the given value\n\n    USAGE:\n\n    .. code-block:: yaml\n\n        foo:\n          check.lte:\n            - value: 42\n\n        run_remote_ex:\n          local.cmd:\n            - tgt: '*'\n            - func: test.ping\n            - require:\n              - check: foo\n    '''\n    ret = {'name': name,\n           'result': False,\n           'comment': '',\n           'changes': {}}\n    if name not in __reg__:\n        ret['result'] = False\n        ret['comment'] = 'Value {0} not in register'.format(name)\n        return ret\n    if __reg__[name]['val'] <= value:\n        ret['result'] = True\n    return ret", "code_tokens": ["def", "lte", "(", "name", ",", "value", ")", ":", "ret", "=", "{", "'name'", ":", "name", ",", "'result'", ":", "False", ",", "'comment'", ":", "''", ",", "'changes'", ":", "{", "}", "}", "if", "name", "not", "in", "__reg__", ":", "ret", "[", "'result'", "]", "=", "False", "ret", "[", "'comment'", "]", "=", "'Value {0} not in register'", ".", "format", "(", "name", ")", "return", "ret", "if", "__reg__", "[", "name", "]", "[", "'val'", "]", "<=", "value", ":", "ret", "[", "'result'", "]", "=", "True", "return", "ret"], "docstring": "Only succeed if the value in the given register location is less than\n    or equal the given value\n\n    USAGE:\n\n    .. code-block:: yaml\n\n        foo:\n          check.lte:\n            - value: 42\n\n        run_remote_ex:\n          local.cmd:\n            - tgt: '*'\n            - func: test.ping\n            - require:\n              - check: foo", "docstring_tokens": ["Only", "succeed", "if", "the", "value", "in", "the", "given", "register", "location", "is", "less", "than", "or", "equal", "the", "given", "value"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/thorium/check.py#L116-L146", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/thorium/check.py", "func_name": "eq", "original_string": "def eq(name, value):\n    '''\n    Only succeed if the value in the given register location is equal to\n    the given value\n\n    USAGE:\n\n    .. code-block:: yaml\n\n        foo:\n          check.eq:\n            - value: 42\n\n        run_remote_ex:\n          local.cmd:\n            - tgt: '*'\n            - func: test.ping\n            - require:\n              - check: foo\n    '''\n    ret = {'name': name,\n           'result': False,\n           'comment': '',\n           'changes': {}}\n    if name not in __reg__:\n        ret['result'] = False\n        ret['comment'] = 'Value {0} not in register'.format(name)\n        return ret\n    if __reg__[name]['val'] == value:\n        ret['result'] = True\n    return ret", "language": "python", "code": "def eq(name, value):\n    '''\n    Only succeed if the value in the given register location is equal to\n    the given value\n\n    USAGE:\n\n    .. code-block:: yaml\n\n        foo:\n          check.eq:\n            - value: 42\n\n        run_remote_ex:\n          local.cmd:\n            - tgt: '*'\n            - func: test.ping\n            - require:\n              - check: foo\n    '''\n    ret = {'name': name,\n           'result': False,\n           'comment': '',\n           'changes': {}}\n    if name not in __reg__:\n        ret['result'] = False\n        ret['comment'] = 'Value {0} not in register'.format(name)\n        return ret\n    if __reg__[name]['val'] == value:\n        ret['result'] = True\n    return ret", "code_tokens": ["def", "eq", "(", "name", ",", "value", ")", ":", "ret", "=", "{", "'name'", ":", "name", ",", "'result'", ":", "False", ",", "'comment'", ":", "''", ",", "'changes'", ":", "{", "}", "}", "if", "name", "not", "in", "__reg__", ":", "ret", "[", "'result'", "]", "=", "False", "ret", "[", "'comment'", "]", "=", "'Value {0} not in register'", ".", "format", "(", "name", ")", "return", "ret", "if", "__reg__", "[", "name", "]", "[", "'val'", "]", "==", "value", ":", "ret", "[", "'result'", "]", "=", "True", "return", "ret"], "docstring": "Only succeed if the value in the given register location is equal to\n    the given value\n\n    USAGE:\n\n    .. code-block:: yaml\n\n        foo:\n          check.eq:\n            - value: 42\n\n        run_remote_ex:\n          local.cmd:\n            - tgt: '*'\n            - func: test.ping\n            - require:\n              - check: foo", "docstring_tokens": ["Only", "succeed", "if", "the", "value", "in", "the", "given", "register", "location", "is", "equal", "to", "the", "given", "value"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/thorium/check.py#L149-L179", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/thorium/check.py", "func_name": "ne", "original_string": "def ne(name, value):\n    '''\n    Only succeed if the value in the given register location is not equal to\n    the given value\n\n    USAGE:\n\n    .. code-block:: yaml\n\n        foo:\n          check.ne:\n            - value: 42\n\n        run_remote_ex:\n          local.cmd:\n            - tgt: '*'\n            - func: test.ping\n            - require:\n              - check: foo\n    '''\n    ret = {'name': name,\n           'result': False,\n           'comment': '',\n           'changes': {}}\n    if name not in __reg__:\n        ret['result'] = False\n        ret['comment'] = 'Value {0} not in register'.format(name)\n        return ret\n    if __reg__[name]['val'] != value:\n        ret['result'] = True\n    return ret", "language": "python", "code": "def ne(name, value):\n    '''\n    Only succeed if the value in the given register location is not equal to\n    the given value\n\n    USAGE:\n\n    .. code-block:: yaml\n\n        foo:\n          check.ne:\n            - value: 42\n\n        run_remote_ex:\n          local.cmd:\n            - tgt: '*'\n            - func: test.ping\n            - require:\n              - check: foo\n    '''\n    ret = {'name': name,\n           'result': False,\n           'comment': '',\n           'changes': {}}\n    if name not in __reg__:\n        ret['result'] = False\n        ret['comment'] = 'Value {0} not in register'.format(name)\n        return ret\n    if __reg__[name]['val'] != value:\n        ret['result'] = True\n    return ret", "code_tokens": ["def", "ne", "(", "name", ",", "value", ")", ":", "ret", "=", "{", "'name'", ":", "name", ",", "'result'", ":", "False", ",", "'comment'", ":", "''", ",", "'changes'", ":", "{", "}", "}", "if", "name", "not", "in", "__reg__", ":", "ret", "[", "'result'", "]", "=", "False", "ret", "[", "'comment'", "]", "=", "'Value {0} not in register'", ".", "format", "(", "name", ")", "return", "ret", "if", "__reg__", "[", "name", "]", "[", "'val'", "]", "!=", "value", ":", "ret", "[", "'result'", "]", "=", "True", "return", "ret"], "docstring": "Only succeed if the value in the given register location is not equal to\n    the given value\n\n    USAGE:\n\n    .. code-block:: yaml\n\n        foo:\n          check.ne:\n            - value: 42\n\n        run_remote_ex:\n          local.cmd:\n            - tgt: '*'\n            - func: test.ping\n            - require:\n              - check: foo", "docstring_tokens": ["Only", "succeed", "if", "the", "value", "in", "the", "given", "register", "location", "is", "not", "equal", "to", "the", "given", "value"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/thorium/check.py#L182-L212", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/thorium/check.py", "func_name": "contains", "original_string": "def contains(name,\n             value,\n             count_lt=None,\n             count_lte=None,\n             count_eq=None,\n             count_gte=None,\n             count_gt=None,\n             count_ne=None):\n    '''\n    Only succeed if the value in the given register location contains\n    the given value\n\n    USAGE:\n\n    .. code-block:: yaml\n\n        foo:\n          check.contains:\n            - value: itni\n\n        run_remote_ex:\n          local.cmd:\n            - tgt: '*'\n            - func: test.ping\n            - require:\n              - check: foo\n    '''\n    ret = {'name': name,\n           'result': False,\n           'comment': '',\n           'changes': {}}\n    if name not in __reg__:\n        ret['result'] = False\n        ret['comment'] = 'Value {0} not in register'.format(name)\n        return ret\n    try:\n        count_compare = count_lt or count_lte or count_eq or\\\n                        count_gte or count_gt or count_ne\n        if count_compare:\n            occurrences = __reg__[name]['val'].count(value)\n            log.debug('%s appears %s times', value, occurrences)\n            ret['result'] = True\n            if count_lt:\n                ret['result'] &= occurrences < count_lt\n            if count_lte:\n                ret['result'] &= occurrences <= count_lte\n            if count_eq:\n                ret['result'] &= occurrences == count_eq\n            if count_gte:\n                ret['result'] &= occurrences >= count_gte\n            if count_gt:\n                ret['result'] &= occurrences > count_gt\n            if count_ne:\n                ret['result'] &= occurrences != count_ne\n        else:\n            if value in __reg__[name]['val']:\n                ret['result'] = True\n    except TypeError:\n        pass\n    return ret", "language": "python", "code": "def contains(name,\n             value,\n             count_lt=None,\n             count_lte=None,\n             count_eq=None,\n             count_gte=None,\n             count_gt=None,\n             count_ne=None):\n    '''\n    Only succeed if the value in the given register location contains\n    the given value\n\n    USAGE:\n\n    .. code-block:: yaml\n\n        foo:\n          check.contains:\n            - value: itni\n\n        run_remote_ex:\n          local.cmd:\n            - tgt: '*'\n            - func: test.ping\n            - require:\n              - check: foo\n    '''\n    ret = {'name': name,\n           'result': False,\n           'comment': '',\n           'changes': {}}\n    if name not in __reg__:\n        ret['result'] = False\n        ret['comment'] = 'Value {0} not in register'.format(name)\n        return ret\n    try:\n        count_compare = count_lt or count_lte or count_eq or\\\n                        count_gte or count_gt or count_ne\n        if count_compare:\n            occurrences = __reg__[name]['val'].count(value)\n            log.debug('%s appears %s times', value, occurrences)\n            ret['result'] = True\n            if count_lt:\n                ret['result'] &= occurrences < count_lt\n            if count_lte:\n                ret['result'] &= occurrences <= count_lte\n            if count_eq:\n                ret['result'] &= occurrences == count_eq\n            if count_gte:\n                ret['result'] &= occurrences >= count_gte\n            if count_gt:\n                ret['result'] &= occurrences > count_gt\n            if count_ne:\n                ret['result'] &= occurrences != count_ne\n        else:\n            if value in __reg__[name]['val']:\n                ret['result'] = True\n    except TypeError:\n        pass\n    return ret", "code_tokens": ["def", "contains", "(", "name", ",", "value", ",", "count_lt", "=", "None", ",", "count_lte", "=", "None", ",", "count_eq", "=", "None", ",", "count_gte", "=", "None", ",", "count_gt", "=", "None", ",", "count_ne", "=", "None", ")", ":", "ret", "=", "{", "'name'", ":", "name", ",", "'result'", ":", "False", ",", "'comment'", ":", "''", ",", "'changes'", ":", "{", "}", "}", "if", "name", "not", "in", "__reg__", ":", "ret", "[", "'result'", "]", "=", "False", "ret", "[", "'comment'", "]", "=", "'Value {0} not in register'", ".", "format", "(", "name", ")", "return", "ret", "try", ":", "count_compare", "=", "count_lt", "or", "count_lte", "or", "count_eq", "or", "count_gte", "or", "count_gt", "or", "count_ne", "if", "count_compare", ":", "occurrences", "=", "__reg__", "[", "name", "]", "[", "'val'", "]", ".", "count", "(", "value", ")", "log", ".", "debug", "(", "'%s appears %s times'", ",", "value", ",", "occurrences", ")", "ret", "[", "'result'", "]", "=", "True", "if", "count_lt", ":", "ret", "[", "'result'", "]", "&=", "occurrences", "<", "count_lt", "if", "count_lte", ":", "ret", "[", "'result'", "]", "&=", "occurrences", "<=", "count_lte", "if", "count_eq", ":", "ret", "[", "'result'", "]", "&=", "occurrences", "==", "count_eq", "if", "count_gte", ":", "ret", "[", "'result'", "]", "&=", "occurrences", ">=", "count_gte", "if", "count_gt", ":", "ret", "[", "'result'", "]", "&=", "occurrences", ">", "count_gt", "if", "count_ne", ":", "ret", "[", "'result'", "]", "&=", "occurrences", "!=", "count_ne", "else", ":", "if", "value", "in", "__reg__", "[", "name", "]", "[", "'val'", "]", ":", "ret", "[", "'result'", "]", "=", "True", "except", "TypeError", ":", "pass", "return", "ret"], "docstring": "Only succeed if the value in the given register location contains\n    the given value\n\n    USAGE:\n\n    .. code-block:: yaml\n\n        foo:\n          check.contains:\n            - value: itni\n\n        run_remote_ex:\n          local.cmd:\n            - tgt: '*'\n            - func: test.ping\n            - require:\n              - check: foo", "docstring_tokens": ["Only", "succeed", "if", "the", "value", "in", "the", "given", "register", "location", "contains", "the", "given", "value"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/thorium/check.py#L215-L274", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/thorium/check.py", "func_name": "event", "original_string": "def event(name):\n    '''\n    Chekcs for a specific event match and returns result True if the match\n    happens\n\n    USAGE:\n\n    .. code-block:: yaml\n\n        salt/foo/*/bar:\n          check.event\n\n        run_remote_ex:\n          local.cmd:\n            - tgt: '*'\n            - func: test.ping\n            - require:\n              - check: salt/foo/*/bar\n    '''\n    ret = {'name': name,\n           'changes': {},\n           'comment': '',\n           'result': False}\n\n    for event in __events__:\n        if salt.utils.stringutils.expr_match(event['tag'], name):\n            ret['result'] = True\n\n    return ret", "language": "python", "code": "def event(name):\n    '''\n    Chekcs for a specific event match and returns result True if the match\n    happens\n\n    USAGE:\n\n    .. code-block:: yaml\n\n        salt/foo/*/bar:\n          check.event\n\n        run_remote_ex:\n          local.cmd:\n            - tgt: '*'\n            - func: test.ping\n            - require:\n              - check: salt/foo/*/bar\n    '''\n    ret = {'name': name,\n           'changes': {},\n           'comment': '',\n           'result': False}\n\n    for event in __events__:\n        if salt.utils.stringutils.expr_match(event['tag'], name):\n            ret['result'] = True\n\n    return ret", "code_tokens": ["def", "event", "(", "name", ")", ":", "ret", "=", "{", "'name'", ":", "name", ",", "'changes'", ":", "{", "}", ",", "'comment'", ":", "''", ",", "'result'", ":", "False", "}", "for", "event", "in", "__events__", ":", "if", "salt", ".", "utils", ".", "stringutils", ".", "expr_match", "(", "event", "[", "'tag'", "]", ",", "name", ")", ":", "ret", "[", "'result'", "]", "=", "True", "return", "ret"], "docstring": "Chekcs for a specific event match and returns result True if the match\n    happens\n\n    USAGE:\n\n    .. code-block:: yaml\n\n        salt/foo/*/bar:\n          check.event\n\n        run_remote_ex:\n          local.cmd:\n            - tgt: '*'\n            - func: test.ping\n            - require:\n              - check: salt/foo/*/bar", "docstring_tokens": ["Chekcs", "for", "a", "specific", "event", "match", "and", "returns", "result", "True", "if", "the", "match", "happens"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/thorium/check.py#L277-L305", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/thorium/check.py", "func_name": "len_gt", "original_string": "def len_gt(name, value):\n    '''\n    Only succeed if length of the given register location is greater than\n    the given value.\n\n    USAGE:\n\n    .. code-block:: yaml\n\n        foo:\n          check.len_gt:\n            - value: 42\n\n        run_remote_ex:\n          local.cmd:\n            - tgt: '*'\n            - func: test.ping\n            - require:\n              - check: foo\n    '''\n    ret = {'name': name,\n           'result': False,\n           'comment': '',\n           'changes': {}}\n    if name not in __reg__:\n        ret['result'] = False\n        ret['comment'] = 'Value {0} not in register'.format(name)\n        return ret\n    if len(__reg__[name]['val']) > value:\n        ret['result'] = True\n    return ret", "language": "python", "code": "def len_gt(name, value):\n    '''\n    Only succeed if length of the given register location is greater than\n    the given value.\n\n    USAGE:\n\n    .. code-block:: yaml\n\n        foo:\n          check.len_gt:\n            - value: 42\n\n        run_remote_ex:\n          local.cmd:\n            - tgt: '*'\n            - func: test.ping\n            - require:\n              - check: foo\n    '''\n    ret = {'name': name,\n           'result': False,\n           'comment': '',\n           'changes': {}}\n    if name not in __reg__:\n        ret['result'] = False\n        ret['comment'] = 'Value {0} not in register'.format(name)\n        return ret\n    if len(__reg__[name]['val']) > value:\n        ret['result'] = True\n    return ret", "code_tokens": ["def", "len_gt", "(", "name", ",", "value", ")", ":", "ret", "=", "{", "'name'", ":", "name", ",", "'result'", ":", "False", ",", "'comment'", ":", "''", ",", "'changes'", ":", "{", "}", "}", "if", "name", "not", "in", "__reg__", ":", "ret", "[", "'result'", "]", "=", "False", "ret", "[", "'comment'", "]", "=", "'Value {0} not in register'", ".", "format", "(", "name", ")", "return", "ret", "if", "len", "(", "__reg__", "[", "name", "]", "[", "'val'", "]", ")", ">", "value", ":", "ret", "[", "'result'", "]", "=", "True", "return", "ret"], "docstring": "Only succeed if length of the given register location is greater than\n    the given value.\n\n    USAGE:\n\n    .. code-block:: yaml\n\n        foo:\n          check.len_gt:\n            - value: 42\n\n        run_remote_ex:\n          local.cmd:\n            - tgt: '*'\n            - func: test.ping\n            - require:\n              - check: foo", "docstring_tokens": ["Only", "succeed", "if", "length", "of", "the", "given", "register", "location", "is", "greater", "than", "the", "given", "value", "."], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/thorium/check.py#L308-L338", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/modules/napalm_users.py", "func_name": "set_users", "original_string": "def set_users(users, test=False, commit=True, **kwargs):  # pylint: disable=unused-argument\n\n    '''\n    Configures users on network devices.\n\n    :param users: Dictionary formatted as the output of the function config()\n\n    :param test: Dry run? If set as True, will apply the config, discard and\n        return the changes. Default: False\n\n    :param commit: Commit? (default: True) Sometimes it is not needed to commit\n        the config immediately after loading the changes. E.g.: a state loads a\n        couple of parts (add / remove / update) and would not be optimal to\n        commit after each operation.  Also, from the CLI when the user needs to\n        apply the similar changes before committing, can specify commit=False\n        and will not discard the config.\n\n    :raise MergeConfigException: If there is an error on the configuration sent.\n    :return a dictionary having the following keys:\n\n    - result (bool): if the config was applied successfully. It is `False` only\n      in case of failure. In case there are no changes to be applied and\n      successfully performs all operations it is still `True` and so will be\n      the `already_configured` flag (example below)\n    - comment (str): a message for the user\n    - already_configured (bool): flag to check if there were no changes applied\n    - diff (str): returns the config changes applied\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' users.set_users \"{'mircea': {}}\"\n    '''\n\n    return __salt__['net.load_template']('set_users',\n                                         users=users,\n                                         test=test,\n                                         commit=commit,\n                                         inherit_napalm_device=napalm_device)", "language": "python", "code": "def set_users(users, test=False, commit=True, **kwargs):  # pylint: disable=unused-argument\n\n    '''\n    Configures users on network devices.\n\n    :param users: Dictionary formatted as the output of the function config()\n\n    :param test: Dry run? If set as True, will apply the config, discard and\n        return the changes. Default: False\n\n    :param commit: Commit? (default: True) Sometimes it is not needed to commit\n        the config immediately after loading the changes. E.g.: a state loads a\n        couple of parts (add / remove / update) and would not be optimal to\n        commit after each operation.  Also, from the CLI when the user needs to\n        apply the similar changes before committing, can specify commit=False\n        and will not discard the config.\n\n    :raise MergeConfigException: If there is an error on the configuration sent.\n    :return a dictionary having the following keys:\n\n    - result (bool): if the config was applied successfully. It is `False` only\n      in case of failure. In case there are no changes to be applied and\n      successfully performs all operations it is still `True` and so will be\n      the `already_configured` flag (example below)\n    - comment (str): a message for the user\n    - already_configured (bool): flag to check if there were no changes applied\n    - diff (str): returns the config changes applied\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' users.set_users \"{'mircea': {}}\"\n    '''\n\n    return __salt__['net.load_template']('set_users',\n                                         users=users,\n                                         test=test,\n                                         commit=commit,\n                                         inherit_napalm_device=napalm_device)", "code_tokens": ["def", "set_users", "(", "users", ",", "test", "=", "False", ",", "commit", "=", "True", ",", "*", "*", "kwargs", ")", ":", "# pylint: disable=unused-argument", "return", "__salt__", "[", "'net.load_template'", "]", "(", "'set_users'", ",", "users", "=", "users", ",", "test", "=", "test", ",", "commit", "=", "commit", ",", "inherit_napalm_device", "=", "napalm_device", ")"], "docstring": "Configures users on network devices.\n\n    :param users: Dictionary formatted as the output of the function config()\n\n    :param test: Dry run? If set as True, will apply the config, discard and\n        return the changes. Default: False\n\n    :param commit: Commit? (default: True) Sometimes it is not needed to commit\n        the config immediately after loading the changes. E.g.: a state loads a\n        couple of parts (add / remove / update) and would not be optimal to\n        commit after each operation.  Also, from the CLI when the user needs to\n        apply the similar changes before committing, can specify commit=False\n        and will not discard the config.\n\n    :raise MergeConfigException: If there is an error on the configuration sent.\n    :return a dictionary having the following keys:\n\n    - result (bool): if the config was applied successfully. It is `False` only\n      in case of failure. In case there are no changes to be applied and\n      successfully performs all operations it is still `True` and so will be\n      the `already_configured` flag (example below)\n    - comment (str): a message for the user\n    - already_configured (bool): flag to check if there were no changes applied\n    - diff (str): returns the config changes applied\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' users.set_users \"{'mircea': {}}\"", "docstring_tokens": ["Configures", "users", "on", "network", "devices", "."], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/modules/napalm_users.py#L102-L141", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/cloud/clouds/virtualbox.py", "func_name": "map_clonemode", "original_string": "def map_clonemode(vm_info):\n    \"\"\"\n    Convert the virtualbox config file values for clone_mode into the integers the API requires\n    \"\"\"\n    mode_map = {\n      'state': 0,\n      'child': 1,\n      'all':   2\n    }\n\n    if not vm_info:\n        return DEFAULT_CLONE_MODE\n\n    if 'clonemode' not in vm_info:\n        return DEFAULT_CLONE_MODE\n\n    if vm_info['clonemode'] in mode_map:\n        return mode_map[vm_info['clonemode']]\n    else:\n        raise SaltCloudSystemExit(\n            \"Illegal clonemode for virtualbox profile.  Legal values are: {}\".format(','.join(mode_map.keys()))\n        )", "language": "python", "code": "def map_clonemode(vm_info):\n    \"\"\"\n    Convert the virtualbox config file values for clone_mode into the integers the API requires\n    \"\"\"\n    mode_map = {\n      'state': 0,\n      'child': 1,\n      'all':   2\n    }\n\n    if not vm_info:\n        return DEFAULT_CLONE_MODE\n\n    if 'clonemode' not in vm_info:\n        return DEFAULT_CLONE_MODE\n\n    if vm_info['clonemode'] in mode_map:\n        return mode_map[vm_info['clonemode']]\n    else:\n        raise SaltCloudSystemExit(\n            \"Illegal clonemode for virtualbox profile.  Legal values are: {}\".format(','.join(mode_map.keys()))\n        )", "code_tokens": ["def", "map_clonemode", "(", "vm_info", ")", ":", "mode_map", "=", "{", "'state'", ":", "0", ",", "'child'", ":", "1", ",", "'all'", ":", "2", "}", "if", "not", "vm_info", ":", "return", "DEFAULT_CLONE_MODE", "if", "'clonemode'", "not", "in", "vm_info", ":", "return", "DEFAULT_CLONE_MODE", "if", "vm_info", "[", "'clonemode'", "]", "in", "mode_map", ":", "return", "mode_map", "[", "vm_info", "[", "'clonemode'", "]", "]", "else", ":", "raise", "SaltCloudSystemExit", "(", "\"Illegal clonemode for virtualbox profile.  Legal values are: {}\"", ".", "format", "(", "','", ".", "join", "(", "mode_map", ".", "keys", "(", ")", ")", ")", ")"], "docstring": "Convert the virtualbox config file values for clone_mode into the integers the API requires", "docstring_tokens": ["Convert", "the", "virtualbox", "config", "file", "values", "for", "clone_mode", "into", "the", "integers", "the", "API", "requires"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/cloud/clouds/virtualbox.py#L92-L113", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/cloud/clouds/virtualbox.py", "func_name": "create", "original_string": "def create(vm_info):\n    '''\n    Creates a virtual machine from the given VM information\n\n    This is what is used to request a virtual machine to be created by the\n    cloud provider, wait for it to become available, and then (optionally) log\n    in and install Salt on it.\n\n    Events fired:\n\n    This function fires the event ``salt/cloud/vm_name/creating``, with the\n    payload containing the names of the VM, profile, and provider.\n\n    @param vm_info\n\n    .. code-block:: text\n\n        {\n            name: <str>\n            profile: <dict>\n            driver: <provider>:<profile>\n            clonefrom: <vm_name>\n            clonemode: <mode> (default: state, choices: state, child, all)\n        }\n\n    @type vm_info dict\n    @return dict of resulting vm. !!!Passwords can and should be included!!!\n    '''\n    try:\n        # Check for required profile parameters before sending any API calls.\n        if vm_info['profile'] and config.is_profile_configured(\n            __opts__,\n                __active_provider_name__ or 'virtualbox',\n            vm_info['profile']\n        ) is False:\n            return False\n    except AttributeError:\n        pass\n\n    vm_name = vm_info[\"name\"]\n    deploy = config.get_cloud_config_value(\n        'deploy', vm_info, __opts__, search_global=False, default=True\n    )\n    wait_for_ip_timeout = config.get_cloud_config_value(\n        'wait_for_ip_timeout', vm_info, __opts__, default=60\n    )\n    boot_timeout = config.get_cloud_config_value(\n        'boot_timeout', vm_info, __opts__, default=60 * 1000\n    )\n    power = config.get_cloud_config_value(\n        'power_on', vm_info, __opts__, default=False\n    )\n    key_filename = config.get_cloud_config_value(\n        'private_key', vm_info, __opts__, search_global=False, default=None\n    )\n    clone_mode = map_clonemode(vm_info)\n    wait_for_pattern = vm_info['waitforpattern'] if 'waitforpattern' in vm_info.keys() else None\n    interface_index = vm_info['interfaceindex'] if 'interfaceindex' in vm_info.keys() else 0\n\n    log.debug(\"Going to fire event: starting create\")\n    __utils__['cloud.fire_event'](\n        'event',\n        'starting create',\n        'salt/cloud/{0}/creating'.format(vm_info['name']),\n        args=__utils__['cloud.filter_event']('creating', vm_info, ['name', 'profile', 'provider', 'driver']),\n        sock_dir=__opts__['sock_dir'],\n        transport=__opts__['transport']\n    )\n\n    # to create the virtual machine.\n    request_kwargs = {\n        'name': vm_info['name'],\n        'clone_from': vm_info['clonefrom'],\n        'clone_mode': clone_mode\n    }\n\n    __utils__['cloud.fire_event'](\n        'event',\n        'requesting instance',\n        'salt/cloud/{0}/requesting'.format(vm_info['name']),\n        args=__utils__['cloud.filter_event']('requesting', request_kwargs, list(request_kwargs)),\n        sock_dir=__opts__['sock_dir'],\n        transport=__opts__['transport']\n    )\n    vm_result = vb_clone_vm(**request_kwargs)\n\n    # Booting and deploying if needed\n    if power:\n        vb_start_vm(vm_name, timeout=boot_timeout)\n        ips = vb_wait_for_network_address(wait_for_ip_timeout, machine_name=vm_name, wait_for_pattern=wait_for_pattern)\n\n        if ips:\n            ip = ips[interface_index]\n            log.info(\"[ %s ] IPv4 is: %s\", vm_name, ip)\n            # ssh or smb using ip and install salt only if deploy is True\n            if deploy:\n                vm_info['key_filename'] = key_filename\n                vm_info['ssh_host'] = ip\n\n                res = __utils__['cloud.bootstrap'](vm_info, __opts__)\n                vm_result.update(res)\n\n    __utils__['cloud.fire_event'](\n        'event',\n        'created machine',\n        'salt/cloud/{0}/created'.format(vm_info['name']),\n        args=__utils__['cloud.filter_event']('created', vm_result, list(vm_result)),\n        sock_dir=__opts__['sock_dir'],\n        transport=__opts__['transport']\n    )\n\n    # Passwords should be included in this object!!\n    return vm_result", "language": "python", "code": "def create(vm_info):\n    '''\n    Creates a virtual machine from the given VM information\n\n    This is what is used to request a virtual machine to be created by the\n    cloud provider, wait for it to become available, and then (optionally) log\n    in and install Salt on it.\n\n    Events fired:\n\n    This function fires the event ``salt/cloud/vm_name/creating``, with the\n    payload containing the names of the VM, profile, and provider.\n\n    @param vm_info\n\n    .. code-block:: text\n\n        {\n            name: <str>\n            profile: <dict>\n            driver: <provider>:<profile>\n            clonefrom: <vm_name>\n            clonemode: <mode> (default: state, choices: state, child, all)\n        }\n\n    @type vm_info dict\n    @return dict of resulting vm. !!!Passwords can and should be included!!!\n    '''\n    try:\n        # Check for required profile parameters before sending any API calls.\n        if vm_info['profile'] and config.is_profile_configured(\n            __opts__,\n                __active_provider_name__ or 'virtualbox',\n            vm_info['profile']\n        ) is False:\n            return False\n    except AttributeError:\n        pass\n\n    vm_name = vm_info[\"name\"]\n    deploy = config.get_cloud_config_value(\n        'deploy', vm_info, __opts__, search_global=False, default=True\n    )\n    wait_for_ip_timeout = config.get_cloud_config_value(\n        'wait_for_ip_timeout', vm_info, __opts__, default=60\n    )\n    boot_timeout = config.get_cloud_config_value(\n        'boot_timeout', vm_info, __opts__, default=60 * 1000\n    )\n    power = config.get_cloud_config_value(\n        'power_on', vm_info, __opts__, default=False\n    )\n    key_filename = config.get_cloud_config_value(\n        'private_key', vm_info, __opts__, search_global=False, default=None\n    )\n    clone_mode = map_clonemode(vm_info)\n    wait_for_pattern = vm_info['waitforpattern'] if 'waitforpattern' in vm_info.keys() else None\n    interface_index = vm_info['interfaceindex'] if 'interfaceindex' in vm_info.keys() else 0\n\n    log.debug(\"Going to fire event: starting create\")\n    __utils__['cloud.fire_event'](\n        'event',\n        'starting create',\n        'salt/cloud/{0}/creating'.format(vm_info['name']),\n        args=__utils__['cloud.filter_event']('creating', vm_info, ['name', 'profile', 'provider', 'driver']),\n        sock_dir=__opts__['sock_dir'],\n        transport=__opts__['transport']\n    )\n\n    # to create the virtual machine.\n    request_kwargs = {\n        'name': vm_info['name'],\n        'clone_from': vm_info['clonefrom'],\n        'clone_mode': clone_mode\n    }\n\n    __utils__['cloud.fire_event'](\n        'event',\n        'requesting instance',\n        'salt/cloud/{0}/requesting'.format(vm_info['name']),\n        args=__utils__['cloud.filter_event']('requesting', request_kwargs, list(request_kwargs)),\n        sock_dir=__opts__['sock_dir'],\n        transport=__opts__['transport']\n    )\n    vm_result = vb_clone_vm(**request_kwargs)\n\n    # Booting and deploying if needed\n    if power:\n        vb_start_vm(vm_name, timeout=boot_timeout)\n        ips = vb_wait_for_network_address(wait_for_ip_timeout, machine_name=vm_name, wait_for_pattern=wait_for_pattern)\n\n        if ips:\n            ip = ips[interface_index]\n            log.info(\"[ %s ] IPv4 is: %s\", vm_name, ip)\n            # ssh or smb using ip and install salt only if deploy is True\n            if deploy:\n                vm_info['key_filename'] = key_filename\n                vm_info['ssh_host'] = ip\n\n                res = __utils__['cloud.bootstrap'](vm_info, __opts__)\n                vm_result.update(res)\n\n    __utils__['cloud.fire_event'](\n        'event',\n        'created machine',\n        'salt/cloud/{0}/created'.format(vm_info['name']),\n        args=__utils__['cloud.filter_event']('created', vm_result, list(vm_result)),\n        sock_dir=__opts__['sock_dir'],\n        transport=__opts__['transport']\n    )\n\n    # Passwords should be included in this object!!\n    return vm_result", "code_tokens": ["def", "create", "(", "vm_info", ")", ":", "try", ":", "# Check for required profile parameters before sending any API calls.", "if", "vm_info", "[", "'profile'", "]", "and", "config", ".", "is_profile_configured", "(", "__opts__", ",", "__active_provider_name__", "or", "'virtualbox'", ",", "vm_info", "[", "'profile'", "]", ")", "is", "False", ":", "return", "False", "except", "AttributeError", ":", "pass", "vm_name", "=", "vm_info", "[", "\"name\"", "]", "deploy", "=", "config", ".", "get_cloud_config_value", "(", "'deploy'", ",", "vm_info", ",", "__opts__", ",", "search_global", "=", "False", ",", "default", "=", "True", ")", "wait_for_ip_timeout", "=", "config", ".", "get_cloud_config_value", "(", "'wait_for_ip_timeout'", ",", "vm_info", ",", "__opts__", ",", "default", "=", "60", ")", "boot_timeout", "=", "config", ".", "get_cloud_config_value", "(", "'boot_timeout'", ",", "vm_info", ",", "__opts__", ",", "default", "=", "60", "*", "1000", ")", "power", "=", "config", ".", "get_cloud_config_value", "(", "'power_on'", ",", "vm_info", ",", "__opts__", ",", "default", "=", "False", ")", "key_filename", "=", "config", ".", "get_cloud_config_value", "(", "'private_key'", ",", "vm_info", ",", "__opts__", ",", "search_global", "=", "False", ",", "default", "=", "None", ")", "clone_mode", "=", "map_clonemode", "(", "vm_info", ")", "wait_for_pattern", "=", "vm_info", "[", "'waitforpattern'", "]", "if", "'waitforpattern'", "in", "vm_info", ".", "keys", "(", ")", "else", "None", "interface_index", "=", "vm_info", "[", "'interfaceindex'", "]", "if", "'interfaceindex'", "in", "vm_info", ".", "keys", "(", ")", "else", "0", "log", ".", "debug", "(", "\"Going to fire event: starting create\"", ")", "__utils__", "[", "'cloud.fire_event'", "]", "(", "'event'", ",", "'starting create'", ",", "'salt/cloud/{0}/creating'", ".", "format", "(", "vm_info", "[", "'name'", "]", ")", ",", "args", "=", "__utils__", "[", "'cloud.filter_event'", "]", "(", "'creating'", ",", "vm_info", ",", "[", "'name'", ",", "'profile'", ",", "'provider'", ",", "'driver'", "]", ")", ",", "sock_dir", "=", "__opts__", "[", "'sock_dir'", "]", ",", "transport", "=", "__opts__", "[", "'transport'", "]", ")", "# to create the virtual machine.", "request_kwargs", "=", "{", "'name'", ":", "vm_info", "[", "'name'", "]", ",", "'clone_from'", ":", "vm_info", "[", "'clonefrom'", "]", ",", "'clone_mode'", ":", "clone_mode", "}", "__utils__", "[", "'cloud.fire_event'", "]", "(", "'event'", ",", "'requesting instance'", ",", "'salt/cloud/{0}/requesting'", ".", "format", "(", "vm_info", "[", "'name'", "]", ")", ",", "args", "=", "__utils__", "[", "'cloud.filter_event'", "]", "(", "'requesting'", ",", "request_kwargs", ",", "list", "(", "request_kwargs", ")", ")", ",", "sock_dir", "=", "__opts__", "[", "'sock_dir'", "]", ",", "transport", "=", "__opts__", "[", "'transport'", "]", ")", "vm_result", "=", "vb_clone_vm", "(", "*", "*", "request_kwargs", ")", "# Booting and deploying if needed", "if", "power", ":", "vb_start_vm", "(", "vm_name", ",", "timeout", "=", "boot_timeout", ")", "ips", "=", "vb_wait_for_network_address", "(", "wait_for_ip_timeout", ",", "machine_name", "=", "vm_name", ",", "wait_for_pattern", "=", "wait_for_pattern", ")", "if", "ips", ":", "ip", "=", "ips", "[", "interface_index", "]", "log", ".", "info", "(", "\"[ %s ] IPv4 is: %s\"", ",", "vm_name", ",", "ip", ")", "# ssh or smb using ip and install salt only if deploy is True", "if", "deploy", ":", "vm_info", "[", "'key_filename'", "]", "=", "key_filename", "vm_info", "[", "'ssh_host'", "]", "=", "ip", "res", "=", "__utils__", "[", "'cloud.bootstrap'", "]", "(", "vm_info", ",", "__opts__", ")", "vm_result", ".", "update", "(", "res", ")", "__utils__", "[", "'cloud.fire_event'", "]", "(", "'event'", ",", "'created machine'", ",", "'salt/cloud/{0}/created'", ".", "format", "(", "vm_info", "[", "'name'", "]", ")", ",", "args", "=", "__utils__", "[", "'cloud.filter_event'", "]", "(", "'created'", ",", "vm_result", ",", "list", "(", "vm_result", ")", ")", ",", "sock_dir", "=", "__opts__", "[", "'sock_dir'", "]", ",", "transport", "=", "__opts__", "[", "'transport'", "]", ")", "# Passwords should be included in this object!!", "return", "vm_result"], "docstring": "Creates a virtual machine from the given VM information\n\n    This is what is used to request a virtual machine to be created by the\n    cloud provider, wait for it to become available, and then (optionally) log\n    in and install Salt on it.\n\n    Events fired:\n\n    This function fires the event ``salt/cloud/vm_name/creating``, with the\n    payload containing the names of the VM, profile, and provider.\n\n    @param vm_info\n\n    .. code-block:: text\n\n        {\n            name: <str>\n            profile: <dict>\n            driver: <provider>:<profile>\n            clonefrom: <vm_name>\n            clonemode: <mode> (default: state, choices: state, child, all)\n        }\n\n    @type vm_info dict\n    @return dict of resulting vm. !!!Passwords can and should be included!!!", "docstring_tokens": ["Creates", "a", "virtual", "machine", "from", "the", "given", "VM", "information"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/cloud/clouds/virtualbox.py#L116-L228", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/cloud/clouds/virtualbox.py", "func_name": "list_nodes_full", "original_string": "def list_nodes_full(kwargs=None, call=None):\n    \"\"\"\n    All information available about all nodes should be returned in this function.\n    The fields in the list_nodes() function should also be returned,\n    even if they would not normally be provided by the cloud provider.\n\n    This is because some functions both within Salt and 3rd party will break if an expected field is not present.\n    This function is normally called with the -F option:\n\n\n    .. code-block:: bash\n\n        salt-cloud -F\n\n\n    @param kwargs:\n    @type kwargs:\n    @param call:\n    @type call:\n    @return:\n    @rtype:\n    \"\"\"\n    if call == 'action':\n        raise SaltCloudSystemExit(\n            'The list_nodes_full function must be called '\n            'with -f or --function.'\n        )\n\n    machines = {}\n\n    # TODO ask for the correct attributes e.g state and private_ips\n    for machine in vb_list_machines():\n        name = machine.get(\"name\")\n        if name:\n            machines[name] = treat_machine_dict(machine)\n            del machine[\"name\"]\n\n    return machines", "language": "python", "code": "def list_nodes_full(kwargs=None, call=None):\n    \"\"\"\n    All information available about all nodes should be returned in this function.\n    The fields in the list_nodes() function should also be returned,\n    even if they would not normally be provided by the cloud provider.\n\n    This is because some functions both within Salt and 3rd party will break if an expected field is not present.\n    This function is normally called with the -F option:\n\n\n    .. code-block:: bash\n\n        salt-cloud -F\n\n\n    @param kwargs:\n    @type kwargs:\n    @param call:\n    @type call:\n    @return:\n    @rtype:\n    \"\"\"\n    if call == 'action':\n        raise SaltCloudSystemExit(\n            'The list_nodes_full function must be called '\n            'with -f or --function.'\n        )\n\n    machines = {}\n\n    # TODO ask for the correct attributes e.g state and private_ips\n    for machine in vb_list_machines():\n        name = machine.get(\"name\")\n        if name:\n            machines[name] = treat_machine_dict(machine)\n            del machine[\"name\"]\n\n    return machines", "code_tokens": ["def", "list_nodes_full", "(", "kwargs", "=", "None", ",", "call", "=", "None", ")", ":", "if", "call", "==", "'action'", ":", "raise", "SaltCloudSystemExit", "(", "'The list_nodes_full function must be called '", "'with -f or --function.'", ")", "machines", "=", "{", "}", "# TODO ask for the correct attributes e.g state and private_ips", "for", "machine", "in", "vb_list_machines", "(", ")", ":", "name", "=", "machine", ".", "get", "(", "\"name\"", ")", "if", "name", ":", "machines", "[", "name", "]", "=", "treat_machine_dict", "(", "machine", ")", "del", "machine", "[", "\"name\"", "]", "return", "machines"], "docstring": "All information available about all nodes should be returned in this function.\n    The fields in the list_nodes() function should also be returned,\n    even if they would not normally be provided by the cloud provider.\n\n    This is because some functions both within Salt and 3rd party will break if an expected field is not present.\n    This function is normally called with the -F option:\n\n\n    .. code-block:: bash\n\n        salt-cloud -F\n\n\n    @param kwargs:\n    @type kwargs:\n    @param call:\n    @type call:\n    @return:\n    @rtype:", "docstring_tokens": ["All", "information", "available", "about", "all", "nodes", "should", "be", "returned", "in", "this", "function", ".", "The", "fields", "in", "the", "list_nodes", "()", "function", "should", "also", "be", "returned", "even", "if", "they", "would", "not", "normally", "be", "provided", "by", "the", "cloud", "provider", "."], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/cloud/clouds/virtualbox.py#L231-L268", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/cloud/clouds/virtualbox.py", "func_name": "list_nodes", "original_string": "def list_nodes(kwargs=None, call=None):\n    \"\"\"\n    This function returns a list of nodes available on this cloud provider, using the following fields:\n\n    id (str)\n    image (str)\n    size (str)\n    state (str)\n    private_ips (list)\n    public_ips (list)\n\n    No other fields should be returned in this function, and all of these fields should be returned, even if empty.\n    The private_ips and public_ips fields should always be of a list type, even if empty,\n    and the other fields should always be of a str type.\n    This function is normally called with the -Q option:\n\n    .. code-block:: bash\n\n        salt-cloud -Q\n\n\n    @param kwargs:\n    @type kwargs:\n    @param call:\n    @type call:\n    @return:\n    @rtype:\n    \"\"\"\n    if call == 'action':\n        raise SaltCloudSystemExit(\n            'The list_nodes function must be called '\n            'with -f or --function.'\n        )\n\n    attributes = [\n        \"id\",\n        \"image\",\n        \"size\",\n        \"state\",\n        \"private_ips\",\n        \"public_ips\",\n    ]\n    return __utils__['cloud.list_nodes_select'](\n        list_nodes_full('function'), attributes, call,\n    )", "language": "python", "code": "def list_nodes(kwargs=None, call=None):\n    \"\"\"\n    This function returns a list of nodes available on this cloud provider, using the following fields:\n\n    id (str)\n    image (str)\n    size (str)\n    state (str)\n    private_ips (list)\n    public_ips (list)\n\n    No other fields should be returned in this function, and all of these fields should be returned, even if empty.\n    The private_ips and public_ips fields should always be of a list type, even if empty,\n    and the other fields should always be of a str type.\n    This function is normally called with the -Q option:\n\n    .. code-block:: bash\n\n        salt-cloud -Q\n\n\n    @param kwargs:\n    @type kwargs:\n    @param call:\n    @type call:\n    @return:\n    @rtype:\n    \"\"\"\n    if call == 'action':\n        raise SaltCloudSystemExit(\n            'The list_nodes function must be called '\n            'with -f or --function.'\n        )\n\n    attributes = [\n        \"id\",\n        \"image\",\n        \"size\",\n        \"state\",\n        \"private_ips\",\n        \"public_ips\",\n    ]\n    return __utils__['cloud.list_nodes_select'](\n        list_nodes_full('function'), attributes, call,\n    )", "code_tokens": ["def", "list_nodes", "(", "kwargs", "=", "None", ",", "call", "=", "None", ")", ":", "if", "call", "==", "'action'", ":", "raise", "SaltCloudSystemExit", "(", "'The list_nodes function must be called '", "'with -f or --function.'", ")", "attributes", "=", "[", "\"id\"", ",", "\"image\"", ",", "\"size\"", ",", "\"state\"", ",", "\"private_ips\"", ",", "\"public_ips\"", ",", "]", "return", "__utils__", "[", "'cloud.list_nodes_select'", "]", "(", "list_nodes_full", "(", "'function'", ")", ",", "attributes", ",", "call", ",", ")"], "docstring": "This function returns a list of nodes available on this cloud provider, using the following fields:\n\n    id (str)\n    image (str)\n    size (str)\n    state (str)\n    private_ips (list)\n    public_ips (list)\n\n    No other fields should be returned in this function, and all of these fields should be returned, even if empty.\n    The private_ips and public_ips fields should always be of a list type, even if empty,\n    and the other fields should always be of a str type.\n    This function is normally called with the -Q option:\n\n    .. code-block:: bash\n\n        salt-cloud -Q\n\n\n    @param kwargs:\n    @type kwargs:\n    @param call:\n    @type call:\n    @return:\n    @rtype:", "docstring_tokens": ["This", "function", "returns", "a", "list", "of", "nodes", "available", "on", "this", "cloud", "provider", "using", "the", "following", "fields", ":"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/cloud/clouds/virtualbox.py#L271-L315", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/cloud/clouds/virtualbox.py", "func_name": "destroy", "original_string": "def destroy(name, call=None):\n    \"\"\"\n    This function irreversibly destroys a virtual machine on the cloud provider.\n    Before doing so, it should fire an event on the Salt event bus.\n\n    The tag for this event is `salt/cloud/<vm name>/destroying`.\n    Once the virtual machine has been destroyed, another event is fired.\n    The tag for that event is `salt/cloud/<vm name>/destroyed`.\n\n    Dependencies:\n        list_nodes\n\n    @param name:\n    @type name: str\n    @param call:\n    @type call:\n    @return: True if all went well, otherwise an error message\n    @rtype: bool|str\n    \"\"\"\n    log.info(\"Attempting to delete instance %s\", name)\n    if not vb_machine_exists(name):\n        return \"{0} doesn't exist and can't be deleted\".format(name)\n\n    __utils__['cloud.fire_event'](\n        'event',\n        'destroying instance',\n        'salt/cloud/{0}/destroying'.format(name),\n        args={'name': name},\n        sock_dir=__opts__['sock_dir'],\n        transport=__opts__['transport']\n    )\n\n    vb_destroy_machine(name)\n\n    __utils__['cloud.fire_event'](\n        'event',\n        'destroyed instance',\n        'salt/cloud/{0}/destroyed'.format(name),\n        args={'name': name},\n        sock_dir=__opts__['sock_dir'],\n        transport=__opts__['transport']\n    )", "language": "python", "code": "def destroy(name, call=None):\n    \"\"\"\n    This function irreversibly destroys a virtual machine on the cloud provider.\n    Before doing so, it should fire an event on the Salt event bus.\n\n    The tag for this event is `salt/cloud/<vm name>/destroying`.\n    Once the virtual machine has been destroyed, another event is fired.\n    The tag for that event is `salt/cloud/<vm name>/destroyed`.\n\n    Dependencies:\n        list_nodes\n\n    @param name:\n    @type name: str\n    @param call:\n    @type call:\n    @return: True if all went well, otherwise an error message\n    @rtype: bool|str\n    \"\"\"\n    log.info(\"Attempting to delete instance %s\", name)\n    if not vb_machine_exists(name):\n        return \"{0} doesn't exist and can't be deleted\".format(name)\n\n    __utils__['cloud.fire_event'](\n        'event',\n        'destroying instance',\n        'salt/cloud/{0}/destroying'.format(name),\n        args={'name': name},\n        sock_dir=__opts__['sock_dir'],\n        transport=__opts__['transport']\n    )\n\n    vb_destroy_machine(name)\n\n    __utils__['cloud.fire_event'](\n        'event',\n        'destroyed instance',\n        'salt/cloud/{0}/destroyed'.format(name),\n        args={'name': name},\n        sock_dir=__opts__['sock_dir'],\n        transport=__opts__['transport']\n    )", "code_tokens": ["def", "destroy", "(", "name", ",", "call", "=", "None", ")", ":", "log", ".", "info", "(", "\"Attempting to delete instance %s\"", ",", "name", ")", "if", "not", "vb_machine_exists", "(", "name", ")", ":", "return", "\"{0} doesn't exist and can't be deleted\"", ".", "format", "(", "name", ")", "__utils__", "[", "'cloud.fire_event'", "]", "(", "'event'", ",", "'destroying instance'", ",", "'salt/cloud/{0}/destroying'", ".", "format", "(", "name", ")", ",", "args", "=", "{", "'name'", ":", "name", "}", ",", "sock_dir", "=", "__opts__", "[", "'sock_dir'", "]", ",", "transport", "=", "__opts__", "[", "'transport'", "]", ")", "vb_destroy_machine", "(", "name", ")", "__utils__", "[", "'cloud.fire_event'", "]", "(", "'event'", ",", "'destroyed instance'", ",", "'salt/cloud/{0}/destroyed'", ".", "format", "(", "name", ")", ",", "args", "=", "{", "'name'", ":", "name", "}", ",", "sock_dir", "=", "__opts__", "[", "'sock_dir'", "]", ",", "transport", "=", "__opts__", "[", "'transport'", "]", ")"], "docstring": "This function irreversibly destroys a virtual machine on the cloud provider.\n    Before doing so, it should fire an event on the Salt event bus.\n\n    The tag for this event is `salt/cloud/<vm name>/destroying`.\n    Once the virtual machine has been destroyed, another event is fired.\n    The tag for that event is `salt/cloud/<vm name>/destroyed`.\n\n    Dependencies:\n        list_nodes\n\n    @param name:\n    @type name: str\n    @param call:\n    @type call:\n    @return: True if all went well, otherwise an error message\n    @rtype: bool|str", "docstring_tokens": ["This", "function", "irreversibly", "destroys", "a", "virtual", "machine", "on", "the", "cloud", "provider", ".", "Before", "doing", "so", "it", "should", "fire", "an", "event", "on", "the", "Salt", "event", "bus", "."], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/cloud/clouds/virtualbox.py#L327-L368", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/cloud/clouds/virtualbox.py", "func_name": "start", "original_string": "def start(name, call=None):\n    '''\n    Start a machine.\n    @param name: Machine to start\n    @type name: str\n    @param call: Must be \"action\"\n    @type call: str\n    '''\n    if call != 'action':\n        raise SaltCloudSystemExit(\n            'The instance action must be called with -a or --action.'\n        )\n\n    log.info(\"Starting machine: %s\", name)\n    vb_start_vm(name)\n    machine = vb_get_machine(name)\n    del machine[\"name\"]\n    return treat_machine_dict(machine)", "language": "python", "code": "def start(name, call=None):\n    '''\n    Start a machine.\n    @param name: Machine to start\n    @type name: str\n    @param call: Must be \"action\"\n    @type call: str\n    '''\n    if call != 'action':\n        raise SaltCloudSystemExit(\n            'The instance action must be called with -a or --action.'\n        )\n\n    log.info(\"Starting machine: %s\", name)\n    vb_start_vm(name)\n    machine = vb_get_machine(name)\n    del machine[\"name\"]\n    return treat_machine_dict(machine)", "code_tokens": ["def", "start", "(", "name", ",", "call", "=", "None", ")", ":", "if", "call", "!=", "'action'", ":", "raise", "SaltCloudSystemExit", "(", "'The instance action must be called with -a or --action.'", ")", "log", ".", "info", "(", "\"Starting machine: %s\"", ",", "name", ")", "vb_start_vm", "(", "name", ")", "machine", "=", "vb_get_machine", "(", "name", ")", "del", "machine", "[", "\"name\"", "]", "return", "treat_machine_dict", "(", "machine", ")"], "docstring": "Start a machine.\n    @param name: Machine to start\n    @type name: str\n    @param call: Must be \"action\"\n    @type call: str", "docstring_tokens": ["Start", "a", "machine", "."], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/cloud/clouds/virtualbox.py#L371-L388", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/cloud/clouds/virtualbox.py", "func_name": "stop", "original_string": "def stop(name, call=None):\n    \"\"\"\n    Stop a running machine.\n    @param name: Machine to stop\n    @type name: str\n    @param call: Must be \"action\"\n    @type call: str\n    \"\"\"\n    if call != 'action':\n        raise SaltCloudSystemExit(\n            'The instance action must be called with -a or --action.'\n        )\n\n    log.info(\"Stopping machine: %s\", name)\n    vb_stop_vm(name)\n    machine = vb_get_machine(name)\n    del machine[\"name\"]\n    return treat_machine_dict(machine)", "language": "python", "code": "def stop(name, call=None):\n    \"\"\"\n    Stop a running machine.\n    @param name: Machine to stop\n    @type name: str\n    @param call: Must be \"action\"\n    @type call: str\n    \"\"\"\n    if call != 'action':\n        raise SaltCloudSystemExit(\n            'The instance action must be called with -a or --action.'\n        )\n\n    log.info(\"Stopping machine: %s\", name)\n    vb_stop_vm(name)\n    machine = vb_get_machine(name)\n    del machine[\"name\"]\n    return treat_machine_dict(machine)", "code_tokens": ["def", "stop", "(", "name", ",", "call", "=", "None", ")", ":", "if", "call", "!=", "'action'", ":", "raise", "SaltCloudSystemExit", "(", "'The instance action must be called with -a or --action.'", ")", "log", ".", "info", "(", "\"Stopping machine: %s\"", ",", "name", ")", "vb_stop_vm", "(", "name", ")", "machine", "=", "vb_get_machine", "(", "name", ")", "del", "machine", "[", "\"name\"", "]", "return", "treat_machine_dict", "(", "machine", ")"], "docstring": "Stop a running machine.\n    @param name: Machine to stop\n    @type name: str\n    @param call: Must be \"action\"\n    @type call: str", "docstring_tokens": ["Stop", "a", "running", "machine", "."], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/cloud/clouds/virtualbox.py#L391-L408", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/cloud/clouds/virtualbox.py", "func_name": "show_image", "original_string": "def show_image(kwargs, call=None):\n    \"\"\"\n    Show the details of an image\n    \"\"\"\n    if call != 'function':\n        raise SaltCloudSystemExit(\n            'The show_image action must be called with -f or --function.'\n        )\n\n    name = kwargs['image']\n    log.info(\"Showing image %s\", name)\n    machine = vb_get_machine(name)\n\n    ret = {\n        machine[\"name\"]: treat_machine_dict(machine)\n    }\n    del machine[\"name\"]\n    return ret", "language": "python", "code": "def show_image(kwargs, call=None):\n    \"\"\"\n    Show the details of an image\n    \"\"\"\n    if call != 'function':\n        raise SaltCloudSystemExit(\n            'The show_image action must be called with -f or --function.'\n        )\n\n    name = kwargs['image']\n    log.info(\"Showing image %s\", name)\n    machine = vb_get_machine(name)\n\n    ret = {\n        machine[\"name\"]: treat_machine_dict(machine)\n    }\n    del machine[\"name\"]\n    return ret", "code_tokens": ["def", "show_image", "(", "kwargs", ",", "call", "=", "None", ")", ":", "if", "call", "!=", "'function'", ":", "raise", "SaltCloudSystemExit", "(", "'The show_image action must be called with -f or --function.'", ")", "name", "=", "kwargs", "[", "'image'", "]", "log", ".", "info", "(", "\"Showing image %s\"", ",", "name", ")", "machine", "=", "vb_get_machine", "(", "name", ")", "ret", "=", "{", "machine", "[", "\"name\"", "]", ":", "treat_machine_dict", "(", "machine", ")", "}", "del", "machine", "[", "\"name\"", "]", "return", "ret"], "docstring": "Show the details of an image", "docstring_tokens": ["Show", "the", "details", "of", "an", "image"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/cloud/clouds/virtualbox.py#L411-L428", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/states/cryptdev.py", "func_name": "mapped", "original_string": "def mapped(name,\n           device,\n           keyfile=None,\n           opts=None,\n           config='/etc/crypttab',\n           persist=True,\n           immediate=False,\n           match_on='name'):\n    '''\n    Verify that a device is mapped\n\n    name\n        The name under which the device is to be mapped\n\n    device\n        The device name, typically the device node, such as ``/dev/sdb1``\n        or ``UUID=066e0200-2867-4ebe-b9e6-f30026ca2314``.\n\n    keyfile\n        Either ``None`` if the password is to be entered manually on boot, or\n        an absolute path to a keyfile. If the password is to be asked\n        interactively, the mapping cannot be performed with ``immediate=True``.\n\n    opts\n        A list object of options or a comma delimited list\n\n    config\n        Set an alternative location for the crypttab, if the map is persistent,\n        Default is ``/etc/crypttab``\n\n    persist\n        Set if the map should be saved in the crypttab, Default is ``True``\n\n    immediate\n        Set if the device mapping should be executed immediately. Requires that\n        the keyfile not be ``None``, because the password cannot be asked\n        interactively. Note that options are not passed through on the initial\n        mapping.  Default is ``False``.\n\n    match_on\n        A name or list of crypttab properties on which this state should be applied.\n        Default is ``name``, meaning that the line is matched only by the name\n        parameter. If the desired configuration requires two devices mapped to\n        the same name, supply a list of parameters to match on.\n    '''\n    ret = {'name': name,\n           'changes': {},\n           'result': True,\n           'comment': ''}\n\n    # If neither option is set, we've been asked to do nothing.\n    if not immediate and not persist:\n        ret['result'] = False\n        ret['comment'] = 'Either persist or immediate must be set, otherwise this state does nothing'\n        return ret\n\n    if immediate and (keyfile is None or keyfile == 'none' or keyfile == '-'):\n        ret['result'] = False\n        ret['changes']['cryptsetup'] = 'Device cannot be mapped immediately without a keyfile'\n\n    elif immediate:\n        # Get the active crypt mounts. If ours is listed already, no action is necessary.\n        active = __salt__['cryptdev.active']()\n        if name not in active.keys():\n            # Open the map using cryptsetup. This does not pass any options.\n            if opts:\n                log.warning('Ignore cryptdev configuration when mapping immediately')\n\n            if __opts__['test']:\n                ret['result'] = None\n                ret['commment'] = 'Device would be mapped immediately'\n            else:\n                cryptsetup_result = __salt__['cryptdev.open'](name, device, keyfile)\n                if cryptsetup_result:\n                    ret['changes']['cryptsetup'] = 'Device mapped using cryptsetup'\n                else:\n                    ret['changes']['cryptsetup'] = 'Device failed to map using cryptsetup'\n                    ret['result'] = False\n\n    if persist and not __opts__['test']:\n        crypttab_result = __salt__['cryptdev.set_crypttab'](name,\n                                                            device,\n                                                            password=keyfile,\n                                                            options=opts,\n                                                            config=config,\n                                                            match_on=match_on)\n        if crypttab_result:\n            if crypttab_result == 'new':\n                ret['changes']['crypttab'] = 'Entry added in {0}'.format(config)\n\n            if crypttab_result == 'change':\n                ret['changes']['crypttab'] = 'Existing entry in {0} changed'.format(config)\n\n        else:\n            ret['changes']['crypttab'] = 'Unable to set entry in {0}'.format(config)\n            ret['result'] = False\n\n    return ret", "language": "python", "code": "def mapped(name,\n           device,\n           keyfile=None,\n           opts=None,\n           config='/etc/crypttab',\n           persist=True,\n           immediate=False,\n           match_on='name'):\n    '''\n    Verify that a device is mapped\n\n    name\n        The name under which the device is to be mapped\n\n    device\n        The device name, typically the device node, such as ``/dev/sdb1``\n        or ``UUID=066e0200-2867-4ebe-b9e6-f30026ca2314``.\n\n    keyfile\n        Either ``None`` if the password is to be entered manually on boot, or\n        an absolute path to a keyfile. If the password is to be asked\n        interactively, the mapping cannot be performed with ``immediate=True``.\n\n    opts\n        A list object of options or a comma delimited list\n\n    config\n        Set an alternative location for the crypttab, if the map is persistent,\n        Default is ``/etc/crypttab``\n\n    persist\n        Set if the map should be saved in the crypttab, Default is ``True``\n\n    immediate\n        Set if the device mapping should be executed immediately. Requires that\n        the keyfile not be ``None``, because the password cannot be asked\n        interactively. Note that options are not passed through on the initial\n        mapping.  Default is ``False``.\n\n    match_on\n        A name or list of crypttab properties on which this state should be applied.\n        Default is ``name``, meaning that the line is matched only by the name\n        parameter. If the desired configuration requires two devices mapped to\n        the same name, supply a list of parameters to match on.\n    '''\n    ret = {'name': name,\n           'changes': {},\n           'result': True,\n           'comment': ''}\n\n    # If neither option is set, we've been asked to do nothing.\n    if not immediate and not persist:\n        ret['result'] = False\n        ret['comment'] = 'Either persist or immediate must be set, otherwise this state does nothing'\n        return ret\n\n    if immediate and (keyfile is None or keyfile == 'none' or keyfile == '-'):\n        ret['result'] = False\n        ret['changes']['cryptsetup'] = 'Device cannot be mapped immediately without a keyfile'\n\n    elif immediate:\n        # Get the active crypt mounts. If ours is listed already, no action is necessary.\n        active = __salt__['cryptdev.active']()\n        if name not in active.keys():\n            # Open the map using cryptsetup. This does not pass any options.\n            if opts:\n                log.warning('Ignore cryptdev configuration when mapping immediately')\n\n            if __opts__['test']:\n                ret['result'] = None\n                ret['commment'] = 'Device would be mapped immediately'\n            else:\n                cryptsetup_result = __salt__['cryptdev.open'](name, device, keyfile)\n                if cryptsetup_result:\n                    ret['changes']['cryptsetup'] = 'Device mapped using cryptsetup'\n                else:\n                    ret['changes']['cryptsetup'] = 'Device failed to map using cryptsetup'\n                    ret['result'] = False\n\n    if persist and not __opts__['test']:\n        crypttab_result = __salt__['cryptdev.set_crypttab'](name,\n                                                            device,\n                                                            password=keyfile,\n                                                            options=opts,\n                                                            config=config,\n                                                            match_on=match_on)\n        if crypttab_result:\n            if crypttab_result == 'new':\n                ret['changes']['crypttab'] = 'Entry added in {0}'.format(config)\n\n            if crypttab_result == 'change':\n                ret['changes']['crypttab'] = 'Existing entry in {0} changed'.format(config)\n\n        else:\n            ret['changes']['crypttab'] = 'Unable to set entry in {0}'.format(config)\n            ret['result'] = False\n\n    return ret", "code_tokens": ["def", "mapped", "(", "name", ",", "device", ",", "keyfile", "=", "None", ",", "opts", "=", "None", ",", "config", "=", "'/etc/crypttab'", ",", "persist", "=", "True", ",", "immediate", "=", "False", ",", "match_on", "=", "'name'", ")", ":", "ret", "=", "{", "'name'", ":", "name", ",", "'changes'", ":", "{", "}", ",", "'result'", ":", "True", ",", "'comment'", ":", "''", "}", "# If neither option is set, we've been asked to do nothing.", "if", "not", "immediate", "and", "not", "persist", ":", "ret", "[", "'result'", "]", "=", "False", "ret", "[", "'comment'", "]", "=", "'Either persist or immediate must be set, otherwise this state does nothing'", "return", "ret", "if", "immediate", "and", "(", "keyfile", "is", "None", "or", "keyfile", "==", "'none'", "or", "keyfile", "==", "'-'", ")", ":", "ret", "[", "'result'", "]", "=", "False", "ret", "[", "'changes'", "]", "[", "'cryptsetup'", "]", "=", "'Device cannot be mapped immediately without a keyfile'", "elif", "immediate", ":", "# Get the active crypt mounts. If ours is listed already, no action is necessary.", "active", "=", "__salt__", "[", "'cryptdev.active'", "]", "(", ")", "if", "name", "not", "in", "active", ".", "keys", "(", ")", ":", "# Open the map using cryptsetup. This does not pass any options.", "if", "opts", ":", "log", ".", "warning", "(", "'Ignore cryptdev configuration when mapping immediately'", ")", "if", "__opts__", "[", "'test'", "]", ":", "ret", "[", "'result'", "]", "=", "None", "ret", "[", "'commment'", "]", "=", "'Device would be mapped immediately'", "else", ":", "cryptsetup_result", "=", "__salt__", "[", "'cryptdev.open'", "]", "(", "name", ",", "device", ",", "keyfile", ")", "if", "cryptsetup_result", ":", "ret", "[", "'changes'", "]", "[", "'cryptsetup'", "]", "=", "'Device mapped using cryptsetup'", "else", ":", "ret", "[", "'changes'", "]", "[", "'cryptsetup'", "]", "=", "'Device failed to map using cryptsetup'", "ret", "[", "'result'", "]", "=", "False", "if", "persist", "and", "not", "__opts__", "[", "'test'", "]", ":", "crypttab_result", "=", "__salt__", "[", "'cryptdev.set_crypttab'", "]", "(", "name", ",", "device", ",", "password", "=", "keyfile", ",", "options", "=", "opts", ",", "config", "=", "config", ",", "match_on", "=", "match_on", ")", "if", "crypttab_result", ":", "if", "crypttab_result", "==", "'new'", ":", "ret", "[", "'changes'", "]", "[", "'crypttab'", "]", "=", "'Entry added in {0}'", ".", "format", "(", "config", ")", "if", "crypttab_result", "==", "'change'", ":", "ret", "[", "'changes'", "]", "[", "'crypttab'", "]", "=", "'Existing entry in {0} changed'", ".", "format", "(", "config", ")", "else", ":", "ret", "[", "'changes'", "]", "[", "'crypttab'", "]", "=", "'Unable to set entry in {0}'", ".", "format", "(", "config", ")", "ret", "[", "'result'", "]", "=", "False", "return", "ret"], "docstring": "Verify that a device is mapped\n\n    name\n        The name under which the device is to be mapped\n\n    device\n        The device name, typically the device node, such as ``/dev/sdb1``\n        or ``UUID=066e0200-2867-4ebe-b9e6-f30026ca2314``.\n\n    keyfile\n        Either ``None`` if the password is to be entered manually on boot, or\n        an absolute path to a keyfile. If the password is to be asked\n        interactively, the mapping cannot be performed with ``immediate=True``.\n\n    opts\n        A list object of options or a comma delimited list\n\n    config\n        Set an alternative location for the crypttab, if the map is persistent,\n        Default is ``/etc/crypttab``\n\n    persist\n        Set if the map should be saved in the crypttab, Default is ``True``\n\n    immediate\n        Set if the device mapping should be executed immediately. Requires that\n        the keyfile not be ``None``, because the password cannot be asked\n        interactively. Note that options are not passed through on the initial\n        mapping.  Default is ``False``.\n\n    match_on\n        A name or list of crypttab properties on which this state should be applied.\n        Default is ``name``, meaning that the line is matched only by the name\n        parameter. If the desired configuration requires two devices mapped to\n        the same name, supply a list of parameters to match on.", "docstring_tokens": ["Verify", "that", "a", "device", "is", "mapped"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/states/cryptdev.py#L37-L134", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/states/cryptdev.py", "func_name": "unmapped", "original_string": "def unmapped(name,\n             config='/etc/crypttab',\n             persist=True,\n             immediate=False):\n    '''\n    Ensure that a device is unmapped\n\n    name\n        The name to ensure is not mapped\n\n    config\n        Set an alternative location for the crypttab, if the map is persistent,\n        Default is ``/etc/crypttab``\n\n    persist\n        Set if the map should be removed from the crypttab. Default is ``True``\n\n    immediate\n        Set if the device should be unmapped immediately. Default is ``False``.\n    '''\n    ret = {'name': name,\n           'changes': {},\n           'result': True,\n           'comment': ''}\n\n    if immediate:\n        # Get the active crypt mounts. If ours is not listed already, no action is necessary.\n        active = __salt__['cryptdev.active']()\n        if name in active.keys():\n            # Close the map using cryptsetup.\n            if __opts__['test']:\n                ret['result'] = None\n                ret['commment'] = 'Device would be unmapped immediately'\n            else:\n                cryptsetup_result = __salt__['cryptdev.close'](name)\n                if cryptsetup_result:\n                    ret['changes']['cryptsetup'] = 'Device unmapped using cryptsetup'\n                else:\n                    ret['changes']['cryptsetup'] = 'Device failed to unmap using cryptsetup'\n                    ret['result'] = False\n\n    if persist and not __opts__['test']:\n        crypttab_result = __salt__['cryptdev.rm_crypttab'](name, config=config)\n        if crypttab_result:\n            if crypttab_result == 'change':\n                ret['changes']['crypttab'] = 'Entry removed from {0}'.format(config)\n\n        else:\n            ret['changes']['crypttab'] = 'Unable to remove entry in {0}'.format(config)\n            ret['result'] = False\n\n    return ret", "language": "python", "code": "def unmapped(name,\n             config='/etc/crypttab',\n             persist=True,\n             immediate=False):\n    '''\n    Ensure that a device is unmapped\n\n    name\n        The name to ensure is not mapped\n\n    config\n        Set an alternative location for the crypttab, if the map is persistent,\n        Default is ``/etc/crypttab``\n\n    persist\n        Set if the map should be removed from the crypttab. Default is ``True``\n\n    immediate\n        Set if the device should be unmapped immediately. Default is ``False``.\n    '''\n    ret = {'name': name,\n           'changes': {},\n           'result': True,\n           'comment': ''}\n\n    if immediate:\n        # Get the active crypt mounts. If ours is not listed already, no action is necessary.\n        active = __salt__['cryptdev.active']()\n        if name in active.keys():\n            # Close the map using cryptsetup.\n            if __opts__['test']:\n                ret['result'] = None\n                ret['commment'] = 'Device would be unmapped immediately'\n            else:\n                cryptsetup_result = __salt__['cryptdev.close'](name)\n                if cryptsetup_result:\n                    ret['changes']['cryptsetup'] = 'Device unmapped using cryptsetup'\n                else:\n                    ret['changes']['cryptsetup'] = 'Device failed to unmap using cryptsetup'\n                    ret['result'] = False\n\n    if persist and not __opts__['test']:\n        crypttab_result = __salt__['cryptdev.rm_crypttab'](name, config=config)\n        if crypttab_result:\n            if crypttab_result == 'change':\n                ret['changes']['crypttab'] = 'Entry removed from {0}'.format(config)\n\n        else:\n            ret['changes']['crypttab'] = 'Unable to remove entry in {0}'.format(config)\n            ret['result'] = False\n\n    return ret", "code_tokens": ["def", "unmapped", "(", "name", ",", "config", "=", "'/etc/crypttab'", ",", "persist", "=", "True", ",", "immediate", "=", "False", ")", ":", "ret", "=", "{", "'name'", ":", "name", ",", "'changes'", ":", "{", "}", ",", "'result'", ":", "True", ",", "'comment'", ":", "''", "}", "if", "immediate", ":", "# Get the active crypt mounts. If ours is not listed already, no action is necessary.", "active", "=", "__salt__", "[", "'cryptdev.active'", "]", "(", ")", "if", "name", "in", "active", ".", "keys", "(", ")", ":", "# Close the map using cryptsetup.", "if", "__opts__", "[", "'test'", "]", ":", "ret", "[", "'result'", "]", "=", "None", "ret", "[", "'commment'", "]", "=", "'Device would be unmapped immediately'", "else", ":", "cryptsetup_result", "=", "__salt__", "[", "'cryptdev.close'", "]", "(", "name", ")", "if", "cryptsetup_result", ":", "ret", "[", "'changes'", "]", "[", "'cryptsetup'", "]", "=", "'Device unmapped using cryptsetup'", "else", ":", "ret", "[", "'changes'", "]", "[", "'cryptsetup'", "]", "=", "'Device failed to unmap using cryptsetup'", "ret", "[", "'result'", "]", "=", "False", "if", "persist", "and", "not", "__opts__", "[", "'test'", "]", ":", "crypttab_result", "=", "__salt__", "[", "'cryptdev.rm_crypttab'", "]", "(", "name", ",", "config", "=", "config", ")", "if", "crypttab_result", ":", "if", "crypttab_result", "==", "'change'", ":", "ret", "[", "'changes'", "]", "[", "'crypttab'", "]", "=", "'Entry removed from {0}'", ".", "format", "(", "config", ")", "else", ":", "ret", "[", "'changes'", "]", "[", "'crypttab'", "]", "=", "'Unable to remove entry in {0}'", ".", "format", "(", "config", ")", "ret", "[", "'result'", "]", "=", "False", "return", "ret"], "docstring": "Ensure that a device is unmapped\n\n    name\n        The name to ensure is not mapped\n\n    config\n        Set an alternative location for the crypttab, if the map is persistent,\n        Default is ``/etc/crypttab``\n\n    persist\n        Set if the map should be removed from the crypttab. Default is ``True``\n\n    immediate\n        Set if the device should be unmapped immediately. Default is ``False``.", "docstring_tokens": ["Ensure", "that", "a", "device", "is", "unmapped"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/states/cryptdev.py#L137-L188", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/runners/pillar.py", "func_name": "show_top", "original_string": "def show_top(minion=None, saltenv='base'):\n    '''\n    Returns the compiled top data for pillar for a specific minion.  If no\n    minion is specified, we use the first minion we find.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt-run pillar.show_top\n    '''\n    id_, grains, _ = salt.utils.minions.get_minion_data(minion, __opts__)\n    if not grains and minion == __opts__['id']:\n        grains = salt.loader.grains(__opts__)\n    pillar = salt.pillar.Pillar(\n        __opts__,\n        grains,\n        id_,\n        saltenv)\n\n    top, errors = pillar.get_top()\n\n    if errors:\n        __jid_event__.fire_event({'data': errors, 'outputter': 'nested'}, 'progress')\n        return errors\n\n    # needed because pillar compilation clobbers grains etc via lazyLoader\n    # this resets the masterminion back to known state\n    __salt__['salt.cmd']('sys.reload_modules')\n\n    return top", "language": "python", "code": "def show_top(minion=None, saltenv='base'):\n    '''\n    Returns the compiled top data for pillar for a specific minion.  If no\n    minion is specified, we use the first minion we find.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt-run pillar.show_top\n    '''\n    id_, grains, _ = salt.utils.minions.get_minion_data(minion, __opts__)\n    if not grains and minion == __opts__['id']:\n        grains = salt.loader.grains(__opts__)\n    pillar = salt.pillar.Pillar(\n        __opts__,\n        grains,\n        id_,\n        saltenv)\n\n    top, errors = pillar.get_top()\n\n    if errors:\n        __jid_event__.fire_event({'data': errors, 'outputter': 'nested'}, 'progress')\n        return errors\n\n    # needed because pillar compilation clobbers grains etc via lazyLoader\n    # this resets the masterminion back to known state\n    __salt__['salt.cmd']('sys.reload_modules')\n\n    return top", "code_tokens": ["def", "show_top", "(", "minion", "=", "None", ",", "saltenv", "=", "'base'", ")", ":", "id_", ",", "grains", ",", "_", "=", "salt", ".", "utils", ".", "minions", ".", "get_minion_data", "(", "minion", ",", "__opts__", ")", "if", "not", "grains", "and", "minion", "==", "__opts__", "[", "'id'", "]", ":", "grains", "=", "salt", ".", "loader", ".", "grains", "(", "__opts__", ")", "pillar", "=", "salt", ".", "pillar", ".", "Pillar", "(", "__opts__", ",", "grains", ",", "id_", ",", "saltenv", ")", "top", ",", "errors", "=", "pillar", ".", "get_top", "(", ")", "if", "errors", ":", "__jid_event__", ".", "fire_event", "(", "{", "'data'", ":", "errors", ",", "'outputter'", ":", "'nested'", "}", ",", "'progress'", ")", "return", "errors", "# needed because pillar compilation clobbers grains etc via lazyLoader", "# this resets the masterminion back to known state", "__salt__", "[", "'salt.cmd'", "]", "(", "'sys.reload_modules'", ")", "return", "top"], "docstring": "Returns the compiled top data for pillar for a specific minion.  If no\n    minion is specified, we use the first minion we find.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt-run pillar.show_top", "docstring_tokens": ["Returns", "the", "compiled", "top", "data", "for", "pillar", "for", "a", "specific", "minion", ".", "If", "no", "minion", "is", "specified", "we", "use", "the", "first", "minion", "we", "find", "."], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/runners/pillar.py#L13-L43", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/runners/pillar.py", "func_name": "show_pillar", "original_string": "def show_pillar(minion='*', **kwargs):\n    '''\n    Returns the compiled pillar either of a specific minion\n    or just the global available pillars. This function assumes\n    that no minion has the id ``*``.\n    Function also accepts pillarenv as attribute in order to limit to a specific pillar branch of git\n\n    CLI Example:\n\n    shows minion specific pillar:\n\n    .. code-block:: bash\n\n        salt-run pillar.show_pillar 'www.example.com'\n\n    shows global pillar:\n\n    .. code-block:: bash\n\n        salt-run pillar.show_pillar\n\n    shows global pillar for 'dev' pillar environment:\n    (note that not specifying pillarenv will merge all pillar environments\n    using the master config option pillar_source_merging_strategy.)\n\n    .. code-block:: bash\n\n        salt-run pillar.show_pillar 'pillarenv=dev'\n\n    shows global pillar for 'dev' pillar environment and specific pillarenv = dev:\n\n    .. code-block:: bash\n\n        salt-run pillar.show_pillar 'saltenv=dev' 'pillarenv=dev'\n\n    API Example:\n\n    .. code-block:: python\n\n        import salt.config\n        import salt.runner\n        opts = salt.config.master_config('/etc/salt/master')\n        runner = salt.runner.RunnerClient(opts)\n        pillar = runner.cmd('pillar.show_pillar', [])\n        print(pillar)\n    '''\n    pillarenv = None\n    saltenv = 'base'\n    id_, grains, _ = salt.utils.minions.get_minion_data(minion, __opts__)\n    if not grains and minion == __opts__['id']:\n        grains = salt.loader.grains(__opts__)\n    if grains is None:\n        grains = {'fqdn': minion}\n\n    for key in kwargs:\n        if key == 'saltenv':\n            saltenv = kwargs[key]\n        elif key == 'pillarenv':\n            # pillarenv overridden on CLI\n            pillarenv = kwargs[key]\n        else:\n            grains[key] = kwargs[key]\n\n    pillar = salt.pillar.Pillar(\n        __opts__,\n        grains,\n        id_,\n        saltenv,\n        pillarenv=pillarenv)\n\n    compiled_pillar = pillar.compile_pillar()\n\n    # needed because pillar compilation clobbers grains etc via lazyLoader\n    # this resets the masterminion back to known state\n    __salt__['salt.cmd']('sys.reload_modules')\n\n    return compiled_pillar", "language": "python", "code": "def show_pillar(minion='*', **kwargs):\n    '''\n    Returns the compiled pillar either of a specific minion\n    or just the global available pillars. This function assumes\n    that no minion has the id ``*``.\n    Function also accepts pillarenv as attribute in order to limit to a specific pillar branch of git\n\n    CLI Example:\n\n    shows minion specific pillar:\n\n    .. code-block:: bash\n\n        salt-run pillar.show_pillar 'www.example.com'\n\n    shows global pillar:\n\n    .. code-block:: bash\n\n        salt-run pillar.show_pillar\n\n    shows global pillar for 'dev' pillar environment:\n    (note that not specifying pillarenv will merge all pillar environments\n    using the master config option pillar_source_merging_strategy.)\n\n    .. code-block:: bash\n\n        salt-run pillar.show_pillar 'pillarenv=dev'\n\n    shows global pillar for 'dev' pillar environment and specific pillarenv = dev:\n\n    .. code-block:: bash\n\n        salt-run pillar.show_pillar 'saltenv=dev' 'pillarenv=dev'\n\n    API Example:\n\n    .. code-block:: python\n\n        import salt.config\n        import salt.runner\n        opts = salt.config.master_config('/etc/salt/master')\n        runner = salt.runner.RunnerClient(opts)\n        pillar = runner.cmd('pillar.show_pillar', [])\n        print(pillar)\n    '''\n    pillarenv = None\n    saltenv = 'base'\n    id_, grains, _ = salt.utils.minions.get_minion_data(minion, __opts__)\n    if not grains and minion == __opts__['id']:\n        grains = salt.loader.grains(__opts__)\n    if grains is None:\n        grains = {'fqdn': minion}\n\n    for key in kwargs:\n        if key == 'saltenv':\n            saltenv = kwargs[key]\n        elif key == 'pillarenv':\n            # pillarenv overridden on CLI\n            pillarenv = kwargs[key]\n        else:\n            grains[key] = kwargs[key]\n\n    pillar = salt.pillar.Pillar(\n        __opts__,\n        grains,\n        id_,\n        saltenv,\n        pillarenv=pillarenv)\n\n    compiled_pillar = pillar.compile_pillar()\n\n    # needed because pillar compilation clobbers grains etc via lazyLoader\n    # this resets the masterminion back to known state\n    __salt__['salt.cmd']('sys.reload_modules')\n\n    return compiled_pillar", "code_tokens": ["def", "show_pillar", "(", "minion", "=", "'*'", ",", "*", "*", "kwargs", ")", ":", "pillarenv", "=", "None", "saltenv", "=", "'base'", "id_", ",", "grains", ",", "_", "=", "salt", ".", "utils", ".", "minions", ".", "get_minion_data", "(", "minion", ",", "__opts__", ")", "if", "not", "grains", "and", "minion", "==", "__opts__", "[", "'id'", "]", ":", "grains", "=", "salt", ".", "loader", ".", "grains", "(", "__opts__", ")", "if", "grains", "is", "None", ":", "grains", "=", "{", "'fqdn'", ":", "minion", "}", "for", "key", "in", "kwargs", ":", "if", "key", "==", "'saltenv'", ":", "saltenv", "=", "kwargs", "[", "key", "]", "elif", "key", "==", "'pillarenv'", ":", "# pillarenv overridden on CLI", "pillarenv", "=", "kwargs", "[", "key", "]", "else", ":", "grains", "[", "key", "]", "=", "kwargs", "[", "key", "]", "pillar", "=", "salt", ".", "pillar", ".", "Pillar", "(", "__opts__", ",", "grains", ",", "id_", ",", "saltenv", ",", "pillarenv", "=", "pillarenv", ")", "compiled_pillar", "=", "pillar", ".", "compile_pillar", "(", ")", "# needed because pillar compilation clobbers grains etc via lazyLoader", "# this resets the masterminion back to known state", "__salt__", "[", "'salt.cmd'", "]", "(", "'sys.reload_modules'", ")", "return", "compiled_pillar"], "docstring": "Returns the compiled pillar either of a specific minion\n    or just the global available pillars. This function assumes\n    that no minion has the id ``*``.\n    Function also accepts pillarenv as attribute in order to limit to a specific pillar branch of git\n\n    CLI Example:\n\n    shows minion specific pillar:\n\n    .. code-block:: bash\n\n        salt-run pillar.show_pillar 'www.example.com'\n\n    shows global pillar:\n\n    .. code-block:: bash\n\n        salt-run pillar.show_pillar\n\n    shows global pillar for 'dev' pillar environment:\n    (note that not specifying pillarenv will merge all pillar environments\n    using the master config option pillar_source_merging_strategy.)\n\n    .. code-block:: bash\n\n        salt-run pillar.show_pillar 'pillarenv=dev'\n\n    shows global pillar for 'dev' pillar environment and specific pillarenv = dev:\n\n    .. code-block:: bash\n\n        salt-run pillar.show_pillar 'saltenv=dev' 'pillarenv=dev'\n\n    API Example:\n\n    .. code-block:: python\n\n        import salt.config\n        import salt.runner\n        opts = salt.config.master_config('/etc/salt/master')\n        runner = salt.runner.RunnerClient(opts)\n        pillar = runner.cmd('pillar.show_pillar', [])\n        print(pillar)", "docstring_tokens": ["Returns", "the", "compiled", "pillar", "either", "of", "a", "specific", "minion", "or", "just", "the", "global", "available", "pillars", ".", "This", "function", "assumes", "that", "no", "minion", "has", "the", "id", "*", ".", "Function", "also", "accepts", "pillarenv", "as", "attribute", "in", "order", "to", "limit", "to", "a", "specific", "pillar", "branch", "of", "git"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/runners/pillar.py#L46-L122", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/modules/rvm.py", "func_name": "install", "original_string": "def install(runas=None):\n    '''\n    Install RVM system-wide\n\n    runas\n        The user under which to run the rvm installer script. If not specified,\n        then it be run as the user under which Salt is running.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' rvm.install\n    '''\n    # RVM dependencies on Ubuntu 10.04:\n    #   bash coreutils gzip bzip2 gawk sed curl git-core subversion\n    installer = 'https://raw.githubusercontent.com/rvm/rvm/master/binscripts/rvm-installer'\n    ret = __salt__['cmd.run_all'](\n        # the RVM installer automatically does a multi-user install when it is\n        # invoked with root privileges\n        'curl -Ls {installer} | bash -s stable'.format(installer=installer),\n        runas=runas,\n        python_shell=True\n    )\n    if ret['retcode'] > 0:\n        msg = 'Error encountered while downloading the RVM installer'\n        if ret['stderr']:\n            msg += '. stderr follows:\\n\\n' + ret['stderr']\n        raise CommandExecutionError(msg)\n    return True", "language": "python", "code": "def install(runas=None):\n    '''\n    Install RVM system-wide\n\n    runas\n        The user under which to run the rvm installer script. If not specified,\n        then it be run as the user under which Salt is running.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' rvm.install\n    '''\n    # RVM dependencies on Ubuntu 10.04:\n    #   bash coreutils gzip bzip2 gawk sed curl git-core subversion\n    installer = 'https://raw.githubusercontent.com/rvm/rvm/master/binscripts/rvm-installer'\n    ret = __salt__['cmd.run_all'](\n        # the RVM installer automatically does a multi-user install when it is\n        # invoked with root privileges\n        'curl -Ls {installer} | bash -s stable'.format(installer=installer),\n        runas=runas,\n        python_shell=True\n    )\n    if ret['retcode'] > 0:\n        msg = 'Error encountered while downloading the RVM installer'\n        if ret['stderr']:\n            msg += '. stderr follows:\\n\\n' + ret['stderr']\n        raise CommandExecutionError(msg)\n    return True", "code_tokens": ["def", "install", "(", "runas", "=", "None", ")", ":", "# RVM dependencies on Ubuntu 10.04:", "#   bash coreutils gzip bzip2 gawk sed curl git-core subversion", "installer", "=", "'https://raw.githubusercontent.com/rvm/rvm/master/binscripts/rvm-installer'", "ret", "=", "__salt__", "[", "'cmd.run_all'", "]", "(", "# the RVM installer automatically does a multi-user install when it is", "# invoked with root privileges", "'curl -Ls {installer} | bash -s stable'", ".", "format", "(", "installer", "=", "installer", ")", ",", "runas", "=", "runas", ",", "python_shell", "=", "True", ")", "if", "ret", "[", "'retcode'", "]", ">", "0", ":", "msg", "=", "'Error encountered while downloading the RVM installer'", "if", "ret", "[", "'stderr'", "]", ":", "msg", "+=", "'. stderr follows:\\n\\n'", "+", "ret", "[", "'stderr'", "]", "raise", "CommandExecutionError", "(", "msg", ")", "return", "True"], "docstring": "Install RVM system-wide\n\n    runas\n        The user under which to run the rvm installer script. If not specified,\n        then it be run as the user under which Salt is running.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' rvm.install", "docstring_tokens": ["Install", "RVM", "system", "-", "wide"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/modules/rvm.py#L79-L108", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/modules/rvm.py", "func_name": "install_ruby", "original_string": "def install_ruby(ruby, runas=None, opts=None, env=None):\n    '''\n    Install a ruby implementation.\n\n    ruby\n        The version of ruby to install\n\n    runas\n        The user under which to run rvm. If not specified, then rvm will be run\n        as the user under which Salt is running.\n\n    env\n        Environment to set for the install command. Useful for exporting compilation\n        flags such as RUBY_CONFIGURE_OPTS\n\n    opts\n        List of options to pass to the RVM installer (ie -C, --patch, etc)\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' rvm.install_ruby 1.9.3-p385\n    '''\n    # MRI/RBX/REE dependencies for Ubuntu 10.04:\n    #   build-essential openssl libreadline6 libreadline6-dev curl\n    #   git-core zlib1g zlib1g-dev libssl-dev libyaml-dev libsqlite3-0\n    #   libsqlite3-dev sqlite3 libxml2-dev libxslt1-dev autoconf libc6-dev\n    #   libncurses5-dev automake libtool bison subversion ruby\n    if opts is None:\n        opts = []\n\n    if runas and runas != 'root':\n        _rvm(['autolibs', 'disable', ruby] + opts, runas=runas)\n        opts.append('--disable-binary')\n    return _rvm(['install', ruby] + opts, runas=runas, env=env)", "language": "python", "code": "def install_ruby(ruby, runas=None, opts=None, env=None):\n    '''\n    Install a ruby implementation.\n\n    ruby\n        The version of ruby to install\n\n    runas\n        The user under which to run rvm. If not specified, then rvm will be run\n        as the user under which Salt is running.\n\n    env\n        Environment to set for the install command. Useful for exporting compilation\n        flags such as RUBY_CONFIGURE_OPTS\n\n    opts\n        List of options to pass to the RVM installer (ie -C, --patch, etc)\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' rvm.install_ruby 1.9.3-p385\n    '''\n    # MRI/RBX/REE dependencies for Ubuntu 10.04:\n    #   build-essential openssl libreadline6 libreadline6-dev curl\n    #   git-core zlib1g zlib1g-dev libssl-dev libyaml-dev libsqlite3-0\n    #   libsqlite3-dev sqlite3 libxml2-dev libxslt1-dev autoconf libc6-dev\n    #   libncurses5-dev automake libtool bison subversion ruby\n    if opts is None:\n        opts = []\n\n    if runas and runas != 'root':\n        _rvm(['autolibs', 'disable', ruby] + opts, runas=runas)\n        opts.append('--disable-binary')\n    return _rvm(['install', ruby] + opts, runas=runas, env=env)", "code_tokens": ["def", "install_ruby", "(", "ruby", ",", "runas", "=", "None", ",", "opts", "=", "None", ",", "env", "=", "None", ")", ":", "# MRI/RBX/REE dependencies for Ubuntu 10.04:", "#   build-essential openssl libreadline6 libreadline6-dev curl", "#   git-core zlib1g zlib1g-dev libssl-dev libyaml-dev libsqlite3-0", "#   libsqlite3-dev sqlite3 libxml2-dev libxslt1-dev autoconf libc6-dev", "#   libncurses5-dev automake libtool bison subversion ruby", "if", "opts", "is", "None", ":", "opts", "=", "[", "]", "if", "runas", "and", "runas", "!=", "'root'", ":", "_rvm", "(", "[", "'autolibs'", ",", "'disable'", ",", "ruby", "]", "+", "opts", ",", "runas", "=", "runas", ")", "opts", ".", "append", "(", "'--disable-binary'", ")", "return", "_rvm", "(", "[", "'install'", ",", "ruby", "]", "+", "opts", ",", "runas", "=", "runas", ",", "env", "=", "env", ")"], "docstring": "Install a ruby implementation.\n\n    ruby\n        The version of ruby to install\n\n    runas\n        The user under which to run rvm. If not specified, then rvm will be run\n        as the user under which Salt is running.\n\n    env\n        Environment to set for the install command. Useful for exporting compilation\n        flags such as RUBY_CONFIGURE_OPTS\n\n    opts\n        List of options to pass to the RVM installer (ie -C, --patch, etc)\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' rvm.install_ruby 1.9.3-p385", "docstring_tokens": ["Install", "a", "ruby", "implementation", "."], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/modules/rvm.py#L111-L146", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/modules/rvm.py", "func_name": "reinstall_ruby", "original_string": "def reinstall_ruby(ruby, runas=None, env=None):\n    '''\n    Reinstall a ruby implementation\n\n    ruby\n        The version of ruby to reinstall\n\n    runas\n        The user under which to run rvm. If not specified, then rvm will be run\n        as the user under which Salt is running.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' rvm.reinstall_ruby 1.9.3-p385\n    '''\n    return _rvm(['reinstall', ruby], runas=runas, env=env)", "language": "python", "code": "def reinstall_ruby(ruby, runas=None, env=None):\n    '''\n    Reinstall a ruby implementation\n\n    ruby\n        The version of ruby to reinstall\n\n    runas\n        The user under which to run rvm. If not specified, then rvm will be run\n        as the user under which Salt is running.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' rvm.reinstall_ruby 1.9.3-p385\n    '''\n    return _rvm(['reinstall', ruby], runas=runas, env=env)", "code_tokens": ["def", "reinstall_ruby", "(", "ruby", ",", "runas", "=", "None", ",", "env", "=", "None", ")", ":", "return", "_rvm", "(", "[", "'reinstall'", ",", "ruby", "]", ",", "runas", "=", "runas", ",", "env", "=", "env", ")"], "docstring": "Reinstall a ruby implementation\n\n    ruby\n        The version of ruby to reinstall\n\n    runas\n        The user under which to run rvm. If not specified, then rvm will be run\n        as the user under which Salt is running.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' rvm.reinstall_ruby 1.9.3-p385", "docstring_tokens": ["Reinstall", "a", "ruby", "implementation"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/modules/rvm.py#L149-L166", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/modules/rvm.py", "func_name": "list_", "original_string": "def list_(runas=None):\n    '''\n    List all rvm-installed rubies\n\n    runas\n        The user under which to run rvm. If not specified, then rvm will be run\n        as the user under which Salt is running.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' rvm.list\n    '''\n    rubies = []\n    output = _rvm(['list'], runas=runas)\n    if output:\n        regex = re.compile(r'^[= ]([*> ]) ([^- ]+)-([^ ]+) \\[ (.*) \\]')\n        for line in output.splitlines():\n            match = regex.match(line)\n            if match:\n                rubies.append([\n                    match.group(2), match.group(3), match.group(1) == '*'\n                ])\n    return rubies", "language": "python", "code": "def list_(runas=None):\n    '''\n    List all rvm-installed rubies\n\n    runas\n        The user under which to run rvm. If not specified, then rvm will be run\n        as the user under which Salt is running.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' rvm.list\n    '''\n    rubies = []\n    output = _rvm(['list'], runas=runas)\n    if output:\n        regex = re.compile(r'^[= ]([*> ]) ([^- ]+)-([^ ]+) \\[ (.*) \\]')\n        for line in output.splitlines():\n            match = regex.match(line)\n            if match:\n                rubies.append([\n                    match.group(2), match.group(3), match.group(1) == '*'\n                ])\n    return rubies", "code_tokens": ["def", "list_", "(", "runas", "=", "None", ")", ":", "rubies", "=", "[", "]", "output", "=", "_rvm", "(", "[", "'list'", "]", ",", "runas", "=", "runas", ")", "if", "output", ":", "regex", "=", "re", ".", "compile", "(", "r'^[= ]([*> ]) ([^- ]+)-([^ ]+) \\[ (.*) \\]'", ")", "for", "line", "in", "output", ".", "splitlines", "(", ")", ":", "match", "=", "regex", ".", "match", "(", "line", ")", "if", "match", ":", "rubies", ".", "append", "(", "[", "match", ".", "group", "(", "2", ")", ",", "match", ".", "group", "(", "3", ")", ",", "match", ".", "group", "(", "1", ")", "==", "'*'", "]", ")", "return", "rubies"], "docstring": "List all rvm-installed rubies\n\n    runas\n        The user under which to run rvm. If not specified, then rvm will be run\n        as the user under which Salt is running.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' rvm.list", "docstring_tokens": ["List", "all", "rvm", "-", "installed", "rubies"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/modules/rvm.py#L169-L193", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/modules/rvm.py", "func_name": "wrapper", "original_string": "def wrapper(ruby_string, wrapper_prefix, runas=None, *binaries):\n    '''\n    Install RVM wrapper scripts\n\n    ruby_string\n        Ruby/gemset to install wrappers for\n\n    wrapper_prefix\n        What to prepend to the name of the generated wrapper binaries\n\n    runas\n        The user under which to run rvm. If not specified, then rvm will be run\n        as the user under which Salt is running.\n\n    binaries : None\n        The names of the binaries to create wrappers for. When nothing is\n        given, wrappers for ruby, gem, rake, irb, rdoc, ri and testrb are\n        generated.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' rvm.wrapper <ruby_string> <wrapper_prefix>\n    '''\n    cmd = ['wrapper', ruby_string, wrapper_prefix]\n    cmd.extend(binaries)\n    return _rvm(cmd, runas=runas)", "language": "python", "code": "def wrapper(ruby_string, wrapper_prefix, runas=None, *binaries):\n    '''\n    Install RVM wrapper scripts\n\n    ruby_string\n        Ruby/gemset to install wrappers for\n\n    wrapper_prefix\n        What to prepend to the name of the generated wrapper binaries\n\n    runas\n        The user under which to run rvm. If not specified, then rvm will be run\n        as the user under which Salt is running.\n\n    binaries : None\n        The names of the binaries to create wrappers for. When nothing is\n        given, wrappers for ruby, gem, rake, irb, rdoc, ri and testrb are\n        generated.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' rvm.wrapper <ruby_string> <wrapper_prefix>\n    '''\n    cmd = ['wrapper', ruby_string, wrapper_prefix]\n    cmd.extend(binaries)\n    return _rvm(cmd, runas=runas)", "code_tokens": ["def", "wrapper", "(", "ruby_string", ",", "wrapper_prefix", ",", "runas", "=", "None", ",", "*", "binaries", ")", ":", "cmd", "=", "[", "'wrapper'", ",", "ruby_string", ",", "wrapper_prefix", "]", "cmd", ".", "extend", "(", "binaries", ")", "return", "_rvm", "(", "cmd", ",", "runas", "=", "runas", ")"], "docstring": "Install RVM wrapper scripts\n\n    ruby_string\n        Ruby/gemset to install wrappers for\n\n    wrapper_prefix\n        What to prepend to the name of the generated wrapper binaries\n\n    runas\n        The user under which to run rvm. If not specified, then rvm will be run\n        as the user under which Salt is running.\n\n    binaries : None\n        The names of the binaries to create wrappers for. When nothing is\n        given, wrappers for ruby, gem, rake, irb, rdoc, ri and testrb are\n        generated.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' rvm.wrapper <ruby_string> <wrapper_prefix>", "docstring_tokens": ["Install", "RVM", "wrapper", "scripts"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/modules/rvm.py#L232-L259", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/modules/rvm.py", "func_name": "gemset_list", "original_string": "def gemset_list(ruby='default', runas=None):\n    '''\n    List all gemsets for the given ruby.\n\n    ruby : default\n        The ruby version for which to list the gemsets\n\n    runas\n        The user under which to run rvm. If not specified, then rvm will be run\n        as the user under which Salt is running.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' rvm.gemset_list\n    '''\n    gemsets = []\n    output = _rvm_do(ruby, ['rvm', 'gemset', 'list'], runas=runas)\n    if output:\n        regex = re.compile('^   ([^ ]+)')\n        for line in output.splitlines():\n            match = regex.match(line)\n            if match:\n                gemsets.append(match.group(1))\n    return gemsets", "language": "python", "code": "def gemset_list(ruby='default', runas=None):\n    '''\n    List all gemsets for the given ruby.\n\n    ruby : default\n        The ruby version for which to list the gemsets\n\n    runas\n        The user under which to run rvm. If not specified, then rvm will be run\n        as the user under which Salt is running.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' rvm.gemset_list\n    '''\n    gemsets = []\n    output = _rvm_do(ruby, ['rvm', 'gemset', 'list'], runas=runas)\n    if output:\n        regex = re.compile('^   ([^ ]+)')\n        for line in output.splitlines():\n            match = regex.match(line)\n            if match:\n                gemsets.append(match.group(1))\n    return gemsets", "code_tokens": ["def", "gemset_list", "(", "ruby", "=", "'default'", ",", "runas", "=", "None", ")", ":", "gemsets", "=", "[", "]", "output", "=", "_rvm_do", "(", "ruby", ",", "[", "'rvm'", ",", "'gemset'", ",", "'list'", "]", ",", "runas", "=", "runas", ")", "if", "output", ":", "regex", "=", "re", ".", "compile", "(", "'^   ([^ ]+)'", ")", "for", "line", "in", "output", ".", "splitlines", "(", ")", ":", "match", "=", "regex", ".", "match", "(", "line", ")", "if", "match", ":", "gemsets", ".", "append", "(", "match", ".", "group", "(", "1", ")", ")", "return", "gemsets"], "docstring": "List all gemsets for the given ruby.\n\n    ruby : default\n        The ruby version for which to list the gemsets\n\n    runas\n        The user under which to run rvm. If not specified, then rvm will be run\n        as the user under which Salt is running.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' rvm.gemset_list", "docstring_tokens": ["List", "all", "gemsets", "for", "the", "given", "ruby", "."], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/modules/rvm.py#L309-L334", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/modules/rvm.py", "func_name": "gemset_list_all", "original_string": "def gemset_list_all(runas=None):\n    '''\n    List all gemsets for all installed rubies.\n\n    Note that you must have set a default ruby before this can work.\n\n    runas\n        The user under which to run rvm. If not specified, then rvm will be run\n        as the user under which Salt is running.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' rvm.gemset_list_all\n    '''\n    gemsets = {}\n    current_ruby = None\n    output = _rvm_do('default', ['rvm', 'gemset', 'list_all'], runas=runas)\n    if output:\n        gems_regex = re.compile('^   ([^ ]+)')\n        gemset_regex = re.compile('^gemsets for ([^ ]+)')\n        for line in output.splitlines():\n            match = gemset_regex.match(line)\n            if match:\n                current_ruby = match.group(1)\n                gemsets[current_ruby] = []\n            match = gems_regex.match(line)\n            if match:\n                gemsets[current_ruby].append(match.group(1))\n    return gemsets", "language": "python", "code": "def gemset_list_all(runas=None):\n    '''\n    List all gemsets for all installed rubies.\n\n    Note that you must have set a default ruby before this can work.\n\n    runas\n        The user under which to run rvm. If not specified, then rvm will be run\n        as the user under which Salt is running.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' rvm.gemset_list_all\n    '''\n    gemsets = {}\n    current_ruby = None\n    output = _rvm_do('default', ['rvm', 'gemset', 'list_all'], runas=runas)\n    if output:\n        gems_regex = re.compile('^   ([^ ]+)')\n        gemset_regex = re.compile('^gemsets for ([^ ]+)')\n        for line in output.splitlines():\n            match = gemset_regex.match(line)\n            if match:\n                current_ruby = match.group(1)\n                gemsets[current_ruby] = []\n            match = gems_regex.match(line)\n            if match:\n                gemsets[current_ruby].append(match.group(1))\n    return gemsets", "code_tokens": ["def", "gemset_list_all", "(", "runas", "=", "None", ")", ":", "gemsets", "=", "{", "}", "current_ruby", "=", "None", "output", "=", "_rvm_do", "(", "'default'", ",", "[", "'rvm'", ",", "'gemset'", ",", "'list_all'", "]", ",", "runas", "=", "runas", ")", "if", "output", ":", "gems_regex", "=", "re", ".", "compile", "(", "'^   ([^ ]+)'", ")", "gemset_regex", "=", "re", ".", "compile", "(", "'^gemsets for ([^ ]+)'", ")", "for", "line", "in", "output", ".", "splitlines", "(", ")", ":", "match", "=", "gemset_regex", ".", "match", "(", "line", ")", "if", "match", ":", "current_ruby", "=", "match", ".", "group", "(", "1", ")", "gemsets", "[", "current_ruby", "]", "=", "[", "]", "match", "=", "gems_regex", ".", "match", "(", "line", ")", "if", "match", ":", "gemsets", "[", "current_ruby", "]", ".", "append", "(", "match", ".", "group", "(", "1", ")", ")", "return", "gemsets"], "docstring": "List all gemsets for all installed rubies.\n\n    Note that you must have set a default ruby before this can work.\n\n    runas\n        The user under which to run rvm. If not specified, then rvm will be run\n        as the user under which Salt is running.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' rvm.gemset_list_all", "docstring_tokens": ["List", "all", "gemsets", "for", "all", "installed", "rubies", "."], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/modules/rvm.py#L410-L440", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/modules/rvm.py", "func_name": "do", "original_string": "def do(ruby, command, runas=None, cwd=None, env=None):  # pylint: disable=C0103\n    '''\n    Execute a command in an RVM controlled environment.\n\n    ruby\n        Which ruby to use\n\n    command\n        The rvm command to execute\n\n    runas\n        The user under which to run rvm. If not specified, then rvm will be run\n        as the user under which Salt is running.\n\n    cwd\n        The directory from which to run the rvm command. Defaults to the user's\n        home directory.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' rvm.do 2.0.0 <command>\n    '''\n    try:\n        command = salt.utils.args.shlex_split(command)\n    except AttributeError:\n        command = salt.utils.args.shlex_split(six.text_type(command))\n    return _rvm_do(ruby, command, runas=runas, cwd=cwd, env=env)", "language": "python", "code": "def do(ruby, command, runas=None, cwd=None, env=None):  # pylint: disable=C0103\n    '''\n    Execute a command in an RVM controlled environment.\n\n    ruby\n        Which ruby to use\n\n    command\n        The rvm command to execute\n\n    runas\n        The user under which to run rvm. If not specified, then rvm will be run\n        as the user under which Salt is running.\n\n    cwd\n        The directory from which to run the rvm command. Defaults to the user's\n        home directory.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' rvm.do 2.0.0 <command>\n    '''\n    try:\n        command = salt.utils.args.shlex_split(command)\n    except AttributeError:\n        command = salt.utils.args.shlex_split(six.text_type(command))\n    return _rvm_do(ruby, command, runas=runas, cwd=cwd, env=env)", "code_tokens": ["def", "do", "(", "ruby", ",", "command", ",", "runas", "=", "None", ",", "cwd", "=", "None", ",", "env", "=", "None", ")", ":", "# pylint: disable=C0103", "try", ":", "command", "=", "salt", ".", "utils", ".", "args", ".", "shlex_split", "(", "command", ")", "except", "AttributeError", ":", "command", "=", "salt", ".", "utils", ".", "args", ".", "shlex_split", "(", "six", ".", "text_type", "(", "command", ")", ")", "return", "_rvm_do", "(", "ruby", ",", "command", ",", "runas", "=", "runas", ",", "cwd", "=", "cwd", ",", "env", "=", "env", ")"], "docstring": "Execute a command in an RVM controlled environment.\n\n    ruby\n        Which ruby to use\n\n    command\n        The rvm command to execute\n\n    runas\n        The user under which to run rvm. If not specified, then rvm will be run\n        as the user under which Salt is running.\n\n    cwd\n        The directory from which to run the rvm command. Defaults to the user's\n        home directory.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' rvm.do 2.0.0 <command>", "docstring_tokens": ["Execute", "a", "command", "in", "an", "RVM", "controlled", "environment", "."], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/modules/rvm.py#L443-L471", "partition": "train"}
{"repo": "saltstack/salt", "path": "doc/_ext/saltdomain.py", "func_name": "LiterateCoding.parse_file", "original_string": "def parse_file(self, fpath):\n        '''\n        Read a file on the file system (relative to salt's base project dir)\n\n        :returns: A file-like object.\n        :raises IOError: If the file cannot be found or read.\n        '''\n        sdir =  os.path.abspath(os.path.join(os.path.dirname(salt.__file__),\n            os.pardir))\n        with open(os.path.join(sdir, fpath), 'rb') as f:\n            return f.readlines()", "language": "python", "code": "def parse_file(self, fpath):\n        '''\n        Read a file on the file system (relative to salt's base project dir)\n\n        :returns: A file-like object.\n        :raises IOError: If the file cannot be found or read.\n        '''\n        sdir =  os.path.abspath(os.path.join(os.path.dirname(salt.__file__),\n            os.pardir))\n        with open(os.path.join(sdir, fpath), 'rb') as f:\n            return f.readlines()", "code_tokens": ["def", "parse_file", "(", "self", ",", "fpath", ")", ":", "sdir", "=", "os", ".", "path", ".", "abspath", "(", "os", ".", "path", ".", "join", "(", "os", ".", "path", ".", "dirname", "(", "salt", ".", "__file__", ")", ",", "os", ".", "pardir", ")", ")", "with", "open", "(", "os", ".", "path", ".", "join", "(", "sdir", ",", "fpath", ")", ",", "'rb'", ")", "as", "f", ":", "return", "f", ".", "readlines", "(", ")"], "docstring": "Read a file on the file system (relative to salt's base project dir)\n\n        :returns: A file-like object.\n        :raises IOError: If the file cannot be found or read.", "docstring_tokens": ["Read", "a", "file", "on", "the", "file", "system", "(", "relative", "to", "salt", "s", "base", "project", "dir", ")"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/doc/_ext/saltdomain.py#L40-L50", "partition": "train"}
{"repo": "saltstack/salt", "path": "doc/_ext/saltdomain.py", "func_name": "LiterateCoding.parse_lit", "original_string": "def parse_lit(self, lines):\n        '''\n        Parse a string line-by-line delineating comments and code\n\n        :returns: An tuple of boolean/list-of-string pairs. True designates a\n            comment; False designates code.\n        '''\n        comment_char = '#' # TODO: move this into a directive option\n        comment = re.compile(r'^\\s*{0}[ \\n]'.format(comment_char))\n        section_test = lambda val: bool(comment.match(val))\n\n        sections = []\n        for is_doc, group in itertools.groupby(lines, section_test):\n            if is_doc:\n                text = [comment.sub('', i).rstrip('\\r\\n') for i in group]\n            else:\n                text = [i.rstrip('\\r\\n') for i in group]\n\n            sections.append((is_doc, text))\n\n        return sections", "language": "python", "code": "def parse_lit(self, lines):\n        '''\n        Parse a string line-by-line delineating comments and code\n\n        :returns: An tuple of boolean/list-of-string pairs. True designates a\n            comment; False designates code.\n        '''\n        comment_char = '#' # TODO: move this into a directive option\n        comment = re.compile(r'^\\s*{0}[ \\n]'.format(comment_char))\n        section_test = lambda val: bool(comment.match(val))\n\n        sections = []\n        for is_doc, group in itertools.groupby(lines, section_test):\n            if is_doc:\n                text = [comment.sub('', i).rstrip('\\r\\n') for i in group]\n            else:\n                text = [i.rstrip('\\r\\n') for i in group]\n\n            sections.append((is_doc, text))\n\n        return sections", "code_tokens": ["def", "parse_lit", "(", "self", ",", "lines", ")", ":", "comment_char", "=", "'#'", "# TODO: move this into a directive option", "comment", "=", "re", ".", "compile", "(", "r'^\\s*{0}[ \\n]'", ".", "format", "(", "comment_char", ")", ")", "section_test", "=", "lambda", "val", ":", "bool", "(", "comment", ".", "match", "(", "val", ")", ")", "sections", "=", "[", "]", "for", "is_doc", ",", "group", "in", "itertools", ".", "groupby", "(", "lines", ",", "section_test", ")", ":", "if", "is_doc", ":", "text", "=", "[", "comment", ".", "sub", "(", "''", ",", "i", ")", ".", "rstrip", "(", "'\\r\\n'", ")", "for", "i", "in", "group", "]", "else", ":", "text", "=", "[", "i", ".", "rstrip", "(", "'\\r\\n'", ")", "for", "i", "in", "group", "]", "sections", ".", "append", "(", "(", "is_doc", ",", "text", ")", ")", "return", "sections"], "docstring": "Parse a string line-by-line delineating comments and code\n\n        :returns: An tuple of boolean/list-of-string pairs. True designates a\n            comment; False designates code.", "docstring_tokens": ["Parse", "a", "string", "line", "-", "by", "-", "line", "delineating", "comments", "and", "code"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/doc/_ext/saltdomain.py#L52-L72", "partition": "train"}
{"repo": "saltstack/salt", "path": "doc/_ext/saltdomain.py", "func_name": "LiterateFormula.parse_file", "original_string": "def parse_file(self, sls_path):\n        '''\n        Given a typical Salt SLS path (e.g.: apache.vhosts.standard), find the\n        file on the file system and parse it\n        '''\n        config = self.state.document.settings.env.config\n        formulas_dirs = config.formulas_dirs\n        fpath = sls_path.replace('.', '/')\n\n        name_options = (\n            '{0}.sls'.format(fpath),\n            os.path.join(fpath, 'init.sls')\n        )\n\n        paths = [os.path.join(fdir, fname)\n                for fname in name_options\n                    for fdir in formulas_dirs]\n\n        for i in paths:\n            try:\n                with open(i, 'rb') as f:\n                    return f.readlines()\n            except IOError:\n                pass\n\n        raise IOError(\"Could not find sls file '{0}'\".format(sls_path))", "language": "python", "code": "def parse_file(self, sls_path):\n        '''\n        Given a typical Salt SLS path (e.g.: apache.vhosts.standard), find the\n        file on the file system and parse it\n        '''\n        config = self.state.document.settings.env.config\n        formulas_dirs = config.formulas_dirs\n        fpath = sls_path.replace('.', '/')\n\n        name_options = (\n            '{0}.sls'.format(fpath),\n            os.path.join(fpath, 'init.sls')\n        )\n\n        paths = [os.path.join(fdir, fname)\n                for fname in name_options\n                    for fdir in formulas_dirs]\n\n        for i in paths:\n            try:\n                with open(i, 'rb') as f:\n                    return f.readlines()\n            except IOError:\n                pass\n\n        raise IOError(\"Could not find sls file '{0}'\".format(sls_path))", "code_tokens": ["def", "parse_file", "(", "self", ",", "sls_path", ")", ":", "config", "=", "self", ".", "state", ".", "document", ".", "settings", ".", "env", ".", "config", "formulas_dirs", "=", "config", ".", "formulas_dirs", "fpath", "=", "sls_path", ".", "replace", "(", "'.'", ",", "'/'", ")", "name_options", "=", "(", "'{0}.sls'", ".", "format", "(", "fpath", ")", ",", "os", ".", "path", ".", "join", "(", "fpath", ",", "'init.sls'", ")", ")", "paths", "=", "[", "os", ".", "path", ".", "join", "(", "fdir", ",", "fname", ")", "for", "fname", "in", "name_options", "for", "fdir", "in", "formulas_dirs", "]", "for", "i", "in", "paths", ":", "try", ":", "with", "open", "(", "i", ",", "'rb'", ")", "as", "f", ":", "return", "f", ".", "readlines", "(", ")", "except", "IOError", ":", "pass", "raise", "IOError", "(", "\"Could not find sls file '{0}'\"", ".", "format", "(", "sls_path", ")", ")"], "docstring": "Given a typical Salt SLS path (e.g.: apache.vhosts.standard), find the\n        file on the file system and parse it", "docstring_tokens": ["Given", "a", "typical", "Salt", "SLS", "path", "(", "e", ".", "g", ".", ":", "apache", ".", "vhosts", ".", "standard", ")", "find", "the", "file", "on", "the", "file", "system", "and", "parse", "it"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/doc/_ext/saltdomain.py#L134-L159", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/matchers/compound_pillar_exact_match.py", "func_name": "mmatch", "original_string": "def mmatch(expr, delimiter, greedy, opts=None):\n    '''\n    Return the minions found by looking via pillar\n    '''\n    if not opts:\n        opts = __opts__\n\n    ckminions = salt.utils.minions.CkMinions(opts)\n    return ckminions._check_compound_minions(expr, delimiter, greedy,\n                                             pillar_exact=True)", "language": "python", "code": "def mmatch(expr, delimiter, greedy, opts=None):\n    '''\n    Return the minions found by looking via pillar\n    '''\n    if not opts:\n        opts = __opts__\n\n    ckminions = salt.utils.minions.CkMinions(opts)\n    return ckminions._check_compound_minions(expr, delimiter, greedy,\n                                             pillar_exact=True)", "code_tokens": ["def", "mmatch", "(", "expr", ",", "delimiter", ",", "greedy", ",", "opts", "=", "None", ")", ":", "if", "not", "opts", ":", "opts", "=", "__opts__", "ckminions", "=", "salt", ".", "utils", ".", "minions", ".", "CkMinions", "(", "opts", ")", "return", "ckminions", ".", "_check_compound_minions", "(", "expr", ",", "delimiter", ",", "greedy", ",", "pillar_exact", "=", "True", ")"], "docstring": "Return the minions found by looking via pillar", "docstring_tokens": ["Return", "the", "minions", "found", "by", "looking", "via", "pillar"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/matchers/compound_pillar_exact_match.py#L17-L26", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/modules/sysfs.py", "func_name": "attr", "original_string": "def attr(key, value=None):\n    '''\n    Access/write a SysFS attribute.\n    If the attribute is a symlink, it's destination is returned\n\n    :return: value or bool\n\n    CLI example:\n     .. code-block:: bash\n\n        salt '*' sysfs.attr block/sda/queue/logical_block_size\n    '''\n    key = target(key)\n\n    if key is False:\n        return False\n    elif os.path.isdir(key):\n        return key\n    elif value is not None:\n        return write(key, value)\n    else:\n        return read(key)", "language": "python", "code": "def attr(key, value=None):\n    '''\n    Access/write a SysFS attribute.\n    If the attribute is a symlink, it's destination is returned\n\n    :return: value or bool\n\n    CLI example:\n     .. code-block:: bash\n\n        salt '*' sysfs.attr block/sda/queue/logical_block_size\n    '''\n    key = target(key)\n\n    if key is False:\n        return False\n    elif os.path.isdir(key):\n        return key\n    elif value is not None:\n        return write(key, value)\n    else:\n        return read(key)", "code_tokens": ["def", "attr", "(", "key", ",", "value", "=", "None", ")", ":", "key", "=", "target", "(", "key", ")", "if", "key", "is", "False", ":", "return", "False", "elif", "os", ".", "path", ".", "isdir", "(", "key", ")", ":", "return", "key", "elif", "value", "is", "not", "None", ":", "return", "write", "(", "key", ",", "value", ")", "else", ":", "return", "read", "(", "key", ")"], "docstring": "Access/write a SysFS attribute.\n    If the attribute is a symlink, it's destination is returned\n\n    :return: value or bool\n\n    CLI example:\n     .. code-block:: bash\n\n        salt '*' sysfs.attr block/sda/queue/logical_block_size", "docstring_tokens": ["Access", "/", "write", "a", "SysFS", "attribute", ".", "If", "the", "attribute", "is", "a", "symlink", "it", "s", "destination", "is", "returned"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/modules/sysfs.py#L32-L53", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/modules/sysfs.py", "func_name": "write", "original_string": "def write(key, value):\n    '''\n    Write a SysFS attribute/action\n\n    CLI example:\n     .. code-block:: bash\n\n        salt '*' sysfs.write devices/system/cpu/cpu0/cpufreq/scaling_governor 'performance'\n    '''\n    try:\n        key = target(key)\n        log.trace('Writing %s to %s', value, key)\n        with salt.utils.files.fopen(key, 'w') as twriter:\n            twriter.write(\n                salt.utils.stringutils.to_str('{0}\\n'.format(value))\n            )\n            return True\n    except Exception:\n        return False", "language": "python", "code": "def write(key, value):\n    '''\n    Write a SysFS attribute/action\n\n    CLI example:\n     .. code-block:: bash\n\n        salt '*' sysfs.write devices/system/cpu/cpu0/cpufreq/scaling_governor 'performance'\n    '''\n    try:\n        key = target(key)\n        log.trace('Writing %s to %s', value, key)\n        with salt.utils.files.fopen(key, 'w') as twriter:\n            twriter.write(\n                salt.utils.stringutils.to_str('{0}\\n'.format(value))\n            )\n            return True\n    except Exception:\n        return False", "code_tokens": ["def", "write", "(", "key", ",", "value", ")", ":", "try", ":", "key", "=", "target", "(", "key", ")", "log", ".", "trace", "(", "'Writing %s to %s'", ",", "value", ",", "key", ")", "with", "salt", ".", "utils", ".", "files", ".", "fopen", "(", "key", ",", "'w'", ")", "as", "twriter", ":", "twriter", ".", "write", "(", "salt", ".", "utils", ".", "stringutils", ".", "to_str", "(", "'{0}\\n'", ".", "format", "(", "value", ")", ")", ")", "return", "True", "except", "Exception", ":", "return", "False"], "docstring": "Write a SysFS attribute/action\n\n    CLI example:\n     .. code-block:: bash\n\n        salt '*' sysfs.write devices/system/cpu/cpu0/cpufreq/scaling_governor 'performance'", "docstring_tokens": ["Write", "a", "SysFS", "attribute", "/", "action"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/modules/sysfs.py#L56-L74", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/modules/sysfs.py", "func_name": "read", "original_string": "def read(key, root=''):\n    '''\n    Read from SysFS\n\n    :param key: file or path in SysFS; if key is a list then root will be prefixed on each key\n\n    :return: the full (tree of) SysFS attributes under key\n\n    CLI example:\n     .. code-block:: bash\n\n        salt '*' sysfs.read class/net/em1/statistics\n    '''\n\n    if not isinstance(key, six.string_types):\n        res = {}\n        for akey in key:\n            ares = read(os.path.join(root, akey))\n            if ares is not False:\n                res[akey] = ares\n        return res\n\n    key = target(os.path.join(root, key))\n    if key is False:\n        return False\n    elif os.path.isdir(key):\n        keys = interfaces(key)\n        result = {}\n        for subkey in keys['r'] + keys['rw']:\n            subval = read(os.path.join(key, subkey))\n            if subval is not False:\n                subkeys = subkey.split('/')\n                subkey = subkeys.pop()\n                subresult = result\n                if subkeys:\n                    for skey in subkeys:\n                        if skey not in subresult:\n                            subresult[skey] = {}\n                        subresult = subresult[skey]\n                subresult[subkey] = subval\n        return result\n    else:\n        try:\n            log.trace('Reading %s...', key)\n\n            # Certain things in SysFS are pipes 'n such.\n            # This opens it non-blocking, which prevents indefinite blocking\n            with os.fdopen(os.open(key, os.O_RDONLY | os.O_NONBLOCK)) as treader:\n                # alternative method for the same idea, but only works for completely empty pipes\n                # treader = select.select([treader], [], [], 1)[0][0]\n                val = treader.read().strip()\n                if not val:\n                    return False\n                try:\n                    val = int(val)\n                except Exception:\n                    try:\n                        val = float(val)\n                    except Exception:\n                        pass\n                return val\n        except Exception:\n            return False", "language": "python", "code": "def read(key, root=''):\n    '''\n    Read from SysFS\n\n    :param key: file or path in SysFS; if key is a list then root will be prefixed on each key\n\n    :return: the full (tree of) SysFS attributes under key\n\n    CLI example:\n     .. code-block:: bash\n\n        salt '*' sysfs.read class/net/em1/statistics\n    '''\n\n    if not isinstance(key, six.string_types):\n        res = {}\n        for akey in key:\n            ares = read(os.path.join(root, akey))\n            if ares is not False:\n                res[akey] = ares\n        return res\n\n    key = target(os.path.join(root, key))\n    if key is False:\n        return False\n    elif os.path.isdir(key):\n        keys = interfaces(key)\n        result = {}\n        for subkey in keys['r'] + keys['rw']:\n            subval = read(os.path.join(key, subkey))\n            if subval is not False:\n                subkeys = subkey.split('/')\n                subkey = subkeys.pop()\n                subresult = result\n                if subkeys:\n                    for skey in subkeys:\n                        if skey not in subresult:\n                            subresult[skey] = {}\n                        subresult = subresult[skey]\n                subresult[subkey] = subval\n        return result\n    else:\n        try:\n            log.trace('Reading %s...', key)\n\n            # Certain things in SysFS are pipes 'n such.\n            # This opens it non-blocking, which prevents indefinite blocking\n            with os.fdopen(os.open(key, os.O_RDONLY | os.O_NONBLOCK)) as treader:\n                # alternative method for the same idea, but only works for completely empty pipes\n                # treader = select.select([treader], [], [], 1)[0][0]\n                val = treader.read().strip()\n                if not val:\n                    return False\n                try:\n                    val = int(val)\n                except Exception:\n                    try:\n                        val = float(val)\n                    except Exception:\n                        pass\n                return val\n        except Exception:\n            return False", "code_tokens": ["def", "read", "(", "key", ",", "root", "=", "''", ")", ":", "if", "not", "isinstance", "(", "key", ",", "six", ".", "string_types", ")", ":", "res", "=", "{", "}", "for", "akey", "in", "key", ":", "ares", "=", "read", "(", "os", ".", "path", ".", "join", "(", "root", ",", "akey", ")", ")", "if", "ares", "is", "not", "False", ":", "res", "[", "akey", "]", "=", "ares", "return", "res", "key", "=", "target", "(", "os", ".", "path", ".", "join", "(", "root", ",", "key", ")", ")", "if", "key", "is", "False", ":", "return", "False", "elif", "os", ".", "path", ".", "isdir", "(", "key", ")", ":", "keys", "=", "interfaces", "(", "key", ")", "result", "=", "{", "}", "for", "subkey", "in", "keys", "[", "'r'", "]", "+", "keys", "[", "'rw'", "]", ":", "subval", "=", "read", "(", "os", ".", "path", ".", "join", "(", "key", ",", "subkey", ")", ")", "if", "subval", "is", "not", "False", ":", "subkeys", "=", "subkey", ".", "split", "(", "'/'", ")", "subkey", "=", "subkeys", ".", "pop", "(", ")", "subresult", "=", "result", "if", "subkeys", ":", "for", "skey", "in", "subkeys", ":", "if", "skey", "not", "in", "subresult", ":", "subresult", "[", "skey", "]", "=", "{", "}", "subresult", "=", "subresult", "[", "skey", "]", "subresult", "[", "subkey", "]", "=", "subval", "return", "result", "else", ":", "try", ":", "log", ".", "trace", "(", "'Reading %s...'", ",", "key", ")", "# Certain things in SysFS are pipes 'n such.", "# This opens it non-blocking, which prevents indefinite blocking", "with", "os", ".", "fdopen", "(", "os", ".", "open", "(", "key", ",", "os", ".", "O_RDONLY", "|", "os", ".", "O_NONBLOCK", ")", ")", "as", "treader", ":", "# alternative method for the same idea, but only works for completely empty pipes", "# treader = select.select([treader], [], [], 1)[0][0]", "val", "=", "treader", ".", "read", "(", ")", ".", "strip", "(", ")", "if", "not", "val", ":", "return", "False", "try", ":", "val", "=", "int", "(", "val", ")", "except", "Exception", ":", "try", ":", "val", "=", "float", "(", "val", ")", "except", "Exception", ":", "pass", "return", "val", "except", "Exception", ":", "return", "False"], "docstring": "Read from SysFS\n\n    :param key: file or path in SysFS; if key is a list then root will be prefixed on each key\n\n    :return: the full (tree of) SysFS attributes under key\n\n    CLI example:\n     .. code-block:: bash\n\n        salt '*' sysfs.read class/net/em1/statistics", "docstring_tokens": ["Read", "from", "SysFS"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/modules/sysfs.py#L77-L139", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/modules/sysfs.py", "func_name": "target", "original_string": "def target(key, full=True):\n    '''\n    Return the basename of a SysFS key path\n\n    :param key: the location to resolve within SysFS\n    :param full: full path instead of basename\n\n    :return: fullpath or basename of path\n\n    CLI example:\n     .. code-block:: bash\n\n        salt '*' sysfs.read class/ttyS0\n\n    '''\n    if not key.startswith('/sys'):\n        key = os.path.join('/sys', key)\n    key = os.path.realpath(key)\n\n    if not os.path.exists(key):\n        log.debug('Unkown SysFS key %s', key)\n        return False\n    elif full:\n        return key\n    else:\n        return os.path.basename(key)", "language": "python", "code": "def target(key, full=True):\n    '''\n    Return the basename of a SysFS key path\n\n    :param key: the location to resolve within SysFS\n    :param full: full path instead of basename\n\n    :return: fullpath or basename of path\n\n    CLI example:\n     .. code-block:: bash\n\n        salt '*' sysfs.read class/ttyS0\n\n    '''\n    if not key.startswith('/sys'):\n        key = os.path.join('/sys', key)\n    key = os.path.realpath(key)\n\n    if not os.path.exists(key):\n        log.debug('Unkown SysFS key %s', key)\n        return False\n    elif full:\n        return key\n    else:\n        return os.path.basename(key)", "code_tokens": ["def", "target", "(", "key", ",", "full", "=", "True", ")", ":", "if", "not", "key", ".", "startswith", "(", "'/sys'", ")", ":", "key", "=", "os", ".", "path", ".", "join", "(", "'/sys'", ",", "key", ")", "key", "=", "os", ".", "path", ".", "realpath", "(", "key", ")", "if", "not", "os", ".", "path", ".", "exists", "(", "key", ")", ":", "log", ".", "debug", "(", "'Unkown SysFS key %s'", ",", "key", ")", "return", "False", "elif", "full", ":", "return", "key", "else", ":", "return", "os", ".", "path", ".", "basename", "(", "key", ")"], "docstring": "Return the basename of a SysFS key path\n\n    :param key: the location to resolve within SysFS\n    :param full: full path instead of basename\n\n    :return: fullpath or basename of path\n\n    CLI example:\n     .. code-block:: bash\n\n        salt '*' sysfs.read class/ttyS0", "docstring_tokens": ["Return", "the", "basename", "of", "a", "SysFS", "key", "path"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/modules/sysfs.py#L142-L167", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/modules/sysfs.py", "func_name": "interfaces", "original_string": "def interfaces(root):\n    '''\n    Generate a dictionary with all available interfaces relative to root.\n    Symlinks are not followed.\n\n    CLI example:\n     .. code-block:: bash\n\n        salt '*' sysfs.interfaces block/bcache0/bcache\n\n    Output example:\n     .. code-block:: json\n\n       {\n          \"r\": [\n            \"state\",\n            \"partial_stripes_expensive\",\n            \"writeback_rate_debug\",\n            \"stripe_size\",\n            \"dirty_data\",\n            \"stats_total/cache_hits\",\n            \"stats_total/cache_bypass_misses\",\n            \"stats_total/bypassed\",\n            \"stats_total/cache_readaheads\",\n            \"stats_total/cache_hit_ratio\",\n            \"stats_total/cache_miss_collisions\",\n            \"stats_total/cache_misses\",\n            \"stats_total/cache_bypass_hits\",\n          ],\n          \"rw\": [\n            \"writeback_rate\",\n            \"writeback_rate_update_seconds\",\n            \"cache_mode\",\n            \"writeback_delay\",\n            \"label\",\n            \"writeback_running\",\n            \"writeback_metadata\",\n            \"running\",\n            \"writeback_rate_p_term_inverse\",\n            \"sequential_cutoff\",\n            \"writeback_percent\",\n            \"writeback_rate_d_term\",\n            \"readahead\"\n          ],\n          \"w\": [\n            \"stop\",\n            \"clear_stats\",\n            \"attach\",\n            \"detach\"\n          ]\n       }\n\n    .. note::\n      * 'r' interfaces are read-only\n      * 'w' interfaces are write-only (e.g. actions)\n      * 'rw' are interfaces that can both be read or written\n    '''\n\n    root = target(root)\n    if root is False or not os.path.isdir(root):\n        log.error('SysFS %s not a dir', root)\n        return False\n\n    readwrites = []\n    reads = []\n    writes = []\n\n    for path, _, files in salt.utils.path.os_walk(root, followlinks=False):\n        for afile in files:\n            canpath = os.path.join(path, afile)\n\n            if not os.path.isfile(canpath):\n                continue\n\n            stat_mode = os.stat(canpath).st_mode\n            is_r = bool(stat.S_IRUSR & stat_mode)\n            is_w = bool(stat.S_IWUSR & stat_mode)\n\n            relpath = os.path.relpath(canpath, root)\n            if is_w:\n                if is_r:\n                    readwrites.append(relpath)\n                else:\n                    writes.append(relpath)\n            elif is_r:\n                reads.append(relpath)\n            else:\n                log.warning('Unable to find any interfaces in %s', canpath)\n\n    return {\n        'r': reads,\n        'w': writes,\n        'rw': readwrites\n    }", "language": "python", "code": "def interfaces(root):\n    '''\n    Generate a dictionary with all available interfaces relative to root.\n    Symlinks are not followed.\n\n    CLI example:\n     .. code-block:: bash\n\n        salt '*' sysfs.interfaces block/bcache0/bcache\n\n    Output example:\n     .. code-block:: json\n\n       {\n          \"r\": [\n            \"state\",\n            \"partial_stripes_expensive\",\n            \"writeback_rate_debug\",\n            \"stripe_size\",\n            \"dirty_data\",\n            \"stats_total/cache_hits\",\n            \"stats_total/cache_bypass_misses\",\n            \"stats_total/bypassed\",\n            \"stats_total/cache_readaheads\",\n            \"stats_total/cache_hit_ratio\",\n            \"stats_total/cache_miss_collisions\",\n            \"stats_total/cache_misses\",\n            \"stats_total/cache_bypass_hits\",\n          ],\n          \"rw\": [\n            \"writeback_rate\",\n            \"writeback_rate_update_seconds\",\n            \"cache_mode\",\n            \"writeback_delay\",\n            \"label\",\n            \"writeback_running\",\n            \"writeback_metadata\",\n            \"running\",\n            \"writeback_rate_p_term_inverse\",\n            \"sequential_cutoff\",\n            \"writeback_percent\",\n            \"writeback_rate_d_term\",\n            \"readahead\"\n          ],\n          \"w\": [\n            \"stop\",\n            \"clear_stats\",\n            \"attach\",\n            \"detach\"\n          ]\n       }\n\n    .. note::\n      * 'r' interfaces are read-only\n      * 'w' interfaces are write-only (e.g. actions)\n      * 'rw' are interfaces that can both be read or written\n    '''\n\n    root = target(root)\n    if root is False or not os.path.isdir(root):\n        log.error('SysFS %s not a dir', root)\n        return False\n\n    readwrites = []\n    reads = []\n    writes = []\n\n    for path, _, files in salt.utils.path.os_walk(root, followlinks=False):\n        for afile in files:\n            canpath = os.path.join(path, afile)\n\n            if not os.path.isfile(canpath):\n                continue\n\n            stat_mode = os.stat(canpath).st_mode\n            is_r = bool(stat.S_IRUSR & stat_mode)\n            is_w = bool(stat.S_IWUSR & stat_mode)\n\n            relpath = os.path.relpath(canpath, root)\n            if is_w:\n                if is_r:\n                    readwrites.append(relpath)\n                else:\n                    writes.append(relpath)\n            elif is_r:\n                reads.append(relpath)\n            else:\n                log.warning('Unable to find any interfaces in %s', canpath)\n\n    return {\n        'r': reads,\n        'w': writes,\n        'rw': readwrites\n    }", "code_tokens": ["def", "interfaces", "(", "root", ")", ":", "root", "=", "target", "(", "root", ")", "if", "root", "is", "False", "or", "not", "os", ".", "path", ".", "isdir", "(", "root", ")", ":", "log", ".", "error", "(", "'SysFS %s not a dir'", ",", "root", ")", "return", "False", "readwrites", "=", "[", "]", "reads", "=", "[", "]", "writes", "=", "[", "]", "for", "path", ",", "_", ",", "files", "in", "salt", ".", "utils", ".", "path", ".", "os_walk", "(", "root", ",", "followlinks", "=", "False", ")", ":", "for", "afile", "in", "files", ":", "canpath", "=", "os", ".", "path", ".", "join", "(", "path", ",", "afile", ")", "if", "not", "os", ".", "path", ".", "isfile", "(", "canpath", ")", ":", "continue", "stat_mode", "=", "os", ".", "stat", "(", "canpath", ")", ".", "st_mode", "is_r", "=", "bool", "(", "stat", ".", "S_IRUSR", "&", "stat_mode", ")", "is_w", "=", "bool", "(", "stat", ".", "S_IWUSR", "&", "stat_mode", ")", "relpath", "=", "os", ".", "path", ".", "relpath", "(", "canpath", ",", "root", ")", "if", "is_w", ":", "if", "is_r", ":", "readwrites", ".", "append", "(", "relpath", ")", "else", ":", "writes", ".", "append", "(", "relpath", ")", "elif", "is_r", ":", "reads", ".", "append", "(", "relpath", ")", "else", ":", "log", ".", "warning", "(", "'Unable to find any interfaces in %s'", ",", "canpath", ")", "return", "{", "'r'", ":", "reads", ",", "'w'", ":", "writes", ",", "'rw'", ":", "readwrites", "}"], "docstring": "Generate a dictionary with all available interfaces relative to root.\n    Symlinks are not followed.\n\n    CLI example:\n     .. code-block:: bash\n\n        salt '*' sysfs.interfaces block/bcache0/bcache\n\n    Output example:\n     .. code-block:: json\n\n       {\n          \"r\": [\n            \"state\",\n            \"partial_stripes_expensive\",\n            \"writeback_rate_debug\",\n            \"stripe_size\",\n            \"dirty_data\",\n            \"stats_total/cache_hits\",\n            \"stats_total/cache_bypass_misses\",\n            \"stats_total/bypassed\",\n            \"stats_total/cache_readaheads\",\n            \"stats_total/cache_hit_ratio\",\n            \"stats_total/cache_miss_collisions\",\n            \"stats_total/cache_misses\",\n            \"stats_total/cache_bypass_hits\",\n          ],\n          \"rw\": [\n            \"writeback_rate\",\n            \"writeback_rate_update_seconds\",\n            \"cache_mode\",\n            \"writeback_delay\",\n            \"label\",\n            \"writeback_running\",\n            \"writeback_metadata\",\n            \"running\",\n            \"writeback_rate_p_term_inverse\",\n            \"sequential_cutoff\",\n            \"writeback_percent\",\n            \"writeback_rate_d_term\",\n            \"readahead\"\n          ],\n          \"w\": [\n            \"stop\",\n            \"clear_stats\",\n            \"attach\",\n            \"detach\"\n          ]\n       }\n\n    .. note::\n      * 'r' interfaces are read-only\n      * 'w' interfaces are write-only (e.g. actions)\n      * 'rw' are interfaces that can both be read or written", "docstring_tokens": ["Generate", "a", "dictionary", "with", "all", "available", "interfaces", "relative", "to", "root", ".", "Symlinks", "are", "not", "followed", "."], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/modules/sysfs.py#L170-L263", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/returners/librato_return.py", "func_name": "_get_librato", "original_string": "def _get_librato(ret=None):\n    '''\n    Return a Librato connection object.\n    '''\n    _options = _get_options(ret)\n\n    conn = librato.connect(\n        _options.get('email'),\n        _options.get('api_token'),\n        sanitizer=librato.sanitize_metric_name,\n        hostname=_options.get('api_url'))\n    log.info(\"Connected to librato.\")\n    return conn", "language": "python", "code": "def _get_librato(ret=None):\n    '''\n    Return a Librato connection object.\n    '''\n    _options = _get_options(ret)\n\n    conn = librato.connect(\n        _options.get('email'),\n        _options.get('api_token'),\n        sanitizer=librato.sanitize_metric_name,\n        hostname=_options.get('api_url'))\n    log.info(\"Connected to librato.\")\n    return conn", "code_tokens": ["def", "_get_librato", "(", "ret", "=", "None", ")", ":", "_options", "=", "_get_options", "(", "ret", ")", "conn", "=", "librato", ".", "connect", "(", "_options", ".", "get", "(", "'email'", ")", ",", "_options", ".", "get", "(", "'api_token'", ")", ",", "sanitizer", "=", "librato", ".", "sanitize_metric_name", ",", "hostname", "=", "_options", ".", "get", "(", "'api_url'", ")", ")", "log", ".", "info", "(", "\"Connected to librato.\"", ")", "return", "conn"], "docstring": "Return a Librato connection object.", "docstring_tokens": ["Return", "a", "Librato", "connection", "object", "."], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/returners/librato_return.py#L82-L94", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/returners/librato_return.py", "func_name": "returner", "original_string": "def returner(ret):\n    '''\n    Parse the return data and return metrics to Librato.\n    '''\n    librato_conn = _get_librato(ret)\n\n    q = librato_conn.new_queue()\n\n    if ret['fun'] == 'state.highstate':\n        log.debug('Found returned Highstate data.')\n        # Calculate the runtimes and number of failed states.\n        stats = _calculate_runtimes(ret['return'])\n        log.debug('Batching Metric retcode with %s', ret['retcode'])\n        q.add('saltstack.highstate.retcode',\n              ret['retcode'], tags={'Name': ret['id']})\n\n        log.debug(\n            'Batching Metric num_failed_jobs with %s',\n            stats['num_failed_states']\n        )\n        q.add('saltstack.highstate.failed_states',\n              stats['num_failed_states'], tags={'Name': ret['id']})\n\n        log.debug(\n            'Batching Metric num_passed_states with %s',\n            stats['num_passed_states']\n        )\n        q.add('saltstack.highstate.passed_states',\n              stats['num_passed_states'], tags={'Name': ret['id']})\n\n        log.debug('Batching Metric runtime with %s', stats['runtime'])\n        q.add('saltstack.highstate.runtime',\n              stats['runtime'], tags={'Name': ret['id']})\n\n        log.debug(\n            'Batching Metric runtime with %s',\n            stats['num_failed_states'] + stats['num_passed_states']\n        )\n        q.add('saltstack.highstate.total_states', stats[\n              'num_failed_states'] + stats['num_passed_states'], tags={'Name': ret['id']})\n\n    log.info('Sending metrics to Librato.')\n    q.submit()", "language": "python", "code": "def returner(ret):\n    '''\n    Parse the return data and return metrics to Librato.\n    '''\n    librato_conn = _get_librato(ret)\n\n    q = librato_conn.new_queue()\n\n    if ret['fun'] == 'state.highstate':\n        log.debug('Found returned Highstate data.')\n        # Calculate the runtimes and number of failed states.\n        stats = _calculate_runtimes(ret['return'])\n        log.debug('Batching Metric retcode with %s', ret['retcode'])\n        q.add('saltstack.highstate.retcode',\n              ret['retcode'], tags={'Name': ret['id']})\n\n        log.debug(\n            'Batching Metric num_failed_jobs with %s',\n            stats['num_failed_states']\n        )\n        q.add('saltstack.highstate.failed_states',\n              stats['num_failed_states'], tags={'Name': ret['id']})\n\n        log.debug(\n            'Batching Metric num_passed_states with %s',\n            stats['num_passed_states']\n        )\n        q.add('saltstack.highstate.passed_states',\n              stats['num_passed_states'], tags={'Name': ret['id']})\n\n        log.debug('Batching Metric runtime with %s', stats['runtime'])\n        q.add('saltstack.highstate.runtime',\n              stats['runtime'], tags={'Name': ret['id']})\n\n        log.debug(\n            'Batching Metric runtime with %s',\n            stats['num_failed_states'] + stats['num_passed_states']\n        )\n        q.add('saltstack.highstate.total_states', stats[\n              'num_failed_states'] + stats['num_passed_states'], tags={'Name': ret['id']})\n\n    log.info('Sending metrics to Librato.')\n    q.submit()", "code_tokens": ["def", "returner", "(", "ret", ")", ":", "librato_conn", "=", "_get_librato", "(", "ret", ")", "q", "=", "librato_conn", ".", "new_queue", "(", ")", "if", "ret", "[", "'fun'", "]", "==", "'state.highstate'", ":", "log", ".", "debug", "(", "'Found returned Highstate data.'", ")", "# Calculate the runtimes and number of failed states.", "stats", "=", "_calculate_runtimes", "(", "ret", "[", "'return'", "]", ")", "log", ".", "debug", "(", "'Batching Metric retcode with %s'", ",", "ret", "[", "'retcode'", "]", ")", "q", ".", "add", "(", "'saltstack.highstate.retcode'", ",", "ret", "[", "'retcode'", "]", ",", "tags", "=", "{", "'Name'", ":", "ret", "[", "'id'", "]", "}", ")", "log", ".", "debug", "(", "'Batching Metric num_failed_jobs with %s'", ",", "stats", "[", "'num_failed_states'", "]", ")", "q", ".", "add", "(", "'saltstack.highstate.failed_states'", ",", "stats", "[", "'num_failed_states'", "]", ",", "tags", "=", "{", "'Name'", ":", "ret", "[", "'id'", "]", "}", ")", "log", ".", "debug", "(", "'Batching Metric num_passed_states with %s'", ",", "stats", "[", "'num_passed_states'", "]", ")", "q", ".", "add", "(", "'saltstack.highstate.passed_states'", ",", "stats", "[", "'num_passed_states'", "]", ",", "tags", "=", "{", "'Name'", ":", "ret", "[", "'id'", "]", "}", ")", "log", ".", "debug", "(", "'Batching Metric runtime with %s'", ",", "stats", "[", "'runtime'", "]", ")", "q", ".", "add", "(", "'saltstack.highstate.runtime'", ",", "stats", "[", "'runtime'", "]", ",", "tags", "=", "{", "'Name'", ":", "ret", "[", "'id'", "]", "}", ")", "log", ".", "debug", "(", "'Batching Metric runtime with %s'", ",", "stats", "[", "'num_failed_states'", "]", "+", "stats", "[", "'num_passed_states'", "]", ")", "q", ".", "add", "(", "'saltstack.highstate.total_states'", ",", "stats", "[", "'num_failed_states'", "]", "+", "stats", "[", "'num_passed_states'", "]", ",", "tags", "=", "{", "'Name'", ":", "ret", "[", "'id'", "]", "}", ")", "log", ".", "info", "(", "'Sending metrics to Librato.'", ")", "q", ".", "submit", "(", ")"], "docstring": "Parse the return data and return metrics to Librato.", "docstring_tokens": ["Parse", "the", "return", "data", "and", "return", "metrics", "to", "Librato", "."], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/returners/librato_return.py#L119-L161", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/states/keystone_endpoint.py", "func_name": "_common", "original_string": "def _common(ret, name, service_name, kwargs):\n    '''\n    Returns: tuple whose first element is a bool indicating success or failure\n             and the second element is either a ret dict for salt or an object\n    '''\n    if 'interface' not in kwargs and 'public_url' not in kwargs:\n        kwargs['interface'] = name\n    service = __salt__['keystoneng.service_get'](name_or_id=service_name)\n\n    if not service:\n        ret['comment'] = 'Cannot find service'\n        ret['result'] = False\n        return (False, ret)\n\n    filters = kwargs.copy()\n    filters.pop('enabled', None)\n    filters.pop('url', None)\n    filters['service_id'] = service.id\n    kwargs['service_name_or_id'] = service.id\n    endpoints = __salt__['keystoneng.endpoint_search'](filters=filters)\n\n    if len(endpoints) > 1:\n        ret['comment'] = \"Multiple endpoints match criteria\"\n        ret['result'] = False\n        return ret\n    endpoint = endpoints[0] if endpoints else None\n    return (True, endpoint)", "language": "python", "code": "def _common(ret, name, service_name, kwargs):\n    '''\n    Returns: tuple whose first element is a bool indicating success or failure\n             and the second element is either a ret dict for salt or an object\n    '''\n    if 'interface' not in kwargs and 'public_url' not in kwargs:\n        kwargs['interface'] = name\n    service = __salt__['keystoneng.service_get'](name_or_id=service_name)\n\n    if not service:\n        ret['comment'] = 'Cannot find service'\n        ret['result'] = False\n        return (False, ret)\n\n    filters = kwargs.copy()\n    filters.pop('enabled', None)\n    filters.pop('url', None)\n    filters['service_id'] = service.id\n    kwargs['service_name_or_id'] = service.id\n    endpoints = __salt__['keystoneng.endpoint_search'](filters=filters)\n\n    if len(endpoints) > 1:\n        ret['comment'] = \"Multiple endpoints match criteria\"\n        ret['result'] = False\n        return ret\n    endpoint = endpoints[0] if endpoints else None\n    return (True, endpoint)", "code_tokens": ["def", "_common", "(", "ret", ",", "name", ",", "service_name", ",", "kwargs", ")", ":", "if", "'interface'", "not", "in", "kwargs", "and", "'public_url'", "not", "in", "kwargs", ":", "kwargs", "[", "'interface'", "]", "=", "name", "service", "=", "__salt__", "[", "'keystoneng.service_get'", "]", "(", "name_or_id", "=", "service_name", ")", "if", "not", "service", ":", "ret", "[", "'comment'", "]", "=", "'Cannot find service'", "ret", "[", "'result'", "]", "=", "False", "return", "(", "False", ",", "ret", ")", "filters", "=", "kwargs", ".", "copy", "(", ")", "filters", ".", "pop", "(", "'enabled'", ",", "None", ")", "filters", ".", "pop", "(", "'url'", ",", "None", ")", "filters", "[", "'service_id'", "]", "=", "service", ".", "id", "kwargs", "[", "'service_name_or_id'", "]", "=", "service", ".", "id", "endpoints", "=", "__salt__", "[", "'keystoneng.endpoint_search'", "]", "(", "filters", "=", "filters", ")", "if", "len", "(", "endpoints", ")", ">", "1", ":", "ret", "[", "'comment'", "]", "=", "\"Multiple endpoints match criteria\"", "ret", "[", "'result'", "]", "=", "False", "return", "ret", "endpoint", "=", "endpoints", "[", "0", "]", "if", "endpoints", "else", "None", "return", "(", "True", ",", "endpoint", ")"], "docstring": "Returns: tuple whose first element is a bool indicating success or failure\n             and the second element is either a ret dict for salt or an object", "docstring_tokens": ["Returns", ":", "tuple", "whose", "first", "element", "is", "a", "bool", "indicating", "success", "or", "failure", "and", "the", "second", "element", "is", "either", "a", "ret", "dict", "for", "salt", "or", "an", "object"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/states/keystone_endpoint.py#L51-L77", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/states/keystone_endpoint.py", "func_name": "present", "original_string": "def present(name, service_name, auth=None, **kwargs):\n    '''\n    Ensure an endpoint exists and is up-to-date\n\n    name\n        Interface name\n\n    url\n        URL of the endpoint\n\n    service_name\n        Service name or ID\n\n    region\n        The region name to assign the endpoint\n\n    enabled\n        Boolean to control if endpoint is enabled\n    '''\n    ret = {'name': name,\n           'changes': {},\n           'result': True,\n           'comment': ''}\n\n    kwargs = __utils__['args.clean_kwargs'](**kwargs)\n\n    __salt__['keystoneng.setup_clouds'](auth)\n\n    success, val = _, endpoint = _common(ret, name, service_name, kwargs)\n    if not success:\n        return val\n\n    if not endpoint:\n        if __opts__['test'] is True:\n            ret['result'] = None\n            ret['changes'] = kwargs\n            ret['comment'] = 'Endpoint will be created.'\n            return ret\n\n        # NOTE(SamYaple): Endpoints are returned as a list which can contain\n        # several items depending on the options passed\n        endpoints = __salt__['keystoneng.endpoint_create'](**kwargs)\n        if len(endpoints) == 1:\n            ret['changes'] = endpoints[0]\n        else:\n            for i, endpoint in enumerate(endpoints):\n                ret['changes'][i] = endpoint\n        ret['comment'] = 'Created endpoint'\n        return ret\n\n    changes = __salt__['keystoneng.compare_changes'](endpoint, **kwargs)\n    if changes:\n        if __opts__['test'] is True:\n            ret['result'] = None\n            ret['changes'] = changes\n            ret['comment'] = 'Endpoint will be updated.'\n            return ret\n\n        kwargs['endpoint_id'] = endpoint.id\n        __salt__['keystoneng.endpoint_update'](**kwargs)\n        ret['changes'].update(changes)\n        ret['comment'] = 'Updated endpoint'\n\n    return ret", "language": "python", "code": "def present(name, service_name, auth=None, **kwargs):\n    '''\n    Ensure an endpoint exists and is up-to-date\n\n    name\n        Interface name\n\n    url\n        URL of the endpoint\n\n    service_name\n        Service name or ID\n\n    region\n        The region name to assign the endpoint\n\n    enabled\n        Boolean to control if endpoint is enabled\n    '''\n    ret = {'name': name,\n           'changes': {},\n           'result': True,\n           'comment': ''}\n\n    kwargs = __utils__['args.clean_kwargs'](**kwargs)\n\n    __salt__['keystoneng.setup_clouds'](auth)\n\n    success, val = _, endpoint = _common(ret, name, service_name, kwargs)\n    if not success:\n        return val\n\n    if not endpoint:\n        if __opts__['test'] is True:\n            ret['result'] = None\n            ret['changes'] = kwargs\n            ret['comment'] = 'Endpoint will be created.'\n            return ret\n\n        # NOTE(SamYaple): Endpoints are returned as a list which can contain\n        # several items depending on the options passed\n        endpoints = __salt__['keystoneng.endpoint_create'](**kwargs)\n        if len(endpoints) == 1:\n            ret['changes'] = endpoints[0]\n        else:\n            for i, endpoint in enumerate(endpoints):\n                ret['changes'][i] = endpoint\n        ret['comment'] = 'Created endpoint'\n        return ret\n\n    changes = __salt__['keystoneng.compare_changes'](endpoint, **kwargs)\n    if changes:\n        if __opts__['test'] is True:\n            ret['result'] = None\n            ret['changes'] = changes\n            ret['comment'] = 'Endpoint will be updated.'\n            return ret\n\n        kwargs['endpoint_id'] = endpoint.id\n        __salt__['keystoneng.endpoint_update'](**kwargs)\n        ret['changes'].update(changes)\n        ret['comment'] = 'Updated endpoint'\n\n    return ret", "code_tokens": ["def", "present", "(", "name", ",", "service_name", ",", "auth", "=", "None", ",", "*", "*", "kwargs", ")", ":", "ret", "=", "{", "'name'", ":", "name", ",", "'changes'", ":", "{", "}", ",", "'result'", ":", "True", ",", "'comment'", ":", "''", "}", "kwargs", "=", "__utils__", "[", "'args.clean_kwargs'", "]", "(", "*", "*", "kwargs", ")", "__salt__", "[", "'keystoneng.setup_clouds'", "]", "(", "auth", ")", "success", ",", "val", "=", "_", ",", "endpoint", "=", "_common", "(", "ret", ",", "name", ",", "service_name", ",", "kwargs", ")", "if", "not", "success", ":", "return", "val", "if", "not", "endpoint", ":", "if", "__opts__", "[", "'test'", "]", "is", "True", ":", "ret", "[", "'result'", "]", "=", "None", "ret", "[", "'changes'", "]", "=", "kwargs", "ret", "[", "'comment'", "]", "=", "'Endpoint will be created.'", "return", "ret", "# NOTE(SamYaple): Endpoints are returned as a list which can contain", "# several items depending on the options passed", "endpoints", "=", "__salt__", "[", "'keystoneng.endpoint_create'", "]", "(", "*", "*", "kwargs", ")", "if", "len", "(", "endpoints", ")", "==", "1", ":", "ret", "[", "'changes'", "]", "=", "endpoints", "[", "0", "]", "else", ":", "for", "i", ",", "endpoint", "in", "enumerate", "(", "endpoints", ")", ":", "ret", "[", "'changes'", "]", "[", "i", "]", "=", "endpoint", "ret", "[", "'comment'", "]", "=", "'Created endpoint'", "return", "ret", "changes", "=", "__salt__", "[", "'keystoneng.compare_changes'", "]", "(", "endpoint", ",", "*", "*", "kwargs", ")", "if", "changes", ":", "if", "__opts__", "[", "'test'", "]", "is", "True", ":", "ret", "[", "'result'", "]", "=", "None", "ret", "[", "'changes'", "]", "=", "changes", "ret", "[", "'comment'", "]", "=", "'Endpoint will be updated.'", "return", "ret", "kwargs", "[", "'endpoint_id'", "]", "=", "endpoint", ".", "id", "__salt__", "[", "'keystoneng.endpoint_update'", "]", "(", "*", "*", "kwargs", ")", "ret", "[", "'changes'", "]", ".", "update", "(", "changes", ")", "ret", "[", "'comment'", "]", "=", "'Updated endpoint'", "return", "ret"], "docstring": "Ensure an endpoint exists and is up-to-date\n\n    name\n        Interface name\n\n    url\n        URL of the endpoint\n\n    service_name\n        Service name or ID\n\n    region\n        The region name to assign the endpoint\n\n    enabled\n        Boolean to control if endpoint is enabled", "docstring_tokens": ["Ensure", "an", "endpoint", "exists", "and", "is", "up", "-", "to", "-", "date"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/states/keystone_endpoint.py#L80-L143", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/states/keystone_endpoint.py", "func_name": "absent", "original_string": "def absent(name, service_name, auth=None, **kwargs):\n    '''\n    Ensure an endpoint does not exists\n\n    name\n        Interface name\n\n    url\n        URL of the endpoint\n\n    service_name\n        Service name or ID\n\n    region\n        The region name to assign the endpoint\n    '''\n    ret = {'name': name,\n           'changes': {},\n           'result': True,\n           'comment': ''}\n\n    __salt__['keystoneng.setup_clouds'](auth)\n\n    success, val = _, endpoint = _common(ret, name, service_name, kwargs)\n    if not success:\n        return val\n\n    if endpoint:\n        if __opts__['test'] is True:\n            ret['result'] = None\n            ret['changes'] = {'id': endpoint.id}\n            ret['comment'] = 'Endpoint will be deleted.'\n            return ret\n\n        __salt__['keystoneng.endpoint_delete'](id=endpoint.id)\n        ret['changes']['id'] = endpoint.id\n        ret['comment'] = 'Deleted endpoint'\n\n    return ret", "language": "python", "code": "def absent(name, service_name, auth=None, **kwargs):\n    '''\n    Ensure an endpoint does not exists\n\n    name\n        Interface name\n\n    url\n        URL of the endpoint\n\n    service_name\n        Service name or ID\n\n    region\n        The region name to assign the endpoint\n    '''\n    ret = {'name': name,\n           'changes': {},\n           'result': True,\n           'comment': ''}\n\n    __salt__['keystoneng.setup_clouds'](auth)\n\n    success, val = _, endpoint = _common(ret, name, service_name, kwargs)\n    if not success:\n        return val\n\n    if endpoint:\n        if __opts__['test'] is True:\n            ret['result'] = None\n            ret['changes'] = {'id': endpoint.id}\n            ret['comment'] = 'Endpoint will be deleted.'\n            return ret\n\n        __salt__['keystoneng.endpoint_delete'](id=endpoint.id)\n        ret['changes']['id'] = endpoint.id\n        ret['comment'] = 'Deleted endpoint'\n\n    return ret", "code_tokens": ["def", "absent", "(", "name", ",", "service_name", ",", "auth", "=", "None", ",", "*", "*", "kwargs", ")", ":", "ret", "=", "{", "'name'", ":", "name", ",", "'changes'", ":", "{", "}", ",", "'result'", ":", "True", ",", "'comment'", ":", "''", "}", "__salt__", "[", "'keystoneng.setup_clouds'", "]", "(", "auth", ")", "success", ",", "val", "=", "_", ",", "endpoint", "=", "_common", "(", "ret", ",", "name", ",", "service_name", ",", "kwargs", ")", "if", "not", "success", ":", "return", "val", "if", "endpoint", ":", "if", "__opts__", "[", "'test'", "]", "is", "True", ":", "ret", "[", "'result'", "]", "=", "None", "ret", "[", "'changes'", "]", "=", "{", "'id'", ":", "endpoint", ".", "id", "}", "ret", "[", "'comment'", "]", "=", "'Endpoint will be deleted.'", "return", "ret", "__salt__", "[", "'keystoneng.endpoint_delete'", "]", "(", "id", "=", "endpoint", ".", "id", ")", "ret", "[", "'changes'", "]", "[", "'id'", "]", "=", "endpoint", ".", "id", "ret", "[", "'comment'", "]", "=", "'Deleted endpoint'", "return", "ret"], "docstring": "Ensure an endpoint does not exists\n\n    name\n        Interface name\n\n    url\n        URL of the endpoint\n\n    service_name\n        Service name or ID\n\n    region\n        The region name to assign the endpoint", "docstring_tokens": ["Ensure", "an", "endpoint", "does", "not", "exists"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/states/keystone_endpoint.py#L146-L184", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/runners/bgp.py", "func_name": "_get_bgp_runner_opts", "original_string": "def _get_bgp_runner_opts():\n    '''\n    Return the bgp runner options.\n    '''\n    runner_opts = __opts__.get('runners', {}).get('bgp', {})\n    return {\n        'tgt': runner_opts.get('tgt', _DEFAULT_TARGET),\n        'tgt_type': runner_opts.get('tgt_type', _DEFAULT_EXPR_FORM),\n        'display': runner_opts.get('display', _DEFAULT_DISPLAY),\n        'return_fields': _DEFAULT_INCLUDED_FIELDS + runner_opts.get('return_fields', _DEFAULT_RETURN_FIELDS),\n        'outputter': runner_opts.get('outputter', _DEFAULT_OUTPUTTER),\n    }", "language": "python", "code": "def _get_bgp_runner_opts():\n    '''\n    Return the bgp runner options.\n    '''\n    runner_opts = __opts__.get('runners', {}).get('bgp', {})\n    return {\n        'tgt': runner_opts.get('tgt', _DEFAULT_TARGET),\n        'tgt_type': runner_opts.get('tgt_type', _DEFAULT_EXPR_FORM),\n        'display': runner_opts.get('display', _DEFAULT_DISPLAY),\n        'return_fields': _DEFAULT_INCLUDED_FIELDS + runner_opts.get('return_fields', _DEFAULT_RETURN_FIELDS),\n        'outputter': runner_opts.get('outputter', _DEFAULT_OUTPUTTER),\n    }", "code_tokens": ["def", "_get_bgp_runner_opts", "(", ")", ":", "runner_opts", "=", "__opts__", ".", "get", "(", "'runners'", ",", "{", "}", ")", ".", "get", "(", "'bgp'", ",", "{", "}", ")", "return", "{", "'tgt'", ":", "runner_opts", ".", "get", "(", "'tgt'", ",", "_DEFAULT_TARGET", ")", ",", "'tgt_type'", ":", "runner_opts", ".", "get", "(", "'tgt_type'", ",", "_DEFAULT_EXPR_FORM", ")", ",", "'display'", ":", "runner_opts", ".", "get", "(", "'display'", ",", "_DEFAULT_DISPLAY", ")", ",", "'return_fields'", ":", "_DEFAULT_INCLUDED_FIELDS", "+", "runner_opts", ".", "get", "(", "'return_fields'", ",", "_DEFAULT_RETURN_FIELDS", ")", ",", "'outputter'", ":", "runner_opts", ".", "get", "(", "'outputter'", ",", "_DEFAULT_OUTPUTTER", ")", ",", "}"], "docstring": "Return the bgp runner options.", "docstring_tokens": ["Return", "the", "bgp", "runner", "options", "."], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/runners/bgp.py#L167-L178", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/runners/bgp.py", "func_name": "_compare_match", "original_string": "def _compare_match(dict1, dict2):\n    '''\n    Compare two dictionaries and return a boolean value if their values match.\n    '''\n    for karg, warg in six.iteritems(dict1):\n        if karg in dict2 and dict2[karg] != warg:\n            return False\n    return True", "language": "python", "code": "def _compare_match(dict1, dict2):\n    '''\n    Compare two dictionaries and return a boolean value if their values match.\n    '''\n    for karg, warg in six.iteritems(dict1):\n        if karg in dict2 and dict2[karg] != warg:\n            return False\n    return True", "code_tokens": ["def", "_compare_match", "(", "dict1", ",", "dict2", ")", ":", "for", "karg", ",", "warg", "in", "six", ".", "iteritems", "(", "dict1", ")", ":", "if", "karg", "in", "dict2", "and", "dict2", "[", "karg", "]", "!=", "warg", ":", "return", "False", "return", "True"], "docstring": "Compare two dictionaries and return a boolean value if their values match.", "docstring_tokens": ["Compare", "two", "dictionaries", "and", "return", "a", "boolean", "value", "if", "their", "values", "match", "."], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/runners/bgp.py#L193-L200", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/runners/bgp.py", "func_name": "_display_runner", "original_string": "def _display_runner(rows,\n                    labels,\n                    title,\n                    display=_DEFAULT_DISPLAY,\n                    outputter=_DEFAULT_OUTPUTTER):\n    '''\n    Display or return the rows.\n    '''\n    if display:\n        if outputter == 'table':\n            ret = salt.output.out_format({'rows': rows, 'labels': labels},\n                                         'table',\n                                         __opts__,\n                                         title=title,\n                                         rows_key='rows',\n                                         labels_key='labels')\n        else:\n            ret = salt.output.out_format(rows,\n                                         outputter,\n                                         __opts__)\n        print(ret)\n    else:\n        return rows", "language": "python", "code": "def _display_runner(rows,\n                    labels,\n                    title,\n                    display=_DEFAULT_DISPLAY,\n                    outputter=_DEFAULT_OUTPUTTER):\n    '''\n    Display or return the rows.\n    '''\n    if display:\n        if outputter == 'table':\n            ret = salt.output.out_format({'rows': rows, 'labels': labels},\n                                         'table',\n                                         __opts__,\n                                         title=title,\n                                         rows_key='rows',\n                                         labels_key='labels')\n        else:\n            ret = salt.output.out_format(rows,\n                                         outputter,\n                                         __opts__)\n        print(ret)\n    else:\n        return rows", "code_tokens": ["def", "_display_runner", "(", "rows", ",", "labels", ",", "title", ",", "display", "=", "_DEFAULT_DISPLAY", ",", "outputter", "=", "_DEFAULT_OUTPUTTER", ")", ":", "if", "display", ":", "if", "outputter", "==", "'table'", ":", "ret", "=", "salt", ".", "output", ".", "out_format", "(", "{", "'rows'", ":", "rows", ",", "'labels'", ":", "labels", "}", ",", "'table'", ",", "__opts__", ",", "title", "=", "title", ",", "rows_key", "=", "'rows'", ",", "labels_key", "=", "'labels'", ")", "else", ":", "ret", "=", "salt", ".", "output", ".", "out_format", "(", "rows", ",", "outputter", ",", "__opts__", ")", "print", "(", "ret", ")", "else", ":", "return", "rows"], "docstring": "Display or return the rows.", "docstring_tokens": ["Display", "or", "return", "the", "rows", "."], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/runners/bgp.py#L203-L225", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/runners/bgp.py", "func_name": "neighbors", "original_string": "def neighbors(*asns, **kwargs):\n    '''\n    Search for BGP neighbors details in the mines of the ``bgp.neighbors`` function.\n\n    Arguments:\n\n    asns\n        A list of AS numbers to search for.\n        The runner will return only the neighbors of these AS numbers.\n\n    device\n        Filter by device name (minion ID).\n\n    ip\n        Search BGP neighbor using the IP address.\n        In multi-VRF environments, the same IP address could be used by\n        more than one neighbors, in different routing tables.\n\n    network\n        Search neighbors within a certain IP network.\n\n    title\n        Custom title.\n\n    display: ``True``\n        Display on the screen or return structured object? Default: ``True`` (return on the CLI).\n\n    outputter: ``table``\n        Specify the outputter name when displaying on the CLI. Default: :mod:`table <salt.output.table_out>`.\n\n    In addition, any field from the output of the ``neighbors`` function\n    from the :mod:`NAPALM BGP module <salt.modules.napalm_bgp.neighbors>` can be used as a filter.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt-run bgp.neighbors 13335 15169\n        salt-run bgp.neighbors 13335 ip=172.17.19.1\n        salt-run bgp.neighbors multipath=True\n        salt-run bgp.neighbors up=False export_policy=my-export-policy multihop=False\n        salt-run bgp.neighbors network=192.168.0.0/16\n\n    Output example:\n\n    .. code-block:: text\n\n        BGP Neighbors for 13335, 15169\n        ________________________________________________________________________________________________________________________________________________________________\n        |    Device    | AS Number |         Neighbor Address        | State|#Active/Received/Accepted/Damped |         Policy IN         |         Policy OUT         |\n        ________________________________________________________________________________________________________________________________________________________________\n        | edge01.bjm01 |   13335   |          172.17.109.11          |        Established 0/398/398/0         |       import-policy       |        export-policy       |\n        ________________________________________________________________________________________________________________________________________________________________\n        | edge01.bjm01 |   13335   |          172.17.109.12          |       Established 397/398/398/0        |       import-policy       |        export-policy       |\n        ________________________________________________________________________________________________________________________________________________________________\n        | edge01.flw01 |   13335   |          192.168.172.11         |        Established 1/398/398/0         |       import-policy       |        export-policy       |\n        ________________________________________________________________________________________________________________________________________________________________\n        | edge01.oua01 |   13335   |          172.17.109.17          |          Established 0/0/0/0           |       import-policy       |        export-policy       |\n        ________________________________________________________________________________________________________________________________________________________________\n        | edge01.bjm01 |   15169   |             2001::1             |       Established 102/102/102/0        |       import-policy       |        export-policy       |\n        ________________________________________________________________________________________________________________________________________________________________\n        | edge01.bjm01 |   15169   |             2001::2             |       Established 102/102/102/0        |       import-policy       |        export-policy       |\n        ________________________________________________________________________________________________________________________________________________________________\n        | edge01.tbg01 |   13335   |          192.168.172.17         |          Established 0/1/1/0           |       import-policy       |        export-policy       |\n        ________________________________________________________________________________________________________________________________________________________________\n    '''\n    opts = _get_bgp_runner_opts()\n    title = kwargs.pop('title', None)\n    display = kwargs.pop('display', opts['display'])\n    outputter = kwargs.pop('outputter', opts['outputter'])\n\n    # cleaning up the kwargs\n    # __pub args not used in this runner (yet)\n    kwargs_copy = {}\n    kwargs_copy.update(kwargs)\n    for karg, _ in six.iteritems(kwargs_copy):\n        if karg.startswith('__pub'):\n            kwargs.pop(karg)\n    if not asns and not kwargs:\n        if display:\n            print('Please specify at least an AS Number or an output filter')\n        return []\n    device = kwargs.pop('device', None)\n    neighbor_ip = kwargs.pop('ip', None)\n    ipnet = kwargs.pop('network', None)\n    ipnet_obj = IPNetwork(ipnet) if ipnet else None\n    # any other key passed on the CLI can be used as a filter\n\n    rows = []\n    # building the labels\n    labels = {}\n    for field in opts['return_fields']:\n        if field in _DEFAULT_LABELS_MAPPING:\n            labels[field] = _DEFAULT_LABELS_MAPPING[field]\n        else:\n            # transform from 'previous_connection_state' to 'Previous Connection State'\n            labels[field] = ' '.join(map(lambda word: word.title(), field.split('_')))\n    display_fields = list(set(opts['return_fields']) - set(_DEFAULT_INCLUDED_FIELDS))\n    get_bgp_neighbors_all = _get_mine(opts=opts)\n\n    if not title:\n        title_parts = []\n        if asns:\n            title_parts.append('BGP Neighbors for {asns}'.format(\n                asns=', '.join([six.text_type(asn) for asn in asns])\n            ))\n        if neighbor_ip:\n            title_parts.append('Selecting neighbors having the remote IP address: {ipaddr}'.format(ipaddr=neighbor_ip))\n        if ipnet:\n            title_parts.append('Selecting neighbors within the IP network: {ipnet}'.format(ipnet=ipnet))\n        if kwargs:\n            title_parts.append('Searching for BGP neighbors having the attributes: {attrmap}'.format(\n                attrmap=', '.join(map(lambda key: '{key}={value}'.format(key=key, value=kwargs[key]), kwargs))\n            ))\n        title = '\\n'.join(title_parts)\n    for minion, get_bgp_neighbors_minion in six.iteritems(get_bgp_neighbors_all):  # pylint: disable=too-many-nested-blocks\n        if not get_bgp_neighbors_minion.get('result'):\n            continue  # ignore empty or failed mines\n        if device and minion != device:\n            # when requested to display only the neighbors on a certain device\n            continue\n        get_bgp_neighbors_minion_out = get_bgp_neighbors_minion.get('out', {})\n        for vrf, vrf_bgp_neighbors in six.iteritems(get_bgp_neighbors_minion_out):  # pylint: disable=unused-variable\n            for asn, get_bgp_neighbors_minion_asn in six.iteritems(vrf_bgp_neighbors):\n                if asns and asn not in asns:\n                    # if filtering by AS number(s),\n                    # will ignore if this AS number key not in that list\n                    # and continue the search\n                    continue\n                for neighbor in get_bgp_neighbors_minion_asn:\n                    if kwargs and not _compare_match(kwargs, neighbor):\n                        # requested filtering by neighbors stats\n                        # but this one does not correspond\n                        continue\n                    if neighbor_ip and neighbor_ip != neighbor.get('remote_address'):\n                        # requested filtering by neighbors IP addr\n                        continue\n                    if ipnet_obj and neighbor.get('remote_address'):\n                        neighbor_ip_obj = IPAddress(neighbor.get('remote_address'))\n                        if neighbor_ip_obj not in ipnet_obj:\n                            # Neighbor not in this network\n                            continue\n                    row = {\n                        'device': minion,\n                        'neighbor_address': neighbor.get('remote_address'),\n                        'as_number': asn\n                    }\n                    if 'vrf' in display_fields:\n                        row['vrf'] = vrf\n                    if 'connection_stats' in display_fields:\n                        connection_stats = '{state} {active}/{received}/{accepted}/{damped}'.format(\n                            state=neighbor.get('connection_state', -1),\n                            active=neighbor.get('active_prefix_count', -1),\n                            received=neighbor.get('received_prefix_count', -1),\n                            accepted=neighbor.get('accepted_prefix_count', -1),\n                            damped=neighbor.get('suppressed_prefix_count', -1),\n                        )\n                        row['connection_stats'] = connection_stats\n                    if 'interface_description' in display_fields or 'interface_name' in display_fields:\n                        net_find = __salt__['net.interfaces'](device=minion,\n                                                              ipnet=neighbor.get('remote_address'),\n                                                              display=False)\n                        if net_find:\n                            if 'interface_description' in display_fields:\n                                row['interface_description'] = net_find[0]['interface_description']\n                            if 'interface_name' in display_fields:\n                                row['interface_name'] = net_find[0]['interface']\n                        else:\n                            # if unable to find anything, leave blank\n                            if 'interface_description' in display_fields:\n                                row['interface_description'] = ''\n                            if 'interface_name' in display_fields:\n                                row['interface_name'] = ''\n                    for field in display_fields:\n                        if field in neighbor:\n                            row[field] = neighbor[field]\n                    rows.append(row)\n    return _display_runner(rows, labels, title, display=display, outputter=outputter)", "language": "python", "code": "def neighbors(*asns, **kwargs):\n    '''\n    Search for BGP neighbors details in the mines of the ``bgp.neighbors`` function.\n\n    Arguments:\n\n    asns\n        A list of AS numbers to search for.\n        The runner will return only the neighbors of these AS numbers.\n\n    device\n        Filter by device name (minion ID).\n\n    ip\n        Search BGP neighbor using the IP address.\n        In multi-VRF environments, the same IP address could be used by\n        more than one neighbors, in different routing tables.\n\n    network\n        Search neighbors within a certain IP network.\n\n    title\n        Custom title.\n\n    display: ``True``\n        Display on the screen or return structured object? Default: ``True`` (return on the CLI).\n\n    outputter: ``table``\n        Specify the outputter name when displaying on the CLI. Default: :mod:`table <salt.output.table_out>`.\n\n    In addition, any field from the output of the ``neighbors`` function\n    from the :mod:`NAPALM BGP module <salt.modules.napalm_bgp.neighbors>` can be used as a filter.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt-run bgp.neighbors 13335 15169\n        salt-run bgp.neighbors 13335 ip=172.17.19.1\n        salt-run bgp.neighbors multipath=True\n        salt-run bgp.neighbors up=False export_policy=my-export-policy multihop=False\n        salt-run bgp.neighbors network=192.168.0.0/16\n\n    Output example:\n\n    .. code-block:: text\n\n        BGP Neighbors for 13335, 15169\n        ________________________________________________________________________________________________________________________________________________________________\n        |    Device    | AS Number |         Neighbor Address        | State|#Active/Received/Accepted/Damped |         Policy IN         |         Policy OUT         |\n        ________________________________________________________________________________________________________________________________________________________________\n        | edge01.bjm01 |   13335   |          172.17.109.11          |        Established 0/398/398/0         |       import-policy       |        export-policy       |\n        ________________________________________________________________________________________________________________________________________________________________\n        | edge01.bjm01 |   13335   |          172.17.109.12          |       Established 397/398/398/0        |       import-policy       |        export-policy       |\n        ________________________________________________________________________________________________________________________________________________________________\n        | edge01.flw01 |   13335   |          192.168.172.11         |        Established 1/398/398/0         |       import-policy       |        export-policy       |\n        ________________________________________________________________________________________________________________________________________________________________\n        | edge01.oua01 |   13335   |          172.17.109.17          |          Established 0/0/0/0           |       import-policy       |        export-policy       |\n        ________________________________________________________________________________________________________________________________________________________________\n        | edge01.bjm01 |   15169   |             2001::1             |       Established 102/102/102/0        |       import-policy       |        export-policy       |\n        ________________________________________________________________________________________________________________________________________________________________\n        | edge01.bjm01 |   15169   |             2001::2             |       Established 102/102/102/0        |       import-policy       |        export-policy       |\n        ________________________________________________________________________________________________________________________________________________________________\n        | edge01.tbg01 |   13335   |          192.168.172.17         |          Established 0/1/1/0           |       import-policy       |        export-policy       |\n        ________________________________________________________________________________________________________________________________________________________________\n    '''\n    opts = _get_bgp_runner_opts()\n    title = kwargs.pop('title', None)\n    display = kwargs.pop('display', opts['display'])\n    outputter = kwargs.pop('outputter', opts['outputter'])\n\n    # cleaning up the kwargs\n    # __pub args not used in this runner (yet)\n    kwargs_copy = {}\n    kwargs_copy.update(kwargs)\n    for karg, _ in six.iteritems(kwargs_copy):\n        if karg.startswith('__pub'):\n            kwargs.pop(karg)\n    if not asns and not kwargs:\n        if display:\n            print('Please specify at least an AS Number or an output filter')\n        return []\n    device = kwargs.pop('device', None)\n    neighbor_ip = kwargs.pop('ip', None)\n    ipnet = kwargs.pop('network', None)\n    ipnet_obj = IPNetwork(ipnet) if ipnet else None\n    # any other key passed on the CLI can be used as a filter\n\n    rows = []\n    # building the labels\n    labels = {}\n    for field in opts['return_fields']:\n        if field in _DEFAULT_LABELS_MAPPING:\n            labels[field] = _DEFAULT_LABELS_MAPPING[field]\n        else:\n            # transform from 'previous_connection_state' to 'Previous Connection State'\n            labels[field] = ' '.join(map(lambda word: word.title(), field.split('_')))\n    display_fields = list(set(opts['return_fields']) - set(_DEFAULT_INCLUDED_FIELDS))\n    get_bgp_neighbors_all = _get_mine(opts=opts)\n\n    if not title:\n        title_parts = []\n        if asns:\n            title_parts.append('BGP Neighbors for {asns}'.format(\n                asns=', '.join([six.text_type(asn) for asn in asns])\n            ))\n        if neighbor_ip:\n            title_parts.append('Selecting neighbors having the remote IP address: {ipaddr}'.format(ipaddr=neighbor_ip))\n        if ipnet:\n            title_parts.append('Selecting neighbors within the IP network: {ipnet}'.format(ipnet=ipnet))\n        if kwargs:\n            title_parts.append('Searching for BGP neighbors having the attributes: {attrmap}'.format(\n                attrmap=', '.join(map(lambda key: '{key}={value}'.format(key=key, value=kwargs[key]), kwargs))\n            ))\n        title = '\\n'.join(title_parts)\n    for minion, get_bgp_neighbors_minion in six.iteritems(get_bgp_neighbors_all):  # pylint: disable=too-many-nested-blocks\n        if not get_bgp_neighbors_minion.get('result'):\n            continue  # ignore empty or failed mines\n        if device and minion != device:\n            # when requested to display only the neighbors on a certain device\n            continue\n        get_bgp_neighbors_minion_out = get_bgp_neighbors_minion.get('out', {})\n        for vrf, vrf_bgp_neighbors in six.iteritems(get_bgp_neighbors_minion_out):  # pylint: disable=unused-variable\n            for asn, get_bgp_neighbors_minion_asn in six.iteritems(vrf_bgp_neighbors):\n                if asns and asn not in asns:\n                    # if filtering by AS number(s),\n                    # will ignore if this AS number key not in that list\n                    # and continue the search\n                    continue\n                for neighbor in get_bgp_neighbors_minion_asn:\n                    if kwargs and not _compare_match(kwargs, neighbor):\n                        # requested filtering by neighbors stats\n                        # but this one does not correspond\n                        continue\n                    if neighbor_ip and neighbor_ip != neighbor.get('remote_address'):\n                        # requested filtering by neighbors IP addr\n                        continue\n                    if ipnet_obj and neighbor.get('remote_address'):\n                        neighbor_ip_obj = IPAddress(neighbor.get('remote_address'))\n                        if neighbor_ip_obj not in ipnet_obj:\n                            # Neighbor not in this network\n                            continue\n                    row = {\n                        'device': minion,\n                        'neighbor_address': neighbor.get('remote_address'),\n                        'as_number': asn\n                    }\n                    if 'vrf' in display_fields:\n                        row['vrf'] = vrf\n                    if 'connection_stats' in display_fields:\n                        connection_stats = '{state} {active}/{received}/{accepted}/{damped}'.format(\n                            state=neighbor.get('connection_state', -1),\n                            active=neighbor.get('active_prefix_count', -1),\n                            received=neighbor.get('received_prefix_count', -1),\n                            accepted=neighbor.get('accepted_prefix_count', -1),\n                            damped=neighbor.get('suppressed_prefix_count', -1),\n                        )\n                        row['connection_stats'] = connection_stats\n                    if 'interface_description' in display_fields or 'interface_name' in display_fields:\n                        net_find = __salt__['net.interfaces'](device=minion,\n                                                              ipnet=neighbor.get('remote_address'),\n                                                              display=False)\n                        if net_find:\n                            if 'interface_description' in display_fields:\n                                row['interface_description'] = net_find[0]['interface_description']\n                            if 'interface_name' in display_fields:\n                                row['interface_name'] = net_find[0]['interface']\n                        else:\n                            # if unable to find anything, leave blank\n                            if 'interface_description' in display_fields:\n                                row['interface_description'] = ''\n                            if 'interface_name' in display_fields:\n                                row['interface_name'] = ''\n                    for field in display_fields:\n                        if field in neighbor:\n                            row[field] = neighbor[field]\n                    rows.append(row)\n    return _display_runner(rows, labels, title, display=display, outputter=outputter)", "code_tokens": ["def", "neighbors", "(", "*", "asns", ",", "*", "*", "kwargs", ")", ":", "opts", "=", "_get_bgp_runner_opts", "(", ")", "title", "=", "kwargs", ".", "pop", "(", "'title'", ",", "None", ")", "display", "=", "kwargs", ".", "pop", "(", "'display'", ",", "opts", "[", "'display'", "]", ")", "outputter", "=", "kwargs", ".", "pop", "(", "'outputter'", ",", "opts", "[", "'outputter'", "]", ")", "# cleaning up the kwargs", "# __pub args not used in this runner (yet)", "kwargs_copy", "=", "{", "}", "kwargs_copy", ".", "update", "(", "kwargs", ")", "for", "karg", ",", "_", "in", "six", ".", "iteritems", "(", "kwargs_copy", ")", ":", "if", "karg", ".", "startswith", "(", "'__pub'", ")", ":", "kwargs", ".", "pop", "(", "karg", ")", "if", "not", "asns", "and", "not", "kwargs", ":", "if", "display", ":", "print", "(", "'Please specify at least an AS Number or an output filter'", ")", "return", "[", "]", "device", "=", "kwargs", ".", "pop", "(", "'device'", ",", "None", ")", "neighbor_ip", "=", "kwargs", ".", "pop", "(", "'ip'", ",", "None", ")", "ipnet", "=", "kwargs", ".", "pop", "(", "'network'", ",", "None", ")", "ipnet_obj", "=", "IPNetwork", "(", "ipnet", ")", "if", "ipnet", "else", "None", "# any other key passed on the CLI can be used as a filter", "rows", "=", "[", "]", "# building the labels", "labels", "=", "{", "}", "for", "field", "in", "opts", "[", "'return_fields'", "]", ":", "if", "field", "in", "_DEFAULT_LABELS_MAPPING", ":", "labels", "[", "field", "]", "=", "_DEFAULT_LABELS_MAPPING", "[", "field", "]", "else", ":", "# transform from 'previous_connection_state' to 'Previous Connection State'", "labels", "[", "field", "]", "=", "' '", ".", "join", "(", "map", "(", "lambda", "word", ":", "word", ".", "title", "(", ")", ",", "field", ".", "split", "(", "'_'", ")", ")", ")", "display_fields", "=", "list", "(", "set", "(", "opts", "[", "'return_fields'", "]", ")", "-", "set", "(", "_DEFAULT_INCLUDED_FIELDS", ")", ")", "get_bgp_neighbors_all", "=", "_get_mine", "(", "opts", "=", "opts", ")", "if", "not", "title", ":", "title_parts", "=", "[", "]", "if", "asns", ":", "title_parts", ".", "append", "(", "'BGP Neighbors for {asns}'", ".", "format", "(", "asns", "=", "', '", ".", "join", "(", "[", "six", ".", "text_type", "(", "asn", ")", "for", "asn", "in", "asns", "]", ")", ")", ")", "if", "neighbor_ip", ":", "title_parts", ".", "append", "(", "'Selecting neighbors having the remote IP address: {ipaddr}'", ".", "format", "(", "ipaddr", "=", "neighbor_ip", ")", ")", "if", "ipnet", ":", "title_parts", ".", "append", "(", "'Selecting neighbors within the IP network: {ipnet}'", ".", "format", "(", "ipnet", "=", "ipnet", ")", ")", "if", "kwargs", ":", "title_parts", ".", "append", "(", "'Searching for BGP neighbors having the attributes: {attrmap}'", ".", "format", "(", "attrmap", "=", "', '", ".", "join", "(", "map", "(", "lambda", "key", ":", "'{key}={value}'", ".", "format", "(", "key", "=", "key", ",", "value", "=", "kwargs", "[", "key", "]", ")", ",", "kwargs", ")", ")", ")", ")", "title", "=", "'\\n'", ".", "join", "(", "title_parts", ")", "for", "minion", ",", "get_bgp_neighbors_minion", "in", "six", ".", "iteritems", "(", "get_bgp_neighbors_all", ")", ":", "# pylint: disable=too-many-nested-blocks", "if", "not", "get_bgp_neighbors_minion", ".", "get", "(", "'result'", ")", ":", "continue", "# ignore empty or failed mines", "if", "device", "and", "minion", "!=", "device", ":", "# when requested to display only the neighbors on a certain device", "continue", "get_bgp_neighbors_minion_out", "=", "get_bgp_neighbors_minion", ".", "get", "(", "'out'", ",", "{", "}", ")", "for", "vrf", ",", "vrf_bgp_neighbors", "in", "six", ".", "iteritems", "(", "get_bgp_neighbors_minion_out", ")", ":", "# pylint: disable=unused-variable", "for", "asn", ",", "get_bgp_neighbors_minion_asn", "in", "six", ".", "iteritems", "(", "vrf_bgp_neighbors", ")", ":", "if", "asns", "and", "asn", "not", "in", "asns", ":", "# if filtering by AS number(s),", "# will ignore if this AS number key not in that list", "# and continue the search", "continue", "for", "neighbor", "in", "get_bgp_neighbors_minion_asn", ":", "if", "kwargs", "and", "not", "_compare_match", "(", "kwargs", ",", "neighbor", ")", ":", "# requested filtering by neighbors stats", "# but this one does not correspond", "continue", "if", "neighbor_ip", "and", "neighbor_ip", "!=", "neighbor", ".", "get", "(", "'remote_address'", ")", ":", "# requested filtering by neighbors IP addr", "continue", "if", "ipnet_obj", "and", "neighbor", ".", "get", "(", "'remote_address'", ")", ":", "neighbor_ip_obj", "=", "IPAddress", "(", "neighbor", ".", "get", "(", "'remote_address'", ")", ")", "if", "neighbor_ip_obj", "not", "in", "ipnet_obj", ":", "# Neighbor not in this network", "continue", "row", "=", "{", "'device'", ":", "minion", ",", "'neighbor_address'", ":", "neighbor", ".", "get", "(", "'remote_address'", ")", ",", "'as_number'", ":", "asn", "}", "if", "'vrf'", "in", "display_fields", ":", "row", "[", "'vrf'", "]", "=", "vrf", "if", "'connection_stats'", "in", "display_fields", ":", "connection_stats", "=", "'{state} {active}/{received}/{accepted}/{damped}'", ".", "format", "(", "state", "=", "neighbor", ".", "get", "(", "'connection_state'", ",", "-", "1", ")", ",", "active", "=", "neighbor", ".", "get", "(", "'active_prefix_count'", ",", "-", "1", ")", ",", "received", "=", "neighbor", ".", "get", "(", "'received_prefix_count'", ",", "-", "1", ")", ",", "accepted", "=", "neighbor", ".", "get", "(", "'accepted_prefix_count'", ",", "-", "1", ")", ",", "damped", "=", "neighbor", ".", "get", "(", "'suppressed_prefix_count'", ",", "-", "1", ")", ",", ")", "row", "[", "'connection_stats'", "]", "=", "connection_stats", "if", "'interface_description'", "in", "display_fields", "or", "'interface_name'", "in", "display_fields", ":", "net_find", "=", "__salt__", "[", "'net.interfaces'", "]", "(", "device", "=", "minion", ",", "ipnet", "=", "neighbor", ".", "get", "(", "'remote_address'", ")", ",", "display", "=", "False", ")", "if", "net_find", ":", "if", "'interface_description'", "in", "display_fields", ":", "row", "[", "'interface_description'", "]", "=", "net_find", "[", "0", "]", "[", "'interface_description'", "]", "if", "'interface_name'", "in", "display_fields", ":", "row", "[", "'interface_name'", "]", "=", "net_find", "[", "0", "]", "[", "'interface'", "]", "else", ":", "# if unable to find anything, leave blank", "if", "'interface_description'", "in", "display_fields", ":", "row", "[", "'interface_description'", "]", "=", "''", "if", "'interface_name'", "in", "display_fields", ":", "row", "[", "'interface_name'", "]", "=", "''", "for", "field", "in", "display_fields", ":", "if", "field", "in", "neighbor", ":", "row", "[", "field", "]", "=", "neighbor", "[", "field", "]", "rows", ".", "append", "(", "row", ")", "return", "_display_runner", "(", "rows", ",", "labels", ",", "title", ",", "display", "=", "display", ",", "outputter", "=", "outputter", ")"], "docstring": "Search for BGP neighbors details in the mines of the ``bgp.neighbors`` function.\n\n    Arguments:\n\n    asns\n        A list of AS numbers to search for.\n        The runner will return only the neighbors of these AS numbers.\n\n    device\n        Filter by device name (minion ID).\n\n    ip\n        Search BGP neighbor using the IP address.\n        In multi-VRF environments, the same IP address could be used by\n        more than one neighbors, in different routing tables.\n\n    network\n        Search neighbors within a certain IP network.\n\n    title\n        Custom title.\n\n    display: ``True``\n        Display on the screen or return structured object? Default: ``True`` (return on the CLI).\n\n    outputter: ``table``\n        Specify the outputter name when displaying on the CLI. Default: :mod:`table <salt.output.table_out>`.\n\n    In addition, any field from the output of the ``neighbors`` function\n    from the :mod:`NAPALM BGP module <salt.modules.napalm_bgp.neighbors>` can be used as a filter.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt-run bgp.neighbors 13335 15169\n        salt-run bgp.neighbors 13335 ip=172.17.19.1\n        salt-run bgp.neighbors multipath=True\n        salt-run bgp.neighbors up=False export_policy=my-export-policy multihop=False\n        salt-run bgp.neighbors network=192.168.0.0/16\n\n    Output example:\n\n    .. code-block:: text\n\n        BGP Neighbors for 13335, 15169\n        ________________________________________________________________________________________________________________________________________________________________\n        |    Device    | AS Number |         Neighbor Address        | State|#Active/Received/Accepted/Damped |         Policy IN         |         Policy OUT         |\n        ________________________________________________________________________________________________________________________________________________________________\n        | edge01.bjm01 |   13335   |          172.17.109.11          |        Established 0/398/398/0         |       import-policy       |        export-policy       |\n        ________________________________________________________________________________________________________________________________________________________________\n        | edge01.bjm01 |   13335   |          172.17.109.12          |       Established 397/398/398/0        |       import-policy       |        export-policy       |\n        ________________________________________________________________________________________________________________________________________________________________\n        | edge01.flw01 |   13335   |          192.168.172.11         |        Established 1/398/398/0         |       import-policy       |        export-policy       |\n        ________________________________________________________________________________________________________________________________________________________________\n        | edge01.oua01 |   13335   |          172.17.109.17          |          Established 0/0/0/0           |       import-policy       |        export-policy       |\n        ________________________________________________________________________________________________________________________________________________________________\n        | edge01.bjm01 |   15169   |             2001::1             |       Established 102/102/102/0        |       import-policy       |        export-policy       |\n        ________________________________________________________________________________________________________________________________________________________________\n        | edge01.bjm01 |   15169   |             2001::2             |       Established 102/102/102/0        |       import-policy       |        export-policy       |\n        ________________________________________________________________________________________________________________________________________________________________\n        | edge01.tbg01 |   13335   |          192.168.172.17         |          Established 0/1/1/0           |       import-policy       |        export-policy       |\n        ________________________________________________________________________________________________________________________________________________________________", "docstring_tokens": ["Search", "for", "BGP", "neighbors", "details", "in", "the", "mines", "of", "the", "bgp", ".", "neighbors", "function", "."], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/runners/bgp.py#L232-L409", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/returners/mongo_future_return.py", "func_name": "_get_conn", "original_string": "def _get_conn(ret):\n    '''\n    Return a mongodb connection object\n    '''\n    _options = _get_options(ret)\n\n    host = _options.get('host')\n    port = _options.get('port')\n    uri = _options.get('uri')\n    db_ = _options.get('db')\n    user = _options.get('user')\n    password = _options.get('password')\n    indexes = _options.get('indexes', False)\n\n    # at some point we should remove support for\n    # pymongo versions < 2.3 until then there are\n    # a bunch of these sections that need to be supported\n    if uri and PYMONGO_VERSION > _LooseVersion('2.3'):\n        if uri and host:\n            raise salt.exceptions.SaltConfigurationError(\n                    \"Mongo returner expects either uri or host configuration. Both were provided\")\n        pymongo.uri_parser.parse_uri(uri)\n        conn = pymongo.MongoClient(uri)\n        mdb = conn.get_database()\n    else:\n        if PYMONGO_VERSION > _LooseVersion('2.3'):\n            conn = pymongo.MongoClient(host, port)\n        else:\n            if uri:\n                raise salt.exceptions.SaltConfigurationError(\n                    \"pymongo <= 2.3 does not support uri format\")\n            conn = pymongo.Connection(host, port)\n\n        mdb = conn[db_]\n        if user and password:\n            mdb.authenticate(user, password)\n\n    if indexes:\n        if PYMONGO_VERSION > _LooseVersion('2.3'):\n            mdb.saltReturns.create_index('minion')\n            mdb.saltReturns.create_index('jid')\n            mdb.jobs.create_index('jid')\n            mdb.events.create_index('tag')\n        else:\n            mdb.saltReturns.ensure_index('minion')\n            mdb.saltReturns.ensure_index('jid')\n            mdb.jobs.ensure_index('jid')\n            mdb.events.ensure_index('tag')\n\n    return conn, mdb", "language": "python", "code": "def _get_conn(ret):\n    '''\n    Return a mongodb connection object\n    '''\n    _options = _get_options(ret)\n\n    host = _options.get('host')\n    port = _options.get('port')\n    uri = _options.get('uri')\n    db_ = _options.get('db')\n    user = _options.get('user')\n    password = _options.get('password')\n    indexes = _options.get('indexes', False)\n\n    # at some point we should remove support for\n    # pymongo versions < 2.3 until then there are\n    # a bunch of these sections that need to be supported\n    if uri and PYMONGO_VERSION > _LooseVersion('2.3'):\n        if uri and host:\n            raise salt.exceptions.SaltConfigurationError(\n                    \"Mongo returner expects either uri or host configuration. Both were provided\")\n        pymongo.uri_parser.parse_uri(uri)\n        conn = pymongo.MongoClient(uri)\n        mdb = conn.get_database()\n    else:\n        if PYMONGO_VERSION > _LooseVersion('2.3'):\n            conn = pymongo.MongoClient(host, port)\n        else:\n            if uri:\n                raise salt.exceptions.SaltConfigurationError(\n                    \"pymongo <= 2.3 does not support uri format\")\n            conn = pymongo.Connection(host, port)\n\n        mdb = conn[db_]\n        if user and password:\n            mdb.authenticate(user, password)\n\n    if indexes:\n        if PYMONGO_VERSION > _LooseVersion('2.3'):\n            mdb.saltReturns.create_index('minion')\n            mdb.saltReturns.create_index('jid')\n            mdb.jobs.create_index('jid')\n            mdb.events.create_index('tag')\n        else:\n            mdb.saltReturns.ensure_index('minion')\n            mdb.saltReturns.ensure_index('jid')\n            mdb.jobs.ensure_index('jid')\n            mdb.events.ensure_index('tag')\n\n    return conn, mdb", "code_tokens": ["def", "_get_conn", "(", "ret", ")", ":", "_options", "=", "_get_options", "(", "ret", ")", "host", "=", "_options", ".", "get", "(", "'host'", ")", "port", "=", "_options", ".", "get", "(", "'port'", ")", "uri", "=", "_options", ".", "get", "(", "'uri'", ")", "db_", "=", "_options", ".", "get", "(", "'db'", ")", "user", "=", "_options", ".", "get", "(", "'user'", ")", "password", "=", "_options", ".", "get", "(", "'password'", ")", "indexes", "=", "_options", ".", "get", "(", "'indexes'", ",", "False", ")", "# at some point we should remove support for", "# pymongo versions < 2.3 until then there are", "# a bunch of these sections that need to be supported", "if", "uri", "and", "PYMONGO_VERSION", ">", "_LooseVersion", "(", "'2.3'", ")", ":", "if", "uri", "and", "host", ":", "raise", "salt", ".", "exceptions", ".", "SaltConfigurationError", "(", "\"Mongo returner expects either uri or host configuration. Both were provided\"", ")", "pymongo", ".", "uri_parser", ".", "parse_uri", "(", "uri", ")", "conn", "=", "pymongo", ".", "MongoClient", "(", "uri", ")", "mdb", "=", "conn", ".", "get_database", "(", ")", "else", ":", "if", "PYMONGO_VERSION", ">", "_LooseVersion", "(", "'2.3'", ")", ":", "conn", "=", "pymongo", ".", "MongoClient", "(", "host", ",", "port", ")", "else", ":", "if", "uri", ":", "raise", "salt", ".", "exceptions", ".", "SaltConfigurationError", "(", "\"pymongo <= 2.3 does not support uri format\"", ")", "conn", "=", "pymongo", ".", "Connection", "(", "host", ",", "port", ")", "mdb", "=", "conn", "[", "db_", "]", "if", "user", "and", "password", ":", "mdb", ".", "authenticate", "(", "user", ",", "password", ")", "if", "indexes", ":", "if", "PYMONGO_VERSION", ">", "_LooseVersion", "(", "'2.3'", ")", ":", "mdb", ".", "saltReturns", ".", "create_index", "(", "'minion'", ")", "mdb", ".", "saltReturns", ".", "create_index", "(", "'jid'", ")", "mdb", ".", "jobs", ".", "create_index", "(", "'jid'", ")", "mdb", ".", "events", ".", "create_index", "(", "'tag'", ")", "else", ":", "mdb", ".", "saltReturns", ".", "ensure_index", "(", "'minion'", ")", "mdb", ".", "saltReturns", ".", "ensure_index", "(", "'jid'", ")", "mdb", ".", "jobs", ".", "ensure_index", "(", "'jid'", ")", "mdb", ".", "events", ".", "ensure_index", "(", "'tag'", ")", "return", "conn", ",", "mdb"], "docstring": "Return a mongodb connection object", "docstring_tokens": ["Return", "a", "mongodb", "connection", "object"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/returners/mongo_future_return.py#L158-L207", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/returners/mongo_future_return.py", "func_name": "returner", "original_string": "def returner(ret):\n    '''\n    Return data to a mongodb server\n    '''\n    conn, mdb = _get_conn(ret)\n\n    if isinstance(ret['return'], dict):\n        back = _remove_dots(ret['return'])\n    else:\n        back = ret['return']\n\n    if isinstance(ret, dict):\n        full_ret = _remove_dots(ret)\n    else:\n        full_ret = ret\n\n    log.debug(back)\n    sdata = {'minion': ret['id'], 'jid': ret['jid'], 'return': back, 'fun': ret['fun'], 'full_ret': full_ret}\n    if 'out' in ret:\n        sdata['out'] = ret['out']\n\n    # save returns in the saltReturns collection in the json format:\n    # { 'minion': <minion_name>, 'jid': <job_id>, 'return': <return info with dots removed>,\n    #   'fun': <function>, 'full_ret': <unformatted return with dots removed>}\n    #\n    # again we run into the issue with deprecated code from previous versions\n\n    if PYMONGO_VERSION > _LooseVersion('2.3'):\n        #using .copy() to ensure that the original data is not changed, raising issue with pymongo team\n        mdb.saltReturns.insert_one(sdata.copy())\n    else:\n        mdb.saltReturns.insert(sdata.copy())", "language": "python", "code": "def returner(ret):\n    '''\n    Return data to a mongodb server\n    '''\n    conn, mdb = _get_conn(ret)\n\n    if isinstance(ret['return'], dict):\n        back = _remove_dots(ret['return'])\n    else:\n        back = ret['return']\n\n    if isinstance(ret, dict):\n        full_ret = _remove_dots(ret)\n    else:\n        full_ret = ret\n\n    log.debug(back)\n    sdata = {'minion': ret['id'], 'jid': ret['jid'], 'return': back, 'fun': ret['fun'], 'full_ret': full_ret}\n    if 'out' in ret:\n        sdata['out'] = ret['out']\n\n    # save returns in the saltReturns collection in the json format:\n    # { 'minion': <minion_name>, 'jid': <job_id>, 'return': <return info with dots removed>,\n    #   'fun': <function>, 'full_ret': <unformatted return with dots removed>}\n    #\n    # again we run into the issue with deprecated code from previous versions\n\n    if PYMONGO_VERSION > _LooseVersion('2.3'):\n        #using .copy() to ensure that the original data is not changed, raising issue with pymongo team\n        mdb.saltReturns.insert_one(sdata.copy())\n    else:\n        mdb.saltReturns.insert(sdata.copy())", "code_tokens": ["def", "returner", "(", "ret", ")", ":", "conn", ",", "mdb", "=", "_get_conn", "(", "ret", ")", "if", "isinstance", "(", "ret", "[", "'return'", "]", ",", "dict", ")", ":", "back", "=", "_remove_dots", "(", "ret", "[", "'return'", "]", ")", "else", ":", "back", "=", "ret", "[", "'return'", "]", "if", "isinstance", "(", "ret", ",", "dict", ")", ":", "full_ret", "=", "_remove_dots", "(", "ret", ")", "else", ":", "full_ret", "=", "ret", "log", ".", "debug", "(", "back", ")", "sdata", "=", "{", "'minion'", ":", "ret", "[", "'id'", "]", ",", "'jid'", ":", "ret", "[", "'jid'", "]", ",", "'return'", ":", "back", ",", "'fun'", ":", "ret", "[", "'fun'", "]", ",", "'full_ret'", ":", "full_ret", "}", "if", "'out'", "in", "ret", ":", "sdata", "[", "'out'", "]", "=", "ret", "[", "'out'", "]", "# save returns in the saltReturns collection in the json format:", "# { 'minion': <minion_name>, 'jid': <job_id>, 'return': <return info with dots removed>,", "#   'fun': <function>, 'full_ret': <unformatted return with dots removed>}", "#", "# again we run into the issue with deprecated code from previous versions", "if", "PYMONGO_VERSION", ">", "_LooseVersion", "(", "'2.3'", ")", ":", "#using .copy() to ensure that the original data is not changed, raising issue with pymongo team", "mdb", ".", "saltReturns", ".", "insert_one", "(", "sdata", ".", "copy", "(", ")", ")", "else", ":", "mdb", ".", "saltReturns", ".", "insert", "(", "sdata", ".", "copy", "(", ")", ")"], "docstring": "Return data to a mongodb server", "docstring_tokens": ["Return", "data", "to", "a", "mongodb", "server"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/returners/mongo_future_return.py#L210-L241", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/returners/mongo_future_return.py", "func_name": "_safe_copy", "original_string": "def _safe_copy(dat):\n    ''' mongodb doesn't allow '.' in keys, but does allow unicode equivs.\n        Apparently the docs suggest using escaped unicode full-width\n        encodings.  *sigh*\n\n            \\\\  -->  \\\\\\\\\n            $  -->  \\\\\\\\u0024\n            .  -->  \\\\\\\\u002e\n\n        Personally, I prefer URL encodings,\n\n        \\\\  -->  %5c\n        $  -->  %24\n        .  -->  %2e\n\n\n        Which means also escaping '%':\n\n        % -> %25\n    '''\n\n    if isinstance(dat, dict):\n        ret = {}\n        for k in dat:\n            r = k.replace('%', '%25').replace('\\\\', '%5c').replace('$', '%24').replace('.', '%2e')\n            if r != k:\n                log.debug('converting dict key from %s to %s for mongodb', k, r)\n            ret[r] = _safe_copy(dat[k])\n        return ret\n\n    if isinstance(dat, (list, tuple)):\n        return [_safe_copy(i) for i in dat]\n\n    return dat", "language": "python", "code": "def _safe_copy(dat):\n    ''' mongodb doesn't allow '.' in keys, but does allow unicode equivs.\n        Apparently the docs suggest using escaped unicode full-width\n        encodings.  *sigh*\n\n            \\\\  -->  \\\\\\\\\n            $  -->  \\\\\\\\u0024\n            .  -->  \\\\\\\\u002e\n\n        Personally, I prefer URL encodings,\n\n        \\\\  -->  %5c\n        $  -->  %24\n        .  -->  %2e\n\n\n        Which means also escaping '%':\n\n        % -> %25\n    '''\n\n    if isinstance(dat, dict):\n        ret = {}\n        for k in dat:\n            r = k.replace('%', '%25').replace('\\\\', '%5c').replace('$', '%24').replace('.', '%2e')\n            if r != k:\n                log.debug('converting dict key from %s to %s for mongodb', k, r)\n            ret[r] = _safe_copy(dat[k])\n        return ret\n\n    if isinstance(dat, (list, tuple)):\n        return [_safe_copy(i) for i in dat]\n\n    return dat", "code_tokens": ["def", "_safe_copy", "(", "dat", ")", ":", "if", "isinstance", "(", "dat", ",", "dict", ")", ":", "ret", "=", "{", "}", "for", "k", "in", "dat", ":", "r", "=", "k", ".", "replace", "(", "'%'", ",", "'%25'", ")", ".", "replace", "(", "'\\\\'", ",", "'%5c'", ")", ".", "replace", "(", "'$'", ",", "'%24'", ")", ".", "replace", "(", "'.'", ",", "'%2e'", ")", "if", "r", "!=", "k", ":", "log", ".", "debug", "(", "'converting dict key from %s to %s for mongodb'", ",", "k", ",", "r", ")", "ret", "[", "r", "]", "=", "_safe_copy", "(", "dat", "[", "k", "]", ")", "return", "ret", "if", "isinstance", "(", "dat", ",", "(", "list", ",", "tuple", ")", ")", ":", "return", "[", "_safe_copy", "(", "i", ")", "for", "i", "in", "dat", "]", "return", "dat"], "docstring": "mongodb doesn't allow '.' in keys, but does allow unicode equivs.\n        Apparently the docs suggest using escaped unicode full-width\n        encodings.  *sigh*\n\n            \\\\  -->  \\\\\\\\\n            $  -->  \\\\\\\\u0024\n            .  -->  \\\\\\\\u002e\n\n        Personally, I prefer URL encodings,\n\n        \\\\  -->  %5c\n        $  -->  %24\n        .  -->  %2e\n\n\n        Which means also escaping '%':\n\n        % -> %25", "docstring_tokens": ["mongodb", "doesn", "t", "allow", ".", "in", "keys", "but", "does", "allow", "unicode", "equivs", ".", "Apparently", "the", "docs", "suggest", "using", "escaped", "unicode", "full", "-", "width", "encodings", ".", "*", "sigh", "*"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/returners/mongo_future_return.py#L244-L277", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/returners/mongo_future_return.py", "func_name": "save_load", "original_string": "def save_load(jid, load, minions=None):\n    '''\n    Save the load for a given job id\n    '''\n    conn, mdb = _get_conn(ret=None)\n    to_save = _safe_copy(load)\n\n    if PYMONGO_VERSION > _LooseVersion('2.3'):\n        #using .copy() to ensure original data for load is unchanged\n        mdb.jobs.insert_one(to_save)\n    else:\n        mdb.jobs.insert(to_save)", "language": "python", "code": "def save_load(jid, load, minions=None):\n    '''\n    Save the load for a given job id\n    '''\n    conn, mdb = _get_conn(ret=None)\n    to_save = _safe_copy(load)\n\n    if PYMONGO_VERSION > _LooseVersion('2.3'):\n        #using .copy() to ensure original data for load is unchanged\n        mdb.jobs.insert_one(to_save)\n    else:\n        mdb.jobs.insert(to_save)", "code_tokens": ["def", "save_load", "(", "jid", ",", "load", ",", "minions", "=", "None", ")", ":", "conn", ",", "mdb", "=", "_get_conn", "(", "ret", "=", "None", ")", "to_save", "=", "_safe_copy", "(", "load", ")", "if", "PYMONGO_VERSION", ">", "_LooseVersion", "(", "'2.3'", ")", ":", "#using .copy() to ensure original data for load is unchanged", "mdb", ".", "jobs", ".", "insert_one", "(", "to_save", ")", "else", ":", "mdb", ".", "jobs", ".", "insert", "(", "to_save", ")"], "docstring": "Save the load for a given job id", "docstring_tokens": ["Save", "the", "load", "for", "a", "given", "job", "id"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/returners/mongo_future_return.py#L280-L291", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/returners/mongo_future_return.py", "func_name": "get_load", "original_string": "def get_load(jid):\n    '''\n    Return the load associated with a given job id\n    '''\n    conn, mdb = _get_conn(ret=None)\n    return mdb.jobs.find_one({'jid': jid}, {'_id': 0})", "language": "python", "code": "def get_load(jid):\n    '''\n    Return the load associated with a given job id\n    '''\n    conn, mdb = _get_conn(ret=None)\n    return mdb.jobs.find_one({'jid': jid}, {'_id': 0})", "code_tokens": ["def", "get_load", "(", "jid", ")", ":", "conn", ",", "mdb", "=", "_get_conn", "(", "ret", "=", "None", ")", "return", "mdb", ".", "jobs", ".", "find_one", "(", "{", "'jid'", ":", "jid", "}", ",", "{", "'_id'", ":", "0", "}", ")"], "docstring": "Return the load associated with a given job id", "docstring_tokens": ["Return", "the", "load", "associated", "with", "a", "given", "job", "id"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/returners/mongo_future_return.py#L301-L306", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/returners/mongo_future_return.py", "func_name": "get_minions", "original_string": "def get_minions():\n    '''\n    Return a list of minions\n    '''\n    conn, mdb = _get_conn(ret=None)\n    ret = []\n    name = mdb.saltReturns.distinct('minion')\n    ret.append(name)\n    return ret", "language": "python", "code": "def get_minions():\n    '''\n    Return a list of minions\n    '''\n    conn, mdb = _get_conn(ret=None)\n    ret = []\n    name = mdb.saltReturns.distinct('minion')\n    ret.append(name)\n    return ret", "code_tokens": ["def", "get_minions", "(", ")", ":", "conn", ",", "mdb", "=", "_get_conn", "(", "ret", "=", "None", ")", "ret", "=", "[", "]", "name", "=", "mdb", ".", "saltReturns", ".", "distinct", "(", "'minion'", ")", "ret", ".", "append", "(", "name", ")", "return", "ret"], "docstring": "Return a list of minions", "docstring_tokens": ["Return", "a", "list", "of", "minions"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/returners/mongo_future_return.py#L336-L344", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/returners/mongo_future_return.py", "func_name": "get_jids", "original_string": "def get_jids():\n    '''\n    Return a list of job ids\n    '''\n    conn, mdb = _get_conn(ret=None)\n    map = \"function() { emit(this.jid, this); }\"\n    reduce = \"function (key, values) { return values[0]; }\"\n    result = mdb.jobs.inline_map_reduce(map, reduce)\n    ret = {}\n    for r in result:\n        jid = r['_id']\n        ret[jid] = salt.utils.jid.format_jid_instance(jid, r['value'])\n    return ret", "language": "python", "code": "def get_jids():\n    '''\n    Return a list of job ids\n    '''\n    conn, mdb = _get_conn(ret=None)\n    map = \"function() { emit(this.jid, this); }\"\n    reduce = \"function (key, values) { return values[0]; }\"\n    result = mdb.jobs.inline_map_reduce(map, reduce)\n    ret = {}\n    for r in result:\n        jid = r['_id']\n        ret[jid] = salt.utils.jid.format_jid_instance(jid, r['value'])\n    return ret", "code_tokens": ["def", "get_jids", "(", ")", ":", "conn", ",", "mdb", "=", "_get_conn", "(", "ret", "=", "None", ")", "map", "=", "\"function() { emit(this.jid, this); }\"", "reduce", "=", "\"function (key, values) { return values[0]; }\"", "result", "=", "mdb", ".", "jobs", ".", "inline_map_reduce", "(", "map", ",", "reduce", ")", "ret", "=", "{", "}", "for", "r", "in", "result", ":", "jid", "=", "r", "[", "'_id'", "]", "ret", "[", "jid", "]", "=", "salt", ".", "utils", ".", "jid", ".", "format_jid_instance", "(", "jid", ",", "r", "[", "'value'", "]", ")", "return", "ret"], "docstring": "Return a list of job ids", "docstring_tokens": ["Return", "a", "list", "of", "job", "ids"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/returners/mongo_future_return.py#L347-L359", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/returners/mongo_future_return.py", "func_name": "event_return", "original_string": "def event_return(events):\n    '''\n    Return events to Mongodb server\n    '''\n    conn, mdb = _get_conn(ret=None)\n\n    if isinstance(events, list):\n        events = events[0]\n\n    if isinstance(events, dict):\n        log.debug(events)\n\n        if PYMONGO_VERSION > _LooseVersion('2.3'):\n            mdb.events.insert_one(events.copy())\n        else:\n            mdb.events.insert(events.copy())", "language": "python", "code": "def event_return(events):\n    '''\n    Return events to Mongodb server\n    '''\n    conn, mdb = _get_conn(ret=None)\n\n    if isinstance(events, list):\n        events = events[0]\n\n    if isinstance(events, dict):\n        log.debug(events)\n\n        if PYMONGO_VERSION > _LooseVersion('2.3'):\n            mdb.events.insert_one(events.copy())\n        else:\n            mdb.events.insert(events.copy())", "code_tokens": ["def", "event_return", "(", "events", ")", ":", "conn", ",", "mdb", "=", "_get_conn", "(", "ret", "=", "None", ")", "if", "isinstance", "(", "events", ",", "list", ")", ":", "events", "=", "events", "[", "0", "]", "if", "isinstance", "(", "events", ",", "dict", ")", ":", "log", ".", "debug", "(", "events", ")", "if", "PYMONGO_VERSION", ">", "_LooseVersion", "(", "'2.3'", ")", ":", "mdb", ".", "events", ".", "insert_one", "(", "events", ".", "copy", "(", ")", ")", "else", ":", "mdb", ".", "events", ".", "insert", "(", "events", ".", "copy", "(", ")", ")"], "docstring": "Return events to Mongodb server", "docstring_tokens": ["Return", "events", "to", "Mongodb", "server"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/returners/mongo_future_return.py#L369-L384", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/client/ssh/__init__.py", "func_name": "lowstate_file_refs", "original_string": "def lowstate_file_refs(chunks):\n    '''\n    Create a list of file ref objects to reconcile\n    '''\n    refs = {}\n    for chunk in chunks:\n        saltenv = 'base'\n        crefs = []\n        for state in chunk:\n            if state == '__env__':\n                saltenv = chunk[state]\n            elif state == 'saltenv':\n                saltenv = chunk[state]\n            elif state.startswith('__'):\n                continue\n            crefs.extend(salt_refs(chunk[state]))\n        if crefs:\n            if saltenv not in refs:\n                refs[saltenv] = []\n            refs[saltenv].append(crefs)\n    return refs", "language": "python", "code": "def lowstate_file_refs(chunks):\n    '''\n    Create a list of file ref objects to reconcile\n    '''\n    refs = {}\n    for chunk in chunks:\n        saltenv = 'base'\n        crefs = []\n        for state in chunk:\n            if state == '__env__':\n                saltenv = chunk[state]\n            elif state == 'saltenv':\n                saltenv = chunk[state]\n            elif state.startswith('__'):\n                continue\n            crefs.extend(salt_refs(chunk[state]))\n        if crefs:\n            if saltenv not in refs:\n                refs[saltenv] = []\n            refs[saltenv].append(crefs)\n    return refs", "code_tokens": ["def", "lowstate_file_refs", "(", "chunks", ")", ":", "refs", "=", "{", "}", "for", "chunk", "in", "chunks", ":", "saltenv", "=", "'base'", "crefs", "=", "[", "]", "for", "state", "in", "chunk", ":", "if", "state", "==", "'__env__'", ":", "saltenv", "=", "chunk", "[", "state", "]", "elif", "state", "==", "'saltenv'", ":", "saltenv", "=", "chunk", "[", "state", "]", "elif", "state", ".", "startswith", "(", "'__'", ")", ":", "continue", "crefs", ".", "extend", "(", "salt_refs", "(", "chunk", "[", "state", "]", ")", ")", "if", "crefs", ":", "if", "saltenv", "not", "in", "refs", ":", "refs", "[", "saltenv", "]", "=", "[", "]", "refs", "[", "saltenv", "]", ".", "append", "(", "crefs", ")", "return", "refs"], "docstring": "Create a list of file ref objects to reconcile", "docstring_tokens": ["Create", "a", "list", "of", "file", "ref", "objects", "to", "reconcile"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/client/ssh/__init__.py#L1535-L1555", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/client/ssh/__init__.py", "func_name": "salt_refs", "original_string": "def salt_refs(data):\n    '''\n    Pull salt file references out of the states\n    '''\n    proto = 'salt://'\n    ret = []\n    if isinstance(data, six.string_types):\n        if data.startswith(proto):\n            return [data]\n    if isinstance(data, list):\n        for comp in data:\n            if isinstance(comp, six.string_types):\n                if comp.startswith(proto):\n                    ret.append(comp)\n    return ret", "language": "python", "code": "def salt_refs(data):\n    '''\n    Pull salt file references out of the states\n    '''\n    proto = 'salt://'\n    ret = []\n    if isinstance(data, six.string_types):\n        if data.startswith(proto):\n            return [data]\n    if isinstance(data, list):\n        for comp in data:\n            if isinstance(comp, six.string_types):\n                if comp.startswith(proto):\n                    ret.append(comp)\n    return ret", "code_tokens": ["def", "salt_refs", "(", "data", ")", ":", "proto", "=", "'salt://'", "ret", "=", "[", "]", "if", "isinstance", "(", "data", ",", "six", ".", "string_types", ")", ":", "if", "data", ".", "startswith", "(", "proto", ")", ":", "return", "[", "data", "]", "if", "isinstance", "(", "data", ",", "list", ")", ":", "for", "comp", "in", "data", ":", "if", "isinstance", "(", "comp", ",", "six", ".", "string_types", ")", ":", "if", "comp", ".", "startswith", "(", "proto", ")", ":", "ret", ".", "append", "(", "comp", ")", "return", "ret"], "docstring": "Pull salt file references out of the states", "docstring_tokens": ["Pull", "salt", "file", "references", "out", "of", "the", "states"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/client/ssh/__init__.py#L1558-L1572", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/client/ssh/__init__.py", "func_name": "mod_data", "original_string": "def mod_data(fsclient):\n    '''\n    Generate the module arguments for the shim data\n    '''\n    # TODO, change out for a fileserver backend\n    sync_refs = [\n            'modules',\n            'states',\n            'grains',\n            'renderers',\n            'returners',\n            ]\n    ret = {}\n    envs = fsclient.envs()\n    ver_base = ''\n    for env in envs:\n        files = fsclient.file_list(env)\n        for ref in sync_refs:\n            mods_data = {}\n            pref = '_{0}'.format(ref)\n            for fn_ in sorted(files):\n                if fn_.startswith(pref):\n                    if fn_.endswith(('.py', '.so', '.pyx')):\n                        full = salt.utils.url.create(fn_)\n                        mod_path = fsclient.cache_file(full, env)\n                        if not os.path.isfile(mod_path):\n                            continue\n                        mods_data[os.path.basename(fn_)] = mod_path\n                        chunk = salt.utils.hashutils.get_hash(mod_path)\n                        ver_base += chunk\n            if mods_data:\n                if ref in ret:\n                    ret[ref].update(mods_data)\n                else:\n                    ret[ref] = mods_data\n    if not ret:\n        return {}\n\n    if six.PY3:\n        ver_base = salt.utils.stringutils.to_bytes(ver_base)\n\n    ver = hashlib.sha1(ver_base).hexdigest()\n    ext_tar_path = os.path.join(\n            fsclient.opts['cachedir'],\n            'ext_mods.{0}.tgz'.format(ver))\n    mods = {'version': ver,\n            'file': ext_tar_path}\n    if os.path.isfile(ext_tar_path):\n        return mods\n    tfp = tarfile.open(ext_tar_path, 'w:gz')\n    verfile = os.path.join(fsclient.opts['cachedir'], 'ext_mods.ver')\n    with salt.utils.files.fopen(verfile, 'w+') as fp_:\n        fp_.write(ver)\n    tfp.add(verfile, 'ext_version')\n    for ref in ret:\n        for fn_ in ret[ref]:\n            tfp.add(ret[ref][fn_], os.path.join(ref, fn_))\n    tfp.close()\n    return mods", "language": "python", "code": "def mod_data(fsclient):\n    '''\n    Generate the module arguments for the shim data\n    '''\n    # TODO, change out for a fileserver backend\n    sync_refs = [\n            'modules',\n            'states',\n            'grains',\n            'renderers',\n            'returners',\n            ]\n    ret = {}\n    envs = fsclient.envs()\n    ver_base = ''\n    for env in envs:\n        files = fsclient.file_list(env)\n        for ref in sync_refs:\n            mods_data = {}\n            pref = '_{0}'.format(ref)\n            for fn_ in sorted(files):\n                if fn_.startswith(pref):\n                    if fn_.endswith(('.py', '.so', '.pyx')):\n                        full = salt.utils.url.create(fn_)\n                        mod_path = fsclient.cache_file(full, env)\n                        if not os.path.isfile(mod_path):\n                            continue\n                        mods_data[os.path.basename(fn_)] = mod_path\n                        chunk = salt.utils.hashutils.get_hash(mod_path)\n                        ver_base += chunk\n            if mods_data:\n                if ref in ret:\n                    ret[ref].update(mods_data)\n                else:\n                    ret[ref] = mods_data\n    if not ret:\n        return {}\n\n    if six.PY3:\n        ver_base = salt.utils.stringutils.to_bytes(ver_base)\n\n    ver = hashlib.sha1(ver_base).hexdigest()\n    ext_tar_path = os.path.join(\n            fsclient.opts['cachedir'],\n            'ext_mods.{0}.tgz'.format(ver))\n    mods = {'version': ver,\n            'file': ext_tar_path}\n    if os.path.isfile(ext_tar_path):\n        return mods\n    tfp = tarfile.open(ext_tar_path, 'w:gz')\n    verfile = os.path.join(fsclient.opts['cachedir'], 'ext_mods.ver')\n    with salt.utils.files.fopen(verfile, 'w+') as fp_:\n        fp_.write(ver)\n    tfp.add(verfile, 'ext_version')\n    for ref in ret:\n        for fn_ in ret[ref]:\n            tfp.add(ret[ref][fn_], os.path.join(ref, fn_))\n    tfp.close()\n    return mods", "code_tokens": ["def", "mod_data", "(", "fsclient", ")", ":", "# TODO, change out for a fileserver backend", "sync_refs", "=", "[", "'modules'", ",", "'states'", ",", "'grains'", ",", "'renderers'", ",", "'returners'", ",", "]", "ret", "=", "{", "}", "envs", "=", "fsclient", ".", "envs", "(", ")", "ver_base", "=", "''", "for", "env", "in", "envs", ":", "files", "=", "fsclient", ".", "file_list", "(", "env", ")", "for", "ref", "in", "sync_refs", ":", "mods_data", "=", "{", "}", "pref", "=", "'_{0}'", ".", "format", "(", "ref", ")", "for", "fn_", "in", "sorted", "(", "files", ")", ":", "if", "fn_", ".", "startswith", "(", "pref", ")", ":", "if", "fn_", ".", "endswith", "(", "(", "'.py'", ",", "'.so'", ",", "'.pyx'", ")", ")", ":", "full", "=", "salt", ".", "utils", ".", "url", ".", "create", "(", "fn_", ")", "mod_path", "=", "fsclient", ".", "cache_file", "(", "full", ",", "env", ")", "if", "not", "os", ".", "path", ".", "isfile", "(", "mod_path", ")", ":", "continue", "mods_data", "[", "os", ".", "path", ".", "basename", "(", "fn_", ")", "]", "=", "mod_path", "chunk", "=", "salt", ".", "utils", ".", "hashutils", ".", "get_hash", "(", "mod_path", ")", "ver_base", "+=", "chunk", "if", "mods_data", ":", "if", "ref", "in", "ret", ":", "ret", "[", "ref", "]", ".", "update", "(", "mods_data", ")", "else", ":", "ret", "[", "ref", "]", "=", "mods_data", "if", "not", "ret", ":", "return", "{", "}", "if", "six", ".", "PY3", ":", "ver_base", "=", "salt", ".", "utils", ".", "stringutils", ".", "to_bytes", "(", "ver_base", ")", "ver", "=", "hashlib", ".", "sha1", "(", "ver_base", ")", ".", "hexdigest", "(", ")", "ext_tar_path", "=", "os", ".", "path", ".", "join", "(", "fsclient", ".", "opts", "[", "'cachedir'", "]", ",", "'ext_mods.{0}.tgz'", ".", "format", "(", "ver", ")", ")", "mods", "=", "{", "'version'", ":", "ver", ",", "'file'", ":", "ext_tar_path", "}", "if", "os", ".", "path", ".", "isfile", "(", "ext_tar_path", ")", ":", "return", "mods", "tfp", "=", "tarfile", ".", "open", "(", "ext_tar_path", ",", "'w:gz'", ")", "verfile", "=", "os", ".", "path", ".", "join", "(", "fsclient", ".", "opts", "[", "'cachedir'", "]", ",", "'ext_mods.ver'", ")", "with", "salt", ".", "utils", ".", "files", ".", "fopen", "(", "verfile", ",", "'w+'", ")", "as", "fp_", ":", "fp_", ".", "write", "(", "ver", ")", "tfp", ".", "add", "(", "verfile", ",", "'ext_version'", ")", "for", "ref", "in", "ret", ":", "for", "fn_", "in", "ret", "[", "ref", "]", ":", "tfp", ".", "add", "(", "ret", "[", "ref", "]", "[", "fn_", "]", ",", "os", ".", "path", ".", "join", "(", "ref", ",", "fn_", ")", ")", "tfp", ".", "close", "(", ")", "return", "mods"], "docstring": "Generate the module arguments for the shim data", "docstring_tokens": ["Generate", "the", "module", "arguments", "for", "the", "shim", "data"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/client/ssh/__init__.py#L1575-L1633", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/client/ssh/__init__.py", "func_name": "ssh_version", "original_string": "def ssh_version():\n    '''\n    Returns the version of the installed ssh command\n    '''\n    # This function needs more granular checks and to be validated against\n    # older versions of ssh\n    ret = subprocess.Popen(\n            ['ssh', '-V'],\n            stdout=subprocess.PIPE,\n            stderr=subprocess.PIPE).communicate()\n    try:\n        version_parts = ret[1].split(b',')[0].split(b'_')[1]\n        parts = []\n        for part in version_parts:\n            try:\n                parts.append(int(part))\n            except ValueError:\n                return tuple(parts)\n        return tuple(parts)\n    except IndexError:\n        return (2, 0)", "language": "python", "code": "def ssh_version():\n    '''\n    Returns the version of the installed ssh command\n    '''\n    # This function needs more granular checks and to be validated against\n    # older versions of ssh\n    ret = subprocess.Popen(\n            ['ssh', '-V'],\n            stdout=subprocess.PIPE,\n            stderr=subprocess.PIPE).communicate()\n    try:\n        version_parts = ret[1].split(b',')[0].split(b'_')[1]\n        parts = []\n        for part in version_parts:\n            try:\n                parts.append(int(part))\n            except ValueError:\n                return tuple(parts)\n        return tuple(parts)\n    except IndexError:\n        return (2, 0)", "code_tokens": ["def", "ssh_version", "(", ")", ":", "# This function needs more granular checks and to be validated against", "# older versions of ssh", "ret", "=", "subprocess", ".", "Popen", "(", "[", "'ssh'", ",", "'-V'", "]", ",", "stdout", "=", "subprocess", ".", "PIPE", ",", "stderr", "=", "subprocess", ".", "PIPE", ")", ".", "communicate", "(", ")", "try", ":", "version_parts", "=", "ret", "[", "1", "]", ".", "split", "(", "b','", ")", "[", "0", "]", ".", "split", "(", "b'_'", ")", "[", "1", "]", "parts", "=", "[", "]", "for", "part", "in", "version_parts", ":", "try", ":", "parts", ".", "append", "(", "int", "(", "part", ")", ")", "except", "ValueError", ":", "return", "tuple", "(", "parts", ")", "return", "tuple", "(", "parts", ")", "except", "IndexError", ":", "return", "(", "2", ",", "0", ")"], "docstring": "Returns the version of the installed ssh command", "docstring_tokens": ["Returns", "the", "version", "of", "the", "installed", "ssh", "command"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/client/ssh/__init__.py#L1636-L1656", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/client/ssh/__init__.py", "func_name": "_convert_args", "original_string": "def _convert_args(args):\n    '''\n    Take a list of args, and convert any dicts inside the list to keyword\n    args in the form of `key=value`, ready to be passed to salt-ssh\n    '''\n    converted = []\n    for arg in args:\n        if isinstance(arg, dict):\n            for key in list(arg.keys()):\n                if key == '__kwarg__':\n                    continue\n                converted.append('{0}={1}'.format(key, arg[key]))\n        else:\n            converted.append(arg)\n    return converted", "language": "python", "code": "def _convert_args(args):\n    '''\n    Take a list of args, and convert any dicts inside the list to keyword\n    args in the form of `key=value`, ready to be passed to salt-ssh\n    '''\n    converted = []\n    for arg in args:\n        if isinstance(arg, dict):\n            for key in list(arg.keys()):\n                if key == '__kwarg__':\n                    continue\n                converted.append('{0}={1}'.format(key, arg[key]))\n        else:\n            converted.append(arg)\n    return converted", "code_tokens": ["def", "_convert_args", "(", "args", ")", ":", "converted", "=", "[", "]", "for", "arg", "in", "args", ":", "if", "isinstance", "(", "arg", ",", "dict", ")", ":", "for", "key", "in", "list", "(", "arg", ".", "keys", "(", ")", ")", ":", "if", "key", "==", "'__kwarg__'", ":", "continue", "converted", ".", "append", "(", "'{0}={1}'", ".", "format", "(", "key", ",", "arg", "[", "key", "]", ")", ")", "else", ":", "converted", ".", "append", "(", "arg", ")", "return", "converted"], "docstring": "Take a list of args, and convert any dicts inside the list to keyword\n    args in the form of `key=value`, ready to be passed to salt-ssh", "docstring_tokens": ["Take", "a", "list", "of", "args", "and", "convert", "any", "dicts", "inside", "the", "list", "to", "keyword", "args", "in", "the", "form", "of", "key", "=", "value", "ready", "to", "be", "passed", "to", "salt", "-", "ssh"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/client/ssh/__init__.py#L1659-L1673", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/client/ssh/__init__.py", "func_name": "SSH._get_roster", "original_string": "def _get_roster(self):\n        '''\n        Read roster filename as a key to the data.\n        :return:\n        '''\n        roster_file = salt.roster.get_roster_file(self.opts)\n        if roster_file not in self.__parsed_rosters:\n            roster_data = compile_template(roster_file, salt.loader.render(self.opts, {}),\n                                           self.opts['renderer'], self.opts['renderer_blacklist'],\n                                           self.opts['renderer_whitelist'])\n            self.__parsed_rosters[roster_file] = roster_data\n        return roster_file", "language": "python", "code": "def _get_roster(self):\n        '''\n        Read roster filename as a key to the data.\n        :return:\n        '''\n        roster_file = salt.roster.get_roster_file(self.opts)\n        if roster_file not in self.__parsed_rosters:\n            roster_data = compile_template(roster_file, salt.loader.render(self.opts, {}),\n                                           self.opts['renderer'], self.opts['renderer_blacklist'],\n                                           self.opts['renderer_whitelist'])\n            self.__parsed_rosters[roster_file] = roster_data\n        return roster_file", "code_tokens": ["def", "_get_roster", "(", "self", ")", ":", "roster_file", "=", "salt", ".", "roster", ".", "get_roster_file", "(", "self", ".", "opts", ")", "if", "roster_file", "not", "in", "self", ".", "__parsed_rosters", ":", "roster_data", "=", "compile_template", "(", "roster_file", ",", "salt", ".", "loader", ".", "render", "(", "self", ".", "opts", ",", "{", "}", ")", ",", "self", ".", "opts", "[", "'renderer'", "]", ",", "self", ".", "opts", "[", "'renderer_blacklist'", "]", ",", "self", ".", "opts", "[", "'renderer_whitelist'", "]", ")", "self", ".", "__parsed_rosters", "[", "roster_file", "]", "=", "roster_data", "return", "roster_file"], "docstring": "Read roster filename as a key to the data.\n        :return:", "docstring_tokens": ["Read", "roster", "filename", "as", "a", "key", "to", "the", "data", ".", ":", "return", ":"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/client/ssh/__init__.py#L330-L341", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/client/ssh/__init__.py", "func_name": "SSH._expand_target", "original_string": "def _expand_target(self):\n        '''\n        Figures out if the target is a reachable host without wildcards, expands if any.\n        :return:\n        '''\n        # TODO: Support -L\n        target = self.opts['tgt']\n        if isinstance(target, list):\n            return\n\n        hostname = self.opts['tgt'].split('@')[-1]\n        needs_expansion = '*' not in hostname and \\\n                          salt.utils.network.is_reachable_host(hostname) and \\\n                          salt.utils.network.is_ip(hostname)\n        if needs_expansion:\n            hostname = salt.utils.network.ip_to_host(hostname)\n            if hostname is None:\n                # Reverse lookup failed\n                return\n            self._get_roster()\n            for roster_filename in self.__parsed_rosters:\n                roster_data = self.__parsed_rosters[roster_filename]\n                if not isinstance(roster_data, bool):\n                    for host_id in roster_data:\n                        if hostname in [host_id, roster_data.get('host')]:\n                            if hostname != self.opts['tgt']:\n                                self.opts['tgt'] = hostname\n                            self.__parsed_rosters[self.ROSTER_UPDATE_FLAG] = False\n                            return", "language": "python", "code": "def _expand_target(self):\n        '''\n        Figures out if the target is a reachable host without wildcards, expands if any.\n        :return:\n        '''\n        # TODO: Support -L\n        target = self.opts['tgt']\n        if isinstance(target, list):\n            return\n\n        hostname = self.opts['tgt'].split('@')[-1]\n        needs_expansion = '*' not in hostname and \\\n                          salt.utils.network.is_reachable_host(hostname) and \\\n                          salt.utils.network.is_ip(hostname)\n        if needs_expansion:\n            hostname = salt.utils.network.ip_to_host(hostname)\n            if hostname is None:\n                # Reverse lookup failed\n                return\n            self._get_roster()\n            for roster_filename in self.__parsed_rosters:\n                roster_data = self.__parsed_rosters[roster_filename]\n                if not isinstance(roster_data, bool):\n                    for host_id in roster_data:\n                        if hostname in [host_id, roster_data.get('host')]:\n                            if hostname != self.opts['tgt']:\n                                self.opts['tgt'] = hostname\n                            self.__parsed_rosters[self.ROSTER_UPDATE_FLAG] = False\n                            return", "code_tokens": ["def", "_expand_target", "(", "self", ")", ":", "# TODO: Support -L", "target", "=", "self", ".", "opts", "[", "'tgt'", "]", "if", "isinstance", "(", "target", ",", "list", ")", ":", "return", "hostname", "=", "self", ".", "opts", "[", "'tgt'", "]", ".", "split", "(", "'@'", ")", "[", "-", "1", "]", "needs_expansion", "=", "'*'", "not", "in", "hostname", "and", "salt", ".", "utils", ".", "network", ".", "is_reachable_host", "(", "hostname", ")", "and", "salt", ".", "utils", ".", "network", ".", "is_ip", "(", "hostname", ")", "if", "needs_expansion", ":", "hostname", "=", "salt", ".", "utils", ".", "network", ".", "ip_to_host", "(", "hostname", ")", "if", "hostname", "is", "None", ":", "# Reverse lookup failed", "return", "self", ".", "_get_roster", "(", ")", "for", "roster_filename", "in", "self", ".", "__parsed_rosters", ":", "roster_data", "=", "self", ".", "__parsed_rosters", "[", "roster_filename", "]", "if", "not", "isinstance", "(", "roster_data", ",", "bool", ")", ":", "for", "host_id", "in", "roster_data", ":", "if", "hostname", "in", "[", "host_id", ",", "roster_data", ".", "get", "(", "'host'", ")", "]", ":", "if", "hostname", "!=", "self", ".", "opts", "[", "'tgt'", "]", ":", "self", ".", "opts", "[", "'tgt'", "]", "=", "hostname", "self", ".", "__parsed_rosters", "[", "self", ".", "ROSTER_UPDATE_FLAG", "]", "=", "False", "return"], "docstring": "Figures out if the target is a reachable host without wildcards, expands if any.\n        :return:", "docstring_tokens": ["Figures", "out", "if", "the", "target", "is", "a", "reachable", "host", "without", "wildcards", "expands", "if", "any", ".", ":", "return", ":"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/client/ssh/__init__.py#L343-L371", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/client/ssh/__init__.py", "func_name": "SSH._update_roster", "original_string": "def _update_roster(self):\n        '''\n        Update default flat roster with the passed in information.\n        :return:\n        '''\n        roster_file = self._get_roster()\n        if os.access(roster_file, os.W_OK):\n            if self.__parsed_rosters[self.ROSTER_UPDATE_FLAG]:\n                with salt.utils.files.fopen(roster_file, 'a') as roster_fp:\n                    roster_fp.write('# Automatically added by \"{s_user}\" at {s_time}\\n{hostname}:\\n    host: '\n                                    '{hostname}\\n    user: {user}'\n                                    '\\n    passwd: {passwd}\\n'.format(s_user=getpass.getuser(),\n                                                                      s_time=datetime.datetime.utcnow().isoformat(),\n                                                                      hostname=self.opts.get('tgt', ''),\n                                                                      user=self.opts.get('ssh_user', ''),\n                                                                      passwd=self.opts.get('ssh_passwd', '')))\n                log.info('The host {0} has been added to the roster {1}'.format(self.opts.get('tgt', ''),\n                                                                                roster_file))\n        else:\n            log.error('Unable to update roster {0}: access denied'.format(roster_file))", "language": "python", "code": "def _update_roster(self):\n        '''\n        Update default flat roster with the passed in information.\n        :return:\n        '''\n        roster_file = self._get_roster()\n        if os.access(roster_file, os.W_OK):\n            if self.__parsed_rosters[self.ROSTER_UPDATE_FLAG]:\n                with salt.utils.files.fopen(roster_file, 'a') as roster_fp:\n                    roster_fp.write('# Automatically added by \"{s_user}\" at {s_time}\\n{hostname}:\\n    host: '\n                                    '{hostname}\\n    user: {user}'\n                                    '\\n    passwd: {passwd}\\n'.format(s_user=getpass.getuser(),\n                                                                      s_time=datetime.datetime.utcnow().isoformat(),\n                                                                      hostname=self.opts.get('tgt', ''),\n                                                                      user=self.opts.get('ssh_user', ''),\n                                                                      passwd=self.opts.get('ssh_passwd', '')))\n                log.info('The host {0} has been added to the roster {1}'.format(self.opts.get('tgt', ''),\n                                                                                roster_file))\n        else:\n            log.error('Unable to update roster {0}: access denied'.format(roster_file))", "code_tokens": ["def", "_update_roster", "(", "self", ")", ":", "roster_file", "=", "self", ".", "_get_roster", "(", ")", "if", "os", ".", "access", "(", "roster_file", ",", "os", ".", "W_OK", ")", ":", "if", "self", ".", "__parsed_rosters", "[", "self", ".", "ROSTER_UPDATE_FLAG", "]", ":", "with", "salt", ".", "utils", ".", "files", ".", "fopen", "(", "roster_file", ",", "'a'", ")", "as", "roster_fp", ":", "roster_fp", ".", "write", "(", "'# Automatically added by \"{s_user}\" at {s_time}\\n{hostname}:\\n    host: '", "'{hostname}\\n    user: {user}'", "'\\n    passwd: {passwd}\\n'", ".", "format", "(", "s_user", "=", "getpass", ".", "getuser", "(", ")", ",", "s_time", "=", "datetime", ".", "datetime", ".", "utcnow", "(", ")", ".", "isoformat", "(", ")", ",", "hostname", "=", "self", ".", "opts", ".", "get", "(", "'tgt'", ",", "''", ")", ",", "user", "=", "self", ".", "opts", ".", "get", "(", "'ssh_user'", ",", "''", ")", ",", "passwd", "=", "self", ".", "opts", ".", "get", "(", "'ssh_passwd'", ",", "''", ")", ")", ")", "log", ".", "info", "(", "'The host {0} has been added to the roster {1}'", ".", "format", "(", "self", ".", "opts", ".", "get", "(", "'tgt'", ",", "''", ")", ",", "roster_file", ")", ")", "else", ":", "log", ".", "error", "(", "'Unable to update roster {0}: access denied'", ".", "format", "(", "roster_file", ")", ")"], "docstring": "Update default flat roster with the passed in information.\n        :return:", "docstring_tokens": ["Update", "default", "flat", "roster", "with", "the", "passed", "in", "information", ".", ":", "return", ":"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/client/ssh/__init__.py#L373-L392", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/client/ssh/__init__.py", "func_name": "SSH._update_targets", "original_string": "def _update_targets(self):\n        '''\n        Uptade targets in case hostname was directly passed without the roster.\n        :return:\n        '''\n\n        hostname = self.opts.get('tgt', '')\n        if '@' in hostname:\n            user, hostname = hostname.split('@', 1)\n        else:\n            user = self.opts.get('ssh_user')\n        if hostname == '*':\n            hostname = ''\n\n        if salt.utils.network.is_reachable_host(hostname):\n            hostname = salt.utils.network.ip_to_host(hostname)\n            self.opts['tgt'] = hostname\n            self.targets[hostname] = {\n                'passwd': self.opts.get('ssh_passwd', ''),\n                'host': hostname,\n                'user': user,\n            }\n            if self.opts.get('ssh_update_roster'):\n                self._update_roster()", "language": "python", "code": "def _update_targets(self):\n        '''\n        Uptade targets in case hostname was directly passed without the roster.\n        :return:\n        '''\n\n        hostname = self.opts.get('tgt', '')\n        if '@' in hostname:\n            user, hostname = hostname.split('@', 1)\n        else:\n            user = self.opts.get('ssh_user')\n        if hostname == '*':\n            hostname = ''\n\n        if salt.utils.network.is_reachable_host(hostname):\n            hostname = salt.utils.network.ip_to_host(hostname)\n            self.opts['tgt'] = hostname\n            self.targets[hostname] = {\n                'passwd': self.opts.get('ssh_passwd', ''),\n                'host': hostname,\n                'user': user,\n            }\n            if self.opts.get('ssh_update_roster'):\n                self._update_roster()", "code_tokens": ["def", "_update_targets", "(", "self", ")", ":", "hostname", "=", "self", ".", "opts", ".", "get", "(", "'tgt'", ",", "''", ")", "if", "'@'", "in", "hostname", ":", "user", ",", "hostname", "=", "hostname", ".", "split", "(", "'@'", ",", "1", ")", "else", ":", "user", "=", "self", ".", "opts", ".", "get", "(", "'ssh_user'", ")", "if", "hostname", "==", "'*'", ":", "hostname", "=", "''", "if", "salt", ".", "utils", ".", "network", ".", "is_reachable_host", "(", "hostname", ")", ":", "hostname", "=", "salt", ".", "utils", ".", "network", ".", "ip_to_host", "(", "hostname", ")", "self", ".", "opts", "[", "'tgt'", "]", "=", "hostname", "self", ".", "targets", "[", "hostname", "]", "=", "{", "'passwd'", ":", "self", ".", "opts", ".", "get", "(", "'ssh_passwd'", ",", "''", ")", ",", "'host'", ":", "hostname", ",", "'user'", ":", "user", ",", "}", "if", "self", ".", "opts", ".", "get", "(", "'ssh_update_roster'", ")", ":", "self", ".", "_update_roster", "(", ")"], "docstring": "Uptade targets in case hostname was directly passed without the roster.\n        :return:", "docstring_tokens": ["Uptade", "targets", "in", "case", "hostname", "was", "directly", "passed", "without", "the", "roster", ".", ":", "return", ":"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/client/ssh/__init__.py#L394-L417", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/client/ssh/__init__.py", "func_name": "SSH.get_pubkey", "original_string": "def get_pubkey(self):\n        '''\n        Return the key string for the SSH public key\n        '''\n        if '__master_opts__' in self.opts and \\\n                self.opts['__master_opts__'].get('ssh_use_home_key') and \\\n                os.path.isfile(os.path.expanduser('~/.ssh/id_rsa')):\n            priv = os.path.expanduser('~/.ssh/id_rsa')\n        else:\n            priv = self.opts.get(\n                    'ssh_priv',\n                    os.path.join(\n                        self.opts['pki_dir'],\n                        'ssh',\n                        'salt-ssh.rsa'\n                        )\n                    )\n        pub = '{0}.pub'.format(priv)\n        with salt.utils.files.fopen(pub, 'r') as fp_:\n            return '{0} rsa root@master'.format(fp_.read().split()[1])", "language": "python", "code": "def get_pubkey(self):\n        '''\n        Return the key string for the SSH public key\n        '''\n        if '__master_opts__' in self.opts and \\\n                self.opts['__master_opts__'].get('ssh_use_home_key') and \\\n                os.path.isfile(os.path.expanduser('~/.ssh/id_rsa')):\n            priv = os.path.expanduser('~/.ssh/id_rsa')\n        else:\n            priv = self.opts.get(\n                    'ssh_priv',\n                    os.path.join(\n                        self.opts['pki_dir'],\n                        'ssh',\n                        'salt-ssh.rsa'\n                        )\n                    )\n        pub = '{0}.pub'.format(priv)\n        with salt.utils.files.fopen(pub, 'r') as fp_:\n            return '{0} rsa root@master'.format(fp_.read().split()[1])", "code_tokens": ["def", "get_pubkey", "(", "self", ")", ":", "if", "'__master_opts__'", "in", "self", ".", "opts", "and", "self", ".", "opts", "[", "'__master_opts__'", "]", ".", "get", "(", "'ssh_use_home_key'", ")", "and", "os", ".", "path", ".", "isfile", "(", "os", ".", "path", ".", "expanduser", "(", "'~/.ssh/id_rsa'", ")", ")", ":", "priv", "=", "os", ".", "path", ".", "expanduser", "(", "'~/.ssh/id_rsa'", ")", "else", ":", "priv", "=", "self", ".", "opts", ".", "get", "(", "'ssh_priv'", ",", "os", ".", "path", ".", "join", "(", "self", ".", "opts", "[", "'pki_dir'", "]", ",", "'ssh'", ",", "'salt-ssh.rsa'", ")", ")", "pub", "=", "'{0}.pub'", ".", "format", "(", "priv", ")", "with", "salt", ".", "utils", ".", "files", ".", "fopen", "(", "pub", ",", "'r'", ")", "as", "fp_", ":", "return", "'{0} rsa root@master'", ".", "format", "(", "fp_", ".", "read", "(", ")", ".", "split", "(", ")", "[", "1", "]", ")"], "docstring": "Return the key string for the SSH public key", "docstring_tokens": ["Return", "the", "key", "string", "for", "the", "SSH", "public", "key"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/client/ssh/__init__.py#L419-L438", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/client/ssh/__init__.py", "func_name": "SSH.key_deploy", "original_string": "def key_deploy(self, host, ret):\n        '''\n        Deploy the SSH key if the minions don't auth\n        '''\n        if not isinstance(ret[host], dict) or self.opts.get('ssh_key_deploy'):\n            target = self.targets[host]\n            if target.get('passwd', False) or self.opts['ssh_passwd']:\n                self._key_deploy_run(host, target, False)\n            return ret\n        if ret[host].get('stderr', '').count('Permission denied'):\n            target = self.targets[host]\n            # permission denied, attempt to auto deploy ssh key\n            print(('Permission denied for host {0}, do you want to deploy '\n                   'the salt-ssh key? (password required):').format(host))\n            deploy = input('[Y/n] ')\n            if deploy.startswith(('n', 'N')):\n                return ret\n            target['passwd'] = getpass.getpass(\n                    'Password for {0}@{1}: '.format(target['user'], host)\n                )\n            return self._key_deploy_run(host, target, True)\n        return ret", "language": "python", "code": "def key_deploy(self, host, ret):\n        '''\n        Deploy the SSH key if the minions don't auth\n        '''\n        if not isinstance(ret[host], dict) or self.opts.get('ssh_key_deploy'):\n            target = self.targets[host]\n            if target.get('passwd', False) or self.opts['ssh_passwd']:\n                self._key_deploy_run(host, target, False)\n            return ret\n        if ret[host].get('stderr', '').count('Permission denied'):\n            target = self.targets[host]\n            # permission denied, attempt to auto deploy ssh key\n            print(('Permission denied for host {0}, do you want to deploy '\n                   'the salt-ssh key? (password required):').format(host))\n            deploy = input('[Y/n] ')\n            if deploy.startswith(('n', 'N')):\n                return ret\n            target['passwd'] = getpass.getpass(\n                    'Password for {0}@{1}: '.format(target['user'], host)\n                )\n            return self._key_deploy_run(host, target, True)\n        return ret", "code_tokens": ["def", "key_deploy", "(", "self", ",", "host", ",", "ret", ")", ":", "if", "not", "isinstance", "(", "ret", "[", "host", "]", ",", "dict", ")", "or", "self", ".", "opts", ".", "get", "(", "'ssh_key_deploy'", ")", ":", "target", "=", "self", ".", "targets", "[", "host", "]", "if", "target", ".", "get", "(", "'passwd'", ",", "False", ")", "or", "self", ".", "opts", "[", "'ssh_passwd'", "]", ":", "self", ".", "_key_deploy_run", "(", "host", ",", "target", ",", "False", ")", "return", "ret", "if", "ret", "[", "host", "]", ".", "get", "(", "'stderr'", ",", "''", ")", ".", "count", "(", "'Permission denied'", ")", ":", "target", "=", "self", ".", "targets", "[", "host", "]", "# permission denied, attempt to auto deploy ssh key", "print", "(", "(", "'Permission denied for host {0}, do you want to deploy '", "'the salt-ssh key? (password required):'", ")", ".", "format", "(", "host", ")", ")", "deploy", "=", "input", "(", "'[Y/n] '", ")", "if", "deploy", ".", "startswith", "(", "(", "'n'", ",", "'N'", ")", ")", ":", "return", "ret", "target", "[", "'passwd'", "]", "=", "getpass", ".", "getpass", "(", "'Password for {0}@{1}: '", ".", "format", "(", "target", "[", "'user'", "]", ",", "host", ")", ")", "return", "self", ".", "_key_deploy_run", "(", "host", ",", "target", ",", "True", ")", "return", "ret"], "docstring": "Deploy the SSH key if the minions don't auth", "docstring_tokens": ["Deploy", "the", "SSH", "key", "if", "the", "minions", "don", "t", "auth"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/client/ssh/__init__.py#L440-L461", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/client/ssh/__init__.py", "func_name": "SSH._key_deploy_run", "original_string": "def _key_deploy_run(self, host, target, re_run=True):\n        '''\n        The ssh-copy-id routine\n        '''\n        argv = [\n            'ssh.set_auth_key',\n            target.get('user', 'root'),\n            self.get_pubkey(),\n        ]\n\n        single = Single(\n                self.opts,\n                argv,\n                host,\n                mods=self.mods,\n                fsclient=self.fsclient,\n                thin=self.thin,\n                **target)\n        if salt.utils.path.which('ssh-copy-id'):\n            # we have ssh-copy-id, use it!\n            stdout, stderr, retcode = single.shell.copy_id()\n        else:\n            stdout, stderr, retcode = single.run()\n        if re_run:\n            target.pop('passwd')\n            single = Single(\n                    self.opts,\n                    self.opts['argv'],\n                    host,\n                    mods=self.mods,\n                    fsclient=self.fsclient,\n                    thin=self.thin,\n                    **target)\n            stdout, stderr, retcode = single.cmd_block()\n            try:\n                data = salt.utils.json.find_json(stdout)\n                return {host: data.get('local', data)}\n            except Exception:\n                if stderr:\n                    return {host: stderr}\n                return {host: 'Bad Return'}\n        if salt.defaults.exitcodes.EX_OK != retcode:\n            return {host: stderr}\n        return {host: stdout}", "language": "python", "code": "def _key_deploy_run(self, host, target, re_run=True):\n        '''\n        The ssh-copy-id routine\n        '''\n        argv = [\n            'ssh.set_auth_key',\n            target.get('user', 'root'),\n            self.get_pubkey(),\n        ]\n\n        single = Single(\n                self.opts,\n                argv,\n                host,\n                mods=self.mods,\n                fsclient=self.fsclient,\n                thin=self.thin,\n                **target)\n        if salt.utils.path.which('ssh-copy-id'):\n            # we have ssh-copy-id, use it!\n            stdout, stderr, retcode = single.shell.copy_id()\n        else:\n            stdout, stderr, retcode = single.run()\n        if re_run:\n            target.pop('passwd')\n            single = Single(\n                    self.opts,\n                    self.opts['argv'],\n                    host,\n                    mods=self.mods,\n                    fsclient=self.fsclient,\n                    thin=self.thin,\n                    **target)\n            stdout, stderr, retcode = single.cmd_block()\n            try:\n                data = salt.utils.json.find_json(stdout)\n                return {host: data.get('local', data)}\n            except Exception:\n                if stderr:\n                    return {host: stderr}\n                return {host: 'Bad Return'}\n        if salt.defaults.exitcodes.EX_OK != retcode:\n            return {host: stderr}\n        return {host: stdout}", "code_tokens": ["def", "_key_deploy_run", "(", "self", ",", "host", ",", "target", ",", "re_run", "=", "True", ")", ":", "argv", "=", "[", "'ssh.set_auth_key'", ",", "target", ".", "get", "(", "'user'", ",", "'root'", ")", ",", "self", ".", "get_pubkey", "(", ")", ",", "]", "single", "=", "Single", "(", "self", ".", "opts", ",", "argv", ",", "host", ",", "mods", "=", "self", ".", "mods", ",", "fsclient", "=", "self", ".", "fsclient", ",", "thin", "=", "self", ".", "thin", ",", "*", "*", "target", ")", "if", "salt", ".", "utils", ".", "path", ".", "which", "(", "'ssh-copy-id'", ")", ":", "# we have ssh-copy-id, use it!", "stdout", ",", "stderr", ",", "retcode", "=", "single", ".", "shell", ".", "copy_id", "(", ")", "else", ":", "stdout", ",", "stderr", ",", "retcode", "=", "single", ".", "run", "(", ")", "if", "re_run", ":", "target", ".", "pop", "(", "'passwd'", ")", "single", "=", "Single", "(", "self", ".", "opts", ",", "self", ".", "opts", "[", "'argv'", "]", ",", "host", ",", "mods", "=", "self", ".", "mods", ",", "fsclient", "=", "self", ".", "fsclient", ",", "thin", "=", "self", ".", "thin", ",", "*", "*", "target", ")", "stdout", ",", "stderr", ",", "retcode", "=", "single", ".", "cmd_block", "(", ")", "try", ":", "data", "=", "salt", ".", "utils", ".", "json", ".", "find_json", "(", "stdout", ")", "return", "{", "host", ":", "data", ".", "get", "(", "'local'", ",", "data", ")", "}", "except", "Exception", ":", "if", "stderr", ":", "return", "{", "host", ":", "stderr", "}", "return", "{", "host", ":", "'Bad Return'", "}", "if", "salt", ".", "defaults", ".", "exitcodes", ".", "EX_OK", "!=", "retcode", ":", "return", "{", "host", ":", "stderr", "}", "return", "{", "host", ":", "stdout", "}"], "docstring": "The ssh-copy-id routine", "docstring_tokens": ["The", "ssh", "-", "copy", "-", "id", "routine"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/client/ssh/__init__.py#L463-L506", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/client/ssh/__init__.py", "func_name": "SSH.handle_routine", "original_string": "def handle_routine(self, que, opts, host, target, mine=False):\n        '''\n        Run the routine in a \"Thread\", put a dict on the queue\n        '''\n        opts = copy.deepcopy(opts)\n        single = Single(\n                opts,\n                opts['argv'],\n                host,\n                mods=self.mods,\n                fsclient=self.fsclient,\n                thin=self.thin,\n                mine=mine,\n                **target)\n        ret = {'id': single.id}\n        stdout, stderr, retcode = single.run()\n        # This job is done, yield\n        try:\n            data = salt.utils.json.find_json(stdout)\n            if len(data) < 2 and 'local' in data:\n                ret['ret'] = data['local']\n            else:\n                ret['ret'] = {\n                    'stdout': stdout,\n                    'stderr': stderr,\n                    'retcode': retcode,\n                }\n        except Exception:\n            ret['ret'] = {\n                'stdout': stdout,\n                'stderr': stderr,\n                'retcode': retcode,\n            }\n        que.put(ret)", "language": "python", "code": "def handle_routine(self, que, opts, host, target, mine=False):\n        '''\n        Run the routine in a \"Thread\", put a dict on the queue\n        '''\n        opts = copy.deepcopy(opts)\n        single = Single(\n                opts,\n                opts['argv'],\n                host,\n                mods=self.mods,\n                fsclient=self.fsclient,\n                thin=self.thin,\n                mine=mine,\n                **target)\n        ret = {'id': single.id}\n        stdout, stderr, retcode = single.run()\n        # This job is done, yield\n        try:\n            data = salt.utils.json.find_json(stdout)\n            if len(data) < 2 and 'local' in data:\n                ret['ret'] = data['local']\n            else:\n                ret['ret'] = {\n                    'stdout': stdout,\n                    'stderr': stderr,\n                    'retcode': retcode,\n                }\n        except Exception:\n            ret['ret'] = {\n                'stdout': stdout,\n                'stderr': stderr,\n                'retcode': retcode,\n            }\n        que.put(ret)", "code_tokens": ["def", "handle_routine", "(", "self", ",", "que", ",", "opts", ",", "host", ",", "target", ",", "mine", "=", "False", ")", ":", "opts", "=", "copy", ".", "deepcopy", "(", "opts", ")", "single", "=", "Single", "(", "opts", ",", "opts", "[", "'argv'", "]", ",", "host", ",", "mods", "=", "self", ".", "mods", ",", "fsclient", "=", "self", ".", "fsclient", ",", "thin", "=", "self", ".", "thin", ",", "mine", "=", "mine", ",", "*", "*", "target", ")", "ret", "=", "{", "'id'", ":", "single", ".", "id", "}", "stdout", ",", "stderr", ",", "retcode", "=", "single", ".", "run", "(", ")", "# This job is done, yield", "try", ":", "data", "=", "salt", ".", "utils", ".", "json", ".", "find_json", "(", "stdout", ")", "if", "len", "(", "data", ")", "<", "2", "and", "'local'", "in", "data", ":", "ret", "[", "'ret'", "]", "=", "data", "[", "'local'", "]", "else", ":", "ret", "[", "'ret'", "]", "=", "{", "'stdout'", ":", "stdout", ",", "'stderr'", ":", "stderr", ",", "'retcode'", ":", "retcode", ",", "}", "except", "Exception", ":", "ret", "[", "'ret'", "]", "=", "{", "'stdout'", ":", "stdout", ",", "'stderr'", ":", "stderr", ",", "'retcode'", ":", "retcode", ",", "}", "que", ".", "put", "(", "ret", ")"], "docstring": "Run the routine in a \"Thread\", put a dict on the queue", "docstring_tokens": ["Run", "the", "routine", "in", "a", "Thread", "put", "a", "dict", "on", "the", "queue"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/client/ssh/__init__.py#L508-L541", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/client/ssh/__init__.py", "func_name": "SSH.handle_ssh", "original_string": "def handle_ssh(self, mine=False):\n        '''\n        Spin up the needed threads or processes and execute the subsequent\n        routines\n        '''\n        que = multiprocessing.Queue()\n        running = {}\n        target_iter = self.targets.__iter__()\n        returned = set()\n        rets = set()\n        init = False\n        while True:\n            if not self.targets:\n                log.error('No matching targets found in roster.')\n                break\n            if len(running) < self.opts.get('ssh_max_procs', 25) and not init:\n                try:\n                    host = next(target_iter)\n                except StopIteration:\n                    init = True\n                    continue\n                for default in self.defaults:\n                    if default not in self.targets[host]:\n                        self.targets[host][default] = self.defaults[default]\n                if 'host' not in self.targets[host]:\n                    self.targets[host]['host'] = host\n                if self.targets[host].get('winrm') and not HAS_WINSHELL:\n                    returned.add(host)\n                    rets.add(host)\n                    log_msg = 'Please contact sales@saltstack.com for access to the enterprise saltwinshell module.'\n                    log.debug(log_msg)\n                    no_ret = {'fun_args': [],\n                              'jid': None,\n                              'return': log_msg,\n                              'retcode': 1,\n                              'fun': '',\n                              'id': host}\n                    yield {host: no_ret}\n                    continue\n                args = (\n                        que,\n                        self.opts,\n                        host,\n                        self.targets[host],\n                        mine,\n                        )\n                routine = MultiprocessingProcess(\n                                target=self.handle_routine,\n                                args=args)\n                routine.start()\n                running[host] = {'thread': routine}\n                continue\n            ret = {}\n            try:\n                ret = que.get(False)\n                if 'id' in ret:\n                    returned.add(ret['id'])\n                    yield {ret['id']: ret['ret']}\n            except Exception:\n                # This bare exception is here to catch spurious exceptions\n                # thrown by que.get during healthy operation. Please do not\n                # worry about this bare exception, it is entirely here to\n                # control program flow.\n                pass\n            for host in running:\n                if not running[host]['thread'].is_alive():\n                    if host not in returned:\n                        # Try to get any returns that came through since we\n                        # last checked\n                        try:\n                            while True:\n                                ret = que.get(False)\n                                if 'id' in ret:\n                                    returned.add(ret['id'])\n                                    yield {ret['id']: ret['ret']}\n                        except Exception:\n                            pass\n\n                        if host not in returned:\n                            error = ('Target \\'{0}\\' did not return any data, '\n                                     'probably due to an error.').format(host)\n                            ret = {'id': host,\n                                   'ret': error}\n                            log.error(error)\n                            yield {ret['id']: ret['ret']}\n                    running[host]['thread'].join()\n                    rets.add(host)\n            for host in rets:\n                if host in running:\n                    running.pop(host)\n            if len(rets) >= len(self.targets):\n                break\n            # Sleep when limit or all threads started\n            if len(running) >= self.opts.get('ssh_max_procs', 25) or len(self.targets) >= len(running):\n                time.sleep(0.1)", "language": "python", "code": "def handle_ssh(self, mine=False):\n        '''\n        Spin up the needed threads or processes and execute the subsequent\n        routines\n        '''\n        que = multiprocessing.Queue()\n        running = {}\n        target_iter = self.targets.__iter__()\n        returned = set()\n        rets = set()\n        init = False\n        while True:\n            if not self.targets:\n                log.error('No matching targets found in roster.')\n                break\n            if len(running) < self.opts.get('ssh_max_procs', 25) and not init:\n                try:\n                    host = next(target_iter)\n                except StopIteration:\n                    init = True\n                    continue\n                for default in self.defaults:\n                    if default not in self.targets[host]:\n                        self.targets[host][default] = self.defaults[default]\n                if 'host' not in self.targets[host]:\n                    self.targets[host]['host'] = host\n                if self.targets[host].get('winrm') and not HAS_WINSHELL:\n                    returned.add(host)\n                    rets.add(host)\n                    log_msg = 'Please contact sales@saltstack.com for access to the enterprise saltwinshell module.'\n                    log.debug(log_msg)\n                    no_ret = {'fun_args': [],\n                              'jid': None,\n                              'return': log_msg,\n                              'retcode': 1,\n                              'fun': '',\n                              'id': host}\n                    yield {host: no_ret}\n                    continue\n                args = (\n                        que,\n                        self.opts,\n                        host,\n                        self.targets[host],\n                        mine,\n                        )\n                routine = MultiprocessingProcess(\n                                target=self.handle_routine,\n                                args=args)\n                routine.start()\n                running[host] = {'thread': routine}\n                continue\n            ret = {}\n            try:\n                ret = que.get(False)\n                if 'id' in ret:\n                    returned.add(ret['id'])\n                    yield {ret['id']: ret['ret']}\n            except Exception:\n                # This bare exception is here to catch spurious exceptions\n                # thrown by que.get during healthy operation. Please do not\n                # worry about this bare exception, it is entirely here to\n                # control program flow.\n                pass\n            for host in running:\n                if not running[host]['thread'].is_alive():\n                    if host not in returned:\n                        # Try to get any returns that came through since we\n                        # last checked\n                        try:\n                            while True:\n                                ret = que.get(False)\n                                if 'id' in ret:\n                                    returned.add(ret['id'])\n                                    yield {ret['id']: ret['ret']}\n                        except Exception:\n                            pass\n\n                        if host not in returned:\n                            error = ('Target \\'{0}\\' did not return any data, '\n                                     'probably due to an error.').format(host)\n                            ret = {'id': host,\n                                   'ret': error}\n                            log.error(error)\n                            yield {ret['id']: ret['ret']}\n                    running[host]['thread'].join()\n                    rets.add(host)\n            for host in rets:\n                if host in running:\n                    running.pop(host)\n            if len(rets) >= len(self.targets):\n                break\n            # Sleep when limit or all threads started\n            if len(running) >= self.opts.get('ssh_max_procs', 25) or len(self.targets) >= len(running):\n                time.sleep(0.1)", "code_tokens": ["def", "handle_ssh", "(", "self", ",", "mine", "=", "False", ")", ":", "que", "=", "multiprocessing", ".", "Queue", "(", ")", "running", "=", "{", "}", "target_iter", "=", "self", ".", "targets", ".", "__iter__", "(", ")", "returned", "=", "set", "(", ")", "rets", "=", "set", "(", ")", "init", "=", "False", "while", "True", ":", "if", "not", "self", ".", "targets", ":", "log", ".", "error", "(", "'No matching targets found in roster.'", ")", "break", "if", "len", "(", "running", ")", "<", "self", ".", "opts", ".", "get", "(", "'ssh_max_procs'", ",", "25", ")", "and", "not", "init", ":", "try", ":", "host", "=", "next", "(", "target_iter", ")", "except", "StopIteration", ":", "init", "=", "True", "continue", "for", "default", "in", "self", ".", "defaults", ":", "if", "default", "not", "in", "self", ".", "targets", "[", "host", "]", ":", "self", ".", "targets", "[", "host", "]", "[", "default", "]", "=", "self", ".", "defaults", "[", "default", "]", "if", "'host'", "not", "in", "self", ".", "targets", "[", "host", "]", ":", "self", ".", "targets", "[", "host", "]", "[", "'host'", "]", "=", "host", "if", "self", ".", "targets", "[", "host", "]", ".", "get", "(", "'winrm'", ")", "and", "not", "HAS_WINSHELL", ":", "returned", ".", "add", "(", "host", ")", "rets", ".", "add", "(", "host", ")", "log_msg", "=", "'Please contact sales@saltstack.com for access to the enterprise saltwinshell module.'", "log", ".", "debug", "(", "log_msg", ")", "no_ret", "=", "{", "'fun_args'", ":", "[", "]", ",", "'jid'", ":", "None", ",", "'return'", ":", "log_msg", ",", "'retcode'", ":", "1", ",", "'fun'", ":", "''", ",", "'id'", ":", "host", "}", "yield", "{", "host", ":", "no_ret", "}", "continue", "args", "=", "(", "que", ",", "self", ".", "opts", ",", "host", ",", "self", ".", "targets", "[", "host", "]", ",", "mine", ",", ")", "routine", "=", "MultiprocessingProcess", "(", "target", "=", "self", ".", "handle_routine", ",", "args", "=", "args", ")", "routine", ".", "start", "(", ")", "running", "[", "host", "]", "=", "{", "'thread'", ":", "routine", "}", "continue", "ret", "=", "{", "}", "try", ":", "ret", "=", "que", ".", "get", "(", "False", ")", "if", "'id'", "in", "ret", ":", "returned", ".", "add", "(", "ret", "[", "'id'", "]", ")", "yield", "{", "ret", "[", "'id'", "]", ":", "ret", "[", "'ret'", "]", "}", "except", "Exception", ":", "# This bare exception is here to catch spurious exceptions", "# thrown by que.get during healthy operation. Please do not", "# worry about this bare exception, it is entirely here to", "# control program flow.", "pass", "for", "host", "in", "running", ":", "if", "not", "running", "[", "host", "]", "[", "'thread'", "]", ".", "is_alive", "(", ")", ":", "if", "host", "not", "in", "returned", ":", "# Try to get any returns that came through since we", "# last checked", "try", ":", "while", "True", ":", "ret", "=", "que", ".", "get", "(", "False", ")", "if", "'id'", "in", "ret", ":", "returned", ".", "add", "(", "ret", "[", "'id'", "]", ")", "yield", "{", "ret", "[", "'id'", "]", ":", "ret", "[", "'ret'", "]", "}", "except", "Exception", ":", "pass", "if", "host", "not", "in", "returned", ":", "error", "=", "(", "'Target \\'{0}\\' did not return any data, '", "'probably due to an error.'", ")", ".", "format", "(", "host", ")", "ret", "=", "{", "'id'", ":", "host", ",", "'ret'", ":", "error", "}", "log", ".", "error", "(", "error", ")", "yield", "{", "ret", "[", "'id'", "]", ":", "ret", "[", "'ret'", "]", "}", "running", "[", "host", "]", "[", "'thread'", "]", ".", "join", "(", ")", "rets", ".", "add", "(", "host", ")", "for", "host", "in", "rets", ":", "if", "host", "in", "running", ":", "running", ".", "pop", "(", "host", ")", "if", "len", "(", "rets", ")", ">=", "len", "(", "self", ".", "targets", ")", ":", "break", "# Sleep when limit or all threads started", "if", "len", "(", "running", ")", ">=", "self", ".", "opts", ".", "get", "(", "'ssh_max_procs'", ",", "25", ")", "or", "len", "(", "self", ".", "targets", ")", ">=", "len", "(", "running", ")", ":", "time", ".", "sleep", "(", "0.1", ")"], "docstring": "Spin up the needed threads or processes and execute the subsequent\n        routines", "docstring_tokens": ["Spin", "up", "the", "needed", "threads", "or", "processes", "and", "execute", "the", "subsequent", "routines"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/client/ssh/__init__.py#L543-L637", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/client/ssh/__init__.py", "func_name": "SSH.run_iter", "original_string": "def run_iter(self, mine=False, jid=None):\n        '''\n        Execute and yield returns as they come in, do not print to the display\n\n        mine\n            The Single objects will use mine_functions defined in the roster,\n            pillar, or master config (they will be checked in that order) and\n            will modify the argv with the arguments from mine_functions\n        '''\n        fstr = '{0}.prep_jid'.format(self.opts['master_job_cache'])\n        jid = self.returners[fstr](passed_jid=jid or self.opts.get('jid', None))\n\n        # Save the invocation information\n        argv = self.opts['argv']\n\n        if self.opts.get('raw_shell', False):\n            fun = 'ssh._raw'\n            args = argv\n        else:\n            fun = argv[0] if argv else ''\n            args = argv[1:]\n\n        job_load = {\n            'jid': jid,\n            'tgt_type': self.tgt_type,\n            'tgt': self.opts['tgt'],\n            'user': self.opts['user'],\n            'fun': fun,\n            'arg': args,\n            }\n\n        # save load to the master job cache\n        if self.opts['master_job_cache'] == 'local_cache':\n            self.returners['{0}.save_load'.format(self.opts['master_job_cache'])](jid, job_load, minions=self.targets.keys())\n        else:\n            self.returners['{0}.save_load'.format(self.opts['master_job_cache'])](jid, job_load)\n\n        for ret in self.handle_ssh(mine=mine):\n            host = next(six.iterkeys(ret))\n            self.cache_job(jid, host, ret[host], fun)\n            if self.event:\n                id_, data = next(six.iteritems(ret))\n                if isinstance(data, six.text_type):\n                    data = {'return': data}\n                if 'id' not in data:\n                    data['id'] = id_\n                data['jid'] = jid  # make the jid in the payload the same as the jid in the tag\n                self.event.fire_event(\n                    data,\n                    salt.utils.event.tagify(\n                        [jid, 'ret', host],\n                        'job'))\n            yield ret", "language": "python", "code": "def run_iter(self, mine=False, jid=None):\n        '''\n        Execute and yield returns as they come in, do not print to the display\n\n        mine\n            The Single objects will use mine_functions defined in the roster,\n            pillar, or master config (they will be checked in that order) and\n            will modify the argv with the arguments from mine_functions\n        '''\n        fstr = '{0}.prep_jid'.format(self.opts['master_job_cache'])\n        jid = self.returners[fstr](passed_jid=jid or self.opts.get('jid', None))\n\n        # Save the invocation information\n        argv = self.opts['argv']\n\n        if self.opts.get('raw_shell', False):\n            fun = 'ssh._raw'\n            args = argv\n        else:\n            fun = argv[0] if argv else ''\n            args = argv[1:]\n\n        job_load = {\n            'jid': jid,\n            'tgt_type': self.tgt_type,\n            'tgt': self.opts['tgt'],\n            'user': self.opts['user'],\n            'fun': fun,\n            'arg': args,\n            }\n\n        # save load to the master job cache\n        if self.opts['master_job_cache'] == 'local_cache':\n            self.returners['{0}.save_load'.format(self.opts['master_job_cache'])](jid, job_load, minions=self.targets.keys())\n        else:\n            self.returners['{0}.save_load'.format(self.opts['master_job_cache'])](jid, job_load)\n\n        for ret in self.handle_ssh(mine=mine):\n            host = next(six.iterkeys(ret))\n            self.cache_job(jid, host, ret[host], fun)\n            if self.event:\n                id_, data = next(six.iteritems(ret))\n                if isinstance(data, six.text_type):\n                    data = {'return': data}\n                if 'id' not in data:\n                    data['id'] = id_\n                data['jid'] = jid  # make the jid in the payload the same as the jid in the tag\n                self.event.fire_event(\n                    data,\n                    salt.utils.event.tagify(\n                        [jid, 'ret', host],\n                        'job'))\n            yield ret", "code_tokens": ["def", "run_iter", "(", "self", ",", "mine", "=", "False", ",", "jid", "=", "None", ")", ":", "fstr", "=", "'{0}.prep_jid'", ".", "format", "(", "self", ".", "opts", "[", "'master_job_cache'", "]", ")", "jid", "=", "self", ".", "returners", "[", "fstr", "]", "(", "passed_jid", "=", "jid", "or", "self", ".", "opts", ".", "get", "(", "'jid'", ",", "None", ")", ")", "# Save the invocation information", "argv", "=", "self", ".", "opts", "[", "'argv'", "]", "if", "self", ".", "opts", ".", "get", "(", "'raw_shell'", ",", "False", ")", ":", "fun", "=", "'ssh._raw'", "args", "=", "argv", "else", ":", "fun", "=", "argv", "[", "0", "]", "if", "argv", "else", "''", "args", "=", "argv", "[", "1", ":", "]", "job_load", "=", "{", "'jid'", ":", "jid", ",", "'tgt_type'", ":", "self", ".", "tgt_type", ",", "'tgt'", ":", "self", ".", "opts", "[", "'tgt'", "]", ",", "'user'", ":", "self", ".", "opts", "[", "'user'", "]", ",", "'fun'", ":", "fun", ",", "'arg'", ":", "args", ",", "}", "# save load to the master job cache", "if", "self", ".", "opts", "[", "'master_job_cache'", "]", "==", "'local_cache'", ":", "self", ".", "returners", "[", "'{0}.save_load'", ".", "format", "(", "self", ".", "opts", "[", "'master_job_cache'", "]", ")", "]", "(", "jid", ",", "job_load", ",", "minions", "=", "self", ".", "targets", ".", "keys", "(", ")", ")", "else", ":", "self", ".", "returners", "[", "'{0}.save_load'", ".", "format", "(", "self", ".", "opts", "[", "'master_job_cache'", "]", ")", "]", "(", "jid", ",", "job_load", ")", "for", "ret", "in", "self", ".", "handle_ssh", "(", "mine", "=", "mine", ")", ":", "host", "=", "next", "(", "six", ".", "iterkeys", "(", "ret", ")", ")", "self", ".", "cache_job", "(", "jid", ",", "host", ",", "ret", "[", "host", "]", ",", "fun", ")", "if", "self", ".", "event", ":", "id_", ",", "data", "=", "next", "(", "six", ".", "iteritems", "(", "ret", ")", ")", "if", "isinstance", "(", "data", ",", "six", ".", "text_type", ")", ":", "data", "=", "{", "'return'", ":", "data", "}", "if", "'id'", "not", "in", "data", ":", "data", "[", "'id'", "]", "=", "id_", "data", "[", "'jid'", "]", "=", "jid", "# make the jid in the payload the same as the jid in the tag", "self", ".", "event", ".", "fire_event", "(", "data", ",", "salt", ".", "utils", ".", "event", ".", "tagify", "(", "[", "jid", ",", "'ret'", ",", "host", "]", ",", "'job'", ")", ")", "yield", "ret"], "docstring": "Execute and yield returns as they come in, do not print to the display\n\n        mine\n            The Single objects will use mine_functions defined in the roster,\n            pillar, or master config (they will be checked in that order) and\n            will modify the argv with the arguments from mine_functions", "docstring_tokens": ["Execute", "and", "yield", "returns", "as", "they", "come", "in", "do", "not", "print", "to", "the", "display"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/client/ssh/__init__.py#L639-L691", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/client/ssh/__init__.py", "func_name": "SSH.cache_job", "original_string": "def cache_job(self, jid, id_, ret, fun):\n        '''\n        Cache the job information\n        '''\n        self.returners['{0}.returner'.format(self.opts['master_job_cache'])]({'jid': jid,\n                                                                              'id': id_,\n                                                                              'return': ret,\n                                                                              'fun': fun})", "language": "python", "code": "def cache_job(self, jid, id_, ret, fun):\n        '''\n        Cache the job information\n        '''\n        self.returners['{0}.returner'.format(self.opts['master_job_cache'])]({'jid': jid,\n                                                                              'id': id_,\n                                                                              'return': ret,\n                                                                              'fun': fun})", "code_tokens": ["def", "cache_job", "(", "self", ",", "jid", ",", "id_", ",", "ret", ",", "fun", ")", ":", "self", ".", "returners", "[", "'{0}.returner'", ".", "format", "(", "self", ".", "opts", "[", "'master_job_cache'", "]", ")", "]", "(", "{", "'jid'", ":", "jid", ",", "'id'", ":", "id_", ",", "'return'", ":", "ret", ",", "'fun'", ":", "fun", "}", ")"], "docstring": "Cache the job information", "docstring_tokens": ["Cache", "the", "job", "information"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/client/ssh/__init__.py#L693-L700", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/client/ssh/__init__.py", "func_name": "SSH.run", "original_string": "def run(self, jid=None):\n        '''\n        Execute the overall routine, print results via outputters\n        '''\n        if self.opts.get('list_hosts'):\n            self._get_roster()\n            ret = {}\n            for roster_file in self.__parsed_rosters:\n                if roster_file.startswith('#'):\n                    continue\n                ret[roster_file] = {}\n                for host_id in self.__parsed_rosters[roster_file]:\n                    hostname = self.__parsed_rosters[roster_file][host_id]['host']\n                    ret[roster_file][host_id] = hostname\n            salt.output.display_output(ret, 'nested', self.opts)\n            sys.exit()\n\n        fstr = '{0}.prep_jid'.format(self.opts['master_job_cache'])\n        jid = self.returners[fstr](passed_jid=jid or self.opts.get('jid', None))\n\n        # Save the invocation information\n        argv = self.opts['argv']\n\n        if self.opts.get('raw_shell', False):\n            fun = 'ssh._raw'\n            args = argv\n        else:\n            fun = argv[0] if argv else ''\n            args = argv[1:]\n\n        job_load = {\n            'jid': jid,\n            'tgt_type': self.tgt_type,\n            'tgt': self.opts['tgt'],\n            'user': self.opts['user'],\n            'fun': fun,\n            'arg': args,\n            }\n\n        # save load to the master job cache\n        try:\n            if isinstance(jid, bytes):\n                jid = jid.decode('utf-8')\n            if self.opts['master_job_cache'] == 'local_cache':\n                self.returners['{0}.save_load'.format(self.opts['master_job_cache'])](jid, job_load, minions=self.targets.keys())\n            else:\n                self.returners['{0}.save_load'.format(self.opts['master_job_cache'])](jid, job_load)\n        except Exception as exc:\n            log.exception(exc)\n            log.error(\n                'Could not save load with returner %s: %s',\n                self.opts['master_job_cache'], exc\n            )\n\n        if self.opts.get('verbose'):\n            msg = 'Executing job with jid {0}'.format(jid)\n            print(msg)\n            print('-' * len(msg) + '\\n')\n            print('')\n        sret = {}\n        outputter = self.opts.get('output', 'nested')\n        final_exit = 0\n        for ret in self.handle_ssh():\n            host = next(six.iterkeys(ret))\n            if isinstance(ret[host], dict):\n                host_ret = ret[host].get('retcode', 0)\n                if host_ret != 0:\n                    final_exit = 1\n            else:\n                # Error on host\n                final_exit = 1\n\n            self.cache_job(jid, host, ret[host], fun)\n            ret = self.key_deploy(host, ret)\n\n            if isinstance(ret[host], dict) and (ret[host].get('stderr') or '').startswith('ssh:'):\n                ret[host] = ret[host]['stderr']\n\n            if not isinstance(ret[host], dict):\n                p_data = {host: ret[host]}\n            elif 'return' not in ret[host]:\n                p_data = ret\n            else:\n                outputter = ret[host].get('out', self.opts.get('output', 'nested'))\n                p_data = {host: ret[host].get('return', {})}\n            if self.opts.get('static'):\n                sret.update(p_data)\n            else:\n                salt.output.display_output(\n                        p_data,\n                        outputter,\n                        self.opts)\n            if self.event:\n                id_, data = next(six.iteritems(ret))\n                if isinstance(data, six.text_type):\n                    data = {'return': data}\n                if 'id' not in data:\n                    data['id'] = id_\n                data['jid'] = jid  # make the jid in the payload the same as the jid in the tag\n                self.event.fire_event(\n                    data,\n                    salt.utils.event.tagify(\n                        [jid, 'ret', host],\n                        'job'))\n        if self.opts.get('static'):\n            salt.output.display_output(\n                    sret,\n                    outputter,\n                    self.opts)\n        if final_exit:\n            sys.exit(salt.defaults.exitcodes.EX_AGGREGATE)", "language": "python", "code": "def run(self, jid=None):\n        '''\n        Execute the overall routine, print results via outputters\n        '''\n        if self.opts.get('list_hosts'):\n            self._get_roster()\n            ret = {}\n            for roster_file in self.__parsed_rosters:\n                if roster_file.startswith('#'):\n                    continue\n                ret[roster_file] = {}\n                for host_id in self.__parsed_rosters[roster_file]:\n                    hostname = self.__parsed_rosters[roster_file][host_id]['host']\n                    ret[roster_file][host_id] = hostname\n            salt.output.display_output(ret, 'nested', self.opts)\n            sys.exit()\n\n        fstr = '{0}.prep_jid'.format(self.opts['master_job_cache'])\n        jid = self.returners[fstr](passed_jid=jid or self.opts.get('jid', None))\n\n        # Save the invocation information\n        argv = self.opts['argv']\n\n        if self.opts.get('raw_shell', False):\n            fun = 'ssh._raw'\n            args = argv\n        else:\n            fun = argv[0] if argv else ''\n            args = argv[1:]\n\n        job_load = {\n            'jid': jid,\n            'tgt_type': self.tgt_type,\n            'tgt': self.opts['tgt'],\n            'user': self.opts['user'],\n            'fun': fun,\n            'arg': args,\n            }\n\n        # save load to the master job cache\n        try:\n            if isinstance(jid, bytes):\n                jid = jid.decode('utf-8')\n            if self.opts['master_job_cache'] == 'local_cache':\n                self.returners['{0}.save_load'.format(self.opts['master_job_cache'])](jid, job_load, minions=self.targets.keys())\n            else:\n                self.returners['{0}.save_load'.format(self.opts['master_job_cache'])](jid, job_load)\n        except Exception as exc:\n            log.exception(exc)\n            log.error(\n                'Could not save load with returner %s: %s',\n                self.opts['master_job_cache'], exc\n            )\n\n        if self.opts.get('verbose'):\n            msg = 'Executing job with jid {0}'.format(jid)\n            print(msg)\n            print('-' * len(msg) + '\\n')\n            print('')\n        sret = {}\n        outputter = self.opts.get('output', 'nested')\n        final_exit = 0\n        for ret in self.handle_ssh():\n            host = next(six.iterkeys(ret))\n            if isinstance(ret[host], dict):\n                host_ret = ret[host].get('retcode', 0)\n                if host_ret != 0:\n                    final_exit = 1\n            else:\n                # Error on host\n                final_exit = 1\n\n            self.cache_job(jid, host, ret[host], fun)\n            ret = self.key_deploy(host, ret)\n\n            if isinstance(ret[host], dict) and (ret[host].get('stderr') or '').startswith('ssh:'):\n                ret[host] = ret[host]['stderr']\n\n            if not isinstance(ret[host], dict):\n                p_data = {host: ret[host]}\n            elif 'return' not in ret[host]:\n                p_data = ret\n            else:\n                outputter = ret[host].get('out', self.opts.get('output', 'nested'))\n                p_data = {host: ret[host].get('return', {})}\n            if self.opts.get('static'):\n                sret.update(p_data)\n            else:\n                salt.output.display_output(\n                        p_data,\n                        outputter,\n                        self.opts)\n            if self.event:\n                id_, data = next(six.iteritems(ret))\n                if isinstance(data, six.text_type):\n                    data = {'return': data}\n                if 'id' not in data:\n                    data['id'] = id_\n                data['jid'] = jid  # make the jid in the payload the same as the jid in the tag\n                self.event.fire_event(\n                    data,\n                    salt.utils.event.tagify(\n                        [jid, 'ret', host],\n                        'job'))\n        if self.opts.get('static'):\n            salt.output.display_output(\n                    sret,\n                    outputter,\n                    self.opts)\n        if final_exit:\n            sys.exit(salt.defaults.exitcodes.EX_AGGREGATE)", "code_tokens": ["def", "run", "(", "self", ",", "jid", "=", "None", ")", ":", "if", "self", ".", "opts", ".", "get", "(", "'list_hosts'", ")", ":", "self", ".", "_get_roster", "(", ")", "ret", "=", "{", "}", "for", "roster_file", "in", "self", ".", "__parsed_rosters", ":", "if", "roster_file", ".", "startswith", "(", "'#'", ")", ":", "continue", "ret", "[", "roster_file", "]", "=", "{", "}", "for", "host_id", "in", "self", ".", "__parsed_rosters", "[", "roster_file", "]", ":", "hostname", "=", "self", ".", "__parsed_rosters", "[", "roster_file", "]", "[", "host_id", "]", "[", "'host'", "]", "ret", "[", "roster_file", "]", "[", "host_id", "]", "=", "hostname", "salt", ".", "output", ".", "display_output", "(", "ret", ",", "'nested'", ",", "self", ".", "opts", ")", "sys", ".", "exit", "(", ")", "fstr", "=", "'{0}.prep_jid'", ".", "format", "(", "self", ".", "opts", "[", "'master_job_cache'", "]", ")", "jid", "=", "self", ".", "returners", "[", "fstr", "]", "(", "passed_jid", "=", "jid", "or", "self", ".", "opts", ".", "get", "(", "'jid'", ",", "None", ")", ")", "# Save the invocation information", "argv", "=", "self", ".", "opts", "[", "'argv'", "]", "if", "self", ".", "opts", ".", "get", "(", "'raw_shell'", ",", "False", ")", ":", "fun", "=", "'ssh._raw'", "args", "=", "argv", "else", ":", "fun", "=", "argv", "[", "0", "]", "if", "argv", "else", "''", "args", "=", "argv", "[", "1", ":", "]", "job_load", "=", "{", "'jid'", ":", "jid", ",", "'tgt_type'", ":", "self", ".", "tgt_type", ",", "'tgt'", ":", "self", ".", "opts", "[", "'tgt'", "]", ",", "'user'", ":", "self", ".", "opts", "[", "'user'", "]", ",", "'fun'", ":", "fun", ",", "'arg'", ":", "args", ",", "}", "# save load to the master job cache", "try", ":", "if", "isinstance", "(", "jid", ",", "bytes", ")", ":", "jid", "=", "jid", ".", "decode", "(", "'utf-8'", ")", "if", "self", ".", "opts", "[", "'master_job_cache'", "]", "==", "'local_cache'", ":", "self", ".", "returners", "[", "'{0}.save_load'", ".", "format", "(", "self", ".", "opts", "[", "'master_job_cache'", "]", ")", "]", "(", "jid", ",", "job_load", ",", "minions", "=", "self", ".", "targets", ".", "keys", "(", ")", ")", "else", ":", "self", ".", "returners", "[", "'{0}.save_load'", ".", "format", "(", "self", ".", "opts", "[", "'master_job_cache'", "]", ")", "]", "(", "jid", ",", "job_load", ")", "except", "Exception", "as", "exc", ":", "log", ".", "exception", "(", "exc", ")", "log", ".", "error", "(", "'Could not save load with returner %s: %s'", ",", "self", ".", "opts", "[", "'master_job_cache'", "]", ",", "exc", ")", "if", "self", ".", "opts", ".", "get", "(", "'verbose'", ")", ":", "msg", "=", "'Executing job with jid {0}'", ".", "format", "(", "jid", ")", "print", "(", "msg", ")", "print", "(", "'-'", "*", "len", "(", "msg", ")", "+", "'\\n'", ")", "print", "(", "''", ")", "sret", "=", "{", "}", "outputter", "=", "self", ".", "opts", ".", "get", "(", "'output'", ",", "'nested'", ")", "final_exit", "=", "0", "for", "ret", "in", "self", ".", "handle_ssh", "(", ")", ":", "host", "=", "next", "(", "six", ".", "iterkeys", "(", "ret", ")", ")", "if", "isinstance", "(", "ret", "[", "host", "]", ",", "dict", ")", ":", "host_ret", "=", "ret", "[", "host", "]", ".", "get", "(", "'retcode'", ",", "0", ")", "if", "host_ret", "!=", "0", ":", "final_exit", "=", "1", "else", ":", "# Error on host", "final_exit", "=", "1", "self", ".", "cache_job", "(", "jid", ",", "host", ",", "ret", "[", "host", "]", ",", "fun", ")", "ret", "=", "self", ".", "key_deploy", "(", "host", ",", "ret", ")", "if", "isinstance", "(", "ret", "[", "host", "]", ",", "dict", ")", "and", "(", "ret", "[", "host", "]", ".", "get", "(", "'stderr'", ")", "or", "''", ")", ".", "startswith", "(", "'ssh:'", ")", ":", "ret", "[", "host", "]", "=", "ret", "[", "host", "]", "[", "'stderr'", "]", "if", "not", "isinstance", "(", "ret", "[", "host", "]", ",", "dict", ")", ":", "p_data", "=", "{", "host", ":", "ret", "[", "host", "]", "}", "elif", "'return'", "not", "in", "ret", "[", "host", "]", ":", "p_data", "=", "ret", "else", ":", "outputter", "=", "ret", "[", "host", "]", ".", "get", "(", "'out'", ",", "self", ".", "opts", ".", "get", "(", "'output'", ",", "'nested'", ")", ")", "p_data", "=", "{", "host", ":", "ret", "[", "host", "]", ".", "get", "(", "'return'", ",", "{", "}", ")", "}", "if", "self", ".", "opts", ".", "get", "(", "'static'", ")", ":", "sret", ".", "update", "(", "p_data", ")", "else", ":", "salt", ".", "output", ".", "display_output", "(", "p_data", ",", "outputter", ",", "self", ".", "opts", ")", "if", "self", ".", "event", ":", "id_", ",", "data", "=", "next", "(", "six", ".", "iteritems", "(", "ret", ")", ")", "if", "isinstance", "(", "data", ",", "six", ".", "text_type", ")", ":", "data", "=", "{", "'return'", ":", "data", "}", "if", "'id'", "not", "in", "data", ":", "data", "[", "'id'", "]", "=", "id_", "data", "[", "'jid'", "]", "=", "jid", "# make the jid in the payload the same as the jid in the tag", "self", ".", "event", ".", "fire_event", "(", "data", ",", "salt", ".", "utils", ".", "event", ".", "tagify", "(", "[", "jid", ",", "'ret'", ",", "host", "]", ",", "'job'", ")", ")", "if", "self", ".", "opts", ".", "get", "(", "'static'", ")", ":", "salt", ".", "output", ".", "display_output", "(", "sret", ",", "outputter", ",", "self", ".", "opts", ")", "if", "final_exit", ":", "sys", ".", "exit", "(", "salt", ".", "defaults", ".", "exitcodes", ".", "EX_AGGREGATE", ")"], "docstring": "Execute the overall routine, print results via outputters", "docstring_tokens": ["Execute", "the", "overall", "routine", "print", "results", "via", "outputters"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/client/ssh/__init__.py#L702-L812", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/client/ssh/__init__.py", "func_name": "Single.__arg_comps", "original_string": "def __arg_comps(self):\n        '''\n        Return the function name and the arg list\n        '''\n        fun = self.argv[0] if self.argv else ''\n        parsed = salt.utils.args.parse_input(\n            self.argv[1:],\n            condition=False,\n            no_parse=self.opts.get('no_parse', []))\n        args = parsed[0]\n        kws = parsed[1]\n        return fun, args, kws", "language": "python", "code": "def __arg_comps(self):\n        '''\n        Return the function name and the arg list\n        '''\n        fun = self.argv[0] if self.argv else ''\n        parsed = salt.utils.args.parse_input(\n            self.argv[1:],\n            condition=False,\n            no_parse=self.opts.get('no_parse', []))\n        args = parsed[0]\n        kws = parsed[1]\n        return fun, args, kws", "code_tokens": ["def", "__arg_comps", "(", "self", ")", ":", "fun", "=", "self", ".", "argv", "[", "0", "]", "if", "self", ".", "argv", "else", "''", "parsed", "=", "salt", ".", "utils", ".", "args", ".", "parse_input", "(", "self", ".", "argv", "[", "1", ":", "]", ",", "condition", "=", "False", ",", "no_parse", "=", "self", ".", "opts", ".", "get", "(", "'no_parse'", ",", "[", "]", ")", ")", "args", "=", "parsed", "[", "0", "]", "kws", "=", "parsed", "[", "1", "]", "return", "fun", ",", "args", ",", "kws"], "docstring": "Return the function name and the arg list", "docstring_tokens": ["Return", "the", "function", "name", "and", "the", "arg", "list"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/client/ssh/__init__.py#L932-L943", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/client/ssh/__init__.py", "func_name": "Single._escape_arg", "original_string": "def _escape_arg(self, arg):\n        '''\n        Properly escape argument to protect special characters from shell\n        interpretation.  This avoids having to do tricky argument quoting.\n\n        Effectively just escape all characters in the argument that are not\n        alphanumeric!\n        '''\n        if self.winrm:\n            return arg\n        return ''.join(['\\\\' + char if re.match(r'\\W', char) else char for char in arg])", "language": "python", "code": "def _escape_arg(self, arg):\n        '''\n        Properly escape argument to protect special characters from shell\n        interpretation.  This avoids having to do tricky argument quoting.\n\n        Effectively just escape all characters in the argument that are not\n        alphanumeric!\n        '''\n        if self.winrm:\n            return arg\n        return ''.join(['\\\\' + char if re.match(r'\\W', char) else char for char in arg])", "code_tokens": ["def", "_escape_arg", "(", "self", ",", "arg", ")", ":", "if", "self", ".", "winrm", ":", "return", "arg", "return", "''", ".", "join", "(", "[", "'\\\\'", "+", "char", "if", "re", ".", "match", "(", "r'\\W'", ",", "char", ")", "else", "char", "for", "char", "in", "arg", "]", ")"], "docstring": "Properly escape argument to protect special characters from shell\n        interpretation.  This avoids having to do tricky argument quoting.\n\n        Effectively just escape all characters in the argument that are not\n        alphanumeric!", "docstring_tokens": ["Properly", "escape", "argument", "to", "protect", "special", "characters", "from", "shell", "interpretation", ".", "This", "avoids", "having", "to", "do", "tricky", "argument", "quoting", "."], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/client/ssh/__init__.py#L945-L955", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/client/ssh/__init__.py", "func_name": "Single.deploy", "original_string": "def deploy(self):\n        '''\n        Deploy salt-thin\n        '''\n        self.shell.send(\n            self.thin,\n            os.path.join(self.thin_dir, 'salt-thin.tgz'),\n        )\n        self.deploy_ext()\n        return True", "language": "python", "code": "def deploy(self):\n        '''\n        Deploy salt-thin\n        '''\n        self.shell.send(\n            self.thin,\n            os.path.join(self.thin_dir, 'salt-thin.tgz'),\n        )\n        self.deploy_ext()\n        return True", "code_tokens": ["def", "deploy", "(", "self", ")", ":", "self", ".", "shell", ".", "send", "(", "self", ".", "thin", ",", "os", ".", "path", ".", "join", "(", "self", ".", "thin_dir", ",", "'salt-thin.tgz'", ")", ",", ")", "self", ".", "deploy_ext", "(", ")", "return", "True"], "docstring": "Deploy salt-thin", "docstring_tokens": ["Deploy", "salt", "-", "thin"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/client/ssh/__init__.py#L957-L966", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/client/ssh/__init__.py", "func_name": "Single.deploy_ext", "original_string": "def deploy_ext(self):\n        '''\n        Deploy the ext_mods tarball\n        '''\n        if self.mods.get('file'):\n            self.shell.send(\n                self.mods['file'],\n                os.path.join(self.thin_dir, 'salt-ext_mods.tgz'),\n            )\n        return True", "language": "python", "code": "def deploy_ext(self):\n        '''\n        Deploy the ext_mods tarball\n        '''\n        if self.mods.get('file'):\n            self.shell.send(\n                self.mods['file'],\n                os.path.join(self.thin_dir, 'salt-ext_mods.tgz'),\n            )\n        return True", "code_tokens": ["def", "deploy_ext", "(", "self", ")", ":", "if", "self", ".", "mods", ".", "get", "(", "'file'", ")", ":", "self", ".", "shell", ".", "send", "(", "self", ".", "mods", "[", "'file'", "]", ",", "os", ".", "path", ".", "join", "(", "self", ".", "thin_dir", ",", "'salt-ext_mods.tgz'", ")", ",", ")", "return", "True"], "docstring": "Deploy the ext_mods tarball", "docstring_tokens": ["Deploy", "the", "ext_mods", "tarball"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/client/ssh/__init__.py#L968-L977", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/client/ssh/__init__.py", "func_name": "Single.run", "original_string": "def run(self, deploy_attempted=False):\n        '''\n        Execute the routine, the routine can be either:\n        1. Execute a raw shell command\n        2. Execute a wrapper func\n        3. Execute a remote Salt command\n\n        If a (re)deploy is needed, then retry the operation after a deploy\n        attempt\n\n        Returns tuple of (stdout, stderr, retcode)\n        '''\n        stdout = stderr = retcode = None\n\n        if self.opts.get('raw_shell', False):\n            cmd_str = ' '.join([self._escape_arg(arg) for arg in self.argv])\n            stdout, stderr, retcode = self.shell.exec_cmd(cmd_str)\n\n        elif self.fun in self.wfuncs or self.mine:\n            stdout, retcode = self.run_wfunc()\n\n        else:\n            stdout, stderr, retcode = self.cmd_block()\n\n        return stdout, stderr, retcode", "language": "python", "code": "def run(self, deploy_attempted=False):\n        '''\n        Execute the routine, the routine can be either:\n        1. Execute a raw shell command\n        2. Execute a wrapper func\n        3. Execute a remote Salt command\n\n        If a (re)deploy is needed, then retry the operation after a deploy\n        attempt\n\n        Returns tuple of (stdout, stderr, retcode)\n        '''\n        stdout = stderr = retcode = None\n\n        if self.opts.get('raw_shell', False):\n            cmd_str = ' '.join([self._escape_arg(arg) for arg in self.argv])\n            stdout, stderr, retcode = self.shell.exec_cmd(cmd_str)\n\n        elif self.fun in self.wfuncs or self.mine:\n            stdout, retcode = self.run_wfunc()\n\n        else:\n            stdout, stderr, retcode = self.cmd_block()\n\n        return stdout, stderr, retcode", "code_tokens": ["def", "run", "(", "self", ",", "deploy_attempted", "=", "False", ")", ":", "stdout", "=", "stderr", "=", "retcode", "=", "None", "if", "self", ".", "opts", ".", "get", "(", "'raw_shell'", ",", "False", ")", ":", "cmd_str", "=", "' '", ".", "join", "(", "[", "self", ".", "_escape_arg", "(", "arg", ")", "for", "arg", "in", "self", ".", "argv", "]", ")", "stdout", ",", "stderr", ",", "retcode", "=", "self", ".", "shell", ".", "exec_cmd", "(", "cmd_str", ")", "elif", "self", ".", "fun", "in", "self", ".", "wfuncs", "or", "self", ".", "mine", ":", "stdout", ",", "retcode", "=", "self", ".", "run_wfunc", "(", ")", "else", ":", "stdout", ",", "stderr", ",", "retcode", "=", "self", ".", "cmd_block", "(", ")", "return", "stdout", ",", "stderr", ",", "retcode"], "docstring": "Execute the routine, the routine can be either:\n        1. Execute a raw shell command\n        2. Execute a wrapper func\n        3. Execute a remote Salt command\n\n        If a (re)deploy is needed, then retry the operation after a deploy\n        attempt\n\n        Returns tuple of (stdout, stderr, retcode)", "docstring_tokens": ["Execute", "the", "routine", "the", "routine", "can", "be", "either", ":", "1", ".", "Execute", "a", "raw", "shell", "command", "2", ".", "Execute", "a", "wrapper", "func", "3", ".", "Execute", "a", "remote", "Salt", "command"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/client/ssh/__init__.py#L979-L1003", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/client/ssh/__init__.py", "func_name": "Single.run_wfunc", "original_string": "def run_wfunc(self):\n        '''\n        Execute a wrapper function\n\n        Returns tuple of (json_data, '')\n        '''\n        # Ensure that opts/grains are up to date\n        # Execute routine\n        data_cache = False\n        data = None\n        cdir = os.path.join(self.opts['cachedir'], 'minions', self.id)\n        if not os.path.isdir(cdir):\n            os.makedirs(cdir)\n        datap = os.path.join(cdir, 'ssh_data.p')\n        refresh = False\n        if not os.path.isfile(datap):\n            refresh = True\n        else:\n            passed_time = (time.time() - os.stat(datap).st_mtime) / 60\n            if passed_time > self.opts.get('cache_life', 60):\n                refresh = True\n\n        if self.opts.get('refresh_cache'):\n            refresh = True\n        conf_grains = {}\n        # Save conf file grains before they get clobbered\n        if 'ssh_grains' in self.opts:\n            conf_grains = self.opts['ssh_grains']\n        if not data_cache:\n            refresh = True\n        if refresh:\n            # Make the datap\n            # TODO: Auto expire the datap\n            pre_wrapper = salt.client.ssh.wrapper.FunctionWrapper(\n                self.opts,\n                self.id,\n                fsclient=self.fsclient,\n                minion_opts=self.minion_opts,\n                **self.target)\n            opts_pkg = pre_wrapper['test.opts_pkg']()  # pylint: disable=E1102\n            if '_error' in opts_pkg:\n                #Refresh failed\n                retcode = opts_pkg['retcode']\n                ret = salt.utils.json.dumps({'local': opts_pkg})\n                return ret, retcode\n\n            opts_pkg['file_roots'] = self.opts['file_roots']\n            opts_pkg['pillar_roots'] = self.opts['pillar_roots']\n            opts_pkg['ext_pillar'] = self.opts['ext_pillar']\n            opts_pkg['extension_modules'] = self.opts['extension_modules']\n            opts_pkg['module_dirs'] = self.opts['module_dirs']\n            opts_pkg['_ssh_version'] = self.opts['_ssh_version']\n            opts_pkg['__master_opts__'] = self.context['master_opts']\n            if 'known_hosts_file' in self.opts:\n                opts_pkg['known_hosts_file'] = self.opts['known_hosts_file']\n            if '_caller_cachedir' in self.opts:\n                opts_pkg['_caller_cachedir'] = self.opts['_caller_cachedir']\n            else:\n                opts_pkg['_caller_cachedir'] = self.opts['cachedir']\n            # Use the ID defined in the roster file\n            opts_pkg['id'] = self.id\n\n            retcode = 0\n\n            # Restore master grains\n            for grain in conf_grains:\n                opts_pkg['grains'][grain] = conf_grains[grain]\n            # Enable roster grains support\n            if 'grains' in self.target:\n                for grain in self.target['grains']:\n                    opts_pkg['grains'][grain] = self.target['grains'][grain]\n\n            popts = {}\n            popts.update(opts_pkg)\n\n            # Master centric operations such as mine.get must have master option loaded.\n            # The pillar must then be compiled by passing master opts found in opts_pkg['__master_opts__']\n            # which causes the pillar renderer to loose track of salt master options\n            #\n            # Depending on popts merge order, it will overwrite some options found in opts_pkg['__master_opts__']\n            master_centric_funcs = [\n              \"pillar.items\",\n              \"mine.get\"\n            ]\n\n            # Pillar compilation is a master centric operation.\n            # Master options take precedence during Pillar compilation\n            popts.update(opts_pkg['__master_opts__'])\n\n            pillar = salt.pillar.Pillar(\n                    popts,\n                    opts_pkg['grains'],\n                    opts_pkg['id'],\n                    opts_pkg.get('saltenv', 'base')\n                    )\n            pillar_data = pillar.compile_pillar()\n\n            # Once pillar has been compiled, restore priority of minion opts\n            if self.fun not in master_centric_funcs:\n                log.debug('%s is a minion function', self.fun)\n                popts.update(opts_pkg)\n            else:\n                log.debug('%s is a master function', self.fun)\n\n            # TODO: cache minion opts in datap in master.py\n            data = {'opts': opts_pkg,\n                    'grains': opts_pkg['grains'],\n                    'pillar': pillar_data}\n            if data_cache:\n                with salt.utils.files.fopen(datap, 'w+b') as fp_:\n                    fp_.write(\n                            self.serial.dumps(data)\n                            )\n        if not data and data_cache:\n            with salt.utils.files.fopen(datap, 'rb') as fp_:\n                data = self.serial.load(fp_)\n        opts = data.get('opts', {})\n        opts['grains'] = data.get('grains')\n\n        # Restore master grains\n        for grain in conf_grains:\n            opts['grains'][grain] = conf_grains[grain]\n        # Enable roster grains support\n        if 'grains' in self.target:\n            for grain in self.target['grains']:\n                opts['grains'][grain] = self.target['grains'][grain]\n\n        opts['pillar'] = data.get('pillar')\n        wrapper = salt.client.ssh.wrapper.FunctionWrapper(\n            opts,\n            self.id,\n            fsclient=self.fsclient,\n            minion_opts=self.minion_opts,\n            **self.target)\n        self.wfuncs = salt.loader.ssh_wrapper(opts, wrapper, self.context)\n        wrapper.wfuncs = self.wfuncs\n\n        # We're running in the mine, need to fetch the arguments from the\n        # roster, pillar, master config (in that order)\n        if self.mine:\n            mine_args = None\n            mine_fun_data = None\n            mine_fun = self.fun\n\n            if self.mine_functions and self.fun in self.mine_functions:\n                mine_fun_data = self.mine_functions[self.fun]\n            elif opts['pillar'] and self.fun in opts['pillar'].get('mine_functions', {}):\n                mine_fun_data = opts['pillar']['mine_functions'][self.fun]\n            elif self.fun in self.context['master_opts'].get('mine_functions', {}):\n                mine_fun_data = self.context['master_opts']['mine_functions'][self.fun]\n\n            if isinstance(mine_fun_data, dict):\n                mine_fun = mine_fun_data.pop('mine_function', mine_fun)\n                mine_args = mine_fun_data\n            elif isinstance(mine_fun_data, list):\n                for item in mine_fun_data[:]:\n                    if isinstance(item, dict) and 'mine_function' in item:\n                        mine_fun = item['mine_function']\n                        mine_fun_data.pop(mine_fun_data.index(item))\n                mine_args = mine_fun_data\n            else:\n                mine_args = mine_fun_data\n\n            # If we found mine_args, replace our command's args\n            if isinstance(mine_args, dict):\n                self.args = []\n                self.kwargs = mine_args\n            elif isinstance(mine_args, list):\n                self.args = mine_args\n                self.kwargs = {}\n\n        try:\n            if self.mine:\n                result = wrapper[mine_fun](*self.args, **self.kwargs)\n            else:\n                result = self.wfuncs[self.fun](*self.args, **self.kwargs)\n        except TypeError as exc:\n            result = 'TypeError encountered executing {0}: {1}'.format(self.fun, exc)\n            log.error(result, exc_info_on_loglevel=logging.DEBUG)\n            retcode = 1\n        except Exception as exc:\n            result = 'An Exception occurred while executing {0}: {1}'.format(self.fun, exc)\n            log.error(result, exc_info_on_loglevel=logging.DEBUG)\n            retcode = 1\n        # Mimic the json data-structure that \"salt-call --local\" will\n        # emit (as seen in ssh_py_shim.py)\n        if isinstance(result, dict) and 'local' in result:\n            ret = salt.utils.json.dumps({'local': result['local']})\n        else:\n            ret = salt.utils.json.dumps({'local': {'return': result}})\n        return ret, retcode", "language": "python", "code": "def run_wfunc(self):\n        '''\n        Execute a wrapper function\n\n        Returns tuple of (json_data, '')\n        '''\n        # Ensure that opts/grains are up to date\n        # Execute routine\n        data_cache = False\n        data = None\n        cdir = os.path.join(self.opts['cachedir'], 'minions', self.id)\n        if not os.path.isdir(cdir):\n            os.makedirs(cdir)\n        datap = os.path.join(cdir, 'ssh_data.p')\n        refresh = False\n        if not os.path.isfile(datap):\n            refresh = True\n        else:\n            passed_time = (time.time() - os.stat(datap).st_mtime) / 60\n            if passed_time > self.opts.get('cache_life', 60):\n                refresh = True\n\n        if self.opts.get('refresh_cache'):\n            refresh = True\n        conf_grains = {}\n        # Save conf file grains before they get clobbered\n        if 'ssh_grains' in self.opts:\n            conf_grains = self.opts['ssh_grains']\n        if not data_cache:\n            refresh = True\n        if refresh:\n            # Make the datap\n            # TODO: Auto expire the datap\n            pre_wrapper = salt.client.ssh.wrapper.FunctionWrapper(\n                self.opts,\n                self.id,\n                fsclient=self.fsclient,\n                minion_opts=self.minion_opts,\n                **self.target)\n            opts_pkg = pre_wrapper['test.opts_pkg']()  # pylint: disable=E1102\n            if '_error' in opts_pkg:\n                #Refresh failed\n                retcode = opts_pkg['retcode']\n                ret = salt.utils.json.dumps({'local': opts_pkg})\n                return ret, retcode\n\n            opts_pkg['file_roots'] = self.opts['file_roots']\n            opts_pkg['pillar_roots'] = self.opts['pillar_roots']\n            opts_pkg['ext_pillar'] = self.opts['ext_pillar']\n            opts_pkg['extension_modules'] = self.opts['extension_modules']\n            opts_pkg['module_dirs'] = self.opts['module_dirs']\n            opts_pkg['_ssh_version'] = self.opts['_ssh_version']\n            opts_pkg['__master_opts__'] = self.context['master_opts']\n            if 'known_hosts_file' in self.opts:\n                opts_pkg['known_hosts_file'] = self.opts['known_hosts_file']\n            if '_caller_cachedir' in self.opts:\n                opts_pkg['_caller_cachedir'] = self.opts['_caller_cachedir']\n            else:\n                opts_pkg['_caller_cachedir'] = self.opts['cachedir']\n            # Use the ID defined in the roster file\n            opts_pkg['id'] = self.id\n\n            retcode = 0\n\n            # Restore master grains\n            for grain in conf_grains:\n                opts_pkg['grains'][grain] = conf_grains[grain]\n            # Enable roster grains support\n            if 'grains' in self.target:\n                for grain in self.target['grains']:\n                    opts_pkg['grains'][grain] = self.target['grains'][grain]\n\n            popts = {}\n            popts.update(opts_pkg)\n\n            # Master centric operations such as mine.get must have master option loaded.\n            # The pillar must then be compiled by passing master opts found in opts_pkg['__master_opts__']\n            # which causes the pillar renderer to loose track of salt master options\n            #\n            # Depending on popts merge order, it will overwrite some options found in opts_pkg['__master_opts__']\n            master_centric_funcs = [\n              \"pillar.items\",\n              \"mine.get\"\n            ]\n\n            # Pillar compilation is a master centric operation.\n            # Master options take precedence during Pillar compilation\n            popts.update(opts_pkg['__master_opts__'])\n\n            pillar = salt.pillar.Pillar(\n                    popts,\n                    opts_pkg['grains'],\n                    opts_pkg['id'],\n                    opts_pkg.get('saltenv', 'base')\n                    )\n            pillar_data = pillar.compile_pillar()\n\n            # Once pillar has been compiled, restore priority of minion opts\n            if self.fun not in master_centric_funcs:\n                log.debug('%s is a minion function', self.fun)\n                popts.update(opts_pkg)\n            else:\n                log.debug('%s is a master function', self.fun)\n\n            # TODO: cache minion opts in datap in master.py\n            data = {'opts': opts_pkg,\n                    'grains': opts_pkg['grains'],\n                    'pillar': pillar_data}\n            if data_cache:\n                with salt.utils.files.fopen(datap, 'w+b') as fp_:\n                    fp_.write(\n                            self.serial.dumps(data)\n                            )\n        if not data and data_cache:\n            with salt.utils.files.fopen(datap, 'rb') as fp_:\n                data = self.serial.load(fp_)\n        opts = data.get('opts', {})\n        opts['grains'] = data.get('grains')\n\n        # Restore master grains\n        for grain in conf_grains:\n            opts['grains'][grain] = conf_grains[grain]\n        # Enable roster grains support\n        if 'grains' in self.target:\n            for grain in self.target['grains']:\n                opts['grains'][grain] = self.target['grains'][grain]\n\n        opts['pillar'] = data.get('pillar')\n        wrapper = salt.client.ssh.wrapper.FunctionWrapper(\n            opts,\n            self.id,\n            fsclient=self.fsclient,\n            minion_opts=self.minion_opts,\n            **self.target)\n        self.wfuncs = salt.loader.ssh_wrapper(opts, wrapper, self.context)\n        wrapper.wfuncs = self.wfuncs\n\n        # We're running in the mine, need to fetch the arguments from the\n        # roster, pillar, master config (in that order)\n        if self.mine:\n            mine_args = None\n            mine_fun_data = None\n            mine_fun = self.fun\n\n            if self.mine_functions and self.fun in self.mine_functions:\n                mine_fun_data = self.mine_functions[self.fun]\n            elif opts['pillar'] and self.fun in opts['pillar'].get('mine_functions', {}):\n                mine_fun_data = opts['pillar']['mine_functions'][self.fun]\n            elif self.fun in self.context['master_opts'].get('mine_functions', {}):\n                mine_fun_data = self.context['master_opts']['mine_functions'][self.fun]\n\n            if isinstance(mine_fun_data, dict):\n                mine_fun = mine_fun_data.pop('mine_function', mine_fun)\n                mine_args = mine_fun_data\n            elif isinstance(mine_fun_data, list):\n                for item in mine_fun_data[:]:\n                    if isinstance(item, dict) and 'mine_function' in item:\n                        mine_fun = item['mine_function']\n                        mine_fun_data.pop(mine_fun_data.index(item))\n                mine_args = mine_fun_data\n            else:\n                mine_args = mine_fun_data\n\n            # If we found mine_args, replace our command's args\n            if isinstance(mine_args, dict):\n                self.args = []\n                self.kwargs = mine_args\n            elif isinstance(mine_args, list):\n                self.args = mine_args\n                self.kwargs = {}\n\n        try:\n            if self.mine:\n                result = wrapper[mine_fun](*self.args, **self.kwargs)\n            else:\n                result = self.wfuncs[self.fun](*self.args, **self.kwargs)\n        except TypeError as exc:\n            result = 'TypeError encountered executing {0}: {1}'.format(self.fun, exc)\n            log.error(result, exc_info_on_loglevel=logging.DEBUG)\n            retcode = 1\n        except Exception as exc:\n            result = 'An Exception occurred while executing {0}: {1}'.format(self.fun, exc)\n            log.error(result, exc_info_on_loglevel=logging.DEBUG)\n            retcode = 1\n        # Mimic the json data-structure that \"salt-call --local\" will\n        # emit (as seen in ssh_py_shim.py)\n        if isinstance(result, dict) and 'local' in result:\n            ret = salt.utils.json.dumps({'local': result['local']})\n        else:\n            ret = salt.utils.json.dumps({'local': {'return': result}})\n        return ret, retcode", "code_tokens": ["def", "run_wfunc", "(", "self", ")", ":", "# Ensure that opts/grains are up to date", "# Execute routine", "data_cache", "=", "False", "data", "=", "None", "cdir", "=", "os", ".", "path", ".", "join", "(", "self", ".", "opts", "[", "'cachedir'", "]", ",", "'minions'", ",", "self", ".", "id", ")", "if", "not", "os", ".", "path", ".", "isdir", "(", "cdir", ")", ":", "os", ".", "makedirs", "(", "cdir", ")", "datap", "=", "os", ".", "path", ".", "join", "(", "cdir", ",", "'ssh_data.p'", ")", "refresh", "=", "False", "if", "not", "os", ".", "path", ".", "isfile", "(", "datap", ")", ":", "refresh", "=", "True", "else", ":", "passed_time", "=", "(", "time", ".", "time", "(", ")", "-", "os", ".", "stat", "(", "datap", ")", ".", "st_mtime", ")", "/", "60", "if", "passed_time", ">", "self", ".", "opts", ".", "get", "(", "'cache_life'", ",", "60", ")", ":", "refresh", "=", "True", "if", "self", ".", "opts", ".", "get", "(", "'refresh_cache'", ")", ":", "refresh", "=", "True", "conf_grains", "=", "{", "}", "# Save conf file grains before they get clobbered", "if", "'ssh_grains'", "in", "self", ".", "opts", ":", "conf_grains", "=", "self", ".", "opts", "[", "'ssh_grains'", "]", "if", "not", "data_cache", ":", "refresh", "=", "True", "if", "refresh", ":", "# Make the datap", "# TODO: Auto expire the datap", "pre_wrapper", "=", "salt", ".", "client", ".", "ssh", ".", "wrapper", ".", "FunctionWrapper", "(", "self", ".", "opts", ",", "self", ".", "id", ",", "fsclient", "=", "self", ".", "fsclient", ",", "minion_opts", "=", "self", ".", "minion_opts", ",", "*", "*", "self", ".", "target", ")", "opts_pkg", "=", "pre_wrapper", "[", "'test.opts_pkg'", "]", "(", ")", "# pylint: disable=E1102", "if", "'_error'", "in", "opts_pkg", ":", "#Refresh failed", "retcode", "=", "opts_pkg", "[", "'retcode'", "]", "ret", "=", "salt", ".", "utils", ".", "json", ".", "dumps", "(", "{", "'local'", ":", "opts_pkg", "}", ")", "return", "ret", ",", "retcode", "opts_pkg", "[", "'file_roots'", "]", "=", "self", ".", "opts", "[", "'file_roots'", "]", "opts_pkg", "[", "'pillar_roots'", "]", "=", "self", ".", "opts", "[", "'pillar_roots'", "]", "opts_pkg", "[", "'ext_pillar'", "]", "=", "self", ".", "opts", "[", "'ext_pillar'", "]", "opts_pkg", "[", "'extension_modules'", "]", "=", "self", ".", "opts", "[", "'extension_modules'", "]", "opts_pkg", "[", "'module_dirs'", "]", "=", "self", ".", "opts", "[", "'module_dirs'", "]", "opts_pkg", "[", "'_ssh_version'", "]", "=", "self", ".", "opts", "[", "'_ssh_version'", "]", "opts_pkg", "[", "'__master_opts__'", "]", "=", "self", ".", "context", "[", "'master_opts'", "]", "if", "'known_hosts_file'", "in", "self", ".", "opts", ":", "opts_pkg", "[", "'known_hosts_file'", "]", "=", "self", ".", "opts", "[", "'known_hosts_file'", "]", "if", "'_caller_cachedir'", "in", "self", ".", "opts", ":", "opts_pkg", "[", "'_caller_cachedir'", "]", "=", "self", ".", "opts", "[", "'_caller_cachedir'", "]", "else", ":", "opts_pkg", "[", "'_caller_cachedir'", "]", "=", "self", ".", "opts", "[", "'cachedir'", "]", "# Use the ID defined in the roster file", "opts_pkg", "[", "'id'", "]", "=", "self", ".", "id", "retcode", "=", "0", "# Restore master grains", "for", "grain", "in", "conf_grains", ":", "opts_pkg", "[", "'grains'", "]", "[", "grain", "]", "=", "conf_grains", "[", "grain", "]", "# Enable roster grains support", "if", "'grains'", "in", "self", ".", "target", ":", "for", "grain", "in", "self", ".", "target", "[", "'grains'", "]", ":", "opts_pkg", "[", "'grains'", "]", "[", "grain", "]", "=", "self", ".", "target", "[", "'grains'", "]", "[", "grain", "]", "popts", "=", "{", "}", "popts", ".", "update", "(", "opts_pkg", ")", "# Master centric operations such as mine.get must have master option loaded.", "# The pillar must then be compiled by passing master opts found in opts_pkg['__master_opts__']", "# which causes the pillar renderer to loose track of salt master options", "#", "# Depending on popts merge order, it will overwrite some options found in opts_pkg['__master_opts__']", "master_centric_funcs", "=", "[", "\"pillar.items\"", ",", "\"mine.get\"", "]", "# Pillar compilation is a master centric operation.", "# Master options take precedence during Pillar compilation", "popts", ".", "update", "(", "opts_pkg", "[", "'__master_opts__'", "]", ")", "pillar", "=", "salt", ".", "pillar", ".", "Pillar", "(", "popts", ",", "opts_pkg", "[", "'grains'", "]", ",", "opts_pkg", "[", "'id'", "]", ",", "opts_pkg", ".", "get", "(", "'saltenv'", ",", "'base'", ")", ")", "pillar_data", "=", "pillar", ".", "compile_pillar", "(", ")", "# Once pillar has been compiled, restore priority of minion opts", "if", "self", ".", "fun", "not", "in", "master_centric_funcs", ":", "log", ".", "debug", "(", "'%s is a minion function'", ",", "self", ".", "fun", ")", "popts", ".", "update", "(", "opts_pkg", ")", "else", ":", "log", ".", "debug", "(", "'%s is a master function'", ",", "self", ".", "fun", ")", "# TODO: cache minion opts in datap in master.py", "data", "=", "{", "'opts'", ":", "opts_pkg", ",", "'grains'", ":", "opts_pkg", "[", "'grains'", "]", ",", "'pillar'", ":", "pillar_data", "}", "if", "data_cache", ":", "with", "salt", ".", "utils", ".", "files", ".", "fopen", "(", "datap", ",", "'w+b'", ")", "as", "fp_", ":", "fp_", ".", "write", "(", "self", ".", "serial", ".", "dumps", "(", "data", ")", ")", "if", "not", "data", "and", "data_cache", ":", "with", "salt", ".", "utils", ".", "files", ".", "fopen", "(", "datap", ",", "'rb'", ")", "as", "fp_", ":", "data", "=", "self", ".", "serial", ".", "load", "(", "fp_", ")", "opts", "=", "data", ".", "get", "(", "'opts'", ",", "{", "}", ")", "opts", "[", "'grains'", "]", "=", "data", ".", "get", "(", "'grains'", ")", "# Restore master grains", "for", "grain", "in", "conf_grains", ":", "opts", "[", "'grains'", "]", "[", "grain", "]", "=", "conf_grains", "[", "grain", "]", "# Enable roster grains support", "if", "'grains'", "in", "self", ".", "target", ":", "for", "grain", "in", "self", ".", "target", "[", "'grains'", "]", ":", "opts", "[", "'grains'", "]", "[", "grain", "]", "=", "self", ".", "target", "[", "'grains'", "]", "[", "grain", "]", "opts", "[", "'pillar'", "]", "=", "data", ".", "get", "(", "'pillar'", ")", "wrapper", "=", "salt", ".", "client", ".", "ssh", ".", "wrapper", ".", "FunctionWrapper", "(", "opts", ",", "self", ".", "id", ",", "fsclient", "=", "self", ".", "fsclient", ",", "minion_opts", "=", "self", ".", "minion_opts", ",", "*", "*", "self", ".", "target", ")", "self", ".", "wfuncs", "=", "salt", ".", "loader", ".", "ssh_wrapper", "(", "opts", ",", "wrapper", ",", "self", ".", "context", ")", "wrapper", ".", "wfuncs", "=", "self", ".", "wfuncs", "# We're running in the mine, need to fetch the arguments from the", "# roster, pillar, master config (in that order)", "if", "self", ".", "mine", ":", "mine_args", "=", "None", "mine_fun_data", "=", "None", "mine_fun", "=", "self", ".", "fun", "if", "self", ".", "mine_functions", "and", "self", ".", "fun", "in", "self", ".", "mine_functions", ":", "mine_fun_data", "=", "self", ".", "mine_functions", "[", "self", ".", "fun", "]", "elif", "opts", "[", "'pillar'", "]", "and", "self", ".", "fun", "in", "opts", "[", "'pillar'", "]", ".", "get", "(", "'mine_functions'", ",", "{", "}", ")", ":", "mine_fun_data", "=", "opts", "[", "'pillar'", "]", "[", "'mine_functions'", "]", "[", "self", ".", "fun", "]", "elif", "self", ".", "fun", "in", "self", ".", "context", "[", "'master_opts'", "]", ".", "get", "(", "'mine_functions'", ",", "{", "}", ")", ":", "mine_fun_data", "=", "self", ".", "context", "[", "'master_opts'", "]", "[", "'mine_functions'", "]", "[", "self", ".", "fun", "]", "if", "isinstance", "(", "mine_fun_data", ",", "dict", ")", ":", "mine_fun", "=", "mine_fun_data", ".", "pop", "(", "'mine_function'", ",", "mine_fun", ")", "mine_args", "=", "mine_fun_data", "elif", "isinstance", "(", "mine_fun_data", ",", "list", ")", ":", "for", "item", "in", "mine_fun_data", "[", ":", "]", ":", "if", "isinstance", "(", "item", ",", "dict", ")", "and", "'mine_function'", "in", "item", ":", "mine_fun", "=", "item", "[", "'mine_function'", "]", "mine_fun_data", ".", "pop", "(", "mine_fun_data", ".", "index", "(", "item", ")", ")", "mine_args", "=", "mine_fun_data", "else", ":", "mine_args", "=", "mine_fun_data", "# If we found mine_args, replace our command's args", "if", "isinstance", "(", "mine_args", ",", "dict", ")", ":", "self", ".", "args", "=", "[", "]", "self", ".", "kwargs", "=", "mine_args", "elif", "isinstance", "(", "mine_args", ",", "list", ")", ":", "self", ".", "args", "=", "mine_args", "self", ".", "kwargs", "=", "{", "}", "try", ":", "if", "self", ".", "mine", ":", "result", "=", "wrapper", "[", "mine_fun", "]", "(", "*", "self", ".", "args", ",", "*", "*", "self", ".", "kwargs", ")", "else", ":", "result", "=", "self", ".", "wfuncs", "[", "self", ".", "fun", "]", "(", "*", "self", ".", "args", ",", "*", "*", "self", ".", "kwargs", ")", "except", "TypeError", "as", "exc", ":", "result", "=", "'TypeError encountered executing {0}: {1}'", ".", "format", "(", "self", ".", "fun", ",", "exc", ")", "log", ".", "error", "(", "result", ",", "exc_info_on_loglevel", "=", "logging", ".", "DEBUG", ")", "retcode", "=", "1", "except", "Exception", "as", "exc", ":", "result", "=", "'An Exception occurred while executing {0}: {1}'", ".", "format", "(", "self", ".", "fun", ",", "exc", ")", "log", ".", "error", "(", "result", ",", "exc_info_on_loglevel", "=", "logging", ".", "DEBUG", ")", "retcode", "=", "1", "# Mimic the json data-structure that \"salt-call --local\" will", "# emit (as seen in ssh_py_shim.py)", "if", "isinstance", "(", "result", ",", "dict", ")", "and", "'local'", "in", "result", ":", "ret", "=", "salt", ".", "utils", ".", "json", ".", "dumps", "(", "{", "'local'", ":", "result", "[", "'local'", "]", "}", ")", "else", ":", "ret", "=", "salt", ".", "utils", ".", "json", ".", "dumps", "(", "{", "'local'", ":", "{", "'return'", ":", "result", "}", "}", ")", "return", "ret", ",", "retcode"], "docstring": "Execute a wrapper function\n\n        Returns tuple of (json_data, '')", "docstring_tokens": ["Execute", "a", "wrapper", "function"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/client/ssh/__init__.py#L1005-L1195", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/client/ssh/__init__.py", "func_name": "Single._cmd_str", "original_string": "def _cmd_str(self):\n        '''\n        Prepare the command string\n        '''\n        sudo = 'sudo' if self.target['sudo'] else ''\n        sudo_user = self.target['sudo_user']\n        if '_caller_cachedir' in self.opts:\n            cachedir = self.opts['_caller_cachedir']\n        else:\n            cachedir = self.opts['cachedir']\n        thin_code_digest, thin_sum = salt.utils.thin.thin_sum(cachedir, 'sha1')\n        debug = ''\n        if not self.opts.get('log_level'):\n            self.opts['log_level'] = 'info'\n        if salt.log.LOG_LEVELS['debug'] >= salt.log.LOG_LEVELS[self.opts.get('log_level', 'info')]:\n            debug = '1'\n        arg_str = '''\nOPTIONS.config = \\\n\"\"\"\n{config}\n\"\"\"\nOPTIONS.delimiter = '{delimeter}'\nOPTIONS.saltdir = '{saltdir}'\nOPTIONS.checksum = '{checksum}'\nOPTIONS.hashfunc = '{hashfunc}'\nOPTIONS.version = '{version}'\nOPTIONS.ext_mods = '{ext_mods}'\nOPTIONS.wipe = {wipe}\nOPTIONS.tty = {tty}\nOPTIONS.cmd_umask = {cmd_umask}\nOPTIONS.code_checksum = {code_checksum}\nARGS = {arguments}\\n'''.format(config=self.minion_config,\n                               delimeter=RSTR,\n                               saltdir=self.thin_dir,\n                               checksum=thin_sum,\n                               hashfunc='sha1',\n                               version=salt.version.__version__,\n                               ext_mods=self.mods.get('version', ''),\n                               wipe=self.wipe,\n                               tty=self.tty,\n                               cmd_umask=self.cmd_umask,\n                               code_checksum=thin_code_digest,\n                               arguments=self.argv)\n        py_code = SSH_PY_SHIM.replace('#%%OPTS', arg_str)\n        if six.PY2:\n            py_code_enc = py_code.encode('base64')\n        else:\n            py_code_enc = base64.encodebytes(py_code.encode('utf-8')).decode('utf-8')\n        if not self.winrm:\n            cmd = SSH_SH_SHIM.format(\n                DEBUG=debug,\n                SUDO=sudo,\n                SUDO_USER=sudo_user,\n                SSH_PY_CODE=py_code_enc,\n                HOST_PY_MAJOR=sys.version_info[0],\n            )\n        else:\n            cmd = saltwinshell.gen_shim(py_code_enc)\n\n        return cmd", "language": "python", "code": "def _cmd_str(self):\n        '''\n        Prepare the command string\n        '''\n        sudo = 'sudo' if self.target['sudo'] else ''\n        sudo_user = self.target['sudo_user']\n        if '_caller_cachedir' in self.opts:\n            cachedir = self.opts['_caller_cachedir']\n        else:\n            cachedir = self.opts['cachedir']\n        thin_code_digest, thin_sum = salt.utils.thin.thin_sum(cachedir, 'sha1')\n        debug = ''\n        if not self.opts.get('log_level'):\n            self.opts['log_level'] = 'info'\n        if salt.log.LOG_LEVELS['debug'] >= salt.log.LOG_LEVELS[self.opts.get('log_level', 'info')]:\n            debug = '1'\n        arg_str = '''\nOPTIONS.config = \\\n\"\"\"\n{config}\n\"\"\"\nOPTIONS.delimiter = '{delimeter}'\nOPTIONS.saltdir = '{saltdir}'\nOPTIONS.checksum = '{checksum}'\nOPTIONS.hashfunc = '{hashfunc}'\nOPTIONS.version = '{version}'\nOPTIONS.ext_mods = '{ext_mods}'\nOPTIONS.wipe = {wipe}\nOPTIONS.tty = {tty}\nOPTIONS.cmd_umask = {cmd_umask}\nOPTIONS.code_checksum = {code_checksum}\nARGS = {arguments}\\n'''.format(config=self.minion_config,\n                               delimeter=RSTR,\n                               saltdir=self.thin_dir,\n                               checksum=thin_sum,\n                               hashfunc='sha1',\n                               version=salt.version.__version__,\n                               ext_mods=self.mods.get('version', ''),\n                               wipe=self.wipe,\n                               tty=self.tty,\n                               cmd_umask=self.cmd_umask,\n                               code_checksum=thin_code_digest,\n                               arguments=self.argv)\n        py_code = SSH_PY_SHIM.replace('#%%OPTS', arg_str)\n        if six.PY2:\n            py_code_enc = py_code.encode('base64')\n        else:\n            py_code_enc = base64.encodebytes(py_code.encode('utf-8')).decode('utf-8')\n        if not self.winrm:\n            cmd = SSH_SH_SHIM.format(\n                DEBUG=debug,\n                SUDO=sudo,\n                SUDO_USER=sudo_user,\n                SSH_PY_CODE=py_code_enc,\n                HOST_PY_MAJOR=sys.version_info[0],\n            )\n        else:\n            cmd = saltwinshell.gen_shim(py_code_enc)\n\n        return cmd", "code_tokens": ["def", "_cmd_str", "(", "self", ")", ":", "sudo", "=", "'sudo'", "if", "self", ".", "target", "[", "'sudo'", "]", "else", "''", "sudo_user", "=", "self", ".", "target", "[", "'sudo_user'", "]", "if", "'_caller_cachedir'", "in", "self", ".", "opts", ":", "cachedir", "=", "self", ".", "opts", "[", "'_caller_cachedir'", "]", "else", ":", "cachedir", "=", "self", ".", "opts", "[", "'cachedir'", "]", "thin_code_digest", ",", "thin_sum", "=", "salt", ".", "utils", ".", "thin", ".", "thin_sum", "(", "cachedir", ",", "'sha1'", ")", "debug", "=", "''", "if", "not", "self", ".", "opts", ".", "get", "(", "'log_level'", ")", ":", "self", ".", "opts", "[", "'log_level'", "]", "=", "'info'", "if", "salt", ".", "log", ".", "LOG_LEVELS", "[", "'debug'", "]", ">=", "salt", ".", "log", ".", "LOG_LEVELS", "[", "self", ".", "opts", ".", "get", "(", "'log_level'", ",", "'info'", ")", "]", ":", "debug", "=", "'1'", "arg_str", "=", "'''\nOPTIONS.config = \\\n\"\"\"\n{config}\n\"\"\"\nOPTIONS.delimiter = '{delimeter}'\nOPTIONS.saltdir = '{saltdir}'\nOPTIONS.checksum = '{checksum}'\nOPTIONS.hashfunc = '{hashfunc}'\nOPTIONS.version = '{version}'\nOPTIONS.ext_mods = '{ext_mods}'\nOPTIONS.wipe = {wipe}\nOPTIONS.tty = {tty}\nOPTIONS.cmd_umask = {cmd_umask}\nOPTIONS.code_checksum = {code_checksum}\nARGS = {arguments}\\n'''", ".", "format", "(", "config", "=", "self", ".", "minion_config", ",", "delimeter", "=", "RSTR", ",", "saltdir", "=", "self", ".", "thin_dir", ",", "checksum", "=", "thin_sum", ",", "hashfunc", "=", "'sha1'", ",", "version", "=", "salt", ".", "version", ".", "__version__", ",", "ext_mods", "=", "self", ".", "mods", ".", "get", "(", "'version'", ",", "''", ")", ",", "wipe", "=", "self", ".", "wipe", ",", "tty", "=", "self", ".", "tty", ",", "cmd_umask", "=", "self", ".", "cmd_umask", ",", "code_checksum", "=", "thin_code_digest", ",", "arguments", "=", "self", ".", "argv", ")", "py_code", "=", "SSH_PY_SHIM", ".", "replace", "(", "'#%%OPTS'", ",", "arg_str", ")", "if", "six", ".", "PY2", ":", "py_code_enc", "=", "py_code", ".", "encode", "(", "'base64'", ")", "else", ":", "py_code_enc", "=", "base64", ".", "encodebytes", "(", "py_code", ".", "encode", "(", "'utf-8'", ")", ")", ".", "decode", "(", "'utf-8'", ")", "if", "not", "self", ".", "winrm", ":", "cmd", "=", "SSH_SH_SHIM", ".", "format", "(", "DEBUG", "=", "debug", ",", "SUDO", "=", "sudo", ",", "SUDO_USER", "=", "sudo_user", ",", "SSH_PY_CODE", "=", "py_code_enc", ",", "HOST_PY_MAJOR", "=", "sys", ".", "version_info", "[", "0", "]", ",", ")", "else", ":", "cmd", "=", "saltwinshell", ".", "gen_shim", "(", "py_code_enc", ")", "return", "cmd"], "docstring": "Prepare the command string", "docstring_tokens": ["Prepare", "the", "command", "string"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/client/ssh/__init__.py#L1197-L1256", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/client/ssh/__init__.py", "func_name": "Single.shim_cmd", "original_string": "def shim_cmd(self, cmd_str, extension='py'):\n        '''\n        Run a shim command.\n\n        If tty is enabled, we must scp the shim to the target system and\n        execute it there\n        '''\n        if not self.tty and not self.winrm:\n            return self.shell.exec_cmd(cmd_str)\n\n        # Write the shim to a temporary file in the default temp directory\n        with tempfile.NamedTemporaryFile(mode='w+b',\n                                         prefix='shim_',\n                                         delete=False) as shim_tmp_file:\n            shim_tmp_file.write(salt.utils.stringutils.to_bytes(cmd_str))\n\n        # Copy shim to target system, under $HOME/.<randomized name>\n        target_shim_file = '.{0}.{1}'.format(\n            binascii.hexlify(os.urandom(6)).decode('ascii'),\n            extension\n        )\n        if self.winrm:\n            target_shim_file = saltwinshell.get_target_shim_file(self, target_shim_file)\n        self.shell.send(shim_tmp_file.name, target_shim_file, makedirs=True)\n\n        # Remove our shim file\n        try:\n            os.remove(shim_tmp_file.name)\n        except IOError:\n            pass\n\n        # Execute shim\n        if extension == 'ps1':\n            ret = self.shell.exec_cmd('\"powershell {0}\"'.format(target_shim_file))\n        else:\n            if not self.winrm:\n                ret = self.shell.exec_cmd('/bin/sh \\'$HOME/{0}\\''.format(target_shim_file))\n            else:\n                ret = saltwinshell.call_python(self, target_shim_file)\n\n        # Remove shim from target system\n        if not self.winrm:\n            self.shell.exec_cmd('rm \\'$HOME/{0}\\''.format(target_shim_file))\n        else:\n            self.shell.exec_cmd('del {0}'.format(target_shim_file))\n\n        return ret", "language": "python", "code": "def shim_cmd(self, cmd_str, extension='py'):\n        '''\n        Run a shim command.\n\n        If tty is enabled, we must scp the shim to the target system and\n        execute it there\n        '''\n        if not self.tty and not self.winrm:\n            return self.shell.exec_cmd(cmd_str)\n\n        # Write the shim to a temporary file in the default temp directory\n        with tempfile.NamedTemporaryFile(mode='w+b',\n                                         prefix='shim_',\n                                         delete=False) as shim_tmp_file:\n            shim_tmp_file.write(salt.utils.stringutils.to_bytes(cmd_str))\n\n        # Copy shim to target system, under $HOME/.<randomized name>\n        target_shim_file = '.{0}.{1}'.format(\n            binascii.hexlify(os.urandom(6)).decode('ascii'),\n            extension\n        )\n        if self.winrm:\n            target_shim_file = saltwinshell.get_target_shim_file(self, target_shim_file)\n        self.shell.send(shim_tmp_file.name, target_shim_file, makedirs=True)\n\n        # Remove our shim file\n        try:\n            os.remove(shim_tmp_file.name)\n        except IOError:\n            pass\n\n        # Execute shim\n        if extension == 'ps1':\n            ret = self.shell.exec_cmd('\"powershell {0}\"'.format(target_shim_file))\n        else:\n            if not self.winrm:\n                ret = self.shell.exec_cmd('/bin/sh \\'$HOME/{0}\\''.format(target_shim_file))\n            else:\n                ret = saltwinshell.call_python(self, target_shim_file)\n\n        # Remove shim from target system\n        if not self.winrm:\n            self.shell.exec_cmd('rm \\'$HOME/{0}\\''.format(target_shim_file))\n        else:\n            self.shell.exec_cmd('del {0}'.format(target_shim_file))\n\n        return ret", "code_tokens": ["def", "shim_cmd", "(", "self", ",", "cmd_str", ",", "extension", "=", "'py'", ")", ":", "if", "not", "self", ".", "tty", "and", "not", "self", ".", "winrm", ":", "return", "self", ".", "shell", ".", "exec_cmd", "(", "cmd_str", ")", "# Write the shim to a temporary file in the default temp directory", "with", "tempfile", ".", "NamedTemporaryFile", "(", "mode", "=", "'w+b'", ",", "prefix", "=", "'shim_'", ",", "delete", "=", "False", ")", "as", "shim_tmp_file", ":", "shim_tmp_file", ".", "write", "(", "salt", ".", "utils", ".", "stringutils", ".", "to_bytes", "(", "cmd_str", ")", ")", "# Copy shim to target system, under $HOME/.<randomized name>", "target_shim_file", "=", "'.{0}.{1}'", ".", "format", "(", "binascii", ".", "hexlify", "(", "os", ".", "urandom", "(", "6", ")", ")", ".", "decode", "(", "'ascii'", ")", ",", "extension", ")", "if", "self", ".", "winrm", ":", "target_shim_file", "=", "saltwinshell", ".", "get_target_shim_file", "(", "self", ",", "target_shim_file", ")", "self", ".", "shell", ".", "send", "(", "shim_tmp_file", ".", "name", ",", "target_shim_file", ",", "makedirs", "=", "True", ")", "# Remove our shim file", "try", ":", "os", ".", "remove", "(", "shim_tmp_file", ".", "name", ")", "except", "IOError", ":", "pass", "# Execute shim", "if", "extension", "==", "'ps1'", ":", "ret", "=", "self", ".", "shell", ".", "exec_cmd", "(", "'\"powershell {0}\"'", ".", "format", "(", "target_shim_file", ")", ")", "else", ":", "if", "not", "self", ".", "winrm", ":", "ret", "=", "self", ".", "shell", ".", "exec_cmd", "(", "'/bin/sh \\'$HOME/{0}\\''", ".", "format", "(", "target_shim_file", ")", ")", "else", ":", "ret", "=", "saltwinshell", ".", "call_python", "(", "self", ",", "target_shim_file", ")", "# Remove shim from target system", "if", "not", "self", ".", "winrm", ":", "self", ".", "shell", ".", "exec_cmd", "(", "'rm \\'$HOME/{0}\\''", ".", "format", "(", "target_shim_file", ")", ")", "else", ":", "self", ".", "shell", ".", "exec_cmd", "(", "'del {0}'", ".", "format", "(", "target_shim_file", ")", ")", "return", "ret"], "docstring": "Run a shim command.\n\n        If tty is enabled, we must scp the shim to the target system and\n        execute it there", "docstring_tokens": ["Run", "a", "shim", "command", "."], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/client/ssh/__init__.py#L1258-L1304", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/client/ssh/__init__.py", "func_name": "Single.cmd_block", "original_string": "def cmd_block(self, is_retry=False):\n        '''\n        Prepare the pre-check command to send to the subsystem\n\n        1. execute SHIM + command\n        2. check if SHIM returns a master request or if it completed\n        3. handle any master request\n        4. re-execute SHIM + command\n        5. split SHIM results from command results\n        6. return command results\n        '''\n        self.argv = _convert_args(self.argv)\n        log.debug(\n            'Performing shimmed, blocking command as follows:\\n%s',\n            ' '.join([six.text_type(arg) for arg in self.argv])\n        )\n        cmd_str = self._cmd_str()\n        stdout, stderr, retcode = self.shim_cmd(cmd_str)\n\n        log.trace('STDOUT %s\\n%s', self.target['host'], stdout)\n        log.trace('STDERR %s\\n%s', self.target['host'], stderr)\n        log.debug('RETCODE %s: %s', self.target['host'], retcode)\n\n        error = self.categorize_shim_errors(stdout, stderr, retcode)\n        if error:\n            if error == 'Python environment not found on Windows system':\n                saltwinshell.deploy_python(self)\n                stdout, stderr, retcode = self.shim_cmd(cmd_str)\n                while re.search(RSTR_RE, stdout):\n                    stdout = re.split(RSTR_RE, stdout, 1)[1].strip()\n                while re.search(RSTR_RE, stderr):\n                    stderr = re.split(RSTR_RE, stderr, 1)[1].strip()\n            elif error == 'Undefined SHIM state':\n                self.deploy()\n                stdout, stderr, retcode = self.shim_cmd(cmd_str)\n                if not re.search(RSTR_RE, stdout) or not re.search(RSTR_RE, stderr):\n                    # If RSTR is not seen in both stdout and stderr then there\n                    # was a thin deployment problem.\n                    return 'ERROR: Failure deploying thin, undefined state: {0}'.format(stdout), stderr, retcode\n                while re.search(RSTR_RE, stdout):\n                    stdout = re.split(RSTR_RE, stdout, 1)[1].strip()\n                while re.search(RSTR_RE, stderr):\n                    stderr = re.split(RSTR_RE, stderr, 1)[1].strip()\n            else:\n                return 'ERROR: {0}'.format(error), stderr, retcode\n\n        # FIXME: this discards output from ssh_shim if the shim succeeds.  It should\n        # always save the shim output regardless of shim success or failure.\n        while re.search(RSTR_RE, stdout):\n            stdout = re.split(RSTR_RE, stdout, 1)[1].strip()\n\n        if re.search(RSTR_RE, stderr):\n            # Found RSTR in stderr which means SHIM completed and only\n            # and remaining output is only from salt.\n            while re.search(RSTR_RE, stderr):\n                stderr = re.split(RSTR_RE, stderr, 1)[1].strip()\n\n        else:\n            # RSTR was found in stdout but not stderr - which means there\n            # is a SHIM command for the master.\n            shim_command = re.split(r'\\r?\\n', stdout, 1)[0].strip()\n            log.debug('SHIM retcode(%s) and command: %s', retcode, shim_command)\n            if 'deploy' == shim_command and retcode == salt.defaults.exitcodes.EX_THIN_DEPLOY:\n                self.deploy()\n                stdout, stderr, retcode = self.shim_cmd(cmd_str)\n                if not re.search(RSTR_RE, stdout) or not re.search(RSTR_RE, stderr):\n                    if not self.tty:\n                        # If RSTR is not seen in both stdout and stderr then there\n                        # was a thin deployment problem.\n                        log.error(\n                            'ERROR: Failure deploying thin, retrying:\\n'\n                            'STDOUT:\\n%s\\nSTDERR:\\n%s\\nRETCODE: %s',\n                            stdout, stderr, retcode\n                        )\n                        return self.cmd_block()\n                    elif not re.search(RSTR_RE, stdout):\n                        # If RSTR is not seen in stdout with tty, then there\n                        # was a thin deployment problem.\n                        log.error(\n                            'ERROR: Failure deploying thin, retrying:\\n'\n                            'STDOUT:\\n%s\\nSTDERR:\\n%s\\nRETCODE: %s',\n                            stdout, stderr, retcode\n                        )\n                while re.search(RSTR_RE, stdout):\n                    stdout = re.split(RSTR_RE, stdout, 1)[1].strip()\n                if self.tty:\n                    stderr = ''\n                else:\n                    while re.search(RSTR_RE, stderr):\n                        stderr = re.split(RSTR_RE, stderr, 1)[1].strip()\n            elif 'ext_mods' == shim_command:\n                self.deploy_ext()\n                stdout, stderr, retcode = self.shim_cmd(cmd_str)\n                if not re.search(RSTR_RE, stdout) or not re.search(RSTR_RE, stderr):\n                    # If RSTR is not seen in both stdout and stderr then there\n                    # was a thin deployment problem.\n                    return 'ERROR: Failure deploying ext_mods: {0}'.format(stdout), stderr, retcode\n                while re.search(RSTR_RE, stdout):\n                    stdout = re.split(RSTR_RE, stdout, 1)[1].strip()\n                while re.search(RSTR_RE, stderr):\n                    stderr = re.split(RSTR_RE, stderr, 1)[1].strip()\n\n        return stdout, stderr, retcode", "language": "python", "code": "def cmd_block(self, is_retry=False):\n        '''\n        Prepare the pre-check command to send to the subsystem\n\n        1. execute SHIM + command\n        2. check if SHIM returns a master request or if it completed\n        3. handle any master request\n        4. re-execute SHIM + command\n        5. split SHIM results from command results\n        6. return command results\n        '''\n        self.argv = _convert_args(self.argv)\n        log.debug(\n            'Performing shimmed, blocking command as follows:\\n%s',\n            ' '.join([six.text_type(arg) for arg in self.argv])\n        )\n        cmd_str = self._cmd_str()\n        stdout, stderr, retcode = self.shim_cmd(cmd_str)\n\n        log.trace('STDOUT %s\\n%s', self.target['host'], stdout)\n        log.trace('STDERR %s\\n%s', self.target['host'], stderr)\n        log.debug('RETCODE %s: %s', self.target['host'], retcode)\n\n        error = self.categorize_shim_errors(stdout, stderr, retcode)\n        if error:\n            if error == 'Python environment not found on Windows system':\n                saltwinshell.deploy_python(self)\n                stdout, stderr, retcode = self.shim_cmd(cmd_str)\n                while re.search(RSTR_RE, stdout):\n                    stdout = re.split(RSTR_RE, stdout, 1)[1].strip()\n                while re.search(RSTR_RE, stderr):\n                    stderr = re.split(RSTR_RE, stderr, 1)[1].strip()\n            elif error == 'Undefined SHIM state':\n                self.deploy()\n                stdout, stderr, retcode = self.shim_cmd(cmd_str)\n                if not re.search(RSTR_RE, stdout) or not re.search(RSTR_RE, stderr):\n                    # If RSTR is not seen in both stdout and stderr then there\n                    # was a thin deployment problem.\n                    return 'ERROR: Failure deploying thin, undefined state: {0}'.format(stdout), stderr, retcode\n                while re.search(RSTR_RE, stdout):\n                    stdout = re.split(RSTR_RE, stdout, 1)[1].strip()\n                while re.search(RSTR_RE, stderr):\n                    stderr = re.split(RSTR_RE, stderr, 1)[1].strip()\n            else:\n                return 'ERROR: {0}'.format(error), stderr, retcode\n\n        # FIXME: this discards output from ssh_shim if the shim succeeds.  It should\n        # always save the shim output regardless of shim success or failure.\n        while re.search(RSTR_RE, stdout):\n            stdout = re.split(RSTR_RE, stdout, 1)[1].strip()\n\n        if re.search(RSTR_RE, stderr):\n            # Found RSTR in stderr which means SHIM completed and only\n            # and remaining output is only from salt.\n            while re.search(RSTR_RE, stderr):\n                stderr = re.split(RSTR_RE, stderr, 1)[1].strip()\n\n        else:\n            # RSTR was found in stdout but not stderr - which means there\n            # is a SHIM command for the master.\n            shim_command = re.split(r'\\r?\\n', stdout, 1)[0].strip()\n            log.debug('SHIM retcode(%s) and command: %s', retcode, shim_command)\n            if 'deploy' == shim_command and retcode == salt.defaults.exitcodes.EX_THIN_DEPLOY:\n                self.deploy()\n                stdout, stderr, retcode = self.shim_cmd(cmd_str)\n                if not re.search(RSTR_RE, stdout) or not re.search(RSTR_RE, stderr):\n                    if not self.tty:\n                        # If RSTR is not seen in both stdout and stderr then there\n                        # was a thin deployment problem.\n                        log.error(\n                            'ERROR: Failure deploying thin, retrying:\\n'\n                            'STDOUT:\\n%s\\nSTDERR:\\n%s\\nRETCODE: %s',\n                            stdout, stderr, retcode\n                        )\n                        return self.cmd_block()\n                    elif not re.search(RSTR_RE, stdout):\n                        # If RSTR is not seen in stdout with tty, then there\n                        # was a thin deployment problem.\n                        log.error(\n                            'ERROR: Failure deploying thin, retrying:\\n'\n                            'STDOUT:\\n%s\\nSTDERR:\\n%s\\nRETCODE: %s',\n                            stdout, stderr, retcode\n                        )\n                while re.search(RSTR_RE, stdout):\n                    stdout = re.split(RSTR_RE, stdout, 1)[1].strip()\n                if self.tty:\n                    stderr = ''\n                else:\n                    while re.search(RSTR_RE, stderr):\n                        stderr = re.split(RSTR_RE, stderr, 1)[1].strip()\n            elif 'ext_mods' == shim_command:\n                self.deploy_ext()\n                stdout, stderr, retcode = self.shim_cmd(cmd_str)\n                if not re.search(RSTR_RE, stdout) or not re.search(RSTR_RE, stderr):\n                    # If RSTR is not seen in both stdout and stderr then there\n                    # was a thin deployment problem.\n                    return 'ERROR: Failure deploying ext_mods: {0}'.format(stdout), stderr, retcode\n                while re.search(RSTR_RE, stdout):\n                    stdout = re.split(RSTR_RE, stdout, 1)[1].strip()\n                while re.search(RSTR_RE, stderr):\n                    stderr = re.split(RSTR_RE, stderr, 1)[1].strip()\n\n        return stdout, stderr, retcode", "code_tokens": ["def", "cmd_block", "(", "self", ",", "is_retry", "=", "False", ")", ":", "self", ".", "argv", "=", "_convert_args", "(", "self", ".", "argv", ")", "log", ".", "debug", "(", "'Performing shimmed, blocking command as follows:\\n%s'", ",", "' '", ".", "join", "(", "[", "six", ".", "text_type", "(", "arg", ")", "for", "arg", "in", "self", ".", "argv", "]", ")", ")", "cmd_str", "=", "self", ".", "_cmd_str", "(", ")", "stdout", ",", "stderr", ",", "retcode", "=", "self", ".", "shim_cmd", "(", "cmd_str", ")", "log", ".", "trace", "(", "'STDOUT %s\\n%s'", ",", "self", ".", "target", "[", "'host'", "]", ",", "stdout", ")", "log", ".", "trace", "(", "'STDERR %s\\n%s'", ",", "self", ".", "target", "[", "'host'", "]", ",", "stderr", ")", "log", ".", "debug", "(", "'RETCODE %s: %s'", ",", "self", ".", "target", "[", "'host'", "]", ",", "retcode", ")", "error", "=", "self", ".", "categorize_shim_errors", "(", "stdout", ",", "stderr", ",", "retcode", ")", "if", "error", ":", "if", "error", "==", "'Python environment not found on Windows system'", ":", "saltwinshell", ".", "deploy_python", "(", "self", ")", "stdout", ",", "stderr", ",", "retcode", "=", "self", ".", "shim_cmd", "(", "cmd_str", ")", "while", "re", ".", "search", "(", "RSTR_RE", ",", "stdout", ")", ":", "stdout", "=", "re", ".", "split", "(", "RSTR_RE", ",", "stdout", ",", "1", ")", "[", "1", "]", ".", "strip", "(", ")", "while", "re", ".", "search", "(", "RSTR_RE", ",", "stderr", ")", ":", "stderr", "=", "re", ".", "split", "(", "RSTR_RE", ",", "stderr", ",", "1", ")", "[", "1", "]", ".", "strip", "(", ")", "elif", "error", "==", "'Undefined SHIM state'", ":", "self", ".", "deploy", "(", ")", "stdout", ",", "stderr", ",", "retcode", "=", "self", ".", "shim_cmd", "(", "cmd_str", ")", "if", "not", "re", ".", "search", "(", "RSTR_RE", ",", "stdout", ")", "or", "not", "re", ".", "search", "(", "RSTR_RE", ",", "stderr", ")", ":", "# If RSTR is not seen in both stdout and stderr then there", "# was a thin deployment problem.", "return", "'ERROR: Failure deploying thin, undefined state: {0}'", ".", "format", "(", "stdout", ")", ",", "stderr", ",", "retcode", "while", "re", ".", "search", "(", "RSTR_RE", ",", "stdout", ")", ":", "stdout", "=", "re", ".", "split", "(", "RSTR_RE", ",", "stdout", ",", "1", ")", "[", "1", "]", ".", "strip", "(", ")", "while", "re", ".", "search", "(", "RSTR_RE", ",", "stderr", ")", ":", "stderr", "=", "re", ".", "split", "(", "RSTR_RE", ",", "stderr", ",", "1", ")", "[", "1", "]", ".", "strip", "(", ")", "else", ":", "return", "'ERROR: {0}'", ".", "format", "(", "error", ")", ",", "stderr", ",", "retcode", "# FIXME: this discards output from ssh_shim if the shim succeeds.  It should", "# always save the shim output regardless of shim success or failure.", "while", "re", ".", "search", "(", "RSTR_RE", ",", "stdout", ")", ":", "stdout", "=", "re", ".", "split", "(", "RSTR_RE", ",", "stdout", ",", "1", ")", "[", "1", "]", ".", "strip", "(", ")", "if", "re", ".", "search", "(", "RSTR_RE", ",", "stderr", ")", ":", "# Found RSTR in stderr which means SHIM completed and only", "# and remaining output is only from salt.", "while", "re", ".", "search", "(", "RSTR_RE", ",", "stderr", ")", ":", "stderr", "=", "re", ".", "split", "(", "RSTR_RE", ",", "stderr", ",", "1", ")", "[", "1", "]", ".", "strip", "(", ")", "else", ":", "# RSTR was found in stdout but not stderr - which means there", "# is a SHIM command for the master.", "shim_command", "=", "re", ".", "split", "(", "r'\\r?\\n'", ",", "stdout", ",", "1", ")", "[", "0", "]", ".", "strip", "(", ")", "log", ".", "debug", "(", "'SHIM retcode(%s) and command: %s'", ",", "retcode", ",", "shim_command", ")", "if", "'deploy'", "==", "shim_command", "and", "retcode", "==", "salt", ".", "defaults", ".", "exitcodes", ".", "EX_THIN_DEPLOY", ":", "self", ".", "deploy", "(", ")", "stdout", ",", "stderr", ",", "retcode", "=", "self", ".", "shim_cmd", "(", "cmd_str", ")", "if", "not", "re", ".", "search", "(", "RSTR_RE", ",", "stdout", ")", "or", "not", "re", ".", "search", "(", "RSTR_RE", ",", "stderr", ")", ":", "if", "not", "self", ".", "tty", ":", "# If RSTR is not seen in both stdout and stderr then there", "# was a thin deployment problem.", "log", ".", "error", "(", "'ERROR: Failure deploying thin, retrying:\\n'", "'STDOUT:\\n%s\\nSTDERR:\\n%s\\nRETCODE: %s'", ",", "stdout", ",", "stderr", ",", "retcode", ")", "return", "self", ".", "cmd_block", "(", ")", "elif", "not", "re", ".", "search", "(", "RSTR_RE", ",", "stdout", ")", ":", "# If RSTR is not seen in stdout with tty, then there", "# was a thin deployment problem.", "log", ".", "error", "(", "'ERROR: Failure deploying thin, retrying:\\n'", "'STDOUT:\\n%s\\nSTDERR:\\n%s\\nRETCODE: %s'", ",", "stdout", ",", "stderr", ",", "retcode", ")", "while", "re", ".", "search", "(", "RSTR_RE", ",", "stdout", ")", ":", "stdout", "=", "re", ".", "split", "(", "RSTR_RE", ",", "stdout", ",", "1", ")", "[", "1", "]", ".", "strip", "(", ")", "if", "self", ".", "tty", ":", "stderr", "=", "''", "else", ":", "while", "re", ".", "search", "(", "RSTR_RE", ",", "stderr", ")", ":", "stderr", "=", "re", ".", "split", "(", "RSTR_RE", ",", "stderr", ",", "1", ")", "[", "1", "]", ".", "strip", "(", ")", "elif", "'ext_mods'", "==", "shim_command", ":", "self", ".", "deploy_ext", "(", ")", "stdout", ",", "stderr", ",", "retcode", "=", "self", ".", "shim_cmd", "(", "cmd_str", ")", "if", "not", "re", ".", "search", "(", "RSTR_RE", ",", "stdout", ")", "or", "not", "re", ".", "search", "(", "RSTR_RE", ",", "stderr", ")", ":", "# If RSTR is not seen in both stdout and stderr then there", "# was a thin deployment problem.", "return", "'ERROR: Failure deploying ext_mods: {0}'", ".", "format", "(", "stdout", ")", ",", "stderr", ",", "retcode", "while", "re", ".", "search", "(", "RSTR_RE", ",", "stdout", ")", ":", "stdout", "=", "re", ".", "split", "(", "RSTR_RE", ",", "stdout", ",", "1", ")", "[", "1", "]", ".", "strip", "(", ")", "while", "re", ".", "search", "(", "RSTR_RE", ",", "stderr", ")", ":", "stderr", "=", "re", ".", "split", "(", "RSTR_RE", ",", "stderr", ",", "1", ")", "[", "1", "]", ".", "strip", "(", ")", "return", "stdout", ",", "stderr", ",", "retcode"], "docstring": "Prepare the pre-check command to send to the subsystem\n\n        1. execute SHIM + command\n        2. check if SHIM returns a master request or if it completed\n        3. handle any master request\n        4. re-execute SHIM + command\n        5. split SHIM results from command results\n        6. return command results", "docstring_tokens": ["Prepare", "the", "pre", "-", "check", "command", "to", "send", "to", "the", "subsystem"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/client/ssh/__init__.py#L1306-L1408", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/returners/highstate_return.py", "func_name": "_lookup_style", "original_string": "def _lookup_style(element, names):\n    '''\n    Lookup style by either element name or the list of classes\n    '''\n    return _STYLES.get('_'+element, '') + \\\n        ''.join([_STYLES.get(name, '') for name in names])", "language": "python", "code": "def _lookup_style(element, names):\n    '''\n    Lookup style by either element name or the list of classes\n    '''\n    return _STYLES.get('_'+element, '') + \\\n        ''.join([_STYLES.get(name, '') for name in names])", "code_tokens": ["def", "_lookup_style", "(", "element", ",", "names", ")", ":", "return", "_STYLES", ".", "get", "(", "'_'", "+", "element", ",", "''", ")", "+", "''", ".", "join", "(", "[", "_STYLES", ".", "get", "(", "name", ",", "''", ")", "for", "name", "in", "names", "]", ")"], "docstring": "Lookup style by either element name or the list of classes", "docstring_tokens": ["Lookup", "style", "by", "either", "element", "name", "or", "the", "list", "of", "classes"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/returners/highstate_return.py#L168-L173", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/returners/highstate_return.py", "func_name": "_generate_html_table", "original_string": "def _generate_html_table(data, out, level=0, extra_style=''):\n    '''\n    Generate a single table of data\n    '''\n    print('<table style=\"{0}\">'.format(\n        _lookup_style('table', ['table' + six.text_type(level)])), file=out)\n\n    firstone = True\n\n    row_style = 'row' + six.text_type(level)\n    cell_style = 'cell' + six.text_type(level)\n\n    for subdata in data:\n        first_style = 'first_first' if firstone else 'notfirst_first'\n        second_style = 'first' if firstone else 'other'\n\n        if isinstance(subdata, dict):\n            if '__style__' in subdata:\n                new_extra_style = subdata['__style__']\n                del subdata['__style__']\n            else:\n                new_extra_style = extra_style\n            if len(subdata) == 1:\n                name, value = next(six.iteritems(subdata))\n                print('<tr style=\"{0}\">'.format(\n                    _lookup_style('tr', [row_style])\n                ), file=out)\n                print('<td style=\"{0}\">{1}</td>'.format(\n                    _lookup_style(\n                        'td',\n                        [cell_style, first_style, 'name', new_extra_style]\n                    ),\n                    name\n                ), file=out)\n                if isinstance(value, list):\n                    print('<td style=\"{0}\">'.format(\n                        _lookup_style(\n                            'td',\n                            [\n                                cell_style,\n                                second_style,\n                                'container',\n                                new_extra_style\n                            ]\n                        )\n                    ), file=out)\n                    _generate_html_table(\n                        value,\n                        out,\n                        level + 1,\n                        new_extra_style\n                    )\n                    print('</td>', file=out)\n                else:\n                    print('<td style=\"{0}\">{1}</td>'.format(\n                        _lookup_style(\n                            'td',\n                            [\n                                cell_style,\n                                second_style,\n                                'value',\n                                new_extra_style\n                            ]\n                        ),\n                        cgi.escape(six.text_type(value))\n                    ), file=out)\n                print('</tr>', file=out)\n        elif isinstance(subdata, list):\n            print('<tr style=\"{0}\">'.format(\n                _lookup_style('tr', [row_style])\n            ), file=out)\n            print('<td style=\"{0}\">'.format(\n                _lookup_style(\n                    'td',\n                    [cell_style, first_style, 'container', extra_style]\n                )\n            ), file=out)\n            _generate_html_table(subdata, out, level + 1, extra_style)\n            print('</td>', file=out)\n            print('</tr>', file=out)\n        else:\n            print('<tr style=\"{0}\">'.format(\n                _lookup_style('tr', [row_style])\n            ), file=out)\n            print('<td style=\"{0}\">{1}</td>'.format(\n                _lookup_style(\n                    'td',\n                    [cell_style, first_style, 'value', extra_style]\n                ),\n                cgi.escape(six.text_type(subdata))\n            ), file=out)\n            print('</tr>', file=out)\n        firstone = False\n    print('</table>', file=out)", "language": "python", "code": "def _generate_html_table(data, out, level=0, extra_style=''):\n    '''\n    Generate a single table of data\n    '''\n    print('<table style=\"{0}\">'.format(\n        _lookup_style('table', ['table' + six.text_type(level)])), file=out)\n\n    firstone = True\n\n    row_style = 'row' + six.text_type(level)\n    cell_style = 'cell' + six.text_type(level)\n\n    for subdata in data:\n        first_style = 'first_first' if firstone else 'notfirst_first'\n        second_style = 'first' if firstone else 'other'\n\n        if isinstance(subdata, dict):\n            if '__style__' in subdata:\n                new_extra_style = subdata['__style__']\n                del subdata['__style__']\n            else:\n                new_extra_style = extra_style\n            if len(subdata) == 1:\n                name, value = next(six.iteritems(subdata))\n                print('<tr style=\"{0}\">'.format(\n                    _lookup_style('tr', [row_style])\n                ), file=out)\n                print('<td style=\"{0}\">{1}</td>'.format(\n                    _lookup_style(\n                        'td',\n                        [cell_style, first_style, 'name', new_extra_style]\n                    ),\n                    name\n                ), file=out)\n                if isinstance(value, list):\n                    print('<td style=\"{0}\">'.format(\n                        _lookup_style(\n                            'td',\n                            [\n                                cell_style,\n                                second_style,\n                                'container',\n                                new_extra_style\n                            ]\n                        )\n                    ), file=out)\n                    _generate_html_table(\n                        value,\n                        out,\n                        level + 1,\n                        new_extra_style\n                    )\n                    print('</td>', file=out)\n                else:\n                    print('<td style=\"{0}\">{1}</td>'.format(\n                        _lookup_style(\n                            'td',\n                            [\n                                cell_style,\n                                second_style,\n                                'value',\n                                new_extra_style\n                            ]\n                        ),\n                        cgi.escape(six.text_type(value))\n                    ), file=out)\n                print('</tr>', file=out)\n        elif isinstance(subdata, list):\n            print('<tr style=\"{0}\">'.format(\n                _lookup_style('tr', [row_style])\n            ), file=out)\n            print('<td style=\"{0}\">'.format(\n                _lookup_style(\n                    'td',\n                    [cell_style, first_style, 'container', extra_style]\n                )\n            ), file=out)\n            _generate_html_table(subdata, out, level + 1, extra_style)\n            print('</td>', file=out)\n            print('</tr>', file=out)\n        else:\n            print('<tr style=\"{0}\">'.format(\n                _lookup_style('tr', [row_style])\n            ), file=out)\n            print('<td style=\"{0}\">{1}</td>'.format(\n                _lookup_style(\n                    'td',\n                    [cell_style, first_style, 'value', extra_style]\n                ),\n                cgi.escape(six.text_type(subdata))\n            ), file=out)\n            print('</tr>', file=out)\n        firstone = False\n    print('</table>', file=out)", "code_tokens": ["def", "_generate_html_table", "(", "data", ",", "out", ",", "level", "=", "0", ",", "extra_style", "=", "''", ")", ":", "print", "(", "'<table style=\"{0}\">'", ".", "format", "(", "_lookup_style", "(", "'table'", ",", "[", "'table'", "+", "six", ".", "text_type", "(", "level", ")", "]", ")", ")", ",", "file", "=", "out", ")", "firstone", "=", "True", "row_style", "=", "'row'", "+", "six", ".", "text_type", "(", "level", ")", "cell_style", "=", "'cell'", "+", "six", ".", "text_type", "(", "level", ")", "for", "subdata", "in", "data", ":", "first_style", "=", "'first_first'", "if", "firstone", "else", "'notfirst_first'", "second_style", "=", "'first'", "if", "firstone", "else", "'other'", "if", "isinstance", "(", "subdata", ",", "dict", ")", ":", "if", "'__style__'", "in", "subdata", ":", "new_extra_style", "=", "subdata", "[", "'__style__'", "]", "del", "subdata", "[", "'__style__'", "]", "else", ":", "new_extra_style", "=", "extra_style", "if", "len", "(", "subdata", ")", "==", "1", ":", "name", ",", "value", "=", "next", "(", "six", ".", "iteritems", "(", "subdata", ")", ")", "print", "(", "'<tr style=\"{0}\">'", ".", "format", "(", "_lookup_style", "(", "'tr'", ",", "[", "row_style", "]", ")", ")", ",", "file", "=", "out", ")", "print", "(", "'<td style=\"{0}\">{1}</td>'", ".", "format", "(", "_lookup_style", "(", "'td'", ",", "[", "cell_style", ",", "first_style", ",", "'name'", ",", "new_extra_style", "]", ")", ",", "name", ")", ",", "file", "=", "out", ")", "if", "isinstance", "(", "value", ",", "list", ")", ":", "print", "(", "'<td style=\"{0}\">'", ".", "format", "(", "_lookup_style", "(", "'td'", ",", "[", "cell_style", ",", "second_style", ",", "'container'", ",", "new_extra_style", "]", ")", ")", ",", "file", "=", "out", ")", "_generate_html_table", "(", "value", ",", "out", ",", "level", "+", "1", ",", "new_extra_style", ")", "print", "(", "'</td>'", ",", "file", "=", "out", ")", "else", ":", "print", "(", "'<td style=\"{0}\">{1}</td>'", ".", "format", "(", "_lookup_style", "(", "'td'", ",", "[", "cell_style", ",", "second_style", ",", "'value'", ",", "new_extra_style", "]", ")", ",", "cgi", ".", "escape", "(", "six", ".", "text_type", "(", "value", ")", ")", ")", ",", "file", "=", "out", ")", "print", "(", "'</tr>'", ",", "file", "=", "out", ")", "elif", "isinstance", "(", "subdata", ",", "list", ")", ":", "print", "(", "'<tr style=\"{0}\">'", ".", "format", "(", "_lookup_style", "(", "'tr'", ",", "[", "row_style", "]", ")", ")", ",", "file", "=", "out", ")", "print", "(", "'<td style=\"{0}\">'", ".", "format", "(", "_lookup_style", "(", "'td'", ",", "[", "cell_style", ",", "first_style", ",", "'container'", ",", "extra_style", "]", ")", ")", ",", "file", "=", "out", ")", "_generate_html_table", "(", "subdata", ",", "out", ",", "level", "+", "1", ",", "extra_style", ")", "print", "(", "'</td>'", ",", "file", "=", "out", ")", "print", "(", "'</tr>'", ",", "file", "=", "out", ")", "else", ":", "print", "(", "'<tr style=\"{0}\">'", ".", "format", "(", "_lookup_style", "(", "'tr'", ",", "[", "row_style", "]", ")", ")", ",", "file", "=", "out", ")", "print", "(", "'<td style=\"{0}\">{1}</td>'", ".", "format", "(", "_lookup_style", "(", "'td'", ",", "[", "cell_style", ",", "first_style", ",", "'value'", ",", "extra_style", "]", ")", ",", "cgi", ".", "escape", "(", "six", ".", "text_type", "(", "subdata", ")", ")", ")", ",", "file", "=", "out", ")", "print", "(", "'</tr>'", ",", "file", "=", "out", ")", "firstone", "=", "False", "print", "(", "'</table>'", ",", "file", "=", "out", ")"], "docstring": "Generate a single table of data", "docstring_tokens": ["Generate", "a", "single", "table", "of", "data"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/returners/highstate_return.py#L176-L269", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/returners/highstate_return.py", "func_name": "_generate_html", "original_string": "def _generate_html(data, out):\n    '''\n    Generate report data as HTML\n    '''\n    print('<html>', file=out)\n    print('<body>', file=out)\n    _generate_html_table(data, out, 0)\n    print('</body>', file=out)\n    print('</html>', file=out)", "language": "python", "code": "def _generate_html(data, out):\n    '''\n    Generate report data as HTML\n    '''\n    print('<html>', file=out)\n    print('<body>', file=out)\n    _generate_html_table(data, out, 0)\n    print('</body>', file=out)\n    print('</html>', file=out)", "code_tokens": ["def", "_generate_html", "(", "data", ",", "out", ")", ":", "print", "(", "'<html>'", ",", "file", "=", "out", ")", "print", "(", "'<body>'", ",", "file", "=", "out", ")", "_generate_html_table", "(", "data", ",", "out", ",", "0", ")", "print", "(", "'</body>'", ",", "file", "=", "out", ")", "print", "(", "'</html>'", ",", "file", "=", "out", ")"], "docstring": "Generate report data as HTML", "docstring_tokens": ["Generate", "report", "data", "as", "HTML"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/returners/highstate_return.py#L272-L280", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/returners/highstate_return.py", "func_name": "_dict_to_name_value", "original_string": "def _dict_to_name_value(data):\n    '''\n    Convert a dictionary to a list of dictionaries to facilitate ordering\n    '''\n    if isinstance(data, dict):\n        sorted_data = sorted(data.items(), key=lambda s: s[0])\n        result = []\n        for name, value in sorted_data:\n            if isinstance(value, dict):\n                result.append({name: _dict_to_name_value(value)})\n            else:\n                result.append({name: value})\n    else:\n        result = data\n    return result", "language": "python", "code": "def _dict_to_name_value(data):\n    '''\n    Convert a dictionary to a list of dictionaries to facilitate ordering\n    '''\n    if isinstance(data, dict):\n        sorted_data = sorted(data.items(), key=lambda s: s[0])\n        result = []\n        for name, value in sorted_data:\n            if isinstance(value, dict):\n                result.append({name: _dict_to_name_value(value)})\n            else:\n                result.append({name: value})\n    else:\n        result = data\n    return result", "code_tokens": ["def", "_dict_to_name_value", "(", "data", ")", ":", "if", "isinstance", "(", "data", ",", "dict", ")", ":", "sorted_data", "=", "sorted", "(", "data", ".", "items", "(", ")", ",", "key", "=", "lambda", "s", ":", "s", "[", "0", "]", ")", "result", "=", "[", "]", "for", "name", ",", "value", "in", "sorted_data", ":", "if", "isinstance", "(", "value", ",", "dict", ")", ":", "result", ".", "append", "(", "{", "name", ":", "_dict_to_name_value", "(", "value", ")", "}", ")", "else", ":", "result", ".", "append", "(", "{", "name", ":", "value", "}", ")", "else", ":", "result", "=", "data", "return", "result"], "docstring": "Convert a dictionary to a list of dictionaries to facilitate ordering", "docstring_tokens": ["Convert", "a", "dictionary", "to", "a", "list", "of", "dictionaries", "to", "facilitate", "ordering"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/returners/highstate_return.py#L283-L297", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/returners/highstate_return.py", "func_name": "_generate_states_report", "original_string": "def _generate_states_report(sorted_data):\n    '''\n    Generate states report\n    '''\n    states = []\n    for state, data in sorted_data:\n        module, stateid, name, function = state.split('_|-')\n        module_function = '.'.join((module, function))\n        result = data.get('result', '')\n        single = [\n            {'function': module_function},\n            {'name': name},\n            {'result': result},\n            {'duration': data.get('duration', 0.0)},\n            {'comment': data.get('comment', '')}\n        ]\n\n        if not result:\n            style = 'failed'\n        else:\n            changes = data.get('changes', {})\n            if changes and isinstance(changes, dict):\n                single.append({'changes': _dict_to_name_value(changes)})\n                style = 'changed'\n            else:\n                style = 'unchanged'\n\n        started = data.get('start_time', '')\n        if started:\n            single.append({'started': started})\n\n        states.append({stateid: single, '__style__': style})\n    return states", "language": "python", "code": "def _generate_states_report(sorted_data):\n    '''\n    Generate states report\n    '''\n    states = []\n    for state, data in sorted_data:\n        module, stateid, name, function = state.split('_|-')\n        module_function = '.'.join((module, function))\n        result = data.get('result', '')\n        single = [\n            {'function': module_function},\n            {'name': name},\n            {'result': result},\n            {'duration': data.get('duration', 0.0)},\n            {'comment': data.get('comment', '')}\n        ]\n\n        if not result:\n            style = 'failed'\n        else:\n            changes = data.get('changes', {})\n            if changes and isinstance(changes, dict):\n                single.append({'changes': _dict_to_name_value(changes)})\n                style = 'changed'\n            else:\n                style = 'unchanged'\n\n        started = data.get('start_time', '')\n        if started:\n            single.append({'started': started})\n\n        states.append({stateid: single, '__style__': style})\n    return states", "code_tokens": ["def", "_generate_states_report", "(", "sorted_data", ")", ":", "states", "=", "[", "]", "for", "state", ",", "data", "in", "sorted_data", ":", "module", ",", "stateid", ",", "name", ",", "function", "=", "state", ".", "split", "(", "'_|-'", ")", "module_function", "=", "'.'", ".", "join", "(", "(", "module", ",", "function", ")", ")", "result", "=", "data", ".", "get", "(", "'result'", ",", "''", ")", "single", "=", "[", "{", "'function'", ":", "module_function", "}", ",", "{", "'name'", ":", "name", "}", ",", "{", "'result'", ":", "result", "}", ",", "{", "'duration'", ":", "data", ".", "get", "(", "'duration'", ",", "0.0", ")", "}", ",", "{", "'comment'", ":", "data", ".", "get", "(", "'comment'", ",", "''", ")", "}", "]", "if", "not", "result", ":", "style", "=", "'failed'", "else", ":", "changes", "=", "data", ".", "get", "(", "'changes'", ",", "{", "}", ")", "if", "changes", "and", "isinstance", "(", "changes", ",", "dict", ")", ":", "single", ".", "append", "(", "{", "'changes'", ":", "_dict_to_name_value", "(", "changes", ")", "}", ")", "style", "=", "'changed'", "else", ":", "style", "=", "'unchanged'", "started", "=", "data", ".", "get", "(", "'start_time'", ",", "''", ")", "if", "started", ":", "single", ".", "append", "(", "{", "'started'", ":", "started", "}", ")", "states", ".", "append", "(", "{", "stateid", ":", "single", ",", "'__style__'", ":", "style", "}", ")", "return", "states"], "docstring": "Generate states report", "docstring_tokens": ["Generate", "states", "report"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/returners/highstate_return.py#L300-L332", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/returners/highstate_return.py", "func_name": "_generate_report", "original_string": "def _generate_report(ret, setup):\n    '''\n    Generate report dictionary\n    '''\n\n    retdata = ret.get('return', {})\n\n    sorted_data = sorted(\n        retdata.items(),\n        key=lambda s: s[1].get('__run_num__', 0)\n    )\n\n    total = 0\n    failed = 0\n    changed = 0\n    duration = 0.0\n\n    # gather stats\n    for _, data in sorted_data:\n        if not data.get('result', True):\n            failed += 1\n        total += 1\n\n        try:\n            duration += float(data.get('duration', 0.0))\n        except ValueError:\n            pass\n\n        if data.get('changes', {}):\n            changed += 1\n\n    unchanged = total - failed - changed\n\n    log.debug('highstate total: %s', total)\n    log.debug('highstate failed: %s', failed)\n    log.debug('highstate unchanged: %s', unchanged)\n    log.debug('highstate changed: %s', changed)\n\n    # generate report if required\n    if setup.get('report_everything', False) or \\\n       (setup.get('report_changes', True) and changed != 0) or \\\n       (setup.get('report_failures', True) and failed != 0):\n\n        report = [\n            {'stats': [\n                {'total': total},\n                {'failed': failed, '__style__': 'failed'},\n                {'unchanged': unchanged, '__style__': 'unchanged'},\n                {'changed': changed, '__style__': 'changed'},\n                {'duration': duration}\n            ]},\n            {'job': [\n                {'function': ret.get('fun', '')},\n                {'arguments': ret.get('fun_args', '')},\n                {'jid': ret.get('jid', '')},\n                {'success': ret.get('success', True)},\n                {'retcode': ret.get('retcode', 0)}\n            ]},\n            {'states': _generate_states_report(sorted_data)}\n        ]\n\n        if failed:\n            function = setup.get('failure_function', None)\n        else:\n            function = setup.get('success_function', None)\n\n        if function:\n            func_result = __salt__[function]()\n            report.insert(\n                0,\n                {'extra': [{function: _dict_to_name_value(func_result)}]}\n            )\n\n    else:\n        report = []\n\n    return report, failed", "language": "python", "code": "def _generate_report(ret, setup):\n    '''\n    Generate report dictionary\n    '''\n\n    retdata = ret.get('return', {})\n\n    sorted_data = sorted(\n        retdata.items(),\n        key=lambda s: s[1].get('__run_num__', 0)\n    )\n\n    total = 0\n    failed = 0\n    changed = 0\n    duration = 0.0\n\n    # gather stats\n    for _, data in sorted_data:\n        if not data.get('result', True):\n            failed += 1\n        total += 1\n\n        try:\n            duration += float(data.get('duration', 0.0))\n        except ValueError:\n            pass\n\n        if data.get('changes', {}):\n            changed += 1\n\n    unchanged = total - failed - changed\n\n    log.debug('highstate total: %s', total)\n    log.debug('highstate failed: %s', failed)\n    log.debug('highstate unchanged: %s', unchanged)\n    log.debug('highstate changed: %s', changed)\n\n    # generate report if required\n    if setup.get('report_everything', False) or \\\n       (setup.get('report_changes', True) and changed != 0) or \\\n       (setup.get('report_failures', True) and failed != 0):\n\n        report = [\n            {'stats': [\n                {'total': total},\n                {'failed': failed, '__style__': 'failed'},\n                {'unchanged': unchanged, '__style__': 'unchanged'},\n                {'changed': changed, '__style__': 'changed'},\n                {'duration': duration}\n            ]},\n            {'job': [\n                {'function': ret.get('fun', '')},\n                {'arguments': ret.get('fun_args', '')},\n                {'jid': ret.get('jid', '')},\n                {'success': ret.get('success', True)},\n                {'retcode': ret.get('retcode', 0)}\n            ]},\n            {'states': _generate_states_report(sorted_data)}\n        ]\n\n        if failed:\n            function = setup.get('failure_function', None)\n        else:\n            function = setup.get('success_function', None)\n\n        if function:\n            func_result = __salt__[function]()\n            report.insert(\n                0,\n                {'extra': [{function: _dict_to_name_value(func_result)}]}\n            )\n\n    else:\n        report = []\n\n    return report, failed", "code_tokens": ["def", "_generate_report", "(", "ret", ",", "setup", ")", ":", "retdata", "=", "ret", ".", "get", "(", "'return'", ",", "{", "}", ")", "sorted_data", "=", "sorted", "(", "retdata", ".", "items", "(", ")", ",", "key", "=", "lambda", "s", ":", "s", "[", "1", "]", ".", "get", "(", "'__run_num__'", ",", "0", ")", ")", "total", "=", "0", "failed", "=", "0", "changed", "=", "0", "duration", "=", "0.0", "# gather stats", "for", "_", ",", "data", "in", "sorted_data", ":", "if", "not", "data", ".", "get", "(", "'result'", ",", "True", ")", ":", "failed", "+=", "1", "total", "+=", "1", "try", ":", "duration", "+=", "float", "(", "data", ".", "get", "(", "'duration'", ",", "0.0", ")", ")", "except", "ValueError", ":", "pass", "if", "data", ".", "get", "(", "'changes'", ",", "{", "}", ")", ":", "changed", "+=", "1", "unchanged", "=", "total", "-", "failed", "-", "changed", "log", ".", "debug", "(", "'highstate total: %s'", ",", "total", ")", "log", ".", "debug", "(", "'highstate failed: %s'", ",", "failed", ")", "log", ".", "debug", "(", "'highstate unchanged: %s'", ",", "unchanged", ")", "log", ".", "debug", "(", "'highstate changed: %s'", ",", "changed", ")", "# generate report if required", "if", "setup", ".", "get", "(", "'report_everything'", ",", "False", ")", "or", "(", "setup", ".", "get", "(", "'report_changes'", ",", "True", ")", "and", "changed", "!=", "0", ")", "or", "(", "setup", ".", "get", "(", "'report_failures'", ",", "True", ")", "and", "failed", "!=", "0", ")", ":", "report", "=", "[", "{", "'stats'", ":", "[", "{", "'total'", ":", "total", "}", ",", "{", "'failed'", ":", "failed", ",", "'__style__'", ":", "'failed'", "}", ",", "{", "'unchanged'", ":", "unchanged", ",", "'__style__'", ":", "'unchanged'", "}", ",", "{", "'changed'", ":", "changed", ",", "'__style__'", ":", "'changed'", "}", ",", "{", "'duration'", ":", "duration", "}", "]", "}", ",", "{", "'job'", ":", "[", "{", "'function'", ":", "ret", ".", "get", "(", "'fun'", ",", "''", ")", "}", ",", "{", "'arguments'", ":", "ret", ".", "get", "(", "'fun_args'", ",", "''", ")", "}", ",", "{", "'jid'", ":", "ret", ".", "get", "(", "'jid'", ",", "''", ")", "}", ",", "{", "'success'", ":", "ret", ".", "get", "(", "'success'", ",", "True", ")", "}", ",", "{", "'retcode'", ":", "ret", ".", "get", "(", "'retcode'", ",", "0", ")", "}", "]", "}", ",", "{", "'states'", ":", "_generate_states_report", "(", "sorted_data", ")", "}", "]", "if", "failed", ":", "function", "=", "setup", ".", "get", "(", "'failure_function'", ",", "None", ")", "else", ":", "function", "=", "setup", ".", "get", "(", "'success_function'", ",", "None", ")", "if", "function", ":", "func_result", "=", "__salt__", "[", "function", "]", "(", ")", "report", ".", "insert", "(", "0", ",", "{", "'extra'", ":", "[", "{", "function", ":", "_dict_to_name_value", "(", "func_result", ")", "}", "]", "}", ")", "else", ":", "report", "=", "[", "]", "return", "report", ",", "failed"], "docstring": "Generate report dictionary", "docstring_tokens": ["Generate", "report", "dictionary"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/returners/highstate_return.py#L335-L411", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/returners/highstate_return.py", "func_name": "_produce_output", "original_string": "def _produce_output(report, failed, setup):\n    '''\n    Produce output from the report dictionary generated by _generate_report\n    '''\n    report_format = setup.get('report_format', 'yaml')\n\n    log.debug('highstate output format: %s', report_format)\n\n    if report_format == 'json':\n        report_text = salt.utils.json.dumps(report)\n    elif report_format == 'yaml':\n        string_file = StringIO()\n        salt.utils.yaml.safe_dump(report, string_file, default_flow_style=False)\n        string_file.seek(0)\n        report_text = string_file.read()\n    else:\n        string_file = StringIO()\n        _generate_html(report, string_file)\n        string_file.seek(0)\n        report_text = string_file.read()\n\n    report_delivery = setup.get('report_delivery', 'file')\n\n    log.debug('highstate report_delivery: %s', report_delivery)\n\n    if report_delivery == 'file':\n        output_file = _sprinkle(setup.get('file_output', '/tmp/test.rpt'))\n        with salt.utils.files.fopen(output_file, 'w') as out:\n            out.write(salt.utils.stringutils.to_str(report_text))\n    else:\n        msg = MIMEText(report_text, report_format)\n\n        sender = setup.get('smtp_sender', '')\n        recipients = setup.get('smtp_recipients', '')\n\n        host = setup.get('smtp_server', '')\n        port = int(setup.get('smtp_port', 25))\n        tls = setup.get('smtp_tls')\n        username = setup.get('smtp_username')\n        password = setup.get('smtp_password')\n\n        if failed:\n            subject = setup.get('smtp_failure_subject', 'Installation failure')\n        else:\n            subject = setup.get('smtp_success_subject', 'Installation success')\n\n        subject = _sprinkle(subject)\n\n        msg['Subject'] = subject\n        msg['From'] = sender\n        msg['To'] = recipients\n\n        log.debug('highstate smtp port: %d', port)\n        smtp = smtplib.SMTP(host=host, port=port)\n\n        if tls is True:\n            smtp.starttls()\n            log.debug('highstate smtp tls enabled')\n\n        if username and password:\n            smtp.login(username, password)\n            log.debug('highstate smtp authenticated')\n\n        smtp.sendmail(\n            sender,\n            [x.strip() for x in recipients.split(',')], msg.as_string())\n        log.debug('highstate message sent.')\n\n        smtp.quit()", "language": "python", "code": "def _produce_output(report, failed, setup):\n    '''\n    Produce output from the report dictionary generated by _generate_report\n    '''\n    report_format = setup.get('report_format', 'yaml')\n\n    log.debug('highstate output format: %s', report_format)\n\n    if report_format == 'json':\n        report_text = salt.utils.json.dumps(report)\n    elif report_format == 'yaml':\n        string_file = StringIO()\n        salt.utils.yaml.safe_dump(report, string_file, default_flow_style=False)\n        string_file.seek(0)\n        report_text = string_file.read()\n    else:\n        string_file = StringIO()\n        _generate_html(report, string_file)\n        string_file.seek(0)\n        report_text = string_file.read()\n\n    report_delivery = setup.get('report_delivery', 'file')\n\n    log.debug('highstate report_delivery: %s', report_delivery)\n\n    if report_delivery == 'file':\n        output_file = _sprinkle(setup.get('file_output', '/tmp/test.rpt'))\n        with salt.utils.files.fopen(output_file, 'w') as out:\n            out.write(salt.utils.stringutils.to_str(report_text))\n    else:\n        msg = MIMEText(report_text, report_format)\n\n        sender = setup.get('smtp_sender', '')\n        recipients = setup.get('smtp_recipients', '')\n\n        host = setup.get('smtp_server', '')\n        port = int(setup.get('smtp_port', 25))\n        tls = setup.get('smtp_tls')\n        username = setup.get('smtp_username')\n        password = setup.get('smtp_password')\n\n        if failed:\n            subject = setup.get('smtp_failure_subject', 'Installation failure')\n        else:\n            subject = setup.get('smtp_success_subject', 'Installation success')\n\n        subject = _sprinkle(subject)\n\n        msg['Subject'] = subject\n        msg['From'] = sender\n        msg['To'] = recipients\n\n        log.debug('highstate smtp port: %d', port)\n        smtp = smtplib.SMTP(host=host, port=port)\n\n        if tls is True:\n            smtp.starttls()\n            log.debug('highstate smtp tls enabled')\n\n        if username and password:\n            smtp.login(username, password)\n            log.debug('highstate smtp authenticated')\n\n        smtp.sendmail(\n            sender,\n            [x.strip() for x in recipients.split(',')], msg.as_string())\n        log.debug('highstate message sent.')\n\n        smtp.quit()", "code_tokens": ["def", "_produce_output", "(", "report", ",", "failed", ",", "setup", ")", ":", "report_format", "=", "setup", ".", "get", "(", "'report_format'", ",", "'yaml'", ")", "log", ".", "debug", "(", "'highstate output format: %s'", ",", "report_format", ")", "if", "report_format", "==", "'json'", ":", "report_text", "=", "salt", ".", "utils", ".", "json", ".", "dumps", "(", "report", ")", "elif", "report_format", "==", "'yaml'", ":", "string_file", "=", "StringIO", "(", ")", "salt", ".", "utils", ".", "yaml", ".", "safe_dump", "(", "report", ",", "string_file", ",", "default_flow_style", "=", "False", ")", "string_file", ".", "seek", "(", "0", ")", "report_text", "=", "string_file", ".", "read", "(", ")", "else", ":", "string_file", "=", "StringIO", "(", ")", "_generate_html", "(", "report", ",", "string_file", ")", "string_file", ".", "seek", "(", "0", ")", "report_text", "=", "string_file", ".", "read", "(", ")", "report_delivery", "=", "setup", ".", "get", "(", "'report_delivery'", ",", "'file'", ")", "log", ".", "debug", "(", "'highstate report_delivery: %s'", ",", "report_delivery", ")", "if", "report_delivery", "==", "'file'", ":", "output_file", "=", "_sprinkle", "(", "setup", ".", "get", "(", "'file_output'", ",", "'/tmp/test.rpt'", ")", ")", "with", "salt", ".", "utils", ".", "files", ".", "fopen", "(", "output_file", ",", "'w'", ")", "as", "out", ":", "out", ".", "write", "(", "salt", ".", "utils", ".", "stringutils", ".", "to_str", "(", "report_text", ")", ")", "else", ":", "msg", "=", "MIMEText", "(", "report_text", ",", "report_format", ")", "sender", "=", "setup", ".", "get", "(", "'smtp_sender'", ",", "''", ")", "recipients", "=", "setup", ".", "get", "(", "'smtp_recipients'", ",", "''", ")", "host", "=", "setup", ".", "get", "(", "'smtp_server'", ",", "''", ")", "port", "=", "int", "(", "setup", ".", "get", "(", "'smtp_port'", ",", "25", ")", ")", "tls", "=", "setup", ".", "get", "(", "'smtp_tls'", ")", "username", "=", "setup", ".", "get", "(", "'smtp_username'", ")", "password", "=", "setup", ".", "get", "(", "'smtp_password'", ")", "if", "failed", ":", "subject", "=", "setup", ".", "get", "(", "'smtp_failure_subject'", ",", "'Installation failure'", ")", "else", ":", "subject", "=", "setup", ".", "get", "(", "'smtp_success_subject'", ",", "'Installation success'", ")", "subject", "=", "_sprinkle", "(", "subject", ")", "msg", "[", "'Subject'", "]", "=", "subject", "msg", "[", "'From'", "]", "=", "sender", "msg", "[", "'To'", "]", "=", "recipients", "log", ".", "debug", "(", "'highstate smtp port: %d'", ",", "port", ")", "smtp", "=", "smtplib", ".", "SMTP", "(", "host", "=", "host", ",", "port", "=", "port", ")", "if", "tls", "is", "True", ":", "smtp", ".", "starttls", "(", ")", "log", ".", "debug", "(", "'highstate smtp tls enabled'", ")", "if", "username", "and", "password", ":", "smtp", ".", "login", "(", "username", ",", "password", ")", "log", ".", "debug", "(", "'highstate smtp authenticated'", ")", "smtp", ".", "sendmail", "(", "sender", ",", "[", "x", ".", "strip", "(", ")", "for", "x", "in", "recipients", ".", "split", "(", "','", ")", "]", ",", "msg", ".", "as_string", "(", ")", ")", "log", ".", "debug", "(", "'highstate message sent.'", ")", "smtp", ".", "quit", "(", ")"], "docstring": "Produce output from the report dictionary generated by _generate_report", "docstring_tokens": ["Produce", "output", "from", "the", "report", "dictionary", "generated", "by", "_generate_report"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/returners/highstate_return.py#L425-L493", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/returners/highstate_return.py", "func_name": "returner", "original_string": "def returner(ret):\n    '''\n    Check highstate return information and possibly fire off an email\n    or save a file.\n    '''\n    setup = _get_options(ret)\n\n    log.debug('highstate setup %s', setup)\n\n    report, failed = _generate_report(ret, setup)\n    if report:\n        _produce_output(report, failed, setup)", "language": "python", "code": "def returner(ret):\n    '''\n    Check highstate return information and possibly fire off an email\n    or save a file.\n    '''\n    setup = _get_options(ret)\n\n    log.debug('highstate setup %s', setup)\n\n    report, failed = _generate_report(ret, setup)\n    if report:\n        _produce_output(report, failed, setup)", "code_tokens": ["def", "returner", "(", "ret", ")", ":", "setup", "=", "_get_options", "(", "ret", ")", "log", ".", "debug", "(", "'highstate setup %s'", ",", "setup", ")", "report", ",", "failed", "=", "_generate_report", "(", "ret", ",", "setup", ")", "if", "report", ":", "_produce_output", "(", "report", ",", "failed", ",", "setup", ")"], "docstring": "Check highstate return information and possibly fire off an email\n    or save a file.", "docstring_tokens": ["Check", "highstate", "return", "information", "and", "possibly", "fire", "off", "an", "email", "or", "save", "a", "file", "."], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/returners/highstate_return.py#L496-L507", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/modules/out.py", "func_name": "out_format", "original_string": "def out_format(data, out='nested', opts=None, **kwargs):\n    '''\n    Return the formatted outputter string for the Python object.\n\n    data\n        The JSON serializable object.\n\n    out: ``nested``\n        The name of the output to use to transform the data. Default: ``nested``.\n\n    opts\n        Dictionary of configuration options. Default: ``__opts__``.\n\n    kwargs\n        Arguments to sent to the outputter module.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' out.out_format \"{'key': 'value'}\"\n    '''\n    if not opts:\n        opts = __opts__\n    return salt.output.out_format(data, out, opts=opts, **kwargs)", "language": "python", "code": "def out_format(data, out='nested', opts=None, **kwargs):\n    '''\n    Return the formatted outputter string for the Python object.\n\n    data\n        The JSON serializable object.\n\n    out: ``nested``\n        The name of the output to use to transform the data. Default: ``nested``.\n\n    opts\n        Dictionary of configuration options. Default: ``__opts__``.\n\n    kwargs\n        Arguments to sent to the outputter module.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' out.out_format \"{'key': 'value'}\"\n    '''\n    if not opts:\n        opts = __opts__\n    return salt.output.out_format(data, out, opts=opts, **kwargs)", "code_tokens": ["def", "out_format", "(", "data", ",", "out", "=", "'nested'", ",", "opts", "=", "None", ",", "*", "*", "kwargs", ")", ":", "if", "not", "opts", ":", "opts", "=", "__opts__", "return", "salt", ".", "output", ".", "out_format", "(", "data", ",", "out", ",", "opts", "=", "opts", ",", "*", "*", "kwargs", ")"], "docstring": "Return the formatted outputter string for the Python object.\n\n    data\n        The JSON serializable object.\n\n    out: ``nested``\n        The name of the output to use to transform the data. Default: ``nested``.\n\n    opts\n        Dictionary of configuration options. Default: ``__opts__``.\n\n    kwargs\n        Arguments to sent to the outputter module.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' out.out_format \"{'key': 'value'}\"", "docstring_tokens": ["Return", "the", "formatted", "outputter", "string", "for", "the", "Python", "object", "."], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/modules/out.py#L37-L61", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/modules/out.py", "func_name": "string_format", "original_string": "def string_format(data, out='nested', opts=None, **kwargs):\n    '''\n    Return the outputter formatted string, removing the ANSI escape sequences.\n\n    data\n        The JSON serializable object.\n\n    out: ``nested``\n        The name of the output to use to transform the data. Default: ``nested``.\n\n    opts\n        Dictionary of configuration options. Default: ``__opts__``.\n\n    kwargs\n        Arguments to sent to the outputter module.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' out.string_format \"{'key': 'value'}\" out=table\n    '''\n    if not opts:\n        opts = __opts__\n    return salt.output.string_format(data, out, opts=opts, **kwargs)", "language": "python", "code": "def string_format(data, out='nested', opts=None, **kwargs):\n    '''\n    Return the outputter formatted string, removing the ANSI escape sequences.\n\n    data\n        The JSON serializable object.\n\n    out: ``nested``\n        The name of the output to use to transform the data. Default: ``nested``.\n\n    opts\n        Dictionary of configuration options. Default: ``__opts__``.\n\n    kwargs\n        Arguments to sent to the outputter module.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' out.string_format \"{'key': 'value'}\" out=table\n    '''\n    if not opts:\n        opts = __opts__\n    return salt.output.string_format(data, out, opts=opts, **kwargs)", "code_tokens": ["def", "string_format", "(", "data", ",", "out", "=", "'nested'", ",", "opts", "=", "None", ",", "*", "*", "kwargs", ")", ":", "if", "not", "opts", ":", "opts", "=", "__opts__", "return", "salt", ".", "output", ".", "string_format", "(", "data", ",", "out", ",", "opts", "=", "opts", ",", "*", "*", "kwargs", ")"], "docstring": "Return the outputter formatted string, removing the ANSI escape sequences.\n\n    data\n        The JSON serializable object.\n\n    out: ``nested``\n        The name of the output to use to transform the data. Default: ``nested``.\n\n    opts\n        Dictionary of configuration options. Default: ``__opts__``.\n\n    kwargs\n        Arguments to sent to the outputter module.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' out.string_format \"{'key': 'value'}\" out=table", "docstring_tokens": ["Return", "the", "outputter", "formatted", "string", "removing", "the", "ANSI", "escape", "sequences", "."], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/modules/out.py#L64-L88", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/modules/out.py", "func_name": "html_format", "original_string": "def html_format(data, out='nested', opts=None, **kwargs):\n    '''\n    Return the formatted string as HTML.\n\n    data\n        The JSON serializable object.\n\n    out: ``nested``\n        The name of the output to use to transform the data. Default: ``nested``.\n\n    opts\n        Dictionary of configuration options. Default: ``__opts__``.\n\n    kwargs\n        Arguments to sent to the outputter module.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' out.html_format \"{'key': 'value'}\" out=yaml\n    '''\n    if not opts:\n        opts = __opts__\n    return salt.output.html_format(data, out, opts=opts, **kwargs)", "language": "python", "code": "def html_format(data, out='nested', opts=None, **kwargs):\n    '''\n    Return the formatted string as HTML.\n\n    data\n        The JSON serializable object.\n\n    out: ``nested``\n        The name of the output to use to transform the data. Default: ``nested``.\n\n    opts\n        Dictionary of configuration options. Default: ``__opts__``.\n\n    kwargs\n        Arguments to sent to the outputter module.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' out.html_format \"{'key': 'value'}\" out=yaml\n    '''\n    if not opts:\n        opts = __opts__\n    return salt.output.html_format(data, out, opts=opts, **kwargs)", "code_tokens": ["def", "html_format", "(", "data", ",", "out", "=", "'nested'", ",", "opts", "=", "None", ",", "*", "*", "kwargs", ")", ":", "if", "not", "opts", ":", "opts", "=", "__opts__", "return", "salt", ".", "output", ".", "html_format", "(", "data", ",", "out", ",", "opts", "=", "opts", ",", "*", "*", "kwargs", ")"], "docstring": "Return the formatted string as HTML.\n\n    data\n        The JSON serializable object.\n\n    out: ``nested``\n        The name of the output to use to transform the data. Default: ``nested``.\n\n    opts\n        Dictionary of configuration options. Default: ``__opts__``.\n\n    kwargs\n        Arguments to sent to the outputter module.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' out.html_format \"{'key': 'value'}\" out=yaml", "docstring_tokens": ["Return", "the", "formatted", "string", "as", "HTML", "."], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/modules/out.py#L91-L115", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/states/zcbuildout.py", "func_name": "installed", "original_string": "def installed(name,\n              config='buildout.cfg',\n              quiet=False,\n              parts=None,\n              user=None,\n              env=(),\n              buildout_ver=None,\n              test_release=False,\n              distribute=None,\n              new_st=None,\n              offline=False,\n              newest=False,\n              python=sys.executable,\n              debug=False,\n              verbose=False,\n              unless=None,\n              onlyif=None,\n              use_vt=False,\n              loglevel='debug',\n              **kwargs):\n    '''\n    Install buildout in a specific directory\n\n    It is a thin wrapper to modules.buildout.buildout\n\n    name\n        directory to execute in\n\n    quiet\n\n        do not output console & logs\n\n    config\n        buildout config to use (default: buildout.cfg)\n\n    parts\n        specific buildout parts to run\n\n    user\n        user used to run buildout as\n\n        .. versionadded:: 2014.1.4\n\n    env\n        environment variables to set when running\n\n    buildout_ver\n        force a specific buildout version (1 | 2)\n\n    test_release\n        buildout accept test release\n\n    new_st\n        Forcing use of setuptools >= 0.7\n\n    distribute\n        use distribute over setuptools if possible\n\n    offline\n        does buildout run offline\n\n    python\n        python to use\n\n    debug\n        run buildout with -D debug flag\n\n    onlyif\n        Only execute cmd if statement on the host return 0\n\n    unless\n        Do not execute cmd if statement on the host return 0\n\n    newest\n        run buildout in newest mode\n\n    verbose\n        run buildout in verbose mode (-vvvvv)\n\n    use_vt\n        Use the new salt VT to stream output [experimental]\n\n    loglevel\n        loglevel for buildout commands\n    '''\n    ret = {}\n\n    if 'group' in kwargs:\n        log.warning(\"Passing 'group' is deprecated, just remove it\")\n    output_loglevel = kwargs.get('output_loglevel', None)\n    if output_loglevel and not loglevel:\n        log.warning(\"Passing 'output_loglevel' is deprecated,\"\n                 ' please use loglevel instead')\n    try:\n        test_release = int(test_release)\n    except ValueError:\n        test_release = None\n\n    func = __salt('buildout.buildout')\n    kwargs = dict(\n        directory=name,\n        config=config,\n        parts=parts,\n        runas=user,\n        env=env,\n        buildout_ver=buildout_ver,\n        test_release=test_release,\n        distribute=distribute,\n        new_st=new_st,\n        offline=offline,\n        newest=newest,\n        python=python,\n        debug=debug,\n        verbose=verbose,\n        onlyif=onlyif,\n        unless=unless,\n        use_vt=use_vt,\n        loglevel=loglevel\n    )\n    ret.update(_ret_status(func(**kwargs), name, quiet=quiet))\n    return ret", "language": "python", "code": "def installed(name,\n              config='buildout.cfg',\n              quiet=False,\n              parts=None,\n              user=None,\n              env=(),\n              buildout_ver=None,\n              test_release=False,\n              distribute=None,\n              new_st=None,\n              offline=False,\n              newest=False,\n              python=sys.executable,\n              debug=False,\n              verbose=False,\n              unless=None,\n              onlyif=None,\n              use_vt=False,\n              loglevel='debug',\n              **kwargs):\n    '''\n    Install buildout in a specific directory\n\n    It is a thin wrapper to modules.buildout.buildout\n\n    name\n        directory to execute in\n\n    quiet\n\n        do not output console & logs\n\n    config\n        buildout config to use (default: buildout.cfg)\n\n    parts\n        specific buildout parts to run\n\n    user\n        user used to run buildout as\n\n        .. versionadded:: 2014.1.4\n\n    env\n        environment variables to set when running\n\n    buildout_ver\n        force a specific buildout version (1 | 2)\n\n    test_release\n        buildout accept test release\n\n    new_st\n        Forcing use of setuptools >= 0.7\n\n    distribute\n        use distribute over setuptools if possible\n\n    offline\n        does buildout run offline\n\n    python\n        python to use\n\n    debug\n        run buildout with -D debug flag\n\n    onlyif\n        Only execute cmd if statement on the host return 0\n\n    unless\n        Do not execute cmd if statement on the host return 0\n\n    newest\n        run buildout in newest mode\n\n    verbose\n        run buildout in verbose mode (-vvvvv)\n\n    use_vt\n        Use the new salt VT to stream output [experimental]\n\n    loglevel\n        loglevel for buildout commands\n    '''\n    ret = {}\n\n    if 'group' in kwargs:\n        log.warning(\"Passing 'group' is deprecated, just remove it\")\n    output_loglevel = kwargs.get('output_loglevel', None)\n    if output_loglevel and not loglevel:\n        log.warning(\"Passing 'output_loglevel' is deprecated,\"\n                 ' please use loglevel instead')\n    try:\n        test_release = int(test_release)\n    except ValueError:\n        test_release = None\n\n    func = __salt('buildout.buildout')\n    kwargs = dict(\n        directory=name,\n        config=config,\n        parts=parts,\n        runas=user,\n        env=env,\n        buildout_ver=buildout_ver,\n        test_release=test_release,\n        distribute=distribute,\n        new_st=new_st,\n        offline=offline,\n        newest=newest,\n        python=python,\n        debug=debug,\n        verbose=verbose,\n        onlyif=onlyif,\n        unless=unless,\n        use_vt=use_vt,\n        loglevel=loglevel\n    )\n    ret.update(_ret_status(func(**kwargs), name, quiet=quiet))\n    return ret", "code_tokens": ["def", "installed", "(", "name", ",", "config", "=", "'buildout.cfg'", ",", "quiet", "=", "False", ",", "parts", "=", "None", ",", "user", "=", "None", ",", "env", "=", "(", ")", ",", "buildout_ver", "=", "None", ",", "test_release", "=", "False", ",", "distribute", "=", "None", ",", "new_st", "=", "None", ",", "offline", "=", "False", ",", "newest", "=", "False", ",", "python", "=", "sys", ".", "executable", ",", "debug", "=", "False", ",", "verbose", "=", "False", ",", "unless", "=", "None", ",", "onlyif", "=", "None", ",", "use_vt", "=", "False", ",", "loglevel", "=", "'debug'", ",", "*", "*", "kwargs", ")", ":", "ret", "=", "{", "}", "if", "'group'", "in", "kwargs", ":", "log", ".", "warning", "(", "\"Passing 'group' is deprecated, just remove it\"", ")", "output_loglevel", "=", "kwargs", ".", "get", "(", "'output_loglevel'", ",", "None", ")", "if", "output_loglevel", "and", "not", "loglevel", ":", "log", ".", "warning", "(", "\"Passing 'output_loglevel' is deprecated,\"", "' please use loglevel instead'", ")", "try", ":", "test_release", "=", "int", "(", "test_release", ")", "except", "ValueError", ":", "test_release", "=", "None", "func", "=", "__salt", "(", "'buildout.buildout'", ")", "kwargs", "=", "dict", "(", "directory", "=", "name", ",", "config", "=", "config", ",", "parts", "=", "parts", ",", "runas", "=", "user", ",", "env", "=", "env", ",", "buildout_ver", "=", "buildout_ver", ",", "test_release", "=", "test_release", ",", "distribute", "=", "distribute", ",", "new_st", "=", "new_st", ",", "offline", "=", "offline", ",", "newest", "=", "newest", ",", "python", "=", "python", ",", "debug", "=", "debug", ",", "verbose", "=", "verbose", ",", "onlyif", "=", "onlyif", ",", "unless", "=", "unless", ",", "use_vt", "=", "use_vt", ",", "loglevel", "=", "loglevel", ")", "ret", ".", "update", "(", "_ret_status", "(", "func", "(", "*", "*", "kwargs", ")", ",", "name", ",", "quiet", "=", "quiet", ")", ")", "return", "ret"], "docstring": "Install buildout in a specific directory\n\n    It is a thin wrapper to modules.buildout.buildout\n\n    name\n        directory to execute in\n\n    quiet\n\n        do not output console & logs\n\n    config\n        buildout config to use (default: buildout.cfg)\n\n    parts\n        specific buildout parts to run\n\n    user\n        user used to run buildout as\n\n        .. versionadded:: 2014.1.4\n\n    env\n        environment variables to set when running\n\n    buildout_ver\n        force a specific buildout version (1 | 2)\n\n    test_release\n        buildout accept test release\n\n    new_st\n        Forcing use of setuptools >= 0.7\n\n    distribute\n        use distribute over setuptools if possible\n\n    offline\n        does buildout run offline\n\n    python\n        python to use\n\n    debug\n        run buildout with -D debug flag\n\n    onlyif\n        Only execute cmd if statement on the host return 0\n\n    unless\n        Do not execute cmd if statement on the host return 0\n\n    newest\n        run buildout in newest mode\n\n    verbose\n        run buildout in verbose mode (-vvvvv)\n\n    use_vt\n        Use the new salt VT to stream output [experimental]\n\n    loglevel\n        loglevel for buildout commands", "docstring_tokens": ["Install", "buildout", "in", "a", "specific", "directory"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/states/zcbuildout.py#L121-L241", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/modules/dummyproxy_pkg.py", "func_name": "version", "original_string": "def version(*names, **kwargs):\n    '''\n    Returns a string representing the package version or an empty string if not\n    installed. If more than one package name is specified, a dict of\n    name/version pairs is returned.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' pkg.version <package name>\n        salt '*' pkg.version <package1> <package2> <package3> ...\n    '''\n    if len(names) == 1:\n        vers = __proxy__['dummy.package_status'](names[0])\n        return vers[names[0]]\n    else:\n        results = {}\n        for n in names:\n            vers = __proxy__['dummy.package_status'](n)\n            results.update(vers)\n        return results", "language": "python", "code": "def version(*names, **kwargs):\n    '''\n    Returns a string representing the package version or an empty string if not\n    installed. If more than one package name is specified, a dict of\n    name/version pairs is returned.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' pkg.version <package name>\n        salt '*' pkg.version <package1> <package2> <package3> ...\n    '''\n    if len(names) == 1:\n        vers = __proxy__['dummy.package_status'](names[0])\n        return vers[names[0]]\n    else:\n        results = {}\n        for n in names:\n            vers = __proxy__['dummy.package_status'](n)\n            results.update(vers)\n        return results", "code_tokens": ["def", "version", "(", "*", "names", ",", "*", "*", "kwargs", ")", ":", "if", "len", "(", "names", ")", "==", "1", ":", "vers", "=", "__proxy__", "[", "'dummy.package_status'", "]", "(", "names", "[", "0", "]", ")", "return", "vers", "[", "names", "[", "0", "]", "]", "else", ":", "results", "=", "{", "}", "for", "n", "in", "names", ":", "vers", "=", "__proxy__", "[", "'dummy.package_status'", "]", "(", "n", ")", "results", ".", "update", "(", "vers", ")", "return", "results"], "docstring": "Returns a string representing the package version or an empty string if not\n    installed. If more than one package name is specified, a dict of\n    name/version pairs is returned.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' pkg.version <package name>\n        salt '*' pkg.version <package1> <package2> <package3> ...", "docstring_tokens": ["Returns", "a", "string", "representing", "the", "package", "version", "or", "an", "empty", "string", "if", "not", "installed", ".", "If", "more", "than", "one", "package", "name", "is", "specified", "a", "dict", "of", "name", "/", "version", "pairs", "is", "returned", "."], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/modules/dummyproxy_pkg.py#L55-L76", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/platform/win.py", "func_name": "set_user_perm", "original_string": "def set_user_perm(obj, perm, sid):\n    '''\n    Set an object permission for the given user sid\n    '''\n    info = (\n        win32security.OWNER_SECURITY_INFORMATION |\n        win32security.GROUP_SECURITY_INFORMATION |\n        win32security.DACL_SECURITY_INFORMATION\n    )\n    sd = win32security.GetUserObjectSecurity(obj, info)\n    dacl = sd.GetSecurityDescriptorDacl()\n    ace_cnt = dacl.GetAceCount()\n    found = False\n    for idx in range(0, ace_cnt):\n        (aceType, aceFlags), ace_mask, ace_sid = dacl.GetAce(idx)\n        ace_exists = (\n            aceType == ntsecuritycon.ACCESS_ALLOWED_ACE_TYPE and\n            ace_mask == perm and\n            ace_sid == sid\n        )\n        if ace_exists:\n            # If the ace already exists, do nothing\n            break\n    else:\n        dacl.AddAccessAllowedAce(dacl.GetAclRevision(), perm, sid)\n        sd.SetSecurityDescriptorDacl(1, dacl, 0)\n        win32security.SetUserObjectSecurity(obj, info, sd)", "language": "python", "code": "def set_user_perm(obj, perm, sid):\n    '''\n    Set an object permission for the given user sid\n    '''\n    info = (\n        win32security.OWNER_SECURITY_INFORMATION |\n        win32security.GROUP_SECURITY_INFORMATION |\n        win32security.DACL_SECURITY_INFORMATION\n    )\n    sd = win32security.GetUserObjectSecurity(obj, info)\n    dacl = sd.GetSecurityDescriptorDacl()\n    ace_cnt = dacl.GetAceCount()\n    found = False\n    for idx in range(0, ace_cnt):\n        (aceType, aceFlags), ace_mask, ace_sid = dacl.GetAce(idx)\n        ace_exists = (\n            aceType == ntsecuritycon.ACCESS_ALLOWED_ACE_TYPE and\n            ace_mask == perm and\n            ace_sid == sid\n        )\n        if ace_exists:\n            # If the ace already exists, do nothing\n            break\n    else:\n        dacl.AddAccessAllowedAce(dacl.GetAclRevision(), perm, sid)\n        sd.SetSecurityDescriptorDacl(1, dacl, 0)\n        win32security.SetUserObjectSecurity(obj, info, sd)", "code_tokens": ["def", "set_user_perm", "(", "obj", ",", "perm", ",", "sid", ")", ":", "info", "=", "(", "win32security", ".", "OWNER_SECURITY_INFORMATION", "|", "win32security", ".", "GROUP_SECURITY_INFORMATION", "|", "win32security", ".", "DACL_SECURITY_INFORMATION", ")", "sd", "=", "win32security", ".", "GetUserObjectSecurity", "(", "obj", ",", "info", ")", "dacl", "=", "sd", ".", "GetSecurityDescriptorDacl", "(", ")", "ace_cnt", "=", "dacl", ".", "GetAceCount", "(", ")", "found", "=", "False", "for", "idx", "in", "range", "(", "0", ",", "ace_cnt", ")", ":", "(", "aceType", ",", "aceFlags", ")", ",", "ace_mask", ",", "ace_sid", "=", "dacl", ".", "GetAce", "(", "idx", ")", "ace_exists", "=", "(", "aceType", "==", "ntsecuritycon", ".", "ACCESS_ALLOWED_ACE_TYPE", "and", "ace_mask", "==", "perm", "and", "ace_sid", "==", "sid", ")", "if", "ace_exists", ":", "# If the ace already exists, do nothing", "break", "else", ":", "dacl", ".", "AddAccessAllowedAce", "(", "dacl", ".", "GetAclRevision", "(", ")", ",", "perm", ",", "sid", ")", "sd", ".", "SetSecurityDescriptorDacl", "(", "1", ",", "dacl", ",", "0", ")", "win32security", ".", "SetUserObjectSecurity", "(", "obj", ",", "info", ",", "sd", ")"], "docstring": "Set an object permission for the given user sid", "docstring_tokens": ["Set", "an", "object", "permission", "for", "the", "given", "user", "sid"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/platform/win.py#L972-L998", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/platform/win.py", "func_name": "grant_winsta_and_desktop", "original_string": "def grant_winsta_and_desktop(th):\n    '''\n    Grant the token's user access to the current process's window station and\n    desktop.\n    '''\n    current_sid = win32security.GetTokenInformation(th, win32security.TokenUser)[0]\n    # Add permissions for the sid to the current windows station and thread id.\n    # This prevents windows error 0xC0000142.\n    winsta = win32process.GetProcessWindowStation()\n    set_user_perm(winsta, WINSTA_ALL, current_sid)\n    desktop = win32service.GetThreadDesktop(win32api.GetCurrentThreadId())\n    set_user_perm(desktop, DESKTOP_ALL, current_sid)", "language": "python", "code": "def grant_winsta_and_desktop(th):\n    '''\n    Grant the token's user access to the current process's window station and\n    desktop.\n    '''\n    current_sid = win32security.GetTokenInformation(th, win32security.TokenUser)[0]\n    # Add permissions for the sid to the current windows station and thread id.\n    # This prevents windows error 0xC0000142.\n    winsta = win32process.GetProcessWindowStation()\n    set_user_perm(winsta, WINSTA_ALL, current_sid)\n    desktop = win32service.GetThreadDesktop(win32api.GetCurrentThreadId())\n    set_user_perm(desktop, DESKTOP_ALL, current_sid)", "code_tokens": ["def", "grant_winsta_and_desktop", "(", "th", ")", ":", "current_sid", "=", "win32security", ".", "GetTokenInformation", "(", "th", ",", "win32security", ".", "TokenUser", ")", "[", "0", "]", "# Add permissions for the sid to the current windows station and thread id.", "# This prevents windows error 0xC0000142.", "winsta", "=", "win32process", ".", "GetProcessWindowStation", "(", ")", "set_user_perm", "(", "winsta", ",", "WINSTA_ALL", ",", "current_sid", ")", "desktop", "=", "win32service", ".", "GetThreadDesktop", "(", "win32api", ".", "GetCurrentThreadId", "(", ")", ")", "set_user_perm", "(", "desktop", ",", "DESKTOP_ALL", ",", "current_sid", ")"], "docstring": "Grant the token's user access to the current process's window station and\n    desktop.", "docstring_tokens": ["Grant", "the", "token", "s", "user", "access", "to", "the", "current", "process", "s", "window", "station", "and", "desktop", "."], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/platform/win.py#L1001-L1012", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/platform/win.py", "func_name": "enumerate_tokens", "original_string": "def enumerate_tokens(sid=None, session_id=None, privs=None):\n    '''\n    Enumerate tokens from any existing processes that can be accessed.\n    Optionally filter by sid.\n    '''\n    for p in psutil.process_iter():\n        if p.pid == 0:\n            continue\n        try:\n            ph = win32api.OpenProcess(win32con.PROCESS_ALL_ACCESS, 0, p.pid)\n        except win32api.error as exc:\n            if exc.winerror == 5:\n                log.debug(\"Unable to OpenProcess pid=%d name=%s\", p.pid, p.name())\n                continue\n            raise exc\n        try:\n            access = (\n                win32security.TOKEN_DUPLICATE |\n                win32security.TOKEN_QUERY |\n                win32security.TOKEN_IMPERSONATE |\n                win32security.TOKEN_ASSIGN_PRIMARY\n            )\n            th = win32security.OpenProcessToken(ph, access)\n        except Exception as exc:\n            log.debug(\"OpenProcessToken failed pid=%d name=%s user%s\", p.pid, p.name(), p.username())\n            continue\n        try:\n            process_sid = win32security.GetTokenInformation(th, win32security.TokenUser)[0]\n        except Exception as exc:\n            log.exception(\"GetTokenInformation pid=%d name=%s user%s\", p.pid, p.name(), p.username())\n            continue\n\n        proc_sid = win32security.ConvertSidToStringSid(process_sid)\n        if sid and sid != proc_sid:\n            log.debug(\"Token for pid does not match user sid: %s\", sid)\n            continue\n\n        if session_id and win32security.GetTokenInformation(th, win32security.TokenSessionId) != session_id:\n            continue\n\n        def has_priv(tok, priv):\n            luid = win32security.LookupPrivilegeValue(None, priv)\n            for priv_luid, flags in win32security.GetTokenInformation(tok, win32security.TokenPrivileges):\n                if priv_luid == luid:\n                    return True\n            return False\n        if privs:\n            has_all = True\n            for name in privs:\n                if not has_priv(th, name):\n                    has_all = False\n            if not has_all:\n                continue\n        yield dup_token(th)", "language": "python", "code": "def enumerate_tokens(sid=None, session_id=None, privs=None):\n    '''\n    Enumerate tokens from any existing processes that can be accessed.\n    Optionally filter by sid.\n    '''\n    for p in psutil.process_iter():\n        if p.pid == 0:\n            continue\n        try:\n            ph = win32api.OpenProcess(win32con.PROCESS_ALL_ACCESS, 0, p.pid)\n        except win32api.error as exc:\n            if exc.winerror == 5:\n                log.debug(\"Unable to OpenProcess pid=%d name=%s\", p.pid, p.name())\n                continue\n            raise exc\n        try:\n            access = (\n                win32security.TOKEN_DUPLICATE |\n                win32security.TOKEN_QUERY |\n                win32security.TOKEN_IMPERSONATE |\n                win32security.TOKEN_ASSIGN_PRIMARY\n            )\n            th = win32security.OpenProcessToken(ph, access)\n        except Exception as exc:\n            log.debug(\"OpenProcessToken failed pid=%d name=%s user%s\", p.pid, p.name(), p.username())\n            continue\n        try:\n            process_sid = win32security.GetTokenInformation(th, win32security.TokenUser)[0]\n        except Exception as exc:\n            log.exception(\"GetTokenInformation pid=%d name=%s user%s\", p.pid, p.name(), p.username())\n            continue\n\n        proc_sid = win32security.ConvertSidToStringSid(process_sid)\n        if sid and sid != proc_sid:\n            log.debug(\"Token for pid does not match user sid: %s\", sid)\n            continue\n\n        if session_id and win32security.GetTokenInformation(th, win32security.TokenSessionId) != session_id:\n            continue\n\n        def has_priv(tok, priv):\n            luid = win32security.LookupPrivilegeValue(None, priv)\n            for priv_luid, flags in win32security.GetTokenInformation(tok, win32security.TokenPrivileges):\n                if priv_luid == luid:\n                    return True\n            return False\n        if privs:\n            has_all = True\n            for name in privs:\n                if not has_priv(th, name):\n                    has_all = False\n            if not has_all:\n                continue\n        yield dup_token(th)", "code_tokens": ["def", "enumerate_tokens", "(", "sid", "=", "None", ",", "session_id", "=", "None", ",", "privs", "=", "None", ")", ":", "for", "p", "in", "psutil", ".", "process_iter", "(", ")", ":", "if", "p", ".", "pid", "==", "0", ":", "continue", "try", ":", "ph", "=", "win32api", ".", "OpenProcess", "(", "win32con", ".", "PROCESS_ALL_ACCESS", ",", "0", ",", "p", ".", "pid", ")", "except", "win32api", ".", "error", "as", "exc", ":", "if", "exc", ".", "winerror", "==", "5", ":", "log", ".", "debug", "(", "\"Unable to OpenProcess pid=%d name=%s\"", ",", "p", ".", "pid", ",", "p", ".", "name", "(", ")", ")", "continue", "raise", "exc", "try", ":", "access", "=", "(", "win32security", ".", "TOKEN_DUPLICATE", "|", "win32security", ".", "TOKEN_QUERY", "|", "win32security", ".", "TOKEN_IMPERSONATE", "|", "win32security", ".", "TOKEN_ASSIGN_PRIMARY", ")", "th", "=", "win32security", ".", "OpenProcessToken", "(", "ph", ",", "access", ")", "except", "Exception", "as", "exc", ":", "log", ".", "debug", "(", "\"OpenProcessToken failed pid=%d name=%s user%s\"", ",", "p", ".", "pid", ",", "p", ".", "name", "(", ")", ",", "p", ".", "username", "(", ")", ")", "continue", "try", ":", "process_sid", "=", "win32security", ".", "GetTokenInformation", "(", "th", ",", "win32security", ".", "TokenUser", ")", "[", "0", "]", "except", "Exception", "as", "exc", ":", "log", ".", "exception", "(", "\"GetTokenInformation pid=%d name=%s user%s\"", ",", "p", ".", "pid", ",", "p", ".", "name", "(", ")", ",", "p", ".", "username", "(", ")", ")", "continue", "proc_sid", "=", "win32security", ".", "ConvertSidToStringSid", "(", "process_sid", ")", "if", "sid", "and", "sid", "!=", "proc_sid", ":", "log", ".", "debug", "(", "\"Token for pid does not match user sid: %s\"", ",", "sid", ")", "continue", "if", "session_id", "and", "win32security", ".", "GetTokenInformation", "(", "th", ",", "win32security", ".", "TokenSessionId", ")", "!=", "session_id", ":", "continue", "def", "has_priv", "(", "tok", ",", "priv", ")", ":", "luid", "=", "win32security", ".", "LookupPrivilegeValue", "(", "None", ",", "priv", ")", "for", "priv_luid", ",", "flags", "in", "win32security", ".", "GetTokenInformation", "(", "tok", ",", "win32security", ".", "TokenPrivileges", ")", ":", "if", "priv_luid", "==", "luid", ":", "return", "True", "return", "False", "if", "privs", ":", "has_all", "=", "True", "for", "name", "in", "privs", ":", "if", "not", "has_priv", "(", "th", ",", "name", ")", ":", "has_all", "=", "False", "if", "not", "has_all", ":", "continue", "yield", "dup_token", "(", "th", ")"], "docstring": "Enumerate tokens from any existing processes that can be accessed.\n    Optionally filter by sid.", "docstring_tokens": ["Enumerate", "tokens", "from", "any", "existing", "processes", "that", "can", "be", "accessed", ".", "Optionally", "filter", "by", "sid", "."], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/platform/win.py#L1062-L1115", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/platform/win.py", "func_name": "impersonate_sid", "original_string": "def impersonate_sid(sid, session_id=None, privs=None):\n    '''\n    Find an existing process token for the given sid and impersonate the token.\n    '''\n    for tok in enumerate_tokens(sid, session_id, privs):\n        tok = dup_token(tok)\n        elevate_token(tok)\n        if win32security.ImpersonateLoggedOnUser(tok) == 0:\n            raise WindowsError(\"Impersonation failure\")  # pylint: disable=undefined-variable\n        return tok\n    raise WindowsError(\"Impersonation failure\")", "language": "python", "code": "def impersonate_sid(sid, session_id=None, privs=None):\n    '''\n    Find an existing process token for the given sid and impersonate the token.\n    '''\n    for tok in enumerate_tokens(sid, session_id, privs):\n        tok = dup_token(tok)\n        elevate_token(tok)\n        if win32security.ImpersonateLoggedOnUser(tok) == 0:\n            raise WindowsError(\"Impersonation failure\")  # pylint: disable=undefined-variable\n        return tok\n    raise WindowsError(\"Impersonation failure\")", "code_tokens": ["def", "impersonate_sid", "(", "sid", ",", "session_id", "=", "None", ",", "privs", "=", "None", ")", ":", "for", "tok", "in", "enumerate_tokens", "(", "sid", ",", "session_id", ",", "privs", ")", ":", "tok", "=", "dup_token", "(", "tok", ")", "elevate_token", "(", "tok", ")", "if", "win32security", ".", "ImpersonateLoggedOnUser", "(", "tok", ")", "==", "0", ":", "raise", "WindowsError", "(", "\"Impersonation failure\"", ")", "# pylint: disable=undefined-variable", "return", "tok", "raise", "WindowsError", "(", "\"Impersonation failure\"", ")"], "docstring": "Find an existing process token for the given sid and impersonate the token.", "docstring_tokens": ["Find", "an", "existing", "process", "token", "for", "the", "given", "sid", "and", "impersonate", "the", "token", "."], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/platform/win.py#L1118-L1128", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/platform/win.py", "func_name": "dup_token", "original_string": "def dup_token(th):\n    '''\n    duplicate the access token\n    '''\n    # TODO: is `duplicate_token` the same?\n    sec_attr = win32security.SECURITY_ATTRIBUTES()\n    sec_attr.bInheritHandle = True\n    return win32security.DuplicateTokenEx(\n       th,\n       win32security.SecurityImpersonation,\n       win32con.MAXIMUM_ALLOWED,\n       win32security.TokenPrimary,\n       sec_attr,\n    )", "language": "python", "code": "def dup_token(th):\n    '''\n    duplicate the access token\n    '''\n    # TODO: is `duplicate_token` the same?\n    sec_attr = win32security.SECURITY_ATTRIBUTES()\n    sec_attr.bInheritHandle = True\n    return win32security.DuplicateTokenEx(\n       th,\n       win32security.SecurityImpersonation,\n       win32con.MAXIMUM_ALLOWED,\n       win32security.TokenPrimary,\n       sec_attr,\n    )", "code_tokens": ["def", "dup_token", "(", "th", ")", ":", "# TODO: is `duplicate_token` the same?", "sec_attr", "=", "win32security", ".", "SECURITY_ATTRIBUTES", "(", ")", "sec_attr", ".", "bInheritHandle", "=", "True", "return", "win32security", ".", "DuplicateTokenEx", "(", "th", ",", "win32security", ".", "SecurityImpersonation", ",", "win32con", ".", "MAXIMUM_ALLOWED", ",", "win32security", ".", "TokenPrimary", ",", "sec_attr", ",", ")"], "docstring": "duplicate the access token", "docstring_tokens": ["duplicate", "the", "access", "token"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/platform/win.py#L1131-L1144", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/platform/win.py", "func_name": "elevate_token", "original_string": "def elevate_token(th):\n    '''\n    Set all token priviledges to enabled\n    '''\n    # Get list of privileges this token contains\n    privileges = win32security.GetTokenInformation(\n        th, win32security.TokenPrivileges)\n\n    # Create a set of all privileges to be enabled\n    enable_privs = set()\n    for luid, flags in privileges:\n        enable_privs.add((luid, win32con.SE_PRIVILEGE_ENABLED))\n\n    # Enable the privileges\n    if win32security.AdjustTokenPrivileges(th, 0, enable_privs) == 0:\n        raise WindowsError(win32api.FormatMessage(win32api.GetLastError()))", "language": "python", "code": "def elevate_token(th):\n    '''\n    Set all token priviledges to enabled\n    '''\n    # Get list of privileges this token contains\n    privileges = win32security.GetTokenInformation(\n        th, win32security.TokenPrivileges)\n\n    # Create a set of all privileges to be enabled\n    enable_privs = set()\n    for luid, flags in privileges:\n        enable_privs.add((luid, win32con.SE_PRIVILEGE_ENABLED))\n\n    # Enable the privileges\n    if win32security.AdjustTokenPrivileges(th, 0, enable_privs) == 0:\n        raise WindowsError(win32api.FormatMessage(win32api.GetLastError()))", "code_tokens": ["def", "elevate_token", "(", "th", ")", ":", "# Get list of privileges this token contains", "privileges", "=", "win32security", ".", "GetTokenInformation", "(", "th", ",", "win32security", ".", "TokenPrivileges", ")", "# Create a set of all privileges to be enabled", "enable_privs", "=", "set", "(", ")", "for", "luid", ",", "flags", "in", "privileges", ":", "enable_privs", ".", "add", "(", "(", "luid", ",", "win32con", ".", "SE_PRIVILEGE_ENABLED", ")", ")", "# Enable the privileges", "if", "win32security", ".", "AdjustTokenPrivileges", "(", "th", ",", "0", ",", "enable_privs", ")", "==", "0", ":", "raise", "WindowsError", "(", "win32api", ".", "FormatMessage", "(", "win32api", ".", "GetLastError", "(", ")", ")", ")"], "docstring": "Set all token priviledges to enabled", "docstring_tokens": ["Set", "all", "token", "priviledges", "to", "enabled"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/platform/win.py#L1147-L1162", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/platform/win.py", "func_name": "make_inheritable", "original_string": "def make_inheritable(token):\n    '''Create an inheritable handle'''\n    return win32api.DuplicateHandle(\n        win32api.GetCurrentProcess(),\n        token,\n        win32api.GetCurrentProcess(),\n        0,\n        1,\n        win32con.DUPLICATE_SAME_ACCESS\n    )", "language": "python", "code": "def make_inheritable(token):\n    '''Create an inheritable handle'''\n    return win32api.DuplicateHandle(\n        win32api.GetCurrentProcess(),\n        token,\n        win32api.GetCurrentProcess(),\n        0,\n        1,\n        win32con.DUPLICATE_SAME_ACCESS\n    )", "code_tokens": ["def", "make_inheritable", "(", "token", ")", ":", "return", "win32api", ".", "DuplicateHandle", "(", "win32api", ".", "GetCurrentProcess", "(", ")", ",", "token", ",", "win32api", ".", "GetCurrentProcess", "(", ")", ",", "0", ",", "1", ",", "win32con", ".", "DUPLICATE_SAME_ACCESS", ")"], "docstring": "Create an inheritable handle", "docstring_tokens": ["Create", "an", "inheritable", "handle"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/platform/win.py#L1165-L1174", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/states/boto_cloudfront.py", "func_name": "present", "original_string": "def present(\n    name,\n    config,\n    tags,\n    region=None,\n    key=None,\n    keyid=None,\n    profile=None,\n):\n    '''\n    Ensure the CloudFront distribution is present.\n\n    name (string)\n        Name of the CloudFront distribution\n\n    config (dict)\n        Configuration for the distribution\n\n    tags (dict)\n        Tags to associate with the distribution\n\n    region (string)\n        Region to connect to\n\n    key (string)\n        Secret key to use\n\n    keyid (string)\n        Access key to use\n\n    profile (dict or string)\n        A dict with region, key, and keyid,\n        or a pillar key (string) that contains such a dict.\n\n    Example:\n\n    .. code-block:: yaml\n\n        Manage my_distribution CloudFront distribution:\n            boto_cloudfront.present:\n              - name: my_distribution\n              - config:\n                  Comment: 'partial config shown, most parameters elided'\n                  Enabled: True\n              - tags:\n                  testing_key: testing_value\n    '''\n    ret = {\n        'name': name,\n        'comment': '',\n        'changes': {},\n    }\n\n    res = __salt__['boto_cloudfront.get_distribution'](\n        name,\n        region=region,\n        key=key,\n        keyid=keyid,\n        profile=profile,\n    )\n    if 'error' in res:\n        ret['result'] = False\n        ret['comment'] = 'Error checking distribution {0}: {1}'.format(\n            name,\n            res['error'],\n        )\n        return ret\n\n    old = res['result']\n    if old is None:\n        if __opts__['test']:\n            ret['result'] = None\n            ret['comment'] = 'Distribution {0} set for creation.'.format(name)\n            ret['changes'] = {'old': None, 'new': name}\n            return ret\n\n        res = __salt__['boto_cloudfront.create_distribution'](\n            name,\n            config,\n            tags,\n            region=region,\n            key=key,\n            keyid=keyid,\n            profile=profile,\n        )\n        if 'error' in res:\n            ret['result'] = False\n            ret['comment'] = 'Error creating distribution {0}: {1}'.format(\n                name,\n                res['error'],\n            )\n            return ret\n\n        ret['result'] = True\n        ret['comment'] = 'Created distribution {0}.'.format(name)\n        ret['changes'] = {'old': None, 'new': name}\n        return ret\n    else:\n        full_config_old = {\n            'config': old['distribution']['DistributionConfig'],\n            'tags': old['tags'],\n         }\n        full_config_new = {\n            'config': config,\n            'tags': tags,\n         }\n        diffed_config = __utils__['dictdiffer.deep_diff'](\n            full_config_old,\n            full_config_new,\n        )\n\n        def _yaml_safe_dump(attrs):\n            '''\n            Safely dump YAML using a readable flow style\n            '''\n            dumper_name = 'IndentedSafeOrderedDumper'\n            dumper = __utils__['yaml.get_dumper'](dumper_name)\n            return __utils__['yaml.dump'](\n                attrs,\n                default_flow_style=False,\n                Dumper=dumper)\n\n        changes_diff = ''.join(difflib.unified_diff(\n            _yaml_safe_dump(full_config_old).splitlines(True),\n            _yaml_safe_dump(full_config_new).splitlines(True),\n        ))\n\n        any_changes = bool('old' in diffed_config or 'new' in diffed_config)\n        if not any_changes:\n            ret['result'] = True\n            ret['comment'] = 'Distribution {0} has correct config.'.format(\n                name,\n            )\n            return ret\n\n        if __opts__['test']:\n            ret['result'] = None\n            ret['comment'] = '\\n'.join([\n                'Distribution {0} set for new config:'.format(name),\n                changes_diff,\n            ])\n            ret['changes'] = {'diff': changes_diff}\n            return ret\n\n        res = __salt__['boto_cloudfront.update_distribution'](\n            name,\n            config,\n            tags,\n            region=region,\n            key=key,\n            keyid=keyid,\n            profile=profile,\n        )\n        if 'error' in res:\n            ret['result'] = False\n            ret['comment'] = 'Error updating distribution {0}: {1}'.format(\n                name,\n                res['error'],\n            )\n            return ret\n\n        ret['result'] = True\n        ret['comment'] = 'Updated distribution {0}.'.format(name)\n        ret['changes'] = {'diff': changes_diff}\n        return ret", "language": "python", "code": "def present(\n    name,\n    config,\n    tags,\n    region=None,\n    key=None,\n    keyid=None,\n    profile=None,\n):\n    '''\n    Ensure the CloudFront distribution is present.\n\n    name (string)\n        Name of the CloudFront distribution\n\n    config (dict)\n        Configuration for the distribution\n\n    tags (dict)\n        Tags to associate with the distribution\n\n    region (string)\n        Region to connect to\n\n    key (string)\n        Secret key to use\n\n    keyid (string)\n        Access key to use\n\n    profile (dict or string)\n        A dict with region, key, and keyid,\n        or a pillar key (string) that contains such a dict.\n\n    Example:\n\n    .. code-block:: yaml\n\n        Manage my_distribution CloudFront distribution:\n            boto_cloudfront.present:\n              - name: my_distribution\n              - config:\n                  Comment: 'partial config shown, most parameters elided'\n                  Enabled: True\n              - tags:\n                  testing_key: testing_value\n    '''\n    ret = {\n        'name': name,\n        'comment': '',\n        'changes': {},\n    }\n\n    res = __salt__['boto_cloudfront.get_distribution'](\n        name,\n        region=region,\n        key=key,\n        keyid=keyid,\n        profile=profile,\n    )\n    if 'error' in res:\n        ret['result'] = False\n        ret['comment'] = 'Error checking distribution {0}: {1}'.format(\n            name,\n            res['error'],\n        )\n        return ret\n\n    old = res['result']\n    if old is None:\n        if __opts__['test']:\n            ret['result'] = None\n            ret['comment'] = 'Distribution {0} set for creation.'.format(name)\n            ret['changes'] = {'old': None, 'new': name}\n            return ret\n\n        res = __salt__['boto_cloudfront.create_distribution'](\n            name,\n            config,\n            tags,\n            region=region,\n            key=key,\n            keyid=keyid,\n            profile=profile,\n        )\n        if 'error' in res:\n            ret['result'] = False\n            ret['comment'] = 'Error creating distribution {0}: {1}'.format(\n                name,\n                res['error'],\n            )\n            return ret\n\n        ret['result'] = True\n        ret['comment'] = 'Created distribution {0}.'.format(name)\n        ret['changes'] = {'old': None, 'new': name}\n        return ret\n    else:\n        full_config_old = {\n            'config': old['distribution']['DistributionConfig'],\n            'tags': old['tags'],\n         }\n        full_config_new = {\n            'config': config,\n            'tags': tags,\n         }\n        diffed_config = __utils__['dictdiffer.deep_diff'](\n            full_config_old,\n            full_config_new,\n        )\n\n        def _yaml_safe_dump(attrs):\n            '''\n            Safely dump YAML using a readable flow style\n            '''\n            dumper_name = 'IndentedSafeOrderedDumper'\n            dumper = __utils__['yaml.get_dumper'](dumper_name)\n            return __utils__['yaml.dump'](\n                attrs,\n                default_flow_style=False,\n                Dumper=dumper)\n\n        changes_diff = ''.join(difflib.unified_diff(\n            _yaml_safe_dump(full_config_old).splitlines(True),\n            _yaml_safe_dump(full_config_new).splitlines(True),\n        ))\n\n        any_changes = bool('old' in diffed_config or 'new' in diffed_config)\n        if not any_changes:\n            ret['result'] = True\n            ret['comment'] = 'Distribution {0} has correct config.'.format(\n                name,\n            )\n            return ret\n\n        if __opts__['test']:\n            ret['result'] = None\n            ret['comment'] = '\\n'.join([\n                'Distribution {0} set for new config:'.format(name),\n                changes_diff,\n            ])\n            ret['changes'] = {'diff': changes_diff}\n            return ret\n\n        res = __salt__['boto_cloudfront.update_distribution'](\n            name,\n            config,\n            tags,\n            region=region,\n            key=key,\n            keyid=keyid,\n            profile=profile,\n        )\n        if 'error' in res:\n            ret['result'] = False\n            ret['comment'] = 'Error updating distribution {0}: {1}'.format(\n                name,\n                res['error'],\n            )\n            return ret\n\n        ret['result'] = True\n        ret['comment'] = 'Updated distribution {0}.'.format(name)\n        ret['changes'] = {'diff': changes_diff}\n        return ret", "code_tokens": ["def", "present", "(", "name", ",", "config", ",", "tags", ",", "region", "=", "None", ",", "key", "=", "None", ",", "keyid", "=", "None", ",", "profile", "=", "None", ",", ")", ":", "ret", "=", "{", "'name'", ":", "name", ",", "'comment'", ":", "''", ",", "'changes'", ":", "{", "}", ",", "}", "res", "=", "__salt__", "[", "'boto_cloudfront.get_distribution'", "]", "(", "name", ",", "region", "=", "region", ",", "key", "=", "key", ",", "keyid", "=", "keyid", ",", "profile", "=", "profile", ",", ")", "if", "'error'", "in", "res", ":", "ret", "[", "'result'", "]", "=", "False", "ret", "[", "'comment'", "]", "=", "'Error checking distribution {0}: {1}'", ".", "format", "(", "name", ",", "res", "[", "'error'", "]", ",", ")", "return", "ret", "old", "=", "res", "[", "'result'", "]", "if", "old", "is", "None", ":", "if", "__opts__", "[", "'test'", "]", ":", "ret", "[", "'result'", "]", "=", "None", "ret", "[", "'comment'", "]", "=", "'Distribution {0} set for creation.'", ".", "format", "(", "name", ")", "ret", "[", "'changes'", "]", "=", "{", "'old'", ":", "None", ",", "'new'", ":", "name", "}", "return", "ret", "res", "=", "__salt__", "[", "'boto_cloudfront.create_distribution'", "]", "(", "name", ",", "config", ",", "tags", ",", "region", "=", "region", ",", "key", "=", "key", ",", "keyid", "=", "keyid", ",", "profile", "=", "profile", ",", ")", "if", "'error'", "in", "res", ":", "ret", "[", "'result'", "]", "=", "False", "ret", "[", "'comment'", "]", "=", "'Error creating distribution {0}: {1}'", ".", "format", "(", "name", ",", "res", "[", "'error'", "]", ",", ")", "return", "ret", "ret", "[", "'result'", "]", "=", "True", "ret", "[", "'comment'", "]", "=", "'Created distribution {0}.'", ".", "format", "(", "name", ")", "ret", "[", "'changes'", "]", "=", "{", "'old'", ":", "None", ",", "'new'", ":", "name", "}", "return", "ret", "else", ":", "full_config_old", "=", "{", "'config'", ":", "old", "[", "'distribution'", "]", "[", "'DistributionConfig'", "]", ",", "'tags'", ":", "old", "[", "'tags'", "]", ",", "}", "full_config_new", "=", "{", "'config'", ":", "config", ",", "'tags'", ":", "tags", ",", "}", "diffed_config", "=", "__utils__", "[", "'dictdiffer.deep_diff'", "]", "(", "full_config_old", ",", "full_config_new", ",", ")", "def", "_yaml_safe_dump", "(", "attrs", ")", ":", "'''\n            Safely dump YAML using a readable flow style\n            '''", "dumper_name", "=", "'IndentedSafeOrderedDumper'", "dumper", "=", "__utils__", "[", "'yaml.get_dumper'", "]", "(", "dumper_name", ")", "return", "__utils__", "[", "'yaml.dump'", "]", "(", "attrs", ",", "default_flow_style", "=", "False", ",", "Dumper", "=", "dumper", ")", "changes_diff", "=", "''", ".", "join", "(", "difflib", ".", "unified_diff", "(", "_yaml_safe_dump", "(", "full_config_old", ")", ".", "splitlines", "(", "True", ")", ",", "_yaml_safe_dump", "(", "full_config_new", ")", ".", "splitlines", "(", "True", ")", ",", ")", ")", "any_changes", "=", "bool", "(", "'old'", "in", "diffed_config", "or", "'new'", "in", "diffed_config", ")", "if", "not", "any_changes", ":", "ret", "[", "'result'", "]", "=", "True", "ret", "[", "'comment'", "]", "=", "'Distribution {0} has correct config.'", ".", "format", "(", "name", ",", ")", "return", "ret", "if", "__opts__", "[", "'test'", "]", ":", "ret", "[", "'result'", "]", "=", "None", "ret", "[", "'comment'", "]", "=", "'\\n'", ".", "join", "(", "[", "'Distribution {0} set for new config:'", ".", "format", "(", "name", ")", ",", "changes_diff", ",", "]", ")", "ret", "[", "'changes'", "]", "=", "{", "'diff'", ":", "changes_diff", "}", "return", "ret", "res", "=", "__salt__", "[", "'boto_cloudfront.update_distribution'", "]", "(", "name", ",", "config", ",", "tags", ",", "region", "=", "region", ",", "key", "=", "key", ",", "keyid", "=", "keyid", ",", "profile", "=", "profile", ",", ")", "if", "'error'", "in", "res", ":", "ret", "[", "'result'", "]", "=", "False", "ret", "[", "'comment'", "]", "=", "'Error updating distribution {0}: {1}'", ".", "format", "(", "name", ",", "res", "[", "'error'", "]", ",", ")", "return", "ret", "ret", "[", "'result'", "]", "=", "True", "ret", "[", "'comment'", "]", "=", "'Updated distribution {0}.'", ".", "format", "(", "name", ")", "ret", "[", "'changes'", "]", "=", "{", "'diff'", ":", "changes_diff", "}", "return", "ret"], "docstring": "Ensure the CloudFront distribution is present.\n\n    name (string)\n        Name of the CloudFront distribution\n\n    config (dict)\n        Configuration for the distribution\n\n    tags (dict)\n        Tags to associate with the distribution\n\n    region (string)\n        Region to connect to\n\n    key (string)\n        Secret key to use\n\n    keyid (string)\n        Access key to use\n\n    profile (dict or string)\n        A dict with region, key, and keyid,\n        or a pillar key (string) that contains such a dict.\n\n    Example:\n\n    .. code-block:: yaml\n\n        Manage my_distribution CloudFront distribution:\n            boto_cloudfront.present:\n              - name: my_distribution\n              - config:\n                  Comment: 'partial config shown, most parameters elided'\n                  Enabled: True\n              - tags:\n                  testing_key: testing_value", "docstring_tokens": ["Ensure", "the", "CloudFront", "distribution", "is", "present", "."], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/states/boto_cloudfront.py#L73-L237", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/states/boto_cloudfront.py", "func_name": "_fix_quantities", "original_string": "def _fix_quantities(tree):\n    '''\n    Stupidly simple function to fix any Items/Quantity disparities inside a\n    DistributionConfig block before use. Since AWS only accepts JSON-encodable\n    data types, this implementation is \"good enough\" for our purposes.\n    '''\n    if isinstance(tree, dict):\n        tree = {k: _fix_quantities(v) for k, v in tree.items()}\n        if isinstance(tree.get('Items'), list):\n            tree['Quantity'] = len(tree['Items'])\n            if not tree['Items']:\n                tree.pop('Items')  # Silly, but AWS requires it....\n        return tree\n    elif isinstance(tree, list):\n        return [_fix_quantities(t) for t in tree]\n    else:\n        return tree", "language": "python", "code": "def _fix_quantities(tree):\n    '''\n    Stupidly simple function to fix any Items/Quantity disparities inside a\n    DistributionConfig block before use. Since AWS only accepts JSON-encodable\n    data types, this implementation is \"good enough\" for our purposes.\n    '''\n    if isinstance(tree, dict):\n        tree = {k: _fix_quantities(v) for k, v in tree.items()}\n        if isinstance(tree.get('Items'), list):\n            tree['Quantity'] = len(tree['Items'])\n            if not tree['Items']:\n                tree.pop('Items')  # Silly, but AWS requires it....\n        return tree\n    elif isinstance(tree, list):\n        return [_fix_quantities(t) for t in tree]\n    else:\n        return tree", "code_tokens": ["def", "_fix_quantities", "(", "tree", ")", ":", "if", "isinstance", "(", "tree", ",", "dict", ")", ":", "tree", "=", "{", "k", ":", "_fix_quantities", "(", "v", ")", "for", "k", ",", "v", "in", "tree", ".", "items", "(", ")", "}", "if", "isinstance", "(", "tree", ".", "get", "(", "'Items'", ")", ",", "list", ")", ":", "tree", "[", "'Quantity'", "]", "=", "len", "(", "tree", "[", "'Items'", "]", ")", "if", "not", "tree", "[", "'Items'", "]", ":", "tree", ".", "pop", "(", "'Items'", ")", "# Silly, but AWS requires it....", "return", "tree", "elif", "isinstance", "(", "tree", ",", "list", ")", ":", "return", "[", "_fix_quantities", "(", "t", ")", "for", "t", "in", "tree", "]", "else", ":", "return", "tree"], "docstring": "Stupidly simple function to fix any Items/Quantity disparities inside a\n    DistributionConfig block before use. Since AWS only accepts JSON-encodable\n    data types, this implementation is \"good enough\" for our purposes.", "docstring_tokens": ["Stupidly", "simple", "function", "to", "fix", "any", "Items", "/", "Quantity", "disparities", "inside", "a", "DistributionConfig", "block", "before", "use", ".", "Since", "AWS", "only", "accepts", "JSON", "-", "encodable", "data", "types", "this", "implementation", "is", "good", "enough", "for", "our", "purposes", "."], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/states/boto_cloudfront.py#L240-L256", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/states/boto_cloudfront.py", "func_name": "distribution_present", "original_string": "def distribution_present(name, region=None, key=None, keyid=None, profile=None, **kwargs):\n    '''\n    Ensure the given CloudFront distribution exists in the described state.\n\n    The implementation of this function, and all those following, is orthagonal\n    to that of :py:mod:`boto_cloudfront.present\n    <salt.states.boto_cloudfront.present>`. Resources created with\n    :py:mod:`boto_cloudfront.present <salt.states.boto_cloudfront.present>`\n    will not be correctly managed by this function, as a different method is\n    used to store Salt's state signifier. This function and those following are\n    a suite, designed to work together. As an extra bonus, they correctly\n    process updates of the managed resources, so it is recommended to use them\n    in preference to :py:mod:`boto_cloudfront.present\n    <salt.states.boto_cloudfront.present>` above.\n\n    Note that the semantics of DistributionConfig (below) are rather arcane,\n    and vary wildly depending on whether the distribution already exists or not\n    (e.g. is being initially created, or being updated in place). Many more\n    details can be found here__.\n\n    .. __: https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/distribution-overview-required-fields.html\n\n    name (string)\n        Name of the state definition.\n\n    Name (string)\n        Name of the resource (for purposes of Salt's idempotency). If not\n        provided, the value of ``name`` will be used.\n\n    DistributionConfig (dict)\n        Configuration for the distribution.\n\n        Notes:\n\n        - The CallerReference field should NOT be provided - it will be\n          autopopulated by Salt.\n\n        - A large number of sub- (and sub-sub-) fields require a ``Quantity``\n          element, which simply COUNTS the number of items in the ``Items``\n          element. This is bluntly stupid, so as a convenience, Salt will\n          traverse the provided configuration, and add (or fix) a ``Quantity``\n          element for any ``Items`` elements of list-type it encounters. This\n          adds a bit of sanity to an otherwise error-prone situation. Note\n          that for this to work, zero-length lists must be inlined as ``[]``.\n\n        - Due to the unavailibity of a better way to store stateful idempotency\n          information about Distributions, the Comment sub-element (as the only\n          user-settable attribute without weird self-blocking semantics, and\n          which is available from the core ``get_distribution()`` API call) is\n          utilized to store the Salt state signifier, which is used to\n          determine resource existence and state. That said, to enable **some**\n          usability of this field, only the value up to the first colon\n          character is taken as the signifier, with everything afterward\n          free-form, and ignored (but preserved) by Salt.\n\n    Tags (dict)\n        Tags to associate with the distribution.\n\n    region (string)\n        Region to connect to.\n\n    key (string)\n        Secret key to use.\n\n    keyid (string)\n        Access key to use.\n\n    profile (dict or string)\n        Dict, or pillar key pointing to a dict, containing AWS region/key/keyid.\n\n    Example:\n\n    .. code-block:: yaml\n\n          plt-dev-spaapi-cf-dist-cf_dist-present:\n            boto_cloudfront.distribution_present:\n            - Name: plt-dev-spaapi-cf-dist\n            - DistributionConfig:\n                Comment: SPA\n                Logging:\n                  Enabled: false\n                  Prefix: ''\n                  Bucket: ''\n                  IncludeCookies: false\n                WebACLId: ''\n                Origins:\n                  Items:\n                  - S3OriginConfig:\n                      OriginAccessIdentity: the-SPA-OAI\n                    OriginPath: ''\n                    CustomHeaders:\n                      Items: []\n                    Id: S3-hs-backend-srpms\n                    DomainName: hs-backend-srpms.s3.amazonaws.com\n                PriceClass: PriceClass_All\n                DefaultRootObject: ''\n                Enabled: true\n                DefaultCacheBehavior:\n                  ViewerProtocolPolicy: allow-all\n                  TrustedSigners:\n                    Items: []\n                    Enabled: false\n                  SmoothStreaming: false\n                  TargetOriginId: S3-hs-backend-srpms\n                  FieldLevelEncryptionId: ''\n                  ForwardedValues:\n                    Headers:\n                      Items: []\n                    Cookies:\n                      Forward: none\n                    QueryStringCacheKeys:\n                      Items: []\n                    QueryString: false\n                  MaxTTL: 31536000\n                  LambdaFunctionAssociations:\n                    Items: []\n                  DefaultTTL: 86400\n                  AllowedMethods:\n                    CachedMethods:\n                      Items:\n                      - HEAD\n                      - GET\n                    Items:\n                    - HEAD\n                    - GET\n                  MinTTL: 0\n                  Compress: false\n                IsIPV6Enabled: true\n                ViewerCertificate:\n                  CloudFrontDefaultCertificate: true\n                  MinimumProtocolVersion: TLSv1\n                  CertificateSource: cloudfront\n                Aliases:\n                  Items:\n                  - bubba-hotep.bodhi-dev.io\n                HttpVersion: http2\n            - Tags:\n                Owner: dev_engrs\n\n    '''\n    ret = {'name': name, 'result': True, 'comment': '', 'changes': {}}\n    kwargs = {k: v for k, v in kwargs.items() if not k.startswith('_')}\n    authargs = {'region': region, 'key': key, 'keyid': keyid, 'profile': profile}\n    Name = kwargs.pop('Name', name)\n    Tags = kwargs.pop('Tags', None)\n    DistributionConfig = kwargs.get('DistributionConfig', {})\n\n    ## Sub-element munging on config data should go in here, before we proceed:\n    #  For instance, origin access identities must be of the form\n    #  `origin-access-identity/cloudfront/ID-of-origin-access-identity`, but we can't really\n    #  know that ID apriori, so any OAI state names inside the config data must be resolved\n    #  and converted into that format before submission. Be aware that the `state names` of\n    #  salt managed OAIs are stored in their Comment fields for lack of any better place...\n    for item in range(len(DistributionConfig.get('Origins', {}).get('Items', []))):\n        oai = DistributionConfig['Origins']['Items'][item].get('S3OriginConfig',\n                                                   {}).get('OriginAccessIdentity', '')\n        if oai and not oai.startswith('origin-access-identity/cloudfront/'):\n            res = __salt__['boto_cloudfront.get_cloud_front_origin_access_identities_by_comment'](\n                    Comment=oai, region=region, key=key, keyid=keyid, profile=profile)\n            if res is None:  # An error occurred, bubble it up...\n                log.warning('Error encountered while trying to determine the Resource ID of'\n                            ' CloudFront origin access identity `%s`.  Passing as-is.', oai)\n            elif not res:\n                log.warning('Failed to determine the Resource ID of CloudFront origin access'\n                            ' identity `%s`.  Passing as-is.', oai)\n            elif len(res) > 1:\n                log.warning('Failed to find unique Resource ID for CloudFront origin access'\n                            ' identity `%s`.  Passing as-is.', oai)\n            else:\n                # One unique OAI resource found -- deref and replace it...\n                new = 'origin-access-identity/cloudfront/{}'.format(res[0]['Id'])\n                DistributionConfig['Origins']['Items'][item]['S3OriginConfig']['OriginAccessIdentity'] = new\n    # Munge Name into the Comment field...\n    DistributionConfig['Comment'] = '{}:{}'.format(Name, DistributionConfig['Comment']) \\\n            if DistributionConfig.get('Comment') else Name\n\n    # Fix up any missing (or wrong) Quantity sub-elements...\n    DistributionConfig = _fix_quantities(DistributionConfig)\n    kwargs['DistributionConfig'] = DistributionConfig\n\n    # Current state of the thing?\n    res = __salt__['boto_cloudfront.get_distributions_by_comment'](Comment=Name, region=region,\n            key=key, keyid=keyid, profile=profile)\n    if res is None:\n        msg = 'Error determining current state of distribution `{}`.'.format(Name)\n        log.error(msg)\n        ret['comment'] = msg\n        ret['result'] = False\n        return ret\n    if len(res) > 1:\n        msg = 'Multiple CloudFront distibutions matched `{}`.'.format(Name)\n        log.error(msg)\n        ret['comment'] = msg\n        ret['result'] = False\n        return ret\n\n    # Luckily, the `DistributionConfig` structure returned by `get_distribution()` (as a sub-\n    # element of `Distribution`) is identical to that returned by `get_distribution_config(),\n    # and as a bonus, the ETag's are ALSO compatible...\n    # Since \"updates\" are actually \"replace everything from scratch\" events, this implies that\n    # it's enough to simply determine SOME update is necessary to trigger one, rather than\n    # exhaustively calculating all changes needed - this makes life MUCH EASIER :)\n    # Thus our workflow here is:\n    # - check if the distribution exists\n    # - if it doesn't, create it fresh with the requested DistributionConfig, and Tag it if needed\n    # - if it does, grab its ETag, and TWO copies of the current DistributionConfig\n    # - merge the requested DistributionConfig on top of one of them\n    # - compare the copy we just merged against the one we didn't\n    # - if they differ, send the merged copy, along with the ETag we got, back as an update\n    # - lastly, verify and set/unset any Tags which may need changing...\n    exists = bool(res)\n    if not exists:\n        if 'CallerReference' not in kwargs['DistributionConfig']:\n            kwargs['DistributionConfig']['CallerReference'] = str(uuid.uuid4())\n        if __opts__['test']:\n            ret['result'] = None\n            ret['comment'] = 'CloudFront distribution `{}` would be created.'.format(Name)\n            new = {'DistributionConfig': kwargs['DistributionConfig']}\n            new.update({'Tags': Tags}) if Tags else None\n            ret['pchanges'] = {'old': None, 'new': new}\n            return ret\n        kwargs.update(authargs)\n        comments = []\n        res = __salt__['boto_cloudfront.create_distribution_v2'](**kwargs)\n        if res is None:\n            ret['result'] = False\n            msg = 'Error occurred while creating distribution `{}`.'.format(Name)\n            log.error(msg)\n            ret['comment'] = msg\n            return ret\n        new = {'DistributionConfig': res['Distribution']['DistributionConfig']}\n        comments += ['Created distribution `{}`.'.format(Name)]\n        newARN = res.get('Distribution', {}).get('ARN')\n        tagged = __salt__['boto_cloudfront.tag_resource'](Tags=Tags, **authargs)\n        if tagged is False:\n            ret['result'] = False\n            msg = 'Error occurred while tagging distribution `{}`.'.format(Name)\n            log.error(msg)\n            comments += [msg]\n            ret['comment'] = '  '.join(comments)\n            return ret\n        comments += ['Tagged distribution `{}`.'.format(Name)]\n        new['Tags'] = Tags\n        ret['comment'] = '  '.join(comments)\n        ret['changes'] = {'old': None, 'new': new}\n        return ret\n    else:\n        currentId = res[0]['Id']\n        current = __salt__['boto_cloudfront.get_distribution_v2'](Id=currentId, **authargs)\n        # Insanely unlikely given that we JUST got back this Id from the previous search, but....\n        if not current:\n            msg = 'Failed to lookup CloudFront distribution with Id `{}`.'.format(currentId)\n            log.error(msg)\n            ret['comment'] = msg\n            ret['result'] = False\n            return ret\n        currentDC = current['Distribution']['DistributionConfig']\n        currentARN = current['Distribution']['ARN']\n        currentETag = current['ETag']\n        currentTags = __salt__['boto_cloudfront.list_tags_for_resource'](Resource=currentARN,\n                                                                         **authargs)\n        copyOne = copy.deepcopy(currentDC)\n        copyTwo = copy.deepcopy(currentDC)\n        copyTwo.update(kwargs['DistributionConfig'])\n        correct = __utils__['boto3.json_objs_equal'](copyOne, copyTwo)\n        tags_correct = (currentTags == Tags)\n        comments = []\n        old = {}\n        new = {}\n\n        if correct and tags_correct:\n            ret['comment'] = 'CloudFront distribution `{}` is in the correct state.'.format(Name)\n            return ret\n        if __opts__['test']:\n            ret['result'] = None\n            if not correct:\n                comments += ['CloudFront distribution `{}` config would be updated.'.format(Name)]\n                old['DistributionConfig'] = copyOne\n                new['DistributionConfig'] = copyTwo\n            if not tags_correct:\n                comments += ['CloudFront distribution `{}` Tags would be updated.'.format(Name)]\n                old['Tags'] = currentTags\n                new['Tags'] = Tags\n            ret['comment'] = '  '.join(comments)\n            ret['pchanges'] = {'old': old, 'new': new}\n            return ret\n        if not correct:\n            kwargs = {'DistributionConfig': copyTwo, 'Id': currentId, 'IfMatch': currentETag}\n            kwargs.update(authargs)\n            log.debug('Calling `boto_cloudfront.update_distribution_v2()` with **kwargs =='\n                      ' %s', kwargs)\n            res = __salt__['boto_cloudfront.update_distribution_v2'](**kwargs)\n            if res is None:\n                ret['result'] = False\n                msg = 'Error occurred while updating distribution `{}`.'.format(Name)\n                log.error(msg)\n                ret['comment'] = msg\n                return ret\n            old['DistributionConfig'] = copyOne\n            new['DistributionConfig'] = res['Distribution']['DistributionConfig']\n            comments += ['CloudFront distribution `{}` config updated.'.format(Name)]\n        if not tags_correct:\n            tagged = __salt__['boto_cloudfront.enforce_tags'](Resource=currentARN, Tags=Tags,\n                    **authargs)\n            if tagged is False:\n                ret['result'] = False\n                msg = 'Error occurred while updating Tags on distribution `{}`.'.format(Name)\n                log.error(msg)\n                comments += [msg]\n                ret['comment'] = '  '.join(comments)\n                return ret\n            comments += ['CloudFront distribution `{}` Tags updated.'.format(Name)]\n            old['Tags'] = currentTags\n            new['Tags'] = Tags\n        ret['comment'] = '  '.join(comments)\n        ret['changes'] = {'old': old, 'new': new}\n        return ret", "language": "python", "code": "def distribution_present(name, region=None, key=None, keyid=None, profile=None, **kwargs):\n    '''\n    Ensure the given CloudFront distribution exists in the described state.\n\n    The implementation of this function, and all those following, is orthagonal\n    to that of :py:mod:`boto_cloudfront.present\n    <salt.states.boto_cloudfront.present>`. Resources created with\n    :py:mod:`boto_cloudfront.present <salt.states.boto_cloudfront.present>`\n    will not be correctly managed by this function, as a different method is\n    used to store Salt's state signifier. This function and those following are\n    a suite, designed to work together. As an extra bonus, they correctly\n    process updates of the managed resources, so it is recommended to use them\n    in preference to :py:mod:`boto_cloudfront.present\n    <salt.states.boto_cloudfront.present>` above.\n\n    Note that the semantics of DistributionConfig (below) are rather arcane,\n    and vary wildly depending on whether the distribution already exists or not\n    (e.g. is being initially created, or being updated in place). Many more\n    details can be found here__.\n\n    .. __: https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/distribution-overview-required-fields.html\n\n    name (string)\n        Name of the state definition.\n\n    Name (string)\n        Name of the resource (for purposes of Salt's idempotency). If not\n        provided, the value of ``name`` will be used.\n\n    DistributionConfig (dict)\n        Configuration for the distribution.\n\n        Notes:\n\n        - The CallerReference field should NOT be provided - it will be\n          autopopulated by Salt.\n\n        - A large number of sub- (and sub-sub-) fields require a ``Quantity``\n          element, which simply COUNTS the number of items in the ``Items``\n          element. This is bluntly stupid, so as a convenience, Salt will\n          traverse the provided configuration, and add (or fix) a ``Quantity``\n          element for any ``Items`` elements of list-type it encounters. This\n          adds a bit of sanity to an otherwise error-prone situation. Note\n          that for this to work, zero-length lists must be inlined as ``[]``.\n\n        - Due to the unavailibity of a better way to store stateful idempotency\n          information about Distributions, the Comment sub-element (as the only\n          user-settable attribute without weird self-blocking semantics, and\n          which is available from the core ``get_distribution()`` API call) is\n          utilized to store the Salt state signifier, which is used to\n          determine resource existence and state. That said, to enable **some**\n          usability of this field, only the value up to the first colon\n          character is taken as the signifier, with everything afterward\n          free-form, and ignored (but preserved) by Salt.\n\n    Tags (dict)\n        Tags to associate with the distribution.\n\n    region (string)\n        Region to connect to.\n\n    key (string)\n        Secret key to use.\n\n    keyid (string)\n        Access key to use.\n\n    profile (dict or string)\n        Dict, or pillar key pointing to a dict, containing AWS region/key/keyid.\n\n    Example:\n\n    .. code-block:: yaml\n\n          plt-dev-spaapi-cf-dist-cf_dist-present:\n            boto_cloudfront.distribution_present:\n            - Name: plt-dev-spaapi-cf-dist\n            - DistributionConfig:\n                Comment: SPA\n                Logging:\n                  Enabled: false\n                  Prefix: ''\n                  Bucket: ''\n                  IncludeCookies: false\n                WebACLId: ''\n                Origins:\n                  Items:\n                  - S3OriginConfig:\n                      OriginAccessIdentity: the-SPA-OAI\n                    OriginPath: ''\n                    CustomHeaders:\n                      Items: []\n                    Id: S3-hs-backend-srpms\n                    DomainName: hs-backend-srpms.s3.amazonaws.com\n                PriceClass: PriceClass_All\n                DefaultRootObject: ''\n                Enabled: true\n                DefaultCacheBehavior:\n                  ViewerProtocolPolicy: allow-all\n                  TrustedSigners:\n                    Items: []\n                    Enabled: false\n                  SmoothStreaming: false\n                  TargetOriginId: S3-hs-backend-srpms\n                  FieldLevelEncryptionId: ''\n                  ForwardedValues:\n                    Headers:\n                      Items: []\n                    Cookies:\n                      Forward: none\n                    QueryStringCacheKeys:\n                      Items: []\n                    QueryString: false\n                  MaxTTL: 31536000\n                  LambdaFunctionAssociations:\n                    Items: []\n                  DefaultTTL: 86400\n                  AllowedMethods:\n                    CachedMethods:\n                      Items:\n                      - HEAD\n                      - GET\n                    Items:\n                    - HEAD\n                    - GET\n                  MinTTL: 0\n                  Compress: false\n                IsIPV6Enabled: true\n                ViewerCertificate:\n                  CloudFrontDefaultCertificate: true\n                  MinimumProtocolVersion: TLSv1\n                  CertificateSource: cloudfront\n                Aliases:\n                  Items:\n                  - bubba-hotep.bodhi-dev.io\n                HttpVersion: http2\n            - Tags:\n                Owner: dev_engrs\n\n    '''\n    ret = {'name': name, 'result': True, 'comment': '', 'changes': {}}\n    kwargs = {k: v for k, v in kwargs.items() if not k.startswith('_')}\n    authargs = {'region': region, 'key': key, 'keyid': keyid, 'profile': profile}\n    Name = kwargs.pop('Name', name)\n    Tags = kwargs.pop('Tags', None)\n    DistributionConfig = kwargs.get('DistributionConfig', {})\n\n    ## Sub-element munging on config data should go in here, before we proceed:\n    #  For instance, origin access identities must be of the form\n    #  `origin-access-identity/cloudfront/ID-of-origin-access-identity`, but we can't really\n    #  know that ID apriori, so any OAI state names inside the config data must be resolved\n    #  and converted into that format before submission. Be aware that the `state names` of\n    #  salt managed OAIs are stored in their Comment fields for lack of any better place...\n    for item in range(len(DistributionConfig.get('Origins', {}).get('Items', []))):\n        oai = DistributionConfig['Origins']['Items'][item].get('S3OriginConfig',\n                                                   {}).get('OriginAccessIdentity', '')\n        if oai and not oai.startswith('origin-access-identity/cloudfront/'):\n            res = __salt__['boto_cloudfront.get_cloud_front_origin_access_identities_by_comment'](\n                    Comment=oai, region=region, key=key, keyid=keyid, profile=profile)\n            if res is None:  # An error occurred, bubble it up...\n                log.warning('Error encountered while trying to determine the Resource ID of'\n                            ' CloudFront origin access identity `%s`.  Passing as-is.', oai)\n            elif not res:\n                log.warning('Failed to determine the Resource ID of CloudFront origin access'\n                            ' identity `%s`.  Passing as-is.', oai)\n            elif len(res) > 1:\n                log.warning('Failed to find unique Resource ID for CloudFront origin access'\n                            ' identity `%s`.  Passing as-is.', oai)\n            else:\n                # One unique OAI resource found -- deref and replace it...\n                new = 'origin-access-identity/cloudfront/{}'.format(res[0]['Id'])\n                DistributionConfig['Origins']['Items'][item]['S3OriginConfig']['OriginAccessIdentity'] = new\n    # Munge Name into the Comment field...\n    DistributionConfig['Comment'] = '{}:{}'.format(Name, DistributionConfig['Comment']) \\\n            if DistributionConfig.get('Comment') else Name\n\n    # Fix up any missing (or wrong) Quantity sub-elements...\n    DistributionConfig = _fix_quantities(DistributionConfig)\n    kwargs['DistributionConfig'] = DistributionConfig\n\n    # Current state of the thing?\n    res = __salt__['boto_cloudfront.get_distributions_by_comment'](Comment=Name, region=region,\n            key=key, keyid=keyid, profile=profile)\n    if res is None:\n        msg = 'Error determining current state of distribution `{}`.'.format(Name)\n        log.error(msg)\n        ret['comment'] = msg\n        ret['result'] = False\n        return ret\n    if len(res) > 1:\n        msg = 'Multiple CloudFront distibutions matched `{}`.'.format(Name)\n        log.error(msg)\n        ret['comment'] = msg\n        ret['result'] = False\n        return ret\n\n    # Luckily, the `DistributionConfig` structure returned by `get_distribution()` (as a sub-\n    # element of `Distribution`) is identical to that returned by `get_distribution_config(),\n    # and as a bonus, the ETag's are ALSO compatible...\n    # Since \"updates\" are actually \"replace everything from scratch\" events, this implies that\n    # it's enough to simply determine SOME update is necessary to trigger one, rather than\n    # exhaustively calculating all changes needed - this makes life MUCH EASIER :)\n    # Thus our workflow here is:\n    # - check if the distribution exists\n    # - if it doesn't, create it fresh with the requested DistributionConfig, and Tag it if needed\n    # - if it does, grab its ETag, and TWO copies of the current DistributionConfig\n    # - merge the requested DistributionConfig on top of one of them\n    # - compare the copy we just merged against the one we didn't\n    # - if they differ, send the merged copy, along with the ETag we got, back as an update\n    # - lastly, verify and set/unset any Tags which may need changing...\n    exists = bool(res)\n    if not exists:\n        if 'CallerReference' not in kwargs['DistributionConfig']:\n            kwargs['DistributionConfig']['CallerReference'] = str(uuid.uuid4())\n        if __opts__['test']:\n            ret['result'] = None\n            ret['comment'] = 'CloudFront distribution `{}` would be created.'.format(Name)\n            new = {'DistributionConfig': kwargs['DistributionConfig']}\n            new.update({'Tags': Tags}) if Tags else None\n            ret['pchanges'] = {'old': None, 'new': new}\n            return ret\n        kwargs.update(authargs)\n        comments = []\n        res = __salt__['boto_cloudfront.create_distribution_v2'](**kwargs)\n        if res is None:\n            ret['result'] = False\n            msg = 'Error occurred while creating distribution `{}`.'.format(Name)\n            log.error(msg)\n            ret['comment'] = msg\n            return ret\n        new = {'DistributionConfig': res['Distribution']['DistributionConfig']}\n        comments += ['Created distribution `{}`.'.format(Name)]\n        newARN = res.get('Distribution', {}).get('ARN')\n        tagged = __salt__['boto_cloudfront.tag_resource'](Tags=Tags, **authargs)\n        if tagged is False:\n            ret['result'] = False\n            msg = 'Error occurred while tagging distribution `{}`.'.format(Name)\n            log.error(msg)\n            comments += [msg]\n            ret['comment'] = '  '.join(comments)\n            return ret\n        comments += ['Tagged distribution `{}`.'.format(Name)]\n        new['Tags'] = Tags\n        ret['comment'] = '  '.join(comments)\n        ret['changes'] = {'old': None, 'new': new}\n        return ret\n    else:\n        currentId = res[0]['Id']\n        current = __salt__['boto_cloudfront.get_distribution_v2'](Id=currentId, **authargs)\n        # Insanely unlikely given that we JUST got back this Id from the previous search, but....\n        if not current:\n            msg = 'Failed to lookup CloudFront distribution with Id `{}`.'.format(currentId)\n            log.error(msg)\n            ret['comment'] = msg\n            ret['result'] = False\n            return ret\n        currentDC = current['Distribution']['DistributionConfig']\n        currentARN = current['Distribution']['ARN']\n        currentETag = current['ETag']\n        currentTags = __salt__['boto_cloudfront.list_tags_for_resource'](Resource=currentARN,\n                                                                         **authargs)\n        copyOne = copy.deepcopy(currentDC)\n        copyTwo = copy.deepcopy(currentDC)\n        copyTwo.update(kwargs['DistributionConfig'])\n        correct = __utils__['boto3.json_objs_equal'](copyOne, copyTwo)\n        tags_correct = (currentTags == Tags)\n        comments = []\n        old = {}\n        new = {}\n\n        if correct and tags_correct:\n            ret['comment'] = 'CloudFront distribution `{}` is in the correct state.'.format(Name)\n            return ret\n        if __opts__['test']:\n            ret['result'] = None\n            if not correct:\n                comments += ['CloudFront distribution `{}` config would be updated.'.format(Name)]\n                old['DistributionConfig'] = copyOne\n                new['DistributionConfig'] = copyTwo\n            if not tags_correct:\n                comments += ['CloudFront distribution `{}` Tags would be updated.'.format(Name)]\n                old['Tags'] = currentTags\n                new['Tags'] = Tags\n            ret['comment'] = '  '.join(comments)\n            ret['pchanges'] = {'old': old, 'new': new}\n            return ret\n        if not correct:\n            kwargs = {'DistributionConfig': copyTwo, 'Id': currentId, 'IfMatch': currentETag}\n            kwargs.update(authargs)\n            log.debug('Calling `boto_cloudfront.update_distribution_v2()` with **kwargs =='\n                      ' %s', kwargs)\n            res = __salt__['boto_cloudfront.update_distribution_v2'](**kwargs)\n            if res is None:\n                ret['result'] = False\n                msg = 'Error occurred while updating distribution `{}`.'.format(Name)\n                log.error(msg)\n                ret['comment'] = msg\n                return ret\n            old['DistributionConfig'] = copyOne\n            new['DistributionConfig'] = res['Distribution']['DistributionConfig']\n            comments += ['CloudFront distribution `{}` config updated.'.format(Name)]\n        if not tags_correct:\n            tagged = __salt__['boto_cloudfront.enforce_tags'](Resource=currentARN, Tags=Tags,\n                    **authargs)\n            if tagged is False:\n                ret['result'] = False\n                msg = 'Error occurred while updating Tags on distribution `{}`.'.format(Name)\n                log.error(msg)\n                comments += [msg]\n                ret['comment'] = '  '.join(comments)\n                return ret\n            comments += ['CloudFront distribution `{}` Tags updated.'.format(Name)]\n            old['Tags'] = currentTags\n            new['Tags'] = Tags\n        ret['comment'] = '  '.join(comments)\n        ret['changes'] = {'old': old, 'new': new}\n        return ret", "code_tokens": ["def", "distribution_present", "(", "name", ",", "region", "=", "None", ",", "key", "=", "None", ",", "keyid", "=", "None", ",", "profile", "=", "None", ",", "*", "*", "kwargs", ")", ":", "ret", "=", "{", "'name'", ":", "name", ",", "'result'", ":", "True", ",", "'comment'", ":", "''", ",", "'changes'", ":", "{", "}", "}", "kwargs", "=", "{", "k", ":", "v", "for", "k", ",", "v", "in", "kwargs", ".", "items", "(", ")", "if", "not", "k", ".", "startswith", "(", "'_'", ")", "}", "authargs", "=", "{", "'region'", ":", "region", ",", "'key'", ":", "key", ",", "'keyid'", ":", "keyid", ",", "'profile'", ":", "profile", "}", "Name", "=", "kwargs", ".", "pop", "(", "'Name'", ",", "name", ")", "Tags", "=", "kwargs", ".", "pop", "(", "'Tags'", ",", "None", ")", "DistributionConfig", "=", "kwargs", ".", "get", "(", "'DistributionConfig'", ",", "{", "}", ")", "## Sub-element munging on config data should go in here, before we proceed:", "#  For instance, origin access identities must be of the form", "#  `origin-access-identity/cloudfront/ID-of-origin-access-identity`, but we can't really", "#  know that ID apriori, so any OAI state names inside the config data must be resolved", "#  and converted into that format before submission. Be aware that the `state names` of", "#  salt managed OAIs are stored in their Comment fields for lack of any better place...", "for", "item", "in", "range", "(", "len", "(", "DistributionConfig", ".", "get", "(", "'Origins'", ",", "{", "}", ")", ".", "get", "(", "'Items'", ",", "[", "]", ")", ")", ")", ":", "oai", "=", "DistributionConfig", "[", "'Origins'", "]", "[", "'Items'", "]", "[", "item", "]", ".", "get", "(", "'S3OriginConfig'", ",", "{", "}", ")", ".", "get", "(", "'OriginAccessIdentity'", ",", "''", ")", "if", "oai", "and", "not", "oai", ".", "startswith", "(", "'origin-access-identity/cloudfront/'", ")", ":", "res", "=", "__salt__", "[", "'boto_cloudfront.get_cloud_front_origin_access_identities_by_comment'", "]", "(", "Comment", "=", "oai", ",", "region", "=", "region", ",", "key", "=", "key", ",", "keyid", "=", "keyid", ",", "profile", "=", "profile", ")", "if", "res", "is", "None", ":", "# An error occurred, bubble it up...", "log", ".", "warning", "(", "'Error encountered while trying to determine the Resource ID of'", "' CloudFront origin access identity `%s`.  Passing as-is.'", ",", "oai", ")", "elif", "not", "res", ":", "log", ".", "warning", "(", "'Failed to determine the Resource ID of CloudFront origin access'", "' identity `%s`.  Passing as-is.'", ",", "oai", ")", "elif", "len", "(", "res", ")", ">", "1", ":", "log", ".", "warning", "(", "'Failed to find unique Resource ID for CloudFront origin access'", "' identity `%s`.  Passing as-is.'", ",", "oai", ")", "else", ":", "# One unique OAI resource found -- deref and replace it...", "new", "=", "'origin-access-identity/cloudfront/{}'", ".", "format", "(", "res", "[", "0", "]", "[", "'Id'", "]", ")", "DistributionConfig", "[", "'Origins'", "]", "[", "'Items'", "]", "[", "item", "]", "[", "'S3OriginConfig'", "]", "[", "'OriginAccessIdentity'", "]", "=", "new", "# Munge Name into the Comment field...", "DistributionConfig", "[", "'Comment'", "]", "=", "'{}:{}'", ".", "format", "(", "Name", ",", "DistributionConfig", "[", "'Comment'", "]", ")", "if", "DistributionConfig", ".", "get", "(", "'Comment'", ")", "else", "Name", "# Fix up any missing (or wrong) Quantity sub-elements...", "DistributionConfig", "=", "_fix_quantities", "(", "DistributionConfig", ")", "kwargs", "[", "'DistributionConfig'", "]", "=", "DistributionConfig", "# Current state of the thing?", "res", "=", "__salt__", "[", "'boto_cloudfront.get_distributions_by_comment'", "]", "(", "Comment", "=", "Name", ",", "region", "=", "region", ",", "key", "=", "key", ",", "keyid", "=", "keyid", ",", "profile", "=", "profile", ")", "if", "res", "is", "None", ":", "msg", "=", "'Error determining current state of distribution `{}`.'", ".", "format", "(", "Name", ")", "log", ".", "error", "(", "msg", ")", "ret", "[", "'comment'", "]", "=", "msg", "ret", "[", "'result'", "]", "=", "False", "return", "ret", "if", "len", "(", "res", ")", ">", "1", ":", "msg", "=", "'Multiple CloudFront distibutions matched `{}`.'", ".", "format", "(", "Name", ")", "log", ".", "error", "(", "msg", ")", "ret", "[", "'comment'", "]", "=", "msg", "ret", "[", "'result'", "]", "=", "False", "return", "ret", "# Luckily, the `DistributionConfig` structure returned by `get_distribution()` (as a sub-", "# element of `Distribution`) is identical to that returned by `get_distribution_config(),", "# and as a bonus, the ETag's are ALSO compatible...", "# Since \"updates\" are actually \"replace everything from scratch\" events, this implies that", "# it's enough to simply determine SOME update is necessary to trigger one, rather than", "# exhaustively calculating all changes needed - this makes life MUCH EASIER :)", "# Thus our workflow here is:", "# - check if the distribution exists", "# - if it doesn't, create it fresh with the requested DistributionConfig, and Tag it if needed", "# - if it does, grab its ETag, and TWO copies of the current DistributionConfig", "# - merge the requested DistributionConfig on top of one of them", "# - compare the copy we just merged against the one we didn't", "# - if they differ, send the merged copy, along with the ETag we got, back as an update", "# - lastly, verify and set/unset any Tags which may need changing...", "exists", "=", "bool", "(", "res", ")", "if", "not", "exists", ":", "if", "'CallerReference'", "not", "in", "kwargs", "[", "'DistributionConfig'", "]", ":", "kwargs", "[", "'DistributionConfig'", "]", "[", "'CallerReference'", "]", "=", "str", "(", "uuid", ".", "uuid4", "(", ")", ")", "if", "__opts__", "[", "'test'", "]", ":", "ret", "[", "'result'", "]", "=", "None", "ret", "[", "'comment'", "]", "=", "'CloudFront distribution `{}` would be created.'", ".", "format", "(", "Name", ")", "new", "=", "{", "'DistributionConfig'", ":", "kwargs", "[", "'DistributionConfig'", "]", "}", "new", ".", "update", "(", "{", "'Tags'", ":", "Tags", "}", ")", "if", "Tags", "else", "None", "ret", "[", "'pchanges'", "]", "=", "{", "'old'", ":", "None", ",", "'new'", ":", "new", "}", "return", "ret", "kwargs", ".", "update", "(", "authargs", ")", "comments", "=", "[", "]", "res", "=", "__salt__", "[", "'boto_cloudfront.create_distribution_v2'", "]", "(", "*", "*", "kwargs", ")", "if", "res", "is", "None", ":", "ret", "[", "'result'", "]", "=", "False", "msg", "=", "'Error occurred while creating distribution `{}`.'", ".", "format", "(", "Name", ")", "log", ".", "error", "(", "msg", ")", "ret", "[", "'comment'", "]", "=", "msg", "return", "ret", "new", "=", "{", "'DistributionConfig'", ":", "res", "[", "'Distribution'", "]", "[", "'DistributionConfig'", "]", "}", "comments", "+=", "[", "'Created distribution `{}`.'", ".", "format", "(", "Name", ")", "]", "newARN", "=", "res", ".", "get", "(", "'Distribution'", ",", "{", "}", ")", ".", "get", "(", "'ARN'", ")", "tagged", "=", "__salt__", "[", "'boto_cloudfront.tag_resource'", "]", "(", "Tags", "=", "Tags", ",", "*", "*", "authargs", ")", "if", "tagged", "is", "False", ":", "ret", "[", "'result'", "]", "=", "False", "msg", "=", "'Error occurred while tagging distribution `{}`.'", ".", "format", "(", "Name", ")", "log", ".", "error", "(", "msg", ")", "comments", "+=", "[", "msg", "]", "ret", "[", "'comment'", "]", "=", "'  '", ".", "join", "(", "comments", ")", "return", "ret", "comments", "+=", "[", "'Tagged distribution `{}`.'", ".", "format", "(", "Name", ")", "]", "new", "[", "'Tags'", "]", "=", "Tags", "ret", "[", "'comment'", "]", "=", "'  '", ".", "join", "(", "comments", ")", "ret", "[", "'changes'", "]", "=", "{", "'old'", ":", "None", ",", "'new'", ":", "new", "}", "return", "ret", "else", ":", "currentId", "=", "res", "[", "0", "]", "[", "'Id'", "]", "current", "=", "__salt__", "[", "'boto_cloudfront.get_distribution_v2'", "]", "(", "Id", "=", "currentId", ",", "*", "*", "authargs", ")", "# Insanely unlikely given that we JUST got back this Id from the previous search, but....", "if", "not", "current", ":", "msg", "=", "'Failed to lookup CloudFront distribution with Id `{}`.'", ".", "format", "(", "currentId", ")", "log", ".", "error", "(", "msg", ")", "ret", "[", "'comment'", "]", "=", "msg", "ret", "[", "'result'", "]", "=", "False", "return", "ret", "currentDC", "=", "current", "[", "'Distribution'", "]", "[", "'DistributionConfig'", "]", "currentARN", "=", "current", "[", "'Distribution'", "]", "[", "'ARN'", "]", "currentETag", "=", "current", "[", "'ETag'", "]", "currentTags", "=", "__salt__", "[", "'boto_cloudfront.list_tags_for_resource'", "]", "(", "Resource", "=", "currentARN", ",", "*", "*", "authargs", ")", "copyOne", "=", "copy", ".", "deepcopy", "(", "currentDC", ")", "copyTwo", "=", "copy", ".", "deepcopy", "(", "currentDC", ")", "copyTwo", ".", "update", "(", "kwargs", "[", "'DistributionConfig'", "]", ")", "correct", "=", "__utils__", "[", "'boto3.json_objs_equal'", "]", "(", "copyOne", ",", "copyTwo", ")", "tags_correct", "=", "(", "currentTags", "==", "Tags", ")", "comments", "=", "[", "]", "old", "=", "{", "}", "new", "=", "{", "}", "if", "correct", "and", "tags_correct", ":", "ret", "[", "'comment'", "]", "=", "'CloudFront distribution `{}` is in the correct state.'", ".", "format", "(", "Name", ")", "return", "ret", "if", "__opts__", "[", "'test'", "]", ":", "ret", "[", "'result'", "]", "=", "None", "if", "not", "correct", ":", "comments", "+=", "[", "'CloudFront distribution `{}` config would be updated.'", ".", "format", "(", "Name", ")", "]", "old", "[", "'DistributionConfig'", "]", "=", "copyOne", "new", "[", "'DistributionConfig'", "]", "=", "copyTwo", "if", "not", "tags_correct", ":", "comments", "+=", "[", "'CloudFront distribution `{}` Tags would be updated.'", ".", "format", "(", "Name", ")", "]", "old", "[", "'Tags'", "]", "=", "currentTags", "new", "[", "'Tags'", "]", "=", "Tags", "ret", "[", "'comment'", "]", "=", "'  '", ".", "join", "(", "comments", ")", "ret", "[", "'pchanges'", "]", "=", "{", "'old'", ":", "old", ",", "'new'", ":", "new", "}", "return", "ret", "if", "not", "correct", ":", "kwargs", "=", "{", "'DistributionConfig'", ":", "copyTwo", ",", "'Id'", ":", "currentId", ",", "'IfMatch'", ":", "currentETag", "}", "kwargs", ".", "update", "(", "authargs", ")", "log", ".", "debug", "(", "'Calling `boto_cloudfront.update_distribution_v2()` with **kwargs =='", "' %s'", ",", "kwargs", ")", "res", "=", "__salt__", "[", "'boto_cloudfront.update_distribution_v2'", "]", "(", "*", "*", "kwargs", ")", "if", "res", "is", "None", ":", "ret", "[", "'result'", "]", "=", "False", "msg", "=", "'Error occurred while updating distribution `{}`.'", ".", "format", "(", "Name", ")", "log", ".", "error", "(", "msg", ")", "ret", "[", "'comment'", "]", "=", "msg", "return", "ret", "old", "[", "'DistributionConfig'", "]", "=", "copyOne", "new", "[", "'DistributionConfig'", "]", "=", "res", "[", "'Distribution'", "]", "[", "'DistributionConfig'", "]", "comments", "+=", "[", "'CloudFront distribution `{}` config updated.'", ".", "format", "(", "Name", ")", "]", "if", "not", "tags_correct", ":", "tagged", "=", "__salt__", "[", "'boto_cloudfront.enforce_tags'", "]", "(", "Resource", "=", "currentARN", ",", "Tags", "=", "Tags", ",", "*", "*", "authargs", ")", "if", "tagged", "is", "False", ":", "ret", "[", "'result'", "]", "=", "False", "msg", "=", "'Error occurred while updating Tags on distribution `{}`.'", ".", "format", "(", "Name", ")", "log", ".", "error", "(", "msg", ")", "comments", "+=", "[", "msg", "]", "ret", "[", "'comment'", "]", "=", "'  '", ".", "join", "(", "comments", ")", "return", "ret", "comments", "+=", "[", "'CloudFront distribution `{}` Tags updated.'", ".", "format", "(", "Name", ")", "]", "old", "[", "'Tags'", "]", "=", "currentTags", "new", "[", "'Tags'", "]", "=", "Tags", "ret", "[", "'comment'", "]", "=", "'  '", ".", "join", "(", "comments", ")", "ret", "[", "'changes'", "]", "=", "{", "'old'", ":", "old", ",", "'new'", ":", "new", "}", "return", "ret"], "docstring": "Ensure the given CloudFront distribution exists in the described state.\n\n    The implementation of this function, and all those following, is orthagonal\n    to that of :py:mod:`boto_cloudfront.present\n    <salt.states.boto_cloudfront.present>`. Resources created with\n    :py:mod:`boto_cloudfront.present <salt.states.boto_cloudfront.present>`\n    will not be correctly managed by this function, as a different method is\n    used to store Salt's state signifier. This function and those following are\n    a suite, designed to work together. As an extra bonus, they correctly\n    process updates of the managed resources, so it is recommended to use them\n    in preference to :py:mod:`boto_cloudfront.present\n    <salt.states.boto_cloudfront.present>` above.\n\n    Note that the semantics of DistributionConfig (below) are rather arcane,\n    and vary wildly depending on whether the distribution already exists or not\n    (e.g. is being initially created, or being updated in place). Many more\n    details can be found here__.\n\n    .. __: https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/distribution-overview-required-fields.html\n\n    name (string)\n        Name of the state definition.\n\n    Name (string)\n        Name of the resource (for purposes of Salt's idempotency). If not\n        provided, the value of ``name`` will be used.\n\n    DistributionConfig (dict)\n        Configuration for the distribution.\n\n        Notes:\n\n        - The CallerReference field should NOT be provided - it will be\n          autopopulated by Salt.\n\n        - A large number of sub- (and sub-sub-) fields require a ``Quantity``\n          element, which simply COUNTS the number of items in the ``Items``\n          element. This is bluntly stupid, so as a convenience, Salt will\n          traverse the provided configuration, and add (or fix) a ``Quantity``\n          element for any ``Items`` elements of list-type it encounters. This\n          adds a bit of sanity to an otherwise error-prone situation. Note\n          that for this to work, zero-length lists must be inlined as ``[]``.\n\n        - Due to the unavailibity of a better way to store stateful idempotency\n          information about Distributions, the Comment sub-element (as the only\n          user-settable attribute without weird self-blocking semantics, and\n          which is available from the core ``get_distribution()`` API call) is\n          utilized to store the Salt state signifier, which is used to\n          determine resource existence and state. That said, to enable **some**\n          usability of this field, only the value up to the first colon\n          character is taken as the signifier, with everything afterward\n          free-form, and ignored (but preserved) by Salt.\n\n    Tags (dict)\n        Tags to associate with the distribution.\n\n    region (string)\n        Region to connect to.\n\n    key (string)\n        Secret key to use.\n\n    keyid (string)\n        Access key to use.\n\n    profile (dict or string)\n        Dict, or pillar key pointing to a dict, containing AWS region/key/keyid.\n\n    Example:\n\n    .. code-block:: yaml\n\n          plt-dev-spaapi-cf-dist-cf_dist-present:\n            boto_cloudfront.distribution_present:\n            - Name: plt-dev-spaapi-cf-dist\n            - DistributionConfig:\n                Comment: SPA\n                Logging:\n                  Enabled: false\n                  Prefix: ''\n                  Bucket: ''\n                  IncludeCookies: false\n                WebACLId: ''\n                Origins:\n                  Items:\n                  - S3OriginConfig:\n                      OriginAccessIdentity: the-SPA-OAI\n                    OriginPath: ''\n                    CustomHeaders:\n                      Items: []\n                    Id: S3-hs-backend-srpms\n                    DomainName: hs-backend-srpms.s3.amazonaws.com\n                PriceClass: PriceClass_All\n                DefaultRootObject: ''\n                Enabled: true\n                DefaultCacheBehavior:\n                  ViewerProtocolPolicy: allow-all\n                  TrustedSigners:\n                    Items: []\n                    Enabled: false\n                  SmoothStreaming: false\n                  TargetOriginId: S3-hs-backend-srpms\n                  FieldLevelEncryptionId: ''\n                  ForwardedValues:\n                    Headers:\n                      Items: []\n                    Cookies:\n                      Forward: none\n                    QueryStringCacheKeys:\n                      Items: []\n                    QueryString: false\n                  MaxTTL: 31536000\n                  LambdaFunctionAssociations:\n                    Items: []\n                  DefaultTTL: 86400\n                  AllowedMethods:\n                    CachedMethods:\n                      Items:\n                      - HEAD\n                      - GET\n                    Items:\n                    - HEAD\n                    - GET\n                  MinTTL: 0\n                  Compress: false\n                IsIPV6Enabled: true\n                ViewerCertificate:\n                  CloudFrontDefaultCertificate: true\n                  MinimumProtocolVersion: TLSv1\n                  CertificateSource: cloudfront\n                Aliases:\n                  Items:\n                  - bubba-hotep.bodhi-dev.io\n                HttpVersion: http2\n            - Tags:\n                Owner: dev_engrs", "docstring_tokens": ["Ensure", "the", "given", "CloudFront", "distribution", "exists", "in", "the", "described", "state", "."], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/states/boto_cloudfront.py#L259-L575", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/states/boto_cloudfront.py", "func_name": "oai_bucket_policy_present", "original_string": "def oai_bucket_policy_present(name, Bucket, OAI, Policy,\n                              region=None, key=None, keyid=None, profile=None):\n    '''\n    Ensure the given policy exists on an S3 bucket, granting access for the given origin access\n    identity to do the things specified in the policy.\n\n    name\n        The name of the state definition\n\n    Bucket\n        The S3 bucket which CloudFront needs access to. Note that this policy\n        is exclusive - it will be the only policy definition on the bucket (and\n        objects inside the bucket if you specify such permissions in the\n        policy). Note that this likely SHOULD reflect the bucket mentioned in\n        the Resource section of the Policy, but this is not enforced...\n\n    OAI\n        The value of `Name` passed to the state definition for the origin\n        access identity which will be accessing the bucket.\n\n    Policy\n        The full policy document which should be set on the S3 bucket. If a\n        ``Principal`` clause is not provided in the policy, one will be\n        automatically added, and pointed at the correct value as dereferenced\n        from the OAI provided above. If one IS provided, then this is not\n        done, and you are responsible for providing the correct values.\n\n    region (string)\n        Region to connect to.\n\n    key (string)\n        Secret key to use.\n\n    keyid (string)\n        Access key to use.\n\n    profile (dict or string)\n        Dict, or pillar key pointing to a dict, containing AWS region/key/keyid.\n\n    Example:\n\n    .. code-block:: yaml\n\n        my_oai_s3_policy:\n          boto_cloudfront.oai_bucket_policy_present:\n          - Bucket: the_bucket_for_my_distribution\n          - OAI: the_OAI_I_just_created_and_attached_to_my_distribution\n          - Policy:\n              Version: 2012-10-17\n              Statement:\n              - Effect: Allow\n                Action: s3:GetObject\n                Resource: arn:aws:s3:::the_bucket_for_my_distribution/*\n\n    '''\n    ret = {'name': name, 'result': True, 'comment': '', 'changes': {}}\n    oais = __salt__['boto_cloudfront.get_cloud_front_origin_access_identities_by_comment'](\n            Comment=OAI, region=region, key=key, keyid=keyid, profile=profile)\n    if len(oais) > 1:\n        msg = 'Multiple origin access identities matched `{}`.'.format(OAI)\n        log.error(msg)\n        ret['comment'] = msg\n        ret['result'] = False\n        return ret\n    if not oais:\n        msg = 'No origin access identities matched `{}`.'.format(OAI)\n        log.error(msg)\n        ret['comment'] = msg\n        ret['result'] = False\n        return ret\n    canonical_user = oais[0].get('S3CanonicalUserId')\n    oai_id = oais[0].get('Id')\n    if isinstance(Policy, six.string_types):\n        Policy = json.loads(Policy)\n    for stanza in range(len(Policy.get('Statement', []))):\n        if 'Principal' not in Policy['Statement'][stanza]:\n            Policy['Statement'][stanza]['Principal'] = {\"CanonicalUser\": canonical_user}\n    bucket = __salt__['boto_s3_bucket.describe'](Bucket=Bucket, region=region, key=key,\n            keyid=keyid, profile=profile)\n    if not bucket or 'bucket' not in bucket:\n        msg = 'S3 bucket `{}` not found.'.format(Bucket)\n        log.error(msg)\n        ret['comment'] = msg\n        ret['result'] = False\n        return ret\n    curr_policy = bucket['bucket'].get('Policy', {}).get('Policy', {})  # ?!? dunno, that's just how it gets returned...\n    curr_policy = json.loads(curr_policy) if isinstance(curr_policy,\n            six.string_types) else curr_policy\n    # Sooooo, you have to SUBMIT Principals of the form\n    #   Principal: {'S3CanonicalUserId': someCrazyLongMagicValueAsDerivedAbove}\n    # BUT, they RETURN the Principal as something WILDLY different\n    #   Principal: {'AWS': arn:aws:iam::cloudfront:user/CloudFront Origin Access Identity E30ABCDEF12345}\n    # which obviously compare different on every run... So we fake it thusly.\n    fake_Policy = copy.deepcopy(Policy)\n    for stanza in range(len(fake_Policy.get('Statement', []))):\n        # Warning: unavoidable hardcoded magic values HO!\n        fake_Policy['Statement'][stanza].update({'Principal': {'AWS':\n            'arn:aws:iam::cloudfront:user/CloudFront Origin Access Identity {}'.format(oai_id)}})\n    if __utils__['boto3.json_objs_equal'](curr_policy, fake_Policy):\n        msg = 'Policy of S3 bucket `{}` is in the correct state.'.format(Bucket)\n        log.info(msg)\n        ret['comment'] = msg\n        return ret\n    if __opts__['test']:\n        ret['comment'] = 'Policy on S3 bucket `{}` would be updated.'.format(Bucket)\n        ret['result'] = None\n        ret['changes'] = {'old': curr_policy, 'new': fake_Policy}\n        return ret\n    res = __salt__['boto_s3_bucket.put_policy'](Bucket=Bucket, Policy=Policy,\n            region=region, key=key, keyid=keyid, profile=profile)\n    if 'error' in res:\n        ret['comment'] = 'Failed to update policy on S3 bucket `{}`: {}'.format(Bucket,\n                res['error'])\n        ret['return'] = False\n        return ret\n    ret['comment'] = 'Policy on S3 bucket `{}` updated.'.format(Bucket)\n    ret['changes'] = {'old': curr_policy, 'new': fake_Policy}\n    return ret", "language": "python", "code": "def oai_bucket_policy_present(name, Bucket, OAI, Policy,\n                              region=None, key=None, keyid=None, profile=None):\n    '''\n    Ensure the given policy exists on an S3 bucket, granting access for the given origin access\n    identity to do the things specified in the policy.\n\n    name\n        The name of the state definition\n\n    Bucket\n        The S3 bucket which CloudFront needs access to. Note that this policy\n        is exclusive - it will be the only policy definition on the bucket (and\n        objects inside the bucket if you specify such permissions in the\n        policy). Note that this likely SHOULD reflect the bucket mentioned in\n        the Resource section of the Policy, but this is not enforced...\n\n    OAI\n        The value of `Name` passed to the state definition for the origin\n        access identity which will be accessing the bucket.\n\n    Policy\n        The full policy document which should be set on the S3 bucket. If a\n        ``Principal`` clause is not provided in the policy, one will be\n        automatically added, and pointed at the correct value as dereferenced\n        from the OAI provided above. If one IS provided, then this is not\n        done, and you are responsible for providing the correct values.\n\n    region (string)\n        Region to connect to.\n\n    key (string)\n        Secret key to use.\n\n    keyid (string)\n        Access key to use.\n\n    profile (dict or string)\n        Dict, or pillar key pointing to a dict, containing AWS region/key/keyid.\n\n    Example:\n\n    .. code-block:: yaml\n\n        my_oai_s3_policy:\n          boto_cloudfront.oai_bucket_policy_present:\n          - Bucket: the_bucket_for_my_distribution\n          - OAI: the_OAI_I_just_created_and_attached_to_my_distribution\n          - Policy:\n              Version: 2012-10-17\n              Statement:\n              - Effect: Allow\n                Action: s3:GetObject\n                Resource: arn:aws:s3:::the_bucket_for_my_distribution/*\n\n    '''\n    ret = {'name': name, 'result': True, 'comment': '', 'changes': {}}\n    oais = __salt__['boto_cloudfront.get_cloud_front_origin_access_identities_by_comment'](\n            Comment=OAI, region=region, key=key, keyid=keyid, profile=profile)\n    if len(oais) > 1:\n        msg = 'Multiple origin access identities matched `{}`.'.format(OAI)\n        log.error(msg)\n        ret['comment'] = msg\n        ret['result'] = False\n        return ret\n    if not oais:\n        msg = 'No origin access identities matched `{}`.'.format(OAI)\n        log.error(msg)\n        ret['comment'] = msg\n        ret['result'] = False\n        return ret\n    canonical_user = oais[0].get('S3CanonicalUserId')\n    oai_id = oais[0].get('Id')\n    if isinstance(Policy, six.string_types):\n        Policy = json.loads(Policy)\n    for stanza in range(len(Policy.get('Statement', []))):\n        if 'Principal' not in Policy['Statement'][stanza]:\n            Policy['Statement'][stanza]['Principal'] = {\"CanonicalUser\": canonical_user}\n    bucket = __salt__['boto_s3_bucket.describe'](Bucket=Bucket, region=region, key=key,\n            keyid=keyid, profile=profile)\n    if not bucket or 'bucket' not in bucket:\n        msg = 'S3 bucket `{}` not found.'.format(Bucket)\n        log.error(msg)\n        ret['comment'] = msg\n        ret['result'] = False\n        return ret\n    curr_policy = bucket['bucket'].get('Policy', {}).get('Policy', {})  # ?!? dunno, that's just how it gets returned...\n    curr_policy = json.loads(curr_policy) if isinstance(curr_policy,\n            six.string_types) else curr_policy\n    # Sooooo, you have to SUBMIT Principals of the form\n    #   Principal: {'S3CanonicalUserId': someCrazyLongMagicValueAsDerivedAbove}\n    # BUT, they RETURN the Principal as something WILDLY different\n    #   Principal: {'AWS': arn:aws:iam::cloudfront:user/CloudFront Origin Access Identity E30ABCDEF12345}\n    # which obviously compare different on every run... So we fake it thusly.\n    fake_Policy = copy.deepcopy(Policy)\n    for stanza in range(len(fake_Policy.get('Statement', []))):\n        # Warning: unavoidable hardcoded magic values HO!\n        fake_Policy['Statement'][stanza].update({'Principal': {'AWS':\n            'arn:aws:iam::cloudfront:user/CloudFront Origin Access Identity {}'.format(oai_id)}})\n    if __utils__['boto3.json_objs_equal'](curr_policy, fake_Policy):\n        msg = 'Policy of S3 bucket `{}` is in the correct state.'.format(Bucket)\n        log.info(msg)\n        ret['comment'] = msg\n        return ret\n    if __opts__['test']:\n        ret['comment'] = 'Policy on S3 bucket `{}` would be updated.'.format(Bucket)\n        ret['result'] = None\n        ret['changes'] = {'old': curr_policy, 'new': fake_Policy}\n        return ret\n    res = __salt__['boto_s3_bucket.put_policy'](Bucket=Bucket, Policy=Policy,\n            region=region, key=key, keyid=keyid, profile=profile)\n    if 'error' in res:\n        ret['comment'] = 'Failed to update policy on S3 bucket `{}`: {}'.format(Bucket,\n                res['error'])\n        ret['return'] = False\n        return ret\n    ret['comment'] = 'Policy on S3 bucket `{}` updated.'.format(Bucket)\n    ret['changes'] = {'old': curr_policy, 'new': fake_Policy}\n    return ret", "code_tokens": ["def", "oai_bucket_policy_present", "(", "name", ",", "Bucket", ",", "OAI", ",", "Policy", ",", "region", "=", "None", ",", "key", "=", "None", ",", "keyid", "=", "None", ",", "profile", "=", "None", ")", ":", "ret", "=", "{", "'name'", ":", "name", ",", "'result'", ":", "True", ",", "'comment'", ":", "''", ",", "'changes'", ":", "{", "}", "}", "oais", "=", "__salt__", "[", "'boto_cloudfront.get_cloud_front_origin_access_identities_by_comment'", "]", "(", "Comment", "=", "OAI", ",", "region", "=", "region", ",", "key", "=", "key", ",", "keyid", "=", "keyid", ",", "profile", "=", "profile", ")", "if", "len", "(", "oais", ")", ">", "1", ":", "msg", "=", "'Multiple origin access identities matched `{}`.'", ".", "format", "(", "OAI", ")", "log", ".", "error", "(", "msg", ")", "ret", "[", "'comment'", "]", "=", "msg", "ret", "[", "'result'", "]", "=", "False", "return", "ret", "if", "not", "oais", ":", "msg", "=", "'No origin access identities matched `{}`.'", ".", "format", "(", "OAI", ")", "log", ".", "error", "(", "msg", ")", "ret", "[", "'comment'", "]", "=", "msg", "ret", "[", "'result'", "]", "=", "False", "return", "ret", "canonical_user", "=", "oais", "[", "0", "]", ".", "get", "(", "'S3CanonicalUserId'", ")", "oai_id", "=", "oais", "[", "0", "]", ".", "get", "(", "'Id'", ")", "if", "isinstance", "(", "Policy", ",", "six", ".", "string_types", ")", ":", "Policy", "=", "json", ".", "loads", "(", "Policy", ")", "for", "stanza", "in", "range", "(", "len", "(", "Policy", ".", "get", "(", "'Statement'", ",", "[", "]", ")", ")", ")", ":", "if", "'Principal'", "not", "in", "Policy", "[", "'Statement'", "]", "[", "stanza", "]", ":", "Policy", "[", "'Statement'", "]", "[", "stanza", "]", "[", "'Principal'", "]", "=", "{", "\"CanonicalUser\"", ":", "canonical_user", "}", "bucket", "=", "__salt__", "[", "'boto_s3_bucket.describe'", "]", "(", "Bucket", "=", "Bucket", ",", "region", "=", "region", ",", "key", "=", "key", ",", "keyid", "=", "keyid", ",", "profile", "=", "profile", ")", "if", "not", "bucket", "or", "'bucket'", "not", "in", "bucket", ":", "msg", "=", "'S3 bucket `{}` not found.'", ".", "format", "(", "Bucket", ")", "log", ".", "error", "(", "msg", ")", "ret", "[", "'comment'", "]", "=", "msg", "ret", "[", "'result'", "]", "=", "False", "return", "ret", "curr_policy", "=", "bucket", "[", "'bucket'", "]", ".", "get", "(", "'Policy'", ",", "{", "}", ")", ".", "get", "(", "'Policy'", ",", "{", "}", ")", "# ?!? dunno, that's just how it gets returned...", "curr_policy", "=", "json", ".", "loads", "(", "curr_policy", ")", "if", "isinstance", "(", "curr_policy", ",", "six", ".", "string_types", ")", "else", "curr_policy", "# Sooooo, you have to SUBMIT Principals of the form", "#   Principal: {'S3CanonicalUserId': someCrazyLongMagicValueAsDerivedAbove}", "# BUT, they RETURN the Principal as something WILDLY different", "#   Principal: {'AWS': arn:aws:iam::cloudfront:user/CloudFront Origin Access Identity E30ABCDEF12345}", "# which obviously compare different on every run... So we fake it thusly.", "fake_Policy", "=", "copy", ".", "deepcopy", "(", "Policy", ")", "for", "stanza", "in", "range", "(", "len", "(", "fake_Policy", ".", "get", "(", "'Statement'", ",", "[", "]", ")", ")", ")", ":", "# Warning: unavoidable hardcoded magic values HO!", "fake_Policy", "[", "'Statement'", "]", "[", "stanza", "]", ".", "update", "(", "{", "'Principal'", ":", "{", "'AWS'", ":", "'arn:aws:iam::cloudfront:user/CloudFront Origin Access Identity {}'", ".", "format", "(", "oai_id", ")", "}", "}", ")", "if", "__utils__", "[", "'boto3.json_objs_equal'", "]", "(", "curr_policy", ",", "fake_Policy", ")", ":", "msg", "=", "'Policy of S3 bucket `{}` is in the correct state.'", ".", "format", "(", "Bucket", ")", "log", ".", "info", "(", "msg", ")", "ret", "[", "'comment'", "]", "=", "msg", "return", "ret", "if", "__opts__", "[", "'test'", "]", ":", "ret", "[", "'comment'", "]", "=", "'Policy on S3 bucket `{}` would be updated.'", ".", "format", "(", "Bucket", ")", "ret", "[", "'result'", "]", "=", "None", "ret", "[", "'changes'", "]", "=", "{", "'old'", ":", "curr_policy", ",", "'new'", ":", "fake_Policy", "}", "return", "ret", "res", "=", "__salt__", "[", "'boto_s3_bucket.put_policy'", "]", "(", "Bucket", "=", "Bucket", ",", "Policy", "=", "Policy", ",", "region", "=", "region", ",", "key", "=", "key", ",", "keyid", "=", "keyid", ",", "profile", "=", "profile", ")", "if", "'error'", "in", "res", ":", "ret", "[", "'comment'", "]", "=", "'Failed to update policy on S3 bucket `{}`: {}'", ".", "format", "(", "Bucket", ",", "res", "[", "'error'", "]", ")", "ret", "[", "'return'", "]", "=", "False", "return", "ret", "ret", "[", "'comment'", "]", "=", "'Policy on S3 bucket `{}` updated.'", ".", "format", "(", "Bucket", ")", "ret", "[", "'changes'", "]", "=", "{", "'old'", ":", "curr_policy", ",", "'new'", ":", "fake_Policy", "}", "return", "ret"], "docstring": "Ensure the given policy exists on an S3 bucket, granting access for the given origin access\n    identity to do the things specified in the policy.\n\n    name\n        The name of the state definition\n\n    Bucket\n        The S3 bucket which CloudFront needs access to. Note that this policy\n        is exclusive - it will be the only policy definition on the bucket (and\n        objects inside the bucket if you specify such permissions in the\n        policy). Note that this likely SHOULD reflect the bucket mentioned in\n        the Resource section of the Policy, but this is not enforced...\n\n    OAI\n        The value of `Name` passed to the state definition for the origin\n        access identity which will be accessing the bucket.\n\n    Policy\n        The full policy document which should be set on the S3 bucket. If a\n        ``Principal`` clause is not provided in the policy, one will be\n        automatically added, and pointed at the correct value as dereferenced\n        from the OAI provided above. If one IS provided, then this is not\n        done, and you are responsible for providing the correct values.\n\n    region (string)\n        Region to connect to.\n\n    key (string)\n        Secret key to use.\n\n    keyid (string)\n        Access key to use.\n\n    profile (dict or string)\n        Dict, or pillar key pointing to a dict, containing AWS region/key/keyid.\n\n    Example:\n\n    .. code-block:: yaml\n\n        my_oai_s3_policy:\n          boto_cloudfront.oai_bucket_policy_present:\n          - Bucket: the_bucket_for_my_distribution\n          - OAI: the_OAI_I_just_created_and_attached_to_my_distribution\n          - Policy:\n              Version: 2012-10-17\n              Statement:\n              - Effect: Allow\n                Action: s3:GetObject\n                Resource: arn:aws:s3:::the_bucket_for_my_distribution/*", "docstring_tokens": ["Ensure", "the", "given", "policy", "exists", "on", "an", "S3", "bucket", "granting", "access", "for", "the", "given", "origin", "access", "identity", "to", "do", "the", "things", "specified", "in", "the", "policy", "."], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/states/boto_cloudfront.py#L578-L695", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/states/boto_cloudfront.py", "func_name": "route53_alias_present", "original_string": "def route53_alias_present(name, region=None, key=None, keyid=None, profile=None, **kwargs):\n    '''\n    Ensure a Route53 Alias exists and is pointing at the given CloudFront\n    distribution. An ``A`` record is always created, and if IPV6 is enabled on\n    the given distribution, an ``AAAA`` record will be created as well. Also be\n    aware that Alias records for CloudFront distributions are only permitted in\n    non-private zones.\n\n    name\n        The name of the state definition.\n\n    Distribution\n        The name of the CloudFront distribution. Defaults to the value of\n        ``name`` if not provided.\n\n    HostedZoneId\n        Id of the Route53 hosted zone within which the records should be created.\n\n    DomainName\n        The domain name associated with the Hosted Zone. Exclusive with HostedZoneId.\n\n    ResourceRecordSet\n        A Route53 Record Set (with AliasTarget section, suitable for use as an\n        ``Alias`` record, if non-default settings are needed on the Alias)\n        which should be pointed at the provided CloudFront distribution. Note\n        that this MUST correlate with the Aliases set within the\n        DistributionConfig section of the distribution.\n\n        Some notes *specifically* about the ``AliasTarget`` subsection of the\n        ResourceRecordSet:\n\n        - If not specified, the ``DNSName`` sub-field will be populated by\n          dereferencing ``Distribution`` above to the value of its\n          ``DomainName`` attribute.\n\n        - The HostedZoneId sub-field should not be provided -- it will be\n          automatically populated with a ``magic`` AWS value.\n\n        - The EvaluateTargetHealth can only be False on a CloudFront Alias.\n\n        - The above items taken all together imply that, for most use-cases,\n          the AliasTarget sub-section can be entirely omitted, as seen in the\n          first code sample below.\n\n        Lastly, note that if you set ``name`` to the desired ResourceRecordSet\n        Name, you can entirely omit this parameter, as shown in the second\n        example below.\n\n    .. code-block:: yaml\n\n        Add a Route53 Alias for my_distribution:\n          boto_cloudfront.present:\n          - Distribution: my_distribution\n          - DomainName: saltstack.org.\n          - ResourceRecordSet:\n              Name: the-alias.saltstack.org.\n        # This is even simpler - it uses the value of `name` for ResourceRecordSet.Name\n        another-alias.saltstack.org.:\n          boto_cloudfront.present:\n          - Distribution: my_distribution\n          - DomainName: saltstack.org.\n\n    '''\n    MAGIC_CLOUDFRONT_HOSTED_ZONEID = 'Z2FDTNDATAQYW2'\n    ret = {'name': name, 'result': True, 'comment': '', 'changes': {}}\n    Distribution = kwargs['Distribution'] if 'Distribution' in kwargs else name\n    ResourceRecordSet = kwargs.get('ResourceRecordSet', {})\n    Name = ResourceRecordSet.get('Name', name)\n    ResourceRecordSet['Name'] = Name\n\n    res = __salt__['boto_cloudfront.get_distributions_by_comment'](Comment=Distribution,\n            region=region, key=key, keyid=keyid, profile=profile)\n    if res is None:\n        msg = 'Error resolving CloudFront distribution `{}` to a Resource ID.'.format(Distribution)\n        log.error(msg)\n        ret['comment'] = msg\n        ret['result'] = False\n        return ret\n    if len(res) > 1:\n        msg = 'Multiple CloudFront distibutions matched `{}`.'.format(Distribution)\n        log.error(msg)\n        ret['comment'] = msg\n        ret['result'] = False\n        return ret\n    if not res:\n        msg = 'No CloudFront distibutions matching `{}` found.'.format(Distribution)\n        log.error(msg)\n        ret['comment'] = msg\n        ret['result'] = False\n        return ret\n    dist = res[0]\n\n    Types = ('A', 'AAAA') if dist.get('IsIPV6Enabled', False) else ('A',)\n    DNSName = dist.get('DomainName', '')\n    Aliases = dist.get('Aliases', {}).get('Items', [])\n    # AWS annoyance #437:\n    #   Route53 \"FQDNs\" (correctly!) REQUIRE trailing periods...\n    #   while CloudFront \"FQDNs\" don't PERMIT trailing periods...\n    Aliases += [(a if a.endswith('.') else '{}.'.format(a)) for a in Aliases]\n    if Name not in Aliases:\n        msg = ('Route53 alias `{}` requested which is not mirrored in the `Aliases`'\n              ' sub-section of the DistributionConfig.'.format(Name))\n        log.error(msg)\n        ret['comment'] = msg\n        ret['result'] = False\n        return ret\n\n    changes = {'old': [], 'new': []}\n    comments = []\n    # Now mock out a route53 state def, and use the route53 rr_exists state to enforce it...\n    AliasTarget = ResourceRecordSet.get('AliasTarget', {})\n    AliasTarget['DNSName'] = AliasTarget['DNSName'] if 'DNSName' in AliasTarget else DNSName\n    AliasTarget['DNSName'] += '' if AliasTarget['DNSName'].endswith('.') else '.'  # GRRRR!\n    AliasTarget['HostedZoneId'] = MAGIC_CLOUDFRONT_HOSTED_ZONEID\n    AliasTarget['EvaluateTargetHealth'] = False   # Route53 limitation\n    ResourceRecordSet['name'] = Name\n    ResourceRecordSet['AliasTarget'] = AliasTarget\n    ResourceRecordSet['PrivateZone'] = False      # Route53 limitation\n    ResourceRecordSet['DomainName'] = kwargs.get('DomainName')\n    ResourceRecordSet['HostedZoneId'] = kwargs.get('HostedZoneId')\n    ResourceRecordSet.update({'region': region, 'key': key, 'keyid': keyid, 'profile': profile})\n    for Type in Types:\n        ResourceRecordSet['Type'] = Type\n        # Checking for `test=True` will occur in the called state....\n        log.debug('Calling state function `boto3_route53.rr_present()` with args:  `%s`',\n                ResourceRecordSet)\n        res = __states__['boto3_route53.rr_present'](**ResourceRecordSet)\n        ret['result'] = res['result']\n        comments += [res['comment']]\n        if ret['result'] not in (True, None):\n            break\n        changes['old'] += [res['changes']['old']] if res['changes'].get('old') else []\n        changes['new'] += [res['changes']['new']] if res['changes'].get('new') else []\n    ret['changes'].update({'old': changes['old']}) if changes.get('old') else None\n    ret['changes'].update({'new': changes['new']}) if changes.get('new') else None\n    ret['comment'] = '  '.join(comments)\n    return ret", "language": "python", "code": "def route53_alias_present(name, region=None, key=None, keyid=None, profile=None, **kwargs):\n    '''\n    Ensure a Route53 Alias exists and is pointing at the given CloudFront\n    distribution. An ``A`` record is always created, and if IPV6 is enabled on\n    the given distribution, an ``AAAA`` record will be created as well. Also be\n    aware that Alias records for CloudFront distributions are only permitted in\n    non-private zones.\n\n    name\n        The name of the state definition.\n\n    Distribution\n        The name of the CloudFront distribution. Defaults to the value of\n        ``name`` if not provided.\n\n    HostedZoneId\n        Id of the Route53 hosted zone within which the records should be created.\n\n    DomainName\n        The domain name associated with the Hosted Zone. Exclusive with HostedZoneId.\n\n    ResourceRecordSet\n        A Route53 Record Set (with AliasTarget section, suitable for use as an\n        ``Alias`` record, if non-default settings are needed on the Alias)\n        which should be pointed at the provided CloudFront distribution. Note\n        that this MUST correlate with the Aliases set within the\n        DistributionConfig section of the distribution.\n\n        Some notes *specifically* about the ``AliasTarget`` subsection of the\n        ResourceRecordSet:\n\n        - If not specified, the ``DNSName`` sub-field will be populated by\n          dereferencing ``Distribution`` above to the value of its\n          ``DomainName`` attribute.\n\n        - The HostedZoneId sub-field should not be provided -- it will be\n          automatically populated with a ``magic`` AWS value.\n\n        - The EvaluateTargetHealth can only be False on a CloudFront Alias.\n\n        - The above items taken all together imply that, for most use-cases,\n          the AliasTarget sub-section can be entirely omitted, as seen in the\n          first code sample below.\n\n        Lastly, note that if you set ``name`` to the desired ResourceRecordSet\n        Name, you can entirely omit this parameter, as shown in the second\n        example below.\n\n    .. code-block:: yaml\n\n        Add a Route53 Alias for my_distribution:\n          boto_cloudfront.present:\n          - Distribution: my_distribution\n          - DomainName: saltstack.org.\n          - ResourceRecordSet:\n              Name: the-alias.saltstack.org.\n        # This is even simpler - it uses the value of `name` for ResourceRecordSet.Name\n        another-alias.saltstack.org.:\n          boto_cloudfront.present:\n          - Distribution: my_distribution\n          - DomainName: saltstack.org.\n\n    '''\n    MAGIC_CLOUDFRONT_HOSTED_ZONEID = 'Z2FDTNDATAQYW2'\n    ret = {'name': name, 'result': True, 'comment': '', 'changes': {}}\n    Distribution = kwargs['Distribution'] if 'Distribution' in kwargs else name\n    ResourceRecordSet = kwargs.get('ResourceRecordSet', {})\n    Name = ResourceRecordSet.get('Name', name)\n    ResourceRecordSet['Name'] = Name\n\n    res = __salt__['boto_cloudfront.get_distributions_by_comment'](Comment=Distribution,\n            region=region, key=key, keyid=keyid, profile=profile)\n    if res is None:\n        msg = 'Error resolving CloudFront distribution `{}` to a Resource ID.'.format(Distribution)\n        log.error(msg)\n        ret['comment'] = msg\n        ret['result'] = False\n        return ret\n    if len(res) > 1:\n        msg = 'Multiple CloudFront distibutions matched `{}`.'.format(Distribution)\n        log.error(msg)\n        ret['comment'] = msg\n        ret['result'] = False\n        return ret\n    if not res:\n        msg = 'No CloudFront distibutions matching `{}` found.'.format(Distribution)\n        log.error(msg)\n        ret['comment'] = msg\n        ret['result'] = False\n        return ret\n    dist = res[0]\n\n    Types = ('A', 'AAAA') if dist.get('IsIPV6Enabled', False) else ('A',)\n    DNSName = dist.get('DomainName', '')\n    Aliases = dist.get('Aliases', {}).get('Items', [])\n    # AWS annoyance #437:\n    #   Route53 \"FQDNs\" (correctly!) REQUIRE trailing periods...\n    #   while CloudFront \"FQDNs\" don't PERMIT trailing periods...\n    Aliases += [(a if a.endswith('.') else '{}.'.format(a)) for a in Aliases]\n    if Name not in Aliases:\n        msg = ('Route53 alias `{}` requested which is not mirrored in the `Aliases`'\n              ' sub-section of the DistributionConfig.'.format(Name))\n        log.error(msg)\n        ret['comment'] = msg\n        ret['result'] = False\n        return ret\n\n    changes = {'old': [], 'new': []}\n    comments = []\n    # Now mock out a route53 state def, and use the route53 rr_exists state to enforce it...\n    AliasTarget = ResourceRecordSet.get('AliasTarget', {})\n    AliasTarget['DNSName'] = AliasTarget['DNSName'] if 'DNSName' in AliasTarget else DNSName\n    AliasTarget['DNSName'] += '' if AliasTarget['DNSName'].endswith('.') else '.'  # GRRRR!\n    AliasTarget['HostedZoneId'] = MAGIC_CLOUDFRONT_HOSTED_ZONEID\n    AliasTarget['EvaluateTargetHealth'] = False   # Route53 limitation\n    ResourceRecordSet['name'] = Name\n    ResourceRecordSet['AliasTarget'] = AliasTarget\n    ResourceRecordSet['PrivateZone'] = False      # Route53 limitation\n    ResourceRecordSet['DomainName'] = kwargs.get('DomainName')\n    ResourceRecordSet['HostedZoneId'] = kwargs.get('HostedZoneId')\n    ResourceRecordSet.update({'region': region, 'key': key, 'keyid': keyid, 'profile': profile})\n    for Type in Types:\n        ResourceRecordSet['Type'] = Type\n        # Checking for `test=True` will occur in the called state....\n        log.debug('Calling state function `boto3_route53.rr_present()` with args:  `%s`',\n                ResourceRecordSet)\n        res = __states__['boto3_route53.rr_present'](**ResourceRecordSet)\n        ret['result'] = res['result']\n        comments += [res['comment']]\n        if ret['result'] not in (True, None):\n            break\n        changes['old'] += [res['changes']['old']] if res['changes'].get('old') else []\n        changes['new'] += [res['changes']['new']] if res['changes'].get('new') else []\n    ret['changes'].update({'old': changes['old']}) if changes.get('old') else None\n    ret['changes'].update({'new': changes['new']}) if changes.get('new') else None\n    ret['comment'] = '  '.join(comments)\n    return ret", "code_tokens": ["def", "route53_alias_present", "(", "name", ",", "region", "=", "None", ",", "key", "=", "None", ",", "keyid", "=", "None", ",", "profile", "=", "None", ",", "*", "*", "kwargs", ")", ":", "MAGIC_CLOUDFRONT_HOSTED_ZONEID", "=", "'Z2FDTNDATAQYW2'", "ret", "=", "{", "'name'", ":", "name", ",", "'result'", ":", "True", ",", "'comment'", ":", "''", ",", "'changes'", ":", "{", "}", "}", "Distribution", "=", "kwargs", "[", "'Distribution'", "]", "if", "'Distribution'", "in", "kwargs", "else", "name", "ResourceRecordSet", "=", "kwargs", ".", "get", "(", "'ResourceRecordSet'", ",", "{", "}", ")", "Name", "=", "ResourceRecordSet", ".", "get", "(", "'Name'", ",", "name", ")", "ResourceRecordSet", "[", "'Name'", "]", "=", "Name", "res", "=", "__salt__", "[", "'boto_cloudfront.get_distributions_by_comment'", "]", "(", "Comment", "=", "Distribution", ",", "region", "=", "region", ",", "key", "=", "key", ",", "keyid", "=", "keyid", ",", "profile", "=", "profile", ")", "if", "res", "is", "None", ":", "msg", "=", "'Error resolving CloudFront distribution `{}` to a Resource ID.'", ".", "format", "(", "Distribution", ")", "log", ".", "error", "(", "msg", ")", "ret", "[", "'comment'", "]", "=", "msg", "ret", "[", "'result'", "]", "=", "False", "return", "ret", "if", "len", "(", "res", ")", ">", "1", ":", "msg", "=", "'Multiple CloudFront distibutions matched `{}`.'", ".", "format", "(", "Distribution", ")", "log", ".", "error", "(", "msg", ")", "ret", "[", "'comment'", "]", "=", "msg", "ret", "[", "'result'", "]", "=", "False", "return", "ret", "if", "not", "res", ":", "msg", "=", "'No CloudFront distibutions matching `{}` found.'", ".", "format", "(", "Distribution", ")", "log", ".", "error", "(", "msg", ")", "ret", "[", "'comment'", "]", "=", "msg", "ret", "[", "'result'", "]", "=", "False", "return", "ret", "dist", "=", "res", "[", "0", "]", "Types", "=", "(", "'A'", ",", "'AAAA'", ")", "if", "dist", ".", "get", "(", "'IsIPV6Enabled'", ",", "False", ")", "else", "(", "'A'", ",", ")", "DNSName", "=", "dist", ".", "get", "(", "'DomainName'", ",", "''", ")", "Aliases", "=", "dist", ".", "get", "(", "'Aliases'", ",", "{", "}", ")", ".", "get", "(", "'Items'", ",", "[", "]", ")", "# AWS annoyance #437:", "#   Route53 \"FQDNs\" (correctly!) REQUIRE trailing periods...", "#   while CloudFront \"FQDNs\" don't PERMIT trailing periods...", "Aliases", "+=", "[", "(", "a", "if", "a", ".", "endswith", "(", "'.'", ")", "else", "'{}.'", ".", "format", "(", "a", ")", ")", "for", "a", "in", "Aliases", "]", "if", "Name", "not", "in", "Aliases", ":", "msg", "=", "(", "'Route53 alias `{}` requested which is not mirrored in the `Aliases`'", "' sub-section of the DistributionConfig.'", ".", "format", "(", "Name", ")", ")", "log", ".", "error", "(", "msg", ")", "ret", "[", "'comment'", "]", "=", "msg", "ret", "[", "'result'", "]", "=", "False", "return", "ret", "changes", "=", "{", "'old'", ":", "[", "]", ",", "'new'", ":", "[", "]", "}", "comments", "=", "[", "]", "# Now mock out a route53 state def, and use the route53 rr_exists state to enforce it...", "AliasTarget", "=", "ResourceRecordSet", ".", "get", "(", "'AliasTarget'", ",", "{", "}", ")", "AliasTarget", "[", "'DNSName'", "]", "=", "AliasTarget", "[", "'DNSName'", "]", "if", "'DNSName'", "in", "AliasTarget", "else", "DNSName", "AliasTarget", "[", "'DNSName'", "]", "+=", "''", "if", "AliasTarget", "[", "'DNSName'", "]", ".", "endswith", "(", "'.'", ")", "else", "'.'", "# GRRRR!", "AliasTarget", "[", "'HostedZoneId'", "]", "=", "MAGIC_CLOUDFRONT_HOSTED_ZONEID", "AliasTarget", "[", "'EvaluateTargetHealth'", "]", "=", "False", "# Route53 limitation", "ResourceRecordSet", "[", "'name'", "]", "=", "Name", "ResourceRecordSet", "[", "'AliasTarget'", "]", "=", "AliasTarget", "ResourceRecordSet", "[", "'PrivateZone'", "]", "=", "False", "# Route53 limitation", "ResourceRecordSet", "[", "'DomainName'", "]", "=", "kwargs", ".", "get", "(", "'DomainName'", ")", "ResourceRecordSet", "[", "'HostedZoneId'", "]", "=", "kwargs", ".", "get", "(", "'HostedZoneId'", ")", "ResourceRecordSet", ".", "update", "(", "{", "'region'", ":", "region", ",", "'key'", ":", "key", ",", "'keyid'", ":", "keyid", ",", "'profile'", ":", "profile", "}", ")", "for", "Type", "in", "Types", ":", "ResourceRecordSet", "[", "'Type'", "]", "=", "Type", "# Checking for `test=True` will occur in the called state....", "log", ".", "debug", "(", "'Calling state function `boto3_route53.rr_present()` with args:  `%s`'", ",", "ResourceRecordSet", ")", "res", "=", "__states__", "[", "'boto3_route53.rr_present'", "]", "(", "*", "*", "ResourceRecordSet", ")", "ret", "[", "'result'", "]", "=", "res", "[", "'result'", "]", "comments", "+=", "[", "res", "[", "'comment'", "]", "]", "if", "ret", "[", "'result'", "]", "not", "in", "(", "True", ",", "None", ")", ":", "break", "changes", "[", "'old'", "]", "+=", "[", "res", "[", "'changes'", "]", "[", "'old'", "]", "]", "if", "res", "[", "'changes'", "]", ".", "get", "(", "'old'", ")", "else", "[", "]", "changes", "[", "'new'", "]", "+=", "[", "res", "[", "'changes'", "]", "[", "'new'", "]", "]", "if", "res", "[", "'changes'", "]", ".", "get", "(", "'new'", ")", "else", "[", "]", "ret", "[", "'changes'", "]", ".", "update", "(", "{", "'old'", ":", "changes", "[", "'old'", "]", "}", ")", "if", "changes", ".", "get", "(", "'old'", ")", "else", "None", "ret", "[", "'changes'", "]", ".", "update", "(", "{", "'new'", ":", "changes", "[", "'new'", "]", "}", ")", "if", "changes", ".", "get", "(", "'new'", ")", "else", "None", "ret", "[", "'comment'", "]", "=", "'  '", ".", "join", "(", "comments", ")", "return", "ret"], "docstring": "Ensure a Route53 Alias exists and is pointing at the given CloudFront\n    distribution. An ``A`` record is always created, and if IPV6 is enabled on\n    the given distribution, an ``AAAA`` record will be created as well. Also be\n    aware that Alias records for CloudFront distributions are only permitted in\n    non-private zones.\n\n    name\n        The name of the state definition.\n\n    Distribution\n        The name of the CloudFront distribution. Defaults to the value of\n        ``name`` if not provided.\n\n    HostedZoneId\n        Id of the Route53 hosted zone within which the records should be created.\n\n    DomainName\n        The domain name associated with the Hosted Zone. Exclusive with HostedZoneId.\n\n    ResourceRecordSet\n        A Route53 Record Set (with AliasTarget section, suitable for use as an\n        ``Alias`` record, if non-default settings are needed on the Alias)\n        which should be pointed at the provided CloudFront distribution. Note\n        that this MUST correlate with the Aliases set within the\n        DistributionConfig section of the distribution.\n\n        Some notes *specifically* about the ``AliasTarget`` subsection of the\n        ResourceRecordSet:\n\n        - If not specified, the ``DNSName`` sub-field will be populated by\n          dereferencing ``Distribution`` above to the value of its\n          ``DomainName`` attribute.\n\n        - The HostedZoneId sub-field should not be provided -- it will be\n          automatically populated with a ``magic`` AWS value.\n\n        - The EvaluateTargetHealth can only be False on a CloudFront Alias.\n\n        - The above items taken all together imply that, for most use-cases,\n          the AliasTarget sub-section can be entirely omitted, as seen in the\n          first code sample below.\n\n        Lastly, note that if you set ``name`` to the desired ResourceRecordSet\n        Name, you can entirely omit this parameter, as shown in the second\n        example below.\n\n    .. code-block:: yaml\n\n        Add a Route53 Alias for my_distribution:\n          boto_cloudfront.present:\n          - Distribution: my_distribution\n          - DomainName: saltstack.org.\n          - ResourceRecordSet:\n              Name: the-alias.saltstack.org.\n        # This is even simpler - it uses the value of `name` for ResourceRecordSet.Name\n        another-alias.saltstack.org.:\n          boto_cloudfront.present:\n          - Distribution: my_distribution\n          - DomainName: saltstack.org.", "docstring_tokens": ["Ensure", "a", "Route53", "Alias", "exists", "and", "is", "pointing", "at", "the", "given", "CloudFront", "distribution", ".", "An", "A", "record", "is", "always", "created", "and", "if", "IPV6", "is", "enabled", "on", "the", "given", "distribution", "an", "AAAA", "record", "will", "be", "created", "as", "well", ".", "Also", "be", "aware", "that", "Alias", "records", "for", "CloudFront", "distributions", "are", "only", "permitted", "in", "non", "-", "private", "zones", "."], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/states/boto_cloudfront.py#L698-L834", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/states/boto_cloudfront.py", "func_name": "distribution_absent", "original_string": "def distribution_absent(name, region=None, key=None, keyid=None, profile=None, **kwargs):\n    '''\n    Ensure a distribution with the given Name tag does not exist.\n\n    Note that CloudFront does not allow directly deleting an enabled\n    Distribution. If such is requested, Salt will attempt to first update the\n    distribution's status to Disabled, and once that returns success, to then\n    delete the resource. THIS CAN TAKE SOME TIME, so be patient :)\n\n    name (string)\n        Name of the state definition.\n\n    Name (string)\n        Name of the CloudFront distribution to be managed. If not provided, the\n        value of ``name`` will be used as a default. The purpose of this\n        parameter is only to resolve it to a Resource ID, so be aware that an\n        explicit value for ``Id`` below will override any value provided, or\n        defaulted, here.\n\n    Id (string)\n        The Resource ID of a CloudFront distribution to be managed.\n\n    region (string)\n        Region to connect to\n\n    key (string)\n        Secret key to use\n\n    keyid (string)\n        Access key to use\n\n    profile (dict or string)\n        Dict, or pillar key pointing to a dict, containing AWS region/key/keyid.\n\n    Example:\n\n    .. code-block:: yaml\n\n        Ensure a distribution named my_distribution is gone:\n          boto_cloudfront.distribution_absent:\n          - Name: my_distribution\n\n    '''\n    Name = kwargs['Name'] if 'Name' in kwargs else name\n    Id = kwargs.get('Id')\n    ref = kwargs['Id'] if 'Id' in kwargs else Name\n    ret = {'name': Id if Id else Name, 'comment': '', 'changes': {}, 'result': True}\n    authargs = {'region': region, 'key': key, 'keyid': keyid, 'profile': profile}\n    if not Id:\n        res = __salt__['boto_cloudfront.get_distributions_by_comment'](Comment=Name, **authargs)\n        if res is None:\n            msg = 'Error dereferencing CloudFront distribution `{}` to a Resource ID.'.format(Name)\n            log.error(msg)\n            ret['comment'] = msg\n            ret['result'] = False\n            return ret\n        if len(res) > 1:\n            msg = ('Multiple CloudFront distibutions matched `{}`, no way to know which to'\n                   ' delete.`.'.format(Name))\n            log.error(msg)\n            ret['comment'] = msg\n            ret['result'] = False\n            return ret\n        if not res:\n            msg = 'CloudFront Distribution `{}` already absent.'.format(Name)\n            log.info(msg)\n            ret['comment'] = msg\n            ret['result'] = True\n            return ret\n        Id = res[0]['Id']\n\n    if not __salt__['boto_cloudfront.distribution_exists'](Id=Id, **authargs):\n        msg = 'CloudFront distribution `{}` already absent.'.format(ref)\n        log.info(msg)\n        ret['comment'] = msg\n        return ret\n\n    old = __salt__['boto_cloudfront.get_distribution_v2'](Id=Id, **authargs)\n    if old is None:\n        ret['result'] = False\n        msg = 'Error getting state of CloudFront distribution `{}`.'.format(ref)\n        log.error(msg)\n        ret['comment'] = msg\n        return ret\n    currETag = old['ETag']\n\n    Enabled = old['DistributionConfig']['Enabled']\n    if __opts__['test']:\n        ret['result'] = None\n        ret['comment'] = 'CloudFront distribution `{}` would be {}deleted.'.format(ref,\n                ('disabled and ' if Enabled else ''))\n        ret['pchanges'] = {'old': old, 'new': None}\n        return ret\n\n    comments = []\n    if Enabled:\n        disabled = __salt__['boto_cloudfront.disable_distribution'](Id=Id, **authargs)\n        if disabled is None:\n            ret['result'] = False\n            msg = 'Error disabling CloudFront distribution `{}`'.format(ref)\n            log.error(msg)\n            ret['comment'] = msg\n            return ret\n        comments += ['CloudFront distribution `{}` disabled.'.format(ref)]\n        currETag = disabled['ETag']\n    deleted = __salt__['boto_cloudfront.delete_distribution'](Id=Id, IfMatch=currETag, **authargs)\n    if deleted is False:\n        ret['result'] = False\n        msg = 'Error deleting CloudFront distribution `{}`'.format(ref)\n        comments += [msg]\n        log.error(msg)\n        ret['comment'] = '  '.join(comments)\n        return ret\n    msg = 'CloudFront distribution `{}` deleted.'.format(ref)\n    comments += [msg]\n    log.info(msg)\n    ret['comment'] = '  '.join(comments)\n    ret['changes'] = {'old': old, 'new': None}\n    return ret", "language": "python", "code": "def distribution_absent(name, region=None, key=None, keyid=None, profile=None, **kwargs):\n    '''\n    Ensure a distribution with the given Name tag does not exist.\n\n    Note that CloudFront does not allow directly deleting an enabled\n    Distribution. If such is requested, Salt will attempt to first update the\n    distribution's status to Disabled, and once that returns success, to then\n    delete the resource. THIS CAN TAKE SOME TIME, so be patient :)\n\n    name (string)\n        Name of the state definition.\n\n    Name (string)\n        Name of the CloudFront distribution to be managed. If not provided, the\n        value of ``name`` will be used as a default. The purpose of this\n        parameter is only to resolve it to a Resource ID, so be aware that an\n        explicit value for ``Id`` below will override any value provided, or\n        defaulted, here.\n\n    Id (string)\n        The Resource ID of a CloudFront distribution to be managed.\n\n    region (string)\n        Region to connect to\n\n    key (string)\n        Secret key to use\n\n    keyid (string)\n        Access key to use\n\n    profile (dict or string)\n        Dict, or pillar key pointing to a dict, containing AWS region/key/keyid.\n\n    Example:\n\n    .. code-block:: yaml\n\n        Ensure a distribution named my_distribution is gone:\n          boto_cloudfront.distribution_absent:\n          - Name: my_distribution\n\n    '''\n    Name = kwargs['Name'] if 'Name' in kwargs else name\n    Id = kwargs.get('Id')\n    ref = kwargs['Id'] if 'Id' in kwargs else Name\n    ret = {'name': Id if Id else Name, 'comment': '', 'changes': {}, 'result': True}\n    authargs = {'region': region, 'key': key, 'keyid': keyid, 'profile': profile}\n    if not Id:\n        res = __salt__['boto_cloudfront.get_distributions_by_comment'](Comment=Name, **authargs)\n        if res is None:\n            msg = 'Error dereferencing CloudFront distribution `{}` to a Resource ID.'.format(Name)\n            log.error(msg)\n            ret['comment'] = msg\n            ret['result'] = False\n            return ret\n        if len(res) > 1:\n            msg = ('Multiple CloudFront distibutions matched `{}`, no way to know which to'\n                   ' delete.`.'.format(Name))\n            log.error(msg)\n            ret['comment'] = msg\n            ret['result'] = False\n            return ret\n        if not res:\n            msg = 'CloudFront Distribution `{}` already absent.'.format(Name)\n            log.info(msg)\n            ret['comment'] = msg\n            ret['result'] = True\n            return ret\n        Id = res[0]['Id']\n\n    if not __salt__['boto_cloudfront.distribution_exists'](Id=Id, **authargs):\n        msg = 'CloudFront distribution `{}` already absent.'.format(ref)\n        log.info(msg)\n        ret['comment'] = msg\n        return ret\n\n    old = __salt__['boto_cloudfront.get_distribution_v2'](Id=Id, **authargs)\n    if old is None:\n        ret['result'] = False\n        msg = 'Error getting state of CloudFront distribution `{}`.'.format(ref)\n        log.error(msg)\n        ret['comment'] = msg\n        return ret\n    currETag = old['ETag']\n\n    Enabled = old['DistributionConfig']['Enabled']\n    if __opts__['test']:\n        ret['result'] = None\n        ret['comment'] = 'CloudFront distribution `{}` would be {}deleted.'.format(ref,\n                ('disabled and ' if Enabled else ''))\n        ret['pchanges'] = {'old': old, 'new': None}\n        return ret\n\n    comments = []\n    if Enabled:\n        disabled = __salt__['boto_cloudfront.disable_distribution'](Id=Id, **authargs)\n        if disabled is None:\n            ret['result'] = False\n            msg = 'Error disabling CloudFront distribution `{}`'.format(ref)\n            log.error(msg)\n            ret['comment'] = msg\n            return ret\n        comments += ['CloudFront distribution `{}` disabled.'.format(ref)]\n        currETag = disabled['ETag']\n    deleted = __salt__['boto_cloudfront.delete_distribution'](Id=Id, IfMatch=currETag, **authargs)\n    if deleted is False:\n        ret['result'] = False\n        msg = 'Error deleting CloudFront distribution `{}`'.format(ref)\n        comments += [msg]\n        log.error(msg)\n        ret['comment'] = '  '.join(comments)\n        return ret\n    msg = 'CloudFront distribution `{}` deleted.'.format(ref)\n    comments += [msg]\n    log.info(msg)\n    ret['comment'] = '  '.join(comments)\n    ret['changes'] = {'old': old, 'new': None}\n    return ret", "code_tokens": ["def", "distribution_absent", "(", "name", ",", "region", "=", "None", ",", "key", "=", "None", ",", "keyid", "=", "None", ",", "profile", "=", "None", ",", "*", "*", "kwargs", ")", ":", "Name", "=", "kwargs", "[", "'Name'", "]", "if", "'Name'", "in", "kwargs", "else", "name", "Id", "=", "kwargs", ".", "get", "(", "'Id'", ")", "ref", "=", "kwargs", "[", "'Id'", "]", "if", "'Id'", "in", "kwargs", "else", "Name", "ret", "=", "{", "'name'", ":", "Id", "if", "Id", "else", "Name", ",", "'comment'", ":", "''", ",", "'changes'", ":", "{", "}", ",", "'result'", ":", "True", "}", "authargs", "=", "{", "'region'", ":", "region", ",", "'key'", ":", "key", ",", "'keyid'", ":", "keyid", ",", "'profile'", ":", "profile", "}", "if", "not", "Id", ":", "res", "=", "__salt__", "[", "'boto_cloudfront.get_distributions_by_comment'", "]", "(", "Comment", "=", "Name", ",", "*", "*", "authargs", ")", "if", "res", "is", "None", ":", "msg", "=", "'Error dereferencing CloudFront distribution `{}` to a Resource ID.'", ".", "format", "(", "Name", ")", "log", ".", "error", "(", "msg", ")", "ret", "[", "'comment'", "]", "=", "msg", "ret", "[", "'result'", "]", "=", "False", "return", "ret", "if", "len", "(", "res", ")", ">", "1", ":", "msg", "=", "(", "'Multiple CloudFront distibutions matched `{}`, no way to know which to'", "' delete.`.'", ".", "format", "(", "Name", ")", ")", "log", ".", "error", "(", "msg", ")", "ret", "[", "'comment'", "]", "=", "msg", "ret", "[", "'result'", "]", "=", "False", "return", "ret", "if", "not", "res", ":", "msg", "=", "'CloudFront Distribution `{}` already absent.'", ".", "format", "(", "Name", ")", "log", ".", "info", "(", "msg", ")", "ret", "[", "'comment'", "]", "=", "msg", "ret", "[", "'result'", "]", "=", "True", "return", "ret", "Id", "=", "res", "[", "0", "]", "[", "'Id'", "]", "if", "not", "__salt__", "[", "'boto_cloudfront.distribution_exists'", "]", "(", "Id", "=", "Id", ",", "*", "*", "authargs", ")", ":", "msg", "=", "'CloudFront distribution `{}` already absent.'", ".", "format", "(", "ref", ")", "log", ".", "info", "(", "msg", ")", "ret", "[", "'comment'", "]", "=", "msg", "return", "ret", "old", "=", "__salt__", "[", "'boto_cloudfront.get_distribution_v2'", "]", "(", "Id", "=", "Id", ",", "*", "*", "authargs", ")", "if", "old", "is", "None", ":", "ret", "[", "'result'", "]", "=", "False", "msg", "=", "'Error getting state of CloudFront distribution `{}`.'", ".", "format", "(", "ref", ")", "log", ".", "error", "(", "msg", ")", "ret", "[", "'comment'", "]", "=", "msg", "return", "ret", "currETag", "=", "old", "[", "'ETag'", "]", "Enabled", "=", "old", "[", "'DistributionConfig'", "]", "[", "'Enabled'", "]", "if", "__opts__", "[", "'test'", "]", ":", "ret", "[", "'result'", "]", "=", "None", "ret", "[", "'comment'", "]", "=", "'CloudFront distribution `{}` would be {}deleted.'", ".", "format", "(", "ref", ",", "(", "'disabled and '", "if", "Enabled", "else", "''", ")", ")", "ret", "[", "'pchanges'", "]", "=", "{", "'old'", ":", "old", ",", "'new'", ":", "None", "}", "return", "ret", "comments", "=", "[", "]", "if", "Enabled", ":", "disabled", "=", "__salt__", "[", "'boto_cloudfront.disable_distribution'", "]", "(", "Id", "=", "Id", ",", "*", "*", "authargs", ")", "if", "disabled", "is", "None", ":", "ret", "[", "'result'", "]", "=", "False", "msg", "=", "'Error disabling CloudFront distribution `{}`'", ".", "format", "(", "ref", ")", "log", ".", "error", "(", "msg", ")", "ret", "[", "'comment'", "]", "=", "msg", "return", "ret", "comments", "+=", "[", "'CloudFront distribution `{}` disabled.'", ".", "format", "(", "ref", ")", "]", "currETag", "=", "disabled", "[", "'ETag'", "]", "deleted", "=", "__salt__", "[", "'boto_cloudfront.delete_distribution'", "]", "(", "Id", "=", "Id", ",", "IfMatch", "=", "currETag", ",", "*", "*", "authargs", ")", "if", "deleted", "is", "False", ":", "ret", "[", "'result'", "]", "=", "False", "msg", "=", "'Error deleting CloudFront distribution `{}`'", ".", "format", "(", "ref", ")", "comments", "+=", "[", "msg", "]", "log", ".", "error", "(", "msg", ")", "ret", "[", "'comment'", "]", "=", "'  '", ".", "join", "(", "comments", ")", "return", "ret", "msg", "=", "'CloudFront distribution `{}` deleted.'", ".", "format", "(", "ref", ")", "comments", "+=", "[", "msg", "]", "log", ".", "info", "(", "msg", ")", "ret", "[", "'comment'", "]", "=", "'  '", ".", "join", "(", "comments", ")", "ret", "[", "'changes'", "]", "=", "{", "'old'", ":", "old", ",", "'new'", ":", "None", "}", "return", "ret"], "docstring": "Ensure a distribution with the given Name tag does not exist.\n\n    Note that CloudFront does not allow directly deleting an enabled\n    Distribution. If such is requested, Salt will attempt to first update the\n    distribution's status to Disabled, and once that returns success, to then\n    delete the resource. THIS CAN TAKE SOME TIME, so be patient :)\n\n    name (string)\n        Name of the state definition.\n\n    Name (string)\n        Name of the CloudFront distribution to be managed. If not provided, the\n        value of ``name`` will be used as a default. The purpose of this\n        parameter is only to resolve it to a Resource ID, so be aware that an\n        explicit value for ``Id`` below will override any value provided, or\n        defaulted, here.\n\n    Id (string)\n        The Resource ID of a CloudFront distribution to be managed.\n\n    region (string)\n        Region to connect to\n\n    key (string)\n        Secret key to use\n\n    keyid (string)\n        Access key to use\n\n    profile (dict or string)\n        Dict, or pillar key pointing to a dict, containing AWS region/key/keyid.\n\n    Example:\n\n    .. code-block:: yaml\n\n        Ensure a distribution named my_distribution is gone:\n          boto_cloudfront.distribution_absent:\n          - Name: my_distribution", "docstring_tokens": ["Ensure", "a", "distribution", "with", "the", "given", "Name", "tag", "does", "not", "exist", "."], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/states/boto_cloudfront.py#L837-L955", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/states/boto_cloudfront.py", "func_name": "origin_access_identity_present", "original_string": "def origin_access_identity_present(name, region=None, key=None, keyid=None, profile=None, **kwargs):\n    '''\n    Ensure a given CloudFront Origin Access Identity exists.\n\n    .. note::\n        Due to the unavailibity of ANY other way to store stateful idempotency\n        information about Origin Access Identities (including resource tags),\n        the Comment attribute (as the only user-settable attribute without\n        weird self-blocking semantics) is necessarily utilized to store the\n        Salt state signifier, which is used to determine resource existence and\n        state. That said, to enable SOME usability of this field, only the\n        value up to the first colon character is taken as the signifier, while\n        anything afterward is free-form and ignored by Salt.\n\n    name (string)\n        Name of the state definition.\n\n    Name (string)\n        Name of the resource (for purposes of Salt's idempotency). If not provided, the value of\n        `name` will be used.\n\n    Comment\n        Free-form text description of the origin access identity.\n\n    region (string)\n        Region to connect to\n\n    key (string)\n        Secret key to use\n\n    keyid (string)\n        Access key to use\n\n    profile (dict or string)\n        Dict, or pillar key pointing to a dict, containing AWS region/key/keyid.\n\n    Example:\n\n    .. code-block:: yaml\n\n        my_OAI:\n          boto_cloudfront.origin_access_identity_present:\n          - Comment: Simply ensures an OAI named my_OAI exists\n\n    '''\n    ret = {'name': name, 'result': True, 'comment': '', 'changes': {}}\n    kwargs = {k: v for k, v in kwargs.items() if not k.startswith('_')}\n    authargs = {'region': region, 'key': key, 'keyid': keyid, 'profile': profile}\n    Name = kwargs.get('Name', name)\n    # Munge Name into the Comment field...\n    Comment = '{}:{}'.format(Name, kwargs['Comment']) if kwargs.get('Comment') else Name\n\n    # Current state of the thing?\n    res = __salt__['boto_cloudfront.get_cloud_front_origin_access_identities_by_comment'](\n            Comment=Name, region=region, key=key, keyid=keyid, profile=profile)\n    if res is None:\n        msg = 'Error determining current state of origin access identity `{}`.'.format(Name)\n        log.error(msg)\n        ret['comment'] = msg\n        ret['result'] = False\n        return ret\n    if len(res) > 1:\n        msg = 'Multiple CloudFront origin access identities matched `{}`.'.format(Name)\n        log.error(msg)\n        ret['comment'] = msg\n        ret['result'] = False\n        return ret\n\n    exists = bool(res)\n    if not exists:\n        CloudFrontOriginAccessIdentityConfig = {'Comment': Comment,\n                                                'CallerReference': str(uuid.uuid4())}\n        if __opts__['test']:\n            ret['result'] = None\n            ret['comment'] = 'CloudFront origin access identity `{}` would be created.'.format(Name)\n            new = {'CloudFrontOriginAccessIdentityConfig': CloudFrontOriginAccessIdentityConfig}\n            ret['pchanges'] = {'old': None, 'new': new}\n            return ret\n        kwargs = {'CloudFrontOriginAccessIdentityConfig': CloudFrontOriginAccessIdentityConfig}\n        kwargs.update(authargs)\n        res = __salt__['boto_cloudfront.create_cloud_front_origin_access_identity'](**kwargs)\n        if res is None:\n            ret['result'] = False\n            msg = 'Failed to create CloudFront origin access identity `{}`.'.format(Name)\n            log.error(msg)\n            ret['comment'] = msg\n            return ret\n        ret['comment'] = 'Created CloudFrong origin access identity`{}`.'.format(Name)\n        ret['changes'] = {'old': None, 'new': res}\n        return ret\n    else:\n        currentId = res[0]['Id']\n        current = __salt__['boto_cloudfront.get_cloud_front_origin_access_identity'](Id=currentId,\n                **authargs)\n        currentETag = current['ETag']\n        currentOAIC = current['CloudFrontOriginAccessIdentity']['CloudFrontOriginAccessIdentityConfig']\n        new = copy.deepcopy(currentOAIC)\n        new.update({'Comment': Comment})  # Currently the only updatable element :-/\n        if currentOAIC == new:\n            msg = 'CloudFront origin access identity `{}` is in the correct state.'.format(Name)\n            log.info(msg)\n            ret['comment'] = msg\n            return ret\n        if __opts__['test']:\n            ret['result'] = None\n            ret['comment'] = 'CloudFront origin access identity `{}` would be updated.'.format(Name)\n            ret['pchanges'] = {'old': currentOAIC, 'new': new}\n            return ret\n        kwargs = {'CloudFrontOriginAccessIdentityConfig': new,\n                  'Id': currentId, 'IfMatch': currentETag}\n        kwargs.update(authargs)\n        res = __salt__['boto_cloudfront.update_cloud_front_origin_access_identity'](**kwargs)\n        if res is None:\n            ret['result'] = False\n            msg = 'Error occurred while updating origin access identity `{}`.'.format(Name)\n            log.error(msg)\n            ret['comment'] = msg\n            return ret\n        ret['comment'] = 'CloudFront origin access identity `{}` config updated.'.format(Name)\n        ret['changes'] = {'old': currentOAIC, 'new': new}\n        return ret", "language": "python", "code": "def origin_access_identity_present(name, region=None, key=None, keyid=None, profile=None, **kwargs):\n    '''\n    Ensure a given CloudFront Origin Access Identity exists.\n\n    .. note::\n        Due to the unavailibity of ANY other way to store stateful idempotency\n        information about Origin Access Identities (including resource tags),\n        the Comment attribute (as the only user-settable attribute without\n        weird self-blocking semantics) is necessarily utilized to store the\n        Salt state signifier, which is used to determine resource existence and\n        state. That said, to enable SOME usability of this field, only the\n        value up to the first colon character is taken as the signifier, while\n        anything afterward is free-form and ignored by Salt.\n\n    name (string)\n        Name of the state definition.\n\n    Name (string)\n        Name of the resource (for purposes of Salt's idempotency). If not provided, the value of\n        `name` will be used.\n\n    Comment\n        Free-form text description of the origin access identity.\n\n    region (string)\n        Region to connect to\n\n    key (string)\n        Secret key to use\n\n    keyid (string)\n        Access key to use\n\n    profile (dict or string)\n        Dict, or pillar key pointing to a dict, containing AWS region/key/keyid.\n\n    Example:\n\n    .. code-block:: yaml\n\n        my_OAI:\n          boto_cloudfront.origin_access_identity_present:\n          - Comment: Simply ensures an OAI named my_OAI exists\n\n    '''\n    ret = {'name': name, 'result': True, 'comment': '', 'changes': {}}\n    kwargs = {k: v for k, v in kwargs.items() if not k.startswith('_')}\n    authargs = {'region': region, 'key': key, 'keyid': keyid, 'profile': profile}\n    Name = kwargs.get('Name', name)\n    # Munge Name into the Comment field...\n    Comment = '{}:{}'.format(Name, kwargs['Comment']) if kwargs.get('Comment') else Name\n\n    # Current state of the thing?\n    res = __salt__['boto_cloudfront.get_cloud_front_origin_access_identities_by_comment'](\n            Comment=Name, region=region, key=key, keyid=keyid, profile=profile)\n    if res is None:\n        msg = 'Error determining current state of origin access identity `{}`.'.format(Name)\n        log.error(msg)\n        ret['comment'] = msg\n        ret['result'] = False\n        return ret\n    if len(res) > 1:\n        msg = 'Multiple CloudFront origin access identities matched `{}`.'.format(Name)\n        log.error(msg)\n        ret['comment'] = msg\n        ret['result'] = False\n        return ret\n\n    exists = bool(res)\n    if not exists:\n        CloudFrontOriginAccessIdentityConfig = {'Comment': Comment,\n                                                'CallerReference': str(uuid.uuid4())}\n        if __opts__['test']:\n            ret['result'] = None\n            ret['comment'] = 'CloudFront origin access identity `{}` would be created.'.format(Name)\n            new = {'CloudFrontOriginAccessIdentityConfig': CloudFrontOriginAccessIdentityConfig}\n            ret['pchanges'] = {'old': None, 'new': new}\n            return ret\n        kwargs = {'CloudFrontOriginAccessIdentityConfig': CloudFrontOriginAccessIdentityConfig}\n        kwargs.update(authargs)\n        res = __salt__['boto_cloudfront.create_cloud_front_origin_access_identity'](**kwargs)\n        if res is None:\n            ret['result'] = False\n            msg = 'Failed to create CloudFront origin access identity `{}`.'.format(Name)\n            log.error(msg)\n            ret['comment'] = msg\n            return ret\n        ret['comment'] = 'Created CloudFrong origin access identity`{}`.'.format(Name)\n        ret['changes'] = {'old': None, 'new': res}\n        return ret\n    else:\n        currentId = res[0]['Id']\n        current = __salt__['boto_cloudfront.get_cloud_front_origin_access_identity'](Id=currentId,\n                **authargs)\n        currentETag = current['ETag']\n        currentOAIC = current['CloudFrontOriginAccessIdentity']['CloudFrontOriginAccessIdentityConfig']\n        new = copy.deepcopy(currentOAIC)\n        new.update({'Comment': Comment})  # Currently the only updatable element :-/\n        if currentOAIC == new:\n            msg = 'CloudFront origin access identity `{}` is in the correct state.'.format(Name)\n            log.info(msg)\n            ret['comment'] = msg\n            return ret\n        if __opts__['test']:\n            ret['result'] = None\n            ret['comment'] = 'CloudFront origin access identity `{}` would be updated.'.format(Name)\n            ret['pchanges'] = {'old': currentOAIC, 'new': new}\n            return ret\n        kwargs = {'CloudFrontOriginAccessIdentityConfig': new,\n                  'Id': currentId, 'IfMatch': currentETag}\n        kwargs.update(authargs)\n        res = __salt__['boto_cloudfront.update_cloud_front_origin_access_identity'](**kwargs)\n        if res is None:\n            ret['result'] = False\n            msg = 'Error occurred while updating origin access identity `{}`.'.format(Name)\n            log.error(msg)\n            ret['comment'] = msg\n            return ret\n        ret['comment'] = 'CloudFront origin access identity `{}` config updated.'.format(Name)\n        ret['changes'] = {'old': currentOAIC, 'new': new}\n        return ret", "code_tokens": ["def", "origin_access_identity_present", "(", "name", ",", "region", "=", "None", ",", "key", "=", "None", ",", "keyid", "=", "None", ",", "profile", "=", "None", ",", "*", "*", "kwargs", ")", ":", "ret", "=", "{", "'name'", ":", "name", ",", "'result'", ":", "True", ",", "'comment'", ":", "''", ",", "'changes'", ":", "{", "}", "}", "kwargs", "=", "{", "k", ":", "v", "for", "k", ",", "v", "in", "kwargs", ".", "items", "(", ")", "if", "not", "k", ".", "startswith", "(", "'_'", ")", "}", "authargs", "=", "{", "'region'", ":", "region", ",", "'key'", ":", "key", ",", "'keyid'", ":", "keyid", ",", "'profile'", ":", "profile", "}", "Name", "=", "kwargs", ".", "get", "(", "'Name'", ",", "name", ")", "# Munge Name into the Comment field...", "Comment", "=", "'{}:{}'", ".", "format", "(", "Name", ",", "kwargs", "[", "'Comment'", "]", ")", "if", "kwargs", ".", "get", "(", "'Comment'", ")", "else", "Name", "# Current state of the thing?", "res", "=", "__salt__", "[", "'boto_cloudfront.get_cloud_front_origin_access_identities_by_comment'", "]", "(", "Comment", "=", "Name", ",", "region", "=", "region", ",", "key", "=", "key", ",", "keyid", "=", "keyid", ",", "profile", "=", "profile", ")", "if", "res", "is", "None", ":", "msg", "=", "'Error determining current state of origin access identity `{}`.'", ".", "format", "(", "Name", ")", "log", ".", "error", "(", "msg", ")", "ret", "[", "'comment'", "]", "=", "msg", "ret", "[", "'result'", "]", "=", "False", "return", "ret", "if", "len", "(", "res", ")", ">", "1", ":", "msg", "=", "'Multiple CloudFront origin access identities matched `{}`.'", ".", "format", "(", "Name", ")", "log", ".", "error", "(", "msg", ")", "ret", "[", "'comment'", "]", "=", "msg", "ret", "[", "'result'", "]", "=", "False", "return", "ret", "exists", "=", "bool", "(", "res", ")", "if", "not", "exists", ":", "CloudFrontOriginAccessIdentityConfig", "=", "{", "'Comment'", ":", "Comment", ",", "'CallerReference'", ":", "str", "(", "uuid", ".", "uuid4", "(", ")", ")", "}", "if", "__opts__", "[", "'test'", "]", ":", "ret", "[", "'result'", "]", "=", "None", "ret", "[", "'comment'", "]", "=", "'CloudFront origin access identity `{}` would be created.'", ".", "format", "(", "Name", ")", "new", "=", "{", "'CloudFrontOriginAccessIdentityConfig'", ":", "CloudFrontOriginAccessIdentityConfig", "}", "ret", "[", "'pchanges'", "]", "=", "{", "'old'", ":", "None", ",", "'new'", ":", "new", "}", "return", "ret", "kwargs", "=", "{", "'CloudFrontOriginAccessIdentityConfig'", ":", "CloudFrontOriginAccessIdentityConfig", "}", "kwargs", ".", "update", "(", "authargs", ")", "res", "=", "__salt__", "[", "'boto_cloudfront.create_cloud_front_origin_access_identity'", "]", "(", "*", "*", "kwargs", ")", "if", "res", "is", "None", ":", "ret", "[", "'result'", "]", "=", "False", "msg", "=", "'Failed to create CloudFront origin access identity `{}`.'", ".", "format", "(", "Name", ")", "log", ".", "error", "(", "msg", ")", "ret", "[", "'comment'", "]", "=", "msg", "return", "ret", "ret", "[", "'comment'", "]", "=", "'Created CloudFrong origin access identity`{}`.'", ".", "format", "(", "Name", ")", "ret", "[", "'changes'", "]", "=", "{", "'old'", ":", "None", ",", "'new'", ":", "res", "}", "return", "ret", "else", ":", "currentId", "=", "res", "[", "0", "]", "[", "'Id'", "]", "current", "=", "__salt__", "[", "'boto_cloudfront.get_cloud_front_origin_access_identity'", "]", "(", "Id", "=", "currentId", ",", "*", "*", "authargs", ")", "currentETag", "=", "current", "[", "'ETag'", "]", "currentOAIC", "=", "current", "[", "'CloudFrontOriginAccessIdentity'", "]", "[", "'CloudFrontOriginAccessIdentityConfig'", "]", "new", "=", "copy", ".", "deepcopy", "(", "currentOAIC", ")", "new", ".", "update", "(", "{", "'Comment'", ":", "Comment", "}", ")", "# Currently the only updatable element :-/", "if", "currentOAIC", "==", "new", ":", "msg", "=", "'CloudFront origin access identity `{}` is in the correct state.'", ".", "format", "(", "Name", ")", "log", ".", "info", "(", "msg", ")", "ret", "[", "'comment'", "]", "=", "msg", "return", "ret", "if", "__opts__", "[", "'test'", "]", ":", "ret", "[", "'result'", "]", "=", "None", "ret", "[", "'comment'", "]", "=", "'CloudFront origin access identity `{}` would be updated.'", ".", "format", "(", "Name", ")", "ret", "[", "'pchanges'", "]", "=", "{", "'old'", ":", "currentOAIC", ",", "'new'", ":", "new", "}", "return", "ret", "kwargs", "=", "{", "'CloudFrontOriginAccessIdentityConfig'", ":", "new", ",", "'Id'", ":", "currentId", ",", "'IfMatch'", ":", "currentETag", "}", "kwargs", ".", "update", "(", "authargs", ")", "res", "=", "__salt__", "[", "'boto_cloudfront.update_cloud_front_origin_access_identity'", "]", "(", "*", "*", "kwargs", ")", "if", "res", "is", "None", ":", "ret", "[", "'result'", "]", "=", "False", "msg", "=", "'Error occurred while updating origin access identity `{}`.'", ".", "format", "(", "Name", ")", "log", ".", "error", "(", "msg", ")", "ret", "[", "'comment'", "]", "=", "msg", "return", "ret", "ret", "[", "'comment'", "]", "=", "'CloudFront origin access identity `{}` config updated.'", ".", "format", "(", "Name", ")", "ret", "[", "'changes'", "]", "=", "{", "'old'", ":", "currentOAIC", ",", "'new'", ":", "new", "}", "return", "ret"], "docstring": "Ensure a given CloudFront Origin Access Identity exists.\n\n    .. note::\n        Due to the unavailibity of ANY other way to store stateful idempotency\n        information about Origin Access Identities (including resource tags),\n        the Comment attribute (as the only user-settable attribute without\n        weird self-blocking semantics) is necessarily utilized to store the\n        Salt state signifier, which is used to determine resource existence and\n        state. That said, to enable SOME usability of this field, only the\n        value up to the first colon character is taken as the signifier, while\n        anything afterward is free-form and ignored by Salt.\n\n    name (string)\n        Name of the state definition.\n\n    Name (string)\n        Name of the resource (for purposes of Salt's idempotency). If not provided, the value of\n        `name` will be used.\n\n    Comment\n        Free-form text description of the origin access identity.\n\n    region (string)\n        Region to connect to\n\n    key (string)\n        Secret key to use\n\n    keyid (string)\n        Access key to use\n\n    profile (dict or string)\n        Dict, or pillar key pointing to a dict, containing AWS region/key/keyid.\n\n    Example:\n\n    .. code-block:: yaml\n\n        my_OAI:\n          boto_cloudfront.origin_access_identity_present:\n          - Comment: Simply ensures an OAI named my_OAI exists", "docstring_tokens": ["Ensure", "a", "given", "CloudFront", "Origin", "Access", "Identity", "exists", "."], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/states/boto_cloudfront.py#L958-L1078", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/states/boto_cloudfront.py", "func_name": "origin_access_identity_absent", "original_string": "def origin_access_identity_absent(name, region=None, key=None, keyid=None, profile=None, **kwargs):\n    '''\n    Ensure a given CloudFront Origin Access Identity is absent.\n\n    name\n        The name of the state definition.\n\n    Name (string)\n        Name of the resource (for purposes of Salt's idempotency). If not\n        provided, the value of ``name`` will be used.\n\n    Id (string)\n        The Resource ID of a CloudFront origin access identity to be managed.\n\n    region (string)\n        Region to connect to\n\n    key (string)\n        Secret key to use\n\n    keyid (string)\n        Access key to use\n\n    profile (dict or string)\n        Dict, or pillar key pointing to a dict, containing AWS region/key/keyid.\n\n    Example:\n\n    .. code-block:: yaml\n\n        Ensure an origin access identity named my_OAI is gone:\n          boto_cloudfront.origin_access_identity_absent:\n          - Name: my_distribution\n\n    '''\n    Name = kwargs['Name'] if 'Name' in kwargs else name\n    Id = kwargs.get('Id')\n    ref = kwargs['Id'] if 'Id' in kwargs else Name\n    ret = {'name': Id if Id else Name, 'comment': '', 'changes': {}, 'result': True}\n    authargs = {'region': region, 'key': key, 'keyid': keyid, 'profile': profile}\n    current = None\n    if not Id:\n        current = __salt__['boto_cloudfront.get_cloud_front_origin_access_identities_by_comment'](\n                Comment=Name, **authargs)\n        if current is None:\n            msg = 'Error dereferencing origin access identity `{}` to a Resource ID.'.format(Name)\n            log.error(msg)\n            ret['comment'] = msg\n            ret['result'] = False\n            return ret\n        if len(current) > 1:\n            msg = ('Multiple CloudFront origin access identities matched `{}`, no way to know'\n                   ' which to delete.`.'.format(Name))\n            log.error(msg)\n            ret['comment'] = msg\n            ret['result'] = False\n            return ret\n        if not current:\n            msg = 'CloudFront origin access identity `{}` already absent.'.format(Name)\n            log.info(msg)\n            ret['comment'] = msg\n            ret['result'] = True\n            return ret\n        Id = current[0]['Id']\n\n    if not __salt__['boto_cloudfront.cloud_front_origin_access_identity_exists'](Id=Id, **authargs):\n        msg = 'CloudFront origin access identity `{}` already absent.'.format(ref)\n        log.info(msg)\n        ret['comment'] = msg\n        return ret\n\n    old = __salt__['boto_cloudfront.get_cloud_front_origin_access_identity'](Id=Id, **authargs)\n    if old is None:\n        ret['result'] = False\n        msg = 'Error getting state of CloudFront origin access identity `{}`.'.format(ref)\n        log.error(msg)\n        ret['comment'] = msg\n        return ret\n\n    if __opts__['test']:\n        ret['result'] = None\n        ret['comment'] = 'CloudFront origin access identity `{}` would be deleted.'.format(ref)\n        ret['pchanges'] = {'old': old, 'new': None}\n        return ret\n\n    deleted = __salt__['boto_cloudfront.delete_cloud_front_origin_access_identity'](Id=Id,\n            IfMatch=old['ETag'], **authargs)\n    if deleted is False:\n        ret['result'] = False\n        msg = 'Error deleting CloudFront origin access identity `{}`'.format(ref)\n        log.error(msg)\n        ret['comment'] = msg\n        return ret\n    msg = 'CloudFront origin access identity `{}` deleted.'.format(ref)\n    log.info(msg)\n    ret['comment'] = msg\n    ret['changes'] = {'old': old, 'new': None}\n    return ret", "language": "python", "code": "def origin_access_identity_absent(name, region=None, key=None, keyid=None, profile=None, **kwargs):\n    '''\n    Ensure a given CloudFront Origin Access Identity is absent.\n\n    name\n        The name of the state definition.\n\n    Name (string)\n        Name of the resource (for purposes of Salt's idempotency). If not\n        provided, the value of ``name`` will be used.\n\n    Id (string)\n        The Resource ID of a CloudFront origin access identity to be managed.\n\n    region (string)\n        Region to connect to\n\n    key (string)\n        Secret key to use\n\n    keyid (string)\n        Access key to use\n\n    profile (dict or string)\n        Dict, or pillar key pointing to a dict, containing AWS region/key/keyid.\n\n    Example:\n\n    .. code-block:: yaml\n\n        Ensure an origin access identity named my_OAI is gone:\n          boto_cloudfront.origin_access_identity_absent:\n          - Name: my_distribution\n\n    '''\n    Name = kwargs['Name'] if 'Name' in kwargs else name\n    Id = kwargs.get('Id')\n    ref = kwargs['Id'] if 'Id' in kwargs else Name\n    ret = {'name': Id if Id else Name, 'comment': '', 'changes': {}, 'result': True}\n    authargs = {'region': region, 'key': key, 'keyid': keyid, 'profile': profile}\n    current = None\n    if not Id:\n        current = __salt__['boto_cloudfront.get_cloud_front_origin_access_identities_by_comment'](\n                Comment=Name, **authargs)\n        if current is None:\n            msg = 'Error dereferencing origin access identity `{}` to a Resource ID.'.format(Name)\n            log.error(msg)\n            ret['comment'] = msg\n            ret['result'] = False\n            return ret\n        if len(current) > 1:\n            msg = ('Multiple CloudFront origin access identities matched `{}`, no way to know'\n                   ' which to delete.`.'.format(Name))\n            log.error(msg)\n            ret['comment'] = msg\n            ret['result'] = False\n            return ret\n        if not current:\n            msg = 'CloudFront origin access identity `{}` already absent.'.format(Name)\n            log.info(msg)\n            ret['comment'] = msg\n            ret['result'] = True\n            return ret\n        Id = current[0]['Id']\n\n    if not __salt__['boto_cloudfront.cloud_front_origin_access_identity_exists'](Id=Id, **authargs):\n        msg = 'CloudFront origin access identity `{}` already absent.'.format(ref)\n        log.info(msg)\n        ret['comment'] = msg\n        return ret\n\n    old = __salt__['boto_cloudfront.get_cloud_front_origin_access_identity'](Id=Id, **authargs)\n    if old is None:\n        ret['result'] = False\n        msg = 'Error getting state of CloudFront origin access identity `{}`.'.format(ref)\n        log.error(msg)\n        ret['comment'] = msg\n        return ret\n\n    if __opts__['test']:\n        ret['result'] = None\n        ret['comment'] = 'CloudFront origin access identity `{}` would be deleted.'.format(ref)\n        ret['pchanges'] = {'old': old, 'new': None}\n        return ret\n\n    deleted = __salt__['boto_cloudfront.delete_cloud_front_origin_access_identity'](Id=Id,\n            IfMatch=old['ETag'], **authargs)\n    if deleted is False:\n        ret['result'] = False\n        msg = 'Error deleting CloudFront origin access identity `{}`'.format(ref)\n        log.error(msg)\n        ret['comment'] = msg\n        return ret\n    msg = 'CloudFront origin access identity `{}` deleted.'.format(ref)\n    log.info(msg)\n    ret['comment'] = msg\n    ret['changes'] = {'old': old, 'new': None}\n    return ret", "code_tokens": ["def", "origin_access_identity_absent", "(", "name", ",", "region", "=", "None", ",", "key", "=", "None", ",", "keyid", "=", "None", ",", "profile", "=", "None", ",", "*", "*", "kwargs", ")", ":", "Name", "=", "kwargs", "[", "'Name'", "]", "if", "'Name'", "in", "kwargs", "else", "name", "Id", "=", "kwargs", ".", "get", "(", "'Id'", ")", "ref", "=", "kwargs", "[", "'Id'", "]", "if", "'Id'", "in", "kwargs", "else", "Name", "ret", "=", "{", "'name'", ":", "Id", "if", "Id", "else", "Name", ",", "'comment'", ":", "''", ",", "'changes'", ":", "{", "}", ",", "'result'", ":", "True", "}", "authargs", "=", "{", "'region'", ":", "region", ",", "'key'", ":", "key", ",", "'keyid'", ":", "keyid", ",", "'profile'", ":", "profile", "}", "current", "=", "None", "if", "not", "Id", ":", "current", "=", "__salt__", "[", "'boto_cloudfront.get_cloud_front_origin_access_identities_by_comment'", "]", "(", "Comment", "=", "Name", ",", "*", "*", "authargs", ")", "if", "current", "is", "None", ":", "msg", "=", "'Error dereferencing origin access identity `{}` to a Resource ID.'", ".", "format", "(", "Name", ")", "log", ".", "error", "(", "msg", ")", "ret", "[", "'comment'", "]", "=", "msg", "ret", "[", "'result'", "]", "=", "False", "return", "ret", "if", "len", "(", "current", ")", ">", "1", ":", "msg", "=", "(", "'Multiple CloudFront origin access identities matched `{}`, no way to know'", "' which to delete.`.'", ".", "format", "(", "Name", ")", ")", "log", ".", "error", "(", "msg", ")", "ret", "[", "'comment'", "]", "=", "msg", "ret", "[", "'result'", "]", "=", "False", "return", "ret", "if", "not", "current", ":", "msg", "=", "'CloudFront origin access identity `{}` already absent.'", ".", "format", "(", "Name", ")", "log", ".", "info", "(", "msg", ")", "ret", "[", "'comment'", "]", "=", "msg", "ret", "[", "'result'", "]", "=", "True", "return", "ret", "Id", "=", "current", "[", "0", "]", "[", "'Id'", "]", "if", "not", "__salt__", "[", "'boto_cloudfront.cloud_front_origin_access_identity_exists'", "]", "(", "Id", "=", "Id", ",", "*", "*", "authargs", ")", ":", "msg", "=", "'CloudFront origin access identity `{}` already absent.'", ".", "format", "(", "ref", ")", "log", ".", "info", "(", "msg", ")", "ret", "[", "'comment'", "]", "=", "msg", "return", "ret", "old", "=", "__salt__", "[", "'boto_cloudfront.get_cloud_front_origin_access_identity'", "]", "(", "Id", "=", "Id", ",", "*", "*", "authargs", ")", "if", "old", "is", "None", ":", "ret", "[", "'result'", "]", "=", "False", "msg", "=", "'Error getting state of CloudFront origin access identity `{}`.'", ".", "format", "(", "ref", ")", "log", ".", "error", "(", "msg", ")", "ret", "[", "'comment'", "]", "=", "msg", "return", "ret", "if", "__opts__", "[", "'test'", "]", ":", "ret", "[", "'result'", "]", "=", "None", "ret", "[", "'comment'", "]", "=", "'CloudFront origin access identity `{}` would be deleted.'", ".", "format", "(", "ref", ")", "ret", "[", "'pchanges'", "]", "=", "{", "'old'", ":", "old", ",", "'new'", ":", "None", "}", "return", "ret", "deleted", "=", "__salt__", "[", "'boto_cloudfront.delete_cloud_front_origin_access_identity'", "]", "(", "Id", "=", "Id", ",", "IfMatch", "=", "old", "[", "'ETag'", "]", ",", "*", "*", "authargs", ")", "if", "deleted", "is", "False", ":", "ret", "[", "'result'", "]", "=", "False", "msg", "=", "'Error deleting CloudFront origin access identity `{}`'", ".", "format", "(", "ref", ")", "log", ".", "error", "(", "msg", ")", "ret", "[", "'comment'", "]", "=", "msg", "return", "ret", "msg", "=", "'CloudFront origin access identity `{}` deleted.'", ".", "format", "(", "ref", ")", "log", ".", "info", "(", "msg", ")", "ret", "[", "'comment'", "]", "=", "msg", "ret", "[", "'changes'", "]", "=", "{", "'old'", ":", "old", ",", "'new'", ":", "None", "}", "return", "ret"], "docstring": "Ensure a given CloudFront Origin Access Identity is absent.\n\n    name\n        The name of the state definition.\n\n    Name (string)\n        Name of the resource (for purposes of Salt's idempotency). If not\n        provided, the value of ``name`` will be used.\n\n    Id (string)\n        The Resource ID of a CloudFront origin access identity to be managed.\n\n    region (string)\n        Region to connect to\n\n    key (string)\n        Secret key to use\n\n    keyid (string)\n        Access key to use\n\n    profile (dict or string)\n        Dict, or pillar key pointing to a dict, containing AWS region/key/keyid.\n\n    Example:\n\n    .. code-block:: yaml\n\n        Ensure an origin access identity named my_OAI is gone:\n          boto_cloudfront.origin_access_identity_absent:\n          - Name: my_distribution", "docstring_tokens": ["Ensure", "a", "given", "CloudFront", "Origin", "Access", "Identity", "is", "absent", "."], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/states/boto_cloudfront.py#L1081-L1178", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/modules/snap.py", "func_name": "install", "original_string": "def install(pkg, channel=None, refresh=False):\n    '''\n    Install the specified snap package from the specified channel.\n    Returns a dictionary of \"result\" and \"output\".\n\n    pkg\n        The snap package name\n\n    channel\n        Optional. The snap channel to install from, eg \"beta\"\n\n    refresh : False\n        If True, use \"snap refresh\" instead of \"snap install\".\n        This allows changing the channel of a previously installed package.\n    '''\n    args = []\n    ret = {'result': None, 'output': \"\"}\n\n    if refresh:\n        cmd = 'refresh'\n    else:\n        cmd = 'install'\n\n    if channel:\n        args.append('--channel=' + channel)\n\n    try:\n        # Try to run it, merging stderr into output\n        ret['output'] = subprocess.check_output([SNAP_BINARY_NAME, cmd, pkg] + args, stderr=subprocess.STDOUT)\n        ret['result'] = True\n    except subprocess.CalledProcessError as e:\n        ret['output'] = e.output\n        ret['result'] = False\n\n    return ret", "language": "python", "code": "def install(pkg, channel=None, refresh=False):\n    '''\n    Install the specified snap package from the specified channel.\n    Returns a dictionary of \"result\" and \"output\".\n\n    pkg\n        The snap package name\n\n    channel\n        Optional. The snap channel to install from, eg \"beta\"\n\n    refresh : False\n        If True, use \"snap refresh\" instead of \"snap install\".\n        This allows changing the channel of a previously installed package.\n    '''\n    args = []\n    ret = {'result': None, 'output': \"\"}\n\n    if refresh:\n        cmd = 'refresh'\n    else:\n        cmd = 'install'\n\n    if channel:\n        args.append('--channel=' + channel)\n\n    try:\n        # Try to run it, merging stderr into output\n        ret['output'] = subprocess.check_output([SNAP_BINARY_NAME, cmd, pkg] + args, stderr=subprocess.STDOUT)\n        ret['result'] = True\n    except subprocess.CalledProcessError as e:\n        ret['output'] = e.output\n        ret['result'] = False\n\n    return ret", "code_tokens": ["def", "install", "(", "pkg", ",", "channel", "=", "None", ",", "refresh", "=", "False", ")", ":", "args", "=", "[", "]", "ret", "=", "{", "'result'", ":", "None", ",", "'output'", ":", "\"\"", "}", "if", "refresh", ":", "cmd", "=", "'refresh'", "else", ":", "cmd", "=", "'install'", "if", "channel", ":", "args", ".", "append", "(", "'--channel='", "+", "channel", ")", "try", ":", "# Try to run it, merging stderr into output", "ret", "[", "'output'", "]", "=", "subprocess", ".", "check_output", "(", "[", "SNAP_BINARY_NAME", ",", "cmd", ",", "pkg", "]", "+", "args", ",", "stderr", "=", "subprocess", ".", "STDOUT", ")", "ret", "[", "'result'", "]", "=", "True", "except", "subprocess", ".", "CalledProcessError", "as", "e", ":", "ret", "[", "'output'", "]", "=", "e", ".", "output", "ret", "[", "'result'", "]", "=", "False", "return", "ret"], "docstring": "Install the specified snap package from the specified channel.\n    Returns a dictionary of \"result\" and \"output\".\n\n    pkg\n        The snap package name\n\n    channel\n        Optional. The snap channel to install from, eg \"beta\"\n\n    refresh : False\n        If True, use \"snap refresh\" instead of \"snap install\".\n        This allows changing the channel of a previously installed package.", "docstring_tokens": ["Install", "the", "specified", "snap", "package", "from", "the", "specified", "channel", ".", "Returns", "a", "dictionary", "of", "result", "and", "output", "."], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/modules/snap.py#L26-L60", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/modules/snap.py", "func_name": "remove", "original_string": "def remove(pkg):\n    '''\n    Remove the specified snap package. Returns a dictionary of \"result\" and \"output\".\n\n    pkg\n        The package name\n    '''\n    ret = {'result': None, 'output': \"\"}\n    try:\n        ret['output'] = subprocess.check_output([SNAP_BINARY_NAME, 'remove', pkg])\n        ret['result'] = True\n    except subprocess.CalledProcessError as e:\n        ret['output'] = e.output\n        ret['result'] = False", "language": "python", "code": "def remove(pkg):\n    '''\n    Remove the specified snap package. Returns a dictionary of \"result\" and \"output\".\n\n    pkg\n        The package name\n    '''\n    ret = {'result': None, 'output': \"\"}\n    try:\n        ret['output'] = subprocess.check_output([SNAP_BINARY_NAME, 'remove', pkg])\n        ret['result'] = True\n    except subprocess.CalledProcessError as e:\n        ret['output'] = e.output\n        ret['result'] = False", "code_tokens": ["def", "remove", "(", "pkg", ")", ":", "ret", "=", "{", "'result'", ":", "None", ",", "'output'", ":", "\"\"", "}", "try", ":", "ret", "[", "'output'", "]", "=", "subprocess", ".", "check_output", "(", "[", "SNAP_BINARY_NAME", ",", "'remove'", ",", "pkg", "]", ")", "ret", "[", "'result'", "]", "=", "True", "except", "subprocess", ".", "CalledProcessError", "as", "e", ":", "ret", "[", "'output'", "]", "=", "e", ".", "output", "ret", "[", "'result'", "]", "=", "False"], "docstring": "Remove the specified snap package. Returns a dictionary of \"result\" and \"output\".\n\n    pkg\n        The package name", "docstring_tokens": ["Remove", "the", "specified", "snap", "package", ".", "Returns", "a", "dictionary", "of", "result", "and", "output", "."], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/modules/snap.py#L73-L86", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/modules/snap.py", "func_name": "versions_installed", "original_string": "def versions_installed(pkg):\n    '''\n    Query which version(s) of the specified snap package are installed.\n    Returns a list of 0 or more dictionaries.\n\n    pkg\n        The package name\n    '''\n\n    try:\n        # Try to run it, merging stderr into output\n        output = subprocess.check_output([SNAP_BINARY_NAME, 'list', pkg], stderr=subprocess.STDOUT)\n    except subprocess.CalledProcessError:\n        return []\n\n    lines = output.splitlines()[1:]\n    ret = []\n    for item in lines:\n        # If fields contain spaces this will break.\n        i = item.split()\n        # Ignore 'Notes' field\n        ret.append({\n            'name':         i[0],\n            'version':      i[1],\n            'rev':          i[2],\n            'tracking':     i[3],\n            'publisher':    i[4]\n            })\n\n    return ret", "language": "python", "code": "def versions_installed(pkg):\n    '''\n    Query which version(s) of the specified snap package are installed.\n    Returns a list of 0 or more dictionaries.\n\n    pkg\n        The package name\n    '''\n\n    try:\n        # Try to run it, merging stderr into output\n        output = subprocess.check_output([SNAP_BINARY_NAME, 'list', pkg], stderr=subprocess.STDOUT)\n    except subprocess.CalledProcessError:\n        return []\n\n    lines = output.splitlines()[1:]\n    ret = []\n    for item in lines:\n        # If fields contain spaces this will break.\n        i = item.split()\n        # Ignore 'Notes' field\n        ret.append({\n            'name':         i[0],\n            'version':      i[1],\n            'rev':          i[2],\n            'tracking':     i[3],\n            'publisher':    i[4]\n            })\n\n    return ret", "code_tokens": ["def", "versions_installed", "(", "pkg", ")", ":", "try", ":", "# Try to run it, merging stderr into output", "output", "=", "subprocess", ".", "check_output", "(", "[", "SNAP_BINARY_NAME", ",", "'list'", ",", "pkg", "]", ",", "stderr", "=", "subprocess", ".", "STDOUT", ")", "except", "subprocess", ".", "CalledProcessError", ":", "return", "[", "]", "lines", "=", "output", ".", "splitlines", "(", ")", "[", "1", ":", "]", "ret", "=", "[", "]", "for", "item", "in", "lines", ":", "# If fields contain spaces this will break.", "i", "=", "item", ".", "split", "(", ")", "# Ignore 'Notes' field", "ret", ".", "append", "(", "{", "'name'", ":", "i", "[", "0", "]", ",", "'version'", ":", "i", "[", "1", "]", ",", "'rev'", ":", "i", "[", "2", "]", ",", "'tracking'", ":", "i", "[", "3", "]", ",", "'publisher'", ":", "i", "[", "4", "]", "}", ")", "return", "ret"], "docstring": "Query which version(s) of the specified snap package are installed.\n    Returns a list of 0 or more dictionaries.\n\n    pkg\n        The package name", "docstring_tokens": ["Query", "which", "version", "(", "s", ")", "of", "the", "specified", "snap", "package", "are", "installed", ".", "Returns", "a", "list", "of", "0", "or", "more", "dictionaries", "."], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/modules/snap.py#L90-L119", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/modules/virtualenv_mod.py", "func_name": "create", "original_string": "def create(path,\n           venv_bin=None,\n           system_site_packages=False,\n           distribute=False,\n           clear=False,\n           python=None,\n           extra_search_dir=None,\n           never_download=None,\n           prompt=None,\n           pip=False,\n           symlinks=None,\n           upgrade=None,\n           user=None,\n           use_vt=False,\n           saltenv='base',\n           **kwargs):\n    '''\n    Create a virtualenv\n\n    path\n        The path to the virtualenv to be created\n\n    venv_bin\n        The name (and optionally path) of the virtualenv command. This can also\n        be set globally in the pillar data as ``venv_bin``.\n        Defaults to ``pyvenv`` or ``virtualenv``, depending on what is installed.\n\n    system_site_packages : False\n        Passthrough argument given to virtualenv or pyvenv\n\n    distribute : False\n        Passthrough argument given to virtualenv\n\n    pip : False\n        Install pip after creating a virtual environment. Implies\n        ``distribute=True``\n\n    clear : False\n        Passthrough argument given to virtualenv or pyvenv\n\n    python : None (default)\n        Passthrough argument given to virtualenv\n\n    extra_search_dir : None (default)\n        Passthrough argument given to virtualenv\n\n    never_download : None (default)\n        Passthrough argument given to virtualenv if True\n\n    prompt : None (default)\n        Passthrough argument given to virtualenv if not None\n\n    symlinks : None\n        Passthrough argument given to pyvenv if True\n\n    upgrade : None\n        Passthrough argument given to pyvenv if True\n\n    user : None\n        Set ownership for the virtualenv\n\n        .. note::\n            On Windows you must also pass a ``password`` parameter. Additionally,\n            the user must have permissions to the location where the virtual\n            environment is being created\n\n    runas : None\n        Set ownership for the virtualenv\n\n        .. deprecated:: 2014.1.0\n            ``user`` should be used instead\n\n    use_vt : False\n        Use VT terminal emulation (see output while installing)\n\n        .. versionadded:: 2015.5.0\n\n    saltenv : 'base'\n        Specify a different environment. The default environment is ``base``.\n\n        .. versionadded:: 2014.1.0\n\n    .. note::\n        The ``runas`` argument is deprecated as of 2014.1.0. ``user`` should be\n        used instead.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' virtualenv.create /path/to/new/virtualenv\n    '''\n    if venv_bin is None:\n        # Beginning in 3.6, pyvenv has been deprecated\n        # in favor of \"python3 -m venv\"\n        if sys.version_info >= (3, 6):\n            venv_bin = ['python3', '-m', 'venv']\n        else:\n            venv_bin = __pillar__.get('venv_bin') or __opts__.get('venv_bin')\n\n    if not isinstance(venv_bin, list):\n        cmd = [venv_bin]\n    else:\n        cmd = venv_bin\n\n    if 'pyvenv' not in venv_bin:\n        # ----- Stop the user if pyvenv only options are used --------------->\n        # If any of the following values are not None, it means that the user\n        # is actually passing a True or False value. Stop Him!\n        if upgrade is not None:\n            raise CommandExecutionError(\n                'The `upgrade`(`--upgrade`) option is not supported '\n                'by \\'{0}\\''.format(venv_bin)\n            )\n        elif symlinks is not None:\n            raise CommandExecutionError(\n                'The `symlinks`(`--symlinks`) option is not supported '\n                'by \\'{0}\\''.format(venv_bin)\n            )\n        # <---- Stop the user if pyvenv only options are used ----------------\n\n        # Virtualenv package\n        try:\n            import virtualenv\n            version = getattr(virtualenv, '__version__',\n                              virtualenv.virtualenv_version)\n            virtualenv_version_info = tuple(\n                [int(i) for i in version.split('rc')[0].split('.')]\n            )\n        except ImportError:\n            # Unable to import?? Let's parse the version from the console\n            version_cmd = [venv_bin, '--version']\n            ret = __salt__['cmd.run_all'](\n                    version_cmd, runas=user, python_shell=False, **kwargs\n                )\n            if ret['retcode'] > 0 or not ret['stdout'].strip():\n                raise CommandExecutionError(\n                    'Unable to get the virtualenv version output using \\'{0}\\'. '\n                    'Returned data: {1}'.format(version_cmd, ret)\n                )\n            virtualenv_version_info = tuple(\n                [int(i) for i in\n                 ret['stdout'].strip().split('rc')[0].split('.')]\n            )\n\n        if distribute:\n            if virtualenv_version_info >= (1, 10):\n                log.info(\n                    'The virtualenv \\'--distribute\\' option has been '\n                    'deprecated in virtualenv(>=1.10), as such, the '\n                    '\\'distribute\\' option to `virtualenv.create()` has '\n                    'also been deprecated and it\\'s not necessary anymore.'\n                )\n            else:\n                cmd.append('--distribute')\n\n        if python is not None and python.strip() != '':\n            if not salt.utils.path.which(python):\n                raise CommandExecutionError(\n                    'Cannot find requested python ({0}).'.format(python)\n                )\n            cmd.append('--python={0}'.format(python))\n        if extra_search_dir is not None:\n            if isinstance(extra_search_dir, string_types) and \\\n                    extra_search_dir.strip() != '':\n                extra_search_dir = [\n                    e.strip() for e in extra_search_dir.split(',')\n                ]\n            for entry in extra_search_dir:\n                cmd.append('--extra-search-dir={0}'.format(entry))\n        if never_download is True:\n            if (1, 10) <= virtualenv_version_info < (14, 0, 0):\n                log.info(\n                    '--never-download was deprecated in 1.10.0, but reimplemented in 14.0.0. '\n                    'If this feature is needed, please install a supported virtualenv version.'\n                )\n            else:\n                cmd.append('--never-download')\n        if prompt is not None and prompt.strip() != '':\n            cmd.append('--prompt=\\'{0}\\''.format(prompt))\n    else:\n        # venv module from the Python >= 3.3 standard library\n\n        # ----- Stop the user if virtualenv only options are being used ----->\n        # If any of the following values are not None, it means that the user\n        # is actually passing a True or False value. Stop Him!\n        if python is not None and python.strip() != '':\n            raise CommandExecutionError(\n                'The `python`(`--python`) option is not supported '\n                'by \\'{0}\\''.format(venv_bin)\n            )\n        elif extra_search_dir is not None and extra_search_dir.strip() != '':\n            raise CommandExecutionError(\n                'The `extra_search_dir`(`--extra-search-dir`) option is not '\n                'supported by \\'{0}\\''.format(venv_bin)\n            )\n        elif never_download is not None:\n            raise CommandExecutionError(\n                'The `never_download`(`--never-download`) option is not '\n                'supported by \\'{0}\\''.format(venv_bin)\n            )\n        elif prompt is not None and prompt.strip() != '':\n            raise CommandExecutionError(\n                'The `prompt`(`--prompt`) option is not supported '\n                'by \\'{0}\\''.format(venv_bin)\n            )\n        # <---- Stop the user if virtualenv only options are being used ------\n\n        if upgrade is True:\n            cmd.append('--upgrade')\n        if symlinks is True:\n            cmd.append('--symlinks')\n\n    # Common options to virtualenv and pyvenv\n    if clear is True:\n        cmd.append('--clear')\n    if system_site_packages is True:\n        cmd.append('--system-site-packages')\n\n    # Finally the virtualenv path\n    cmd.append(path)\n\n    # Let's create the virtualenv\n    ret = __salt__['cmd.run_all'](cmd, runas=user, python_shell=False, **kwargs)\n    if ret['retcode'] != 0:\n        # Something went wrong. Let's bail out now!\n        return ret\n\n    # Check if distribute and pip are already installed\n    if salt.utils.platform.is_windows():\n        venv_python = os.path.join(path, 'Scripts', 'python.exe')\n        venv_pip = os.path.join(path, 'Scripts', 'pip.exe')\n        venv_setuptools = os.path.join(path, 'Scripts', 'easy_install.exe')\n    else:\n        venv_python = os.path.join(path, 'bin', 'python')\n        venv_pip = os.path.join(path, 'bin', 'pip')\n        venv_setuptools = os.path.join(path, 'bin', 'easy_install')\n\n    # Install setuptools\n    if (pip or distribute) and not os.path.exists(venv_setuptools):\n        _install_script(\n            'https://bitbucket.org/pypa/setuptools/raw/default/ez_setup.py',\n            path, venv_python, user, saltenv=saltenv, use_vt=use_vt\n        )\n\n        # clear up the distribute archive which gets downloaded\n        for fpath in glob.glob(os.path.join(path, 'distribute-*.tar.gz*')):\n            os.unlink(fpath)\n\n    if ret['retcode'] != 0:\n        # Something went wrong. Let's bail out now!\n        return ret\n\n    # Install pip\n    if pip and not os.path.exists(venv_pip):\n        _ret = _install_script(\n            'https://bootstrap.pypa.io/get-pip.py',\n            path, venv_python, user, saltenv=saltenv, use_vt=use_vt\n        )\n        # Let's update the return dictionary with the details from the pip\n        # installation\n        ret.update(\n            retcode=_ret['retcode'],\n            stdout='{0}\\n{1}'.format(ret['stdout'], _ret['stdout']).strip(),\n            stderr='{0}\\n{1}'.format(ret['stderr'], _ret['stderr']).strip(),\n        )\n\n    return ret", "language": "python", "code": "def create(path,\n           venv_bin=None,\n           system_site_packages=False,\n           distribute=False,\n           clear=False,\n           python=None,\n           extra_search_dir=None,\n           never_download=None,\n           prompt=None,\n           pip=False,\n           symlinks=None,\n           upgrade=None,\n           user=None,\n           use_vt=False,\n           saltenv='base',\n           **kwargs):\n    '''\n    Create a virtualenv\n\n    path\n        The path to the virtualenv to be created\n\n    venv_bin\n        The name (and optionally path) of the virtualenv command. This can also\n        be set globally in the pillar data as ``venv_bin``.\n        Defaults to ``pyvenv`` or ``virtualenv``, depending on what is installed.\n\n    system_site_packages : False\n        Passthrough argument given to virtualenv or pyvenv\n\n    distribute : False\n        Passthrough argument given to virtualenv\n\n    pip : False\n        Install pip after creating a virtual environment. Implies\n        ``distribute=True``\n\n    clear : False\n        Passthrough argument given to virtualenv or pyvenv\n\n    python : None (default)\n        Passthrough argument given to virtualenv\n\n    extra_search_dir : None (default)\n        Passthrough argument given to virtualenv\n\n    never_download : None (default)\n        Passthrough argument given to virtualenv if True\n\n    prompt : None (default)\n        Passthrough argument given to virtualenv if not None\n\n    symlinks : None\n        Passthrough argument given to pyvenv if True\n\n    upgrade : None\n        Passthrough argument given to pyvenv if True\n\n    user : None\n        Set ownership for the virtualenv\n\n        .. note::\n            On Windows you must also pass a ``password`` parameter. Additionally,\n            the user must have permissions to the location where the virtual\n            environment is being created\n\n    runas : None\n        Set ownership for the virtualenv\n\n        .. deprecated:: 2014.1.0\n            ``user`` should be used instead\n\n    use_vt : False\n        Use VT terminal emulation (see output while installing)\n\n        .. versionadded:: 2015.5.0\n\n    saltenv : 'base'\n        Specify a different environment. The default environment is ``base``.\n\n        .. versionadded:: 2014.1.0\n\n    .. note::\n        The ``runas`` argument is deprecated as of 2014.1.0. ``user`` should be\n        used instead.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' virtualenv.create /path/to/new/virtualenv\n    '''\n    if venv_bin is None:\n        # Beginning in 3.6, pyvenv has been deprecated\n        # in favor of \"python3 -m venv\"\n        if sys.version_info >= (3, 6):\n            venv_bin = ['python3', '-m', 'venv']\n        else:\n            venv_bin = __pillar__.get('venv_bin') or __opts__.get('venv_bin')\n\n    if not isinstance(venv_bin, list):\n        cmd = [venv_bin]\n    else:\n        cmd = venv_bin\n\n    if 'pyvenv' not in venv_bin:\n        # ----- Stop the user if pyvenv only options are used --------------->\n        # If any of the following values are not None, it means that the user\n        # is actually passing a True or False value. Stop Him!\n        if upgrade is not None:\n            raise CommandExecutionError(\n                'The `upgrade`(`--upgrade`) option is not supported '\n                'by \\'{0}\\''.format(venv_bin)\n            )\n        elif symlinks is not None:\n            raise CommandExecutionError(\n                'The `symlinks`(`--symlinks`) option is not supported '\n                'by \\'{0}\\''.format(venv_bin)\n            )\n        # <---- Stop the user if pyvenv only options are used ----------------\n\n        # Virtualenv package\n        try:\n            import virtualenv\n            version = getattr(virtualenv, '__version__',\n                              virtualenv.virtualenv_version)\n            virtualenv_version_info = tuple(\n                [int(i) for i in version.split('rc')[0].split('.')]\n            )\n        except ImportError:\n            # Unable to import?? Let's parse the version from the console\n            version_cmd = [venv_bin, '--version']\n            ret = __salt__['cmd.run_all'](\n                    version_cmd, runas=user, python_shell=False, **kwargs\n                )\n            if ret['retcode'] > 0 or not ret['stdout'].strip():\n                raise CommandExecutionError(\n                    'Unable to get the virtualenv version output using \\'{0}\\'. '\n                    'Returned data: {1}'.format(version_cmd, ret)\n                )\n            virtualenv_version_info = tuple(\n                [int(i) for i in\n                 ret['stdout'].strip().split('rc')[0].split('.')]\n            )\n\n        if distribute:\n            if virtualenv_version_info >= (1, 10):\n                log.info(\n                    'The virtualenv \\'--distribute\\' option has been '\n                    'deprecated in virtualenv(>=1.10), as such, the '\n                    '\\'distribute\\' option to `virtualenv.create()` has '\n                    'also been deprecated and it\\'s not necessary anymore.'\n                )\n            else:\n                cmd.append('--distribute')\n\n        if python is not None and python.strip() != '':\n            if not salt.utils.path.which(python):\n                raise CommandExecutionError(\n                    'Cannot find requested python ({0}).'.format(python)\n                )\n            cmd.append('--python={0}'.format(python))\n        if extra_search_dir is not None:\n            if isinstance(extra_search_dir, string_types) and \\\n                    extra_search_dir.strip() != '':\n                extra_search_dir = [\n                    e.strip() for e in extra_search_dir.split(',')\n                ]\n            for entry in extra_search_dir:\n                cmd.append('--extra-search-dir={0}'.format(entry))\n        if never_download is True:\n            if (1, 10) <= virtualenv_version_info < (14, 0, 0):\n                log.info(\n                    '--never-download was deprecated in 1.10.0, but reimplemented in 14.0.0. '\n                    'If this feature is needed, please install a supported virtualenv version.'\n                )\n            else:\n                cmd.append('--never-download')\n        if prompt is not None and prompt.strip() != '':\n            cmd.append('--prompt=\\'{0}\\''.format(prompt))\n    else:\n        # venv module from the Python >= 3.3 standard library\n\n        # ----- Stop the user if virtualenv only options are being used ----->\n        # If any of the following values are not None, it means that the user\n        # is actually passing a True or False value. Stop Him!\n        if python is not None and python.strip() != '':\n            raise CommandExecutionError(\n                'The `python`(`--python`) option is not supported '\n                'by \\'{0}\\''.format(venv_bin)\n            )\n        elif extra_search_dir is not None and extra_search_dir.strip() != '':\n            raise CommandExecutionError(\n                'The `extra_search_dir`(`--extra-search-dir`) option is not '\n                'supported by \\'{0}\\''.format(venv_bin)\n            )\n        elif never_download is not None:\n            raise CommandExecutionError(\n                'The `never_download`(`--never-download`) option is not '\n                'supported by \\'{0}\\''.format(venv_bin)\n            )\n        elif prompt is not None and prompt.strip() != '':\n            raise CommandExecutionError(\n                'The `prompt`(`--prompt`) option is not supported '\n                'by \\'{0}\\''.format(venv_bin)\n            )\n        # <---- Stop the user if virtualenv only options are being used ------\n\n        if upgrade is True:\n            cmd.append('--upgrade')\n        if symlinks is True:\n            cmd.append('--symlinks')\n\n    # Common options to virtualenv and pyvenv\n    if clear is True:\n        cmd.append('--clear')\n    if system_site_packages is True:\n        cmd.append('--system-site-packages')\n\n    # Finally the virtualenv path\n    cmd.append(path)\n\n    # Let's create the virtualenv\n    ret = __salt__['cmd.run_all'](cmd, runas=user, python_shell=False, **kwargs)\n    if ret['retcode'] != 0:\n        # Something went wrong. Let's bail out now!\n        return ret\n\n    # Check if distribute and pip are already installed\n    if salt.utils.platform.is_windows():\n        venv_python = os.path.join(path, 'Scripts', 'python.exe')\n        venv_pip = os.path.join(path, 'Scripts', 'pip.exe')\n        venv_setuptools = os.path.join(path, 'Scripts', 'easy_install.exe')\n    else:\n        venv_python = os.path.join(path, 'bin', 'python')\n        venv_pip = os.path.join(path, 'bin', 'pip')\n        venv_setuptools = os.path.join(path, 'bin', 'easy_install')\n\n    # Install setuptools\n    if (pip or distribute) and not os.path.exists(venv_setuptools):\n        _install_script(\n            'https://bitbucket.org/pypa/setuptools/raw/default/ez_setup.py',\n            path, venv_python, user, saltenv=saltenv, use_vt=use_vt\n        )\n\n        # clear up the distribute archive which gets downloaded\n        for fpath in glob.glob(os.path.join(path, 'distribute-*.tar.gz*')):\n            os.unlink(fpath)\n\n    if ret['retcode'] != 0:\n        # Something went wrong. Let's bail out now!\n        return ret\n\n    # Install pip\n    if pip and not os.path.exists(venv_pip):\n        _ret = _install_script(\n            'https://bootstrap.pypa.io/get-pip.py',\n            path, venv_python, user, saltenv=saltenv, use_vt=use_vt\n        )\n        # Let's update the return dictionary with the details from the pip\n        # installation\n        ret.update(\n            retcode=_ret['retcode'],\n            stdout='{0}\\n{1}'.format(ret['stdout'], _ret['stdout']).strip(),\n            stderr='{0}\\n{1}'.format(ret['stderr'], _ret['stderr']).strip(),\n        )\n\n    return ret", "code_tokens": ["def", "create", "(", "path", ",", "venv_bin", "=", "None", ",", "system_site_packages", "=", "False", ",", "distribute", "=", "False", ",", "clear", "=", "False", ",", "python", "=", "None", ",", "extra_search_dir", "=", "None", ",", "never_download", "=", "None", ",", "prompt", "=", "None", ",", "pip", "=", "False", ",", "symlinks", "=", "None", ",", "upgrade", "=", "None", ",", "user", "=", "None", ",", "use_vt", "=", "False", ",", "saltenv", "=", "'base'", ",", "*", "*", "kwargs", ")", ":", "if", "venv_bin", "is", "None", ":", "# Beginning in 3.6, pyvenv has been deprecated", "# in favor of \"python3 -m venv\"", "if", "sys", ".", "version_info", ">=", "(", "3", ",", "6", ")", ":", "venv_bin", "=", "[", "'python3'", ",", "'-m'", ",", "'venv'", "]", "else", ":", "venv_bin", "=", "__pillar__", ".", "get", "(", "'venv_bin'", ")", "or", "__opts__", ".", "get", "(", "'venv_bin'", ")", "if", "not", "isinstance", "(", "venv_bin", ",", "list", ")", ":", "cmd", "=", "[", "venv_bin", "]", "else", ":", "cmd", "=", "venv_bin", "if", "'pyvenv'", "not", "in", "venv_bin", ":", "# ----- Stop the user if pyvenv only options are used --------------->", "# If any of the following values are not None, it means that the user", "# is actually passing a True or False value. Stop Him!", "if", "upgrade", "is", "not", "None", ":", "raise", "CommandExecutionError", "(", "'The `upgrade`(`--upgrade`) option is not supported '", "'by \\'{0}\\''", ".", "format", "(", "venv_bin", ")", ")", "elif", "symlinks", "is", "not", "None", ":", "raise", "CommandExecutionError", "(", "'The `symlinks`(`--symlinks`) option is not supported '", "'by \\'{0}\\''", ".", "format", "(", "venv_bin", ")", ")", "# <---- Stop the user if pyvenv only options are used ----------------", "# Virtualenv package", "try", ":", "import", "virtualenv", "version", "=", "getattr", "(", "virtualenv", ",", "'__version__'", ",", "virtualenv", ".", "virtualenv_version", ")", "virtualenv_version_info", "=", "tuple", "(", "[", "int", "(", "i", ")", "for", "i", "in", "version", ".", "split", "(", "'rc'", ")", "[", "0", "]", ".", "split", "(", "'.'", ")", "]", ")", "except", "ImportError", ":", "# Unable to import?? Let's parse the version from the console", "version_cmd", "=", "[", "venv_bin", ",", "'--version'", "]", "ret", "=", "__salt__", "[", "'cmd.run_all'", "]", "(", "version_cmd", ",", "runas", "=", "user", ",", "python_shell", "=", "False", ",", "*", "*", "kwargs", ")", "if", "ret", "[", "'retcode'", "]", ">", "0", "or", "not", "ret", "[", "'stdout'", "]", ".", "strip", "(", ")", ":", "raise", "CommandExecutionError", "(", "'Unable to get the virtualenv version output using \\'{0}\\'. '", "'Returned data: {1}'", ".", "format", "(", "version_cmd", ",", "ret", ")", ")", "virtualenv_version_info", "=", "tuple", "(", "[", "int", "(", "i", ")", "for", "i", "in", "ret", "[", "'stdout'", "]", ".", "strip", "(", ")", ".", "split", "(", "'rc'", ")", "[", "0", "]", ".", "split", "(", "'.'", ")", "]", ")", "if", "distribute", ":", "if", "virtualenv_version_info", ">=", "(", "1", ",", "10", ")", ":", "log", ".", "info", "(", "'The virtualenv \\'--distribute\\' option has been '", "'deprecated in virtualenv(>=1.10), as such, the '", "'\\'distribute\\' option to `virtualenv.create()` has '", "'also been deprecated and it\\'s not necessary anymore.'", ")", "else", ":", "cmd", ".", "append", "(", "'--distribute'", ")", "if", "python", "is", "not", "None", "and", "python", ".", "strip", "(", ")", "!=", "''", ":", "if", "not", "salt", ".", "utils", ".", "path", ".", "which", "(", "python", ")", ":", "raise", "CommandExecutionError", "(", "'Cannot find requested python ({0}).'", ".", "format", "(", "python", ")", ")", "cmd", ".", "append", "(", "'--python={0}'", ".", "format", "(", "python", ")", ")", "if", "extra_search_dir", "is", "not", "None", ":", "if", "isinstance", "(", "extra_search_dir", ",", "string_types", ")", "and", "extra_search_dir", ".", "strip", "(", ")", "!=", "''", ":", "extra_search_dir", "=", "[", "e", ".", "strip", "(", ")", "for", "e", "in", "extra_search_dir", ".", "split", "(", "','", ")", "]", "for", "entry", "in", "extra_search_dir", ":", "cmd", ".", "append", "(", "'--extra-search-dir={0}'", ".", "format", "(", "entry", ")", ")", "if", "never_download", "is", "True", ":", "if", "(", "1", ",", "10", ")", "<=", "virtualenv_version_info", "<", "(", "14", ",", "0", ",", "0", ")", ":", "log", ".", "info", "(", "'--never-download was deprecated in 1.10.0, but reimplemented in 14.0.0. '", "'If this feature is needed, please install a supported virtualenv version.'", ")", "else", ":", "cmd", ".", "append", "(", "'--never-download'", ")", "if", "prompt", "is", "not", "None", "and", "prompt", ".", "strip", "(", ")", "!=", "''", ":", "cmd", ".", "append", "(", "'--prompt=\\'{0}\\''", ".", "format", "(", "prompt", ")", ")", "else", ":", "# venv module from the Python >= 3.3 standard library", "# ----- Stop the user if virtualenv only options are being used ----->", "# If any of the following values are not None, it means that the user", "# is actually passing a True or False value. Stop Him!", "if", "python", "is", "not", "None", "and", "python", ".", "strip", "(", ")", "!=", "''", ":", "raise", "CommandExecutionError", "(", "'The `python`(`--python`) option is not supported '", "'by \\'{0}\\''", ".", "format", "(", "venv_bin", ")", ")", "elif", "extra_search_dir", "is", "not", "None", "and", "extra_search_dir", ".", "strip", "(", ")", "!=", "''", ":", "raise", "CommandExecutionError", "(", "'The `extra_search_dir`(`--extra-search-dir`) option is not '", "'supported by \\'{0}\\''", ".", "format", "(", "venv_bin", ")", ")", "elif", "never_download", "is", "not", "None", ":", "raise", "CommandExecutionError", "(", "'The `never_download`(`--never-download`) option is not '", "'supported by \\'{0}\\''", ".", "format", "(", "venv_bin", ")", ")", "elif", "prompt", "is", "not", "None", "and", "prompt", ".", "strip", "(", ")", "!=", "''", ":", "raise", "CommandExecutionError", "(", "'The `prompt`(`--prompt`) option is not supported '", "'by \\'{0}\\''", ".", "format", "(", "venv_bin", ")", ")", "# <---- Stop the user if virtualenv only options are being used ------", "if", "upgrade", "is", "True", ":", "cmd", ".", "append", "(", "'--upgrade'", ")", "if", "symlinks", "is", "True", ":", "cmd", ".", "append", "(", "'--symlinks'", ")", "# Common options to virtualenv and pyvenv", "if", "clear", "is", "True", ":", "cmd", ".", "append", "(", "'--clear'", ")", "if", "system_site_packages", "is", "True", ":", "cmd", ".", "append", "(", "'--system-site-packages'", ")", "# Finally the virtualenv path", "cmd", ".", "append", "(", "path", ")", "# Let's create the virtualenv", "ret", "=", "__salt__", "[", "'cmd.run_all'", "]", "(", "cmd", ",", "runas", "=", "user", ",", "python_shell", "=", "False", ",", "*", "*", "kwargs", ")", "if", "ret", "[", "'retcode'", "]", "!=", "0", ":", "# Something went wrong. Let's bail out now!", "return", "ret", "# Check if distribute and pip are already installed", "if", "salt", ".", "utils", ".", "platform", ".", "is_windows", "(", ")", ":", "venv_python", "=", "os", ".", "path", ".", "join", "(", "path", ",", "'Scripts'", ",", "'python.exe'", ")", "venv_pip", "=", "os", ".", "path", ".", "join", "(", "path", ",", "'Scripts'", ",", "'pip.exe'", ")", "venv_setuptools", "=", "os", ".", "path", ".", "join", "(", "path", ",", "'Scripts'", ",", "'easy_install.exe'", ")", "else", ":", "venv_python", "=", "os", ".", "path", ".", "join", "(", "path", ",", "'bin'", ",", "'python'", ")", "venv_pip", "=", "os", ".", "path", ".", "join", "(", "path", ",", "'bin'", ",", "'pip'", ")", "venv_setuptools", "=", "os", ".", "path", ".", "join", "(", "path", ",", "'bin'", ",", "'easy_install'", ")", "# Install setuptools", "if", "(", "pip", "or", "distribute", ")", "and", "not", "os", ".", "path", ".", "exists", "(", "venv_setuptools", ")", ":", "_install_script", "(", "'https://bitbucket.org/pypa/setuptools/raw/default/ez_setup.py'", ",", "path", ",", "venv_python", ",", "user", ",", "saltenv", "=", "saltenv", ",", "use_vt", "=", "use_vt", ")", "# clear up the distribute archive which gets downloaded", "for", "fpath", "in", "glob", ".", "glob", "(", "os", ".", "path", ".", "join", "(", "path", ",", "'distribute-*.tar.gz*'", ")", ")", ":", "os", ".", "unlink", "(", "fpath", ")", "if", "ret", "[", "'retcode'", "]", "!=", "0", ":", "# Something went wrong. Let's bail out now!", "return", "ret", "# Install pip", "if", "pip", "and", "not", "os", ".", "path", ".", "exists", "(", "venv_pip", ")", ":", "_ret", "=", "_install_script", "(", "'https://bootstrap.pypa.io/get-pip.py'", ",", "path", ",", "venv_python", ",", "user", ",", "saltenv", "=", "saltenv", ",", "use_vt", "=", "use_vt", ")", "# Let's update the return dictionary with the details from the pip", "# installation", "ret", ".", "update", "(", "retcode", "=", "_ret", "[", "'retcode'", "]", ",", "stdout", "=", "'{0}\\n{1}'", ".", "format", "(", "ret", "[", "'stdout'", "]", ",", "_ret", "[", "'stdout'", "]", ")", ".", "strip", "(", ")", ",", "stderr", "=", "'{0}\\n{1}'", ".", "format", "(", "ret", "[", "'stderr'", "]", ",", "_ret", "[", "'stderr'", "]", ")", ".", "strip", "(", ")", ",", ")", "return", "ret"], "docstring": "Create a virtualenv\n\n    path\n        The path to the virtualenv to be created\n\n    venv_bin\n        The name (and optionally path) of the virtualenv command. This can also\n        be set globally in the pillar data as ``venv_bin``.\n        Defaults to ``pyvenv`` or ``virtualenv``, depending on what is installed.\n\n    system_site_packages : False\n        Passthrough argument given to virtualenv or pyvenv\n\n    distribute : False\n        Passthrough argument given to virtualenv\n\n    pip : False\n        Install pip after creating a virtual environment. Implies\n        ``distribute=True``\n\n    clear : False\n        Passthrough argument given to virtualenv or pyvenv\n\n    python : None (default)\n        Passthrough argument given to virtualenv\n\n    extra_search_dir : None (default)\n        Passthrough argument given to virtualenv\n\n    never_download : None (default)\n        Passthrough argument given to virtualenv if True\n\n    prompt : None (default)\n        Passthrough argument given to virtualenv if not None\n\n    symlinks : None\n        Passthrough argument given to pyvenv if True\n\n    upgrade : None\n        Passthrough argument given to pyvenv if True\n\n    user : None\n        Set ownership for the virtualenv\n\n        .. note::\n            On Windows you must also pass a ``password`` parameter. Additionally,\n            the user must have permissions to the location where the virtual\n            environment is being created\n\n    runas : None\n        Set ownership for the virtualenv\n\n        .. deprecated:: 2014.1.0\n            ``user`` should be used instead\n\n    use_vt : False\n        Use VT terminal emulation (see output while installing)\n\n        .. versionadded:: 2015.5.0\n\n    saltenv : 'base'\n        Specify a different environment. The default environment is ``base``.\n\n        .. versionadded:: 2014.1.0\n\n    .. note::\n        The ``runas`` argument is deprecated as of 2014.1.0. ``user`` should be\n        used instead.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' virtualenv.create /path/to/new/virtualenv", "docstring_tokens": ["Create", "a", "virtualenv"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/modules/virtualenv_mod.py#L49-L316", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/modules/virtualenv_mod.py", "func_name": "get_site_packages", "original_string": "def get_site_packages(venv):\n    '''\n    Return the path to the site-packages directory of a virtualenv\n\n    venv\n        Path to the virtualenv.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' virtualenv.get_site_packages /path/to/my/venv\n    '''\n    bin_path = _verify_virtualenv(venv)\n\n    ret = __salt__['cmd.exec_code_all'](\n        bin_path,\n        'from distutils import sysconfig; '\n            'print(sysconfig.get_python_lib())'\n    )\n\n    if ret['retcode'] != 0:\n        raise CommandExecutionError('{stdout}\\n{stderr}'.format(**ret))\n\n    return ret['stdout']", "language": "python", "code": "def get_site_packages(venv):\n    '''\n    Return the path to the site-packages directory of a virtualenv\n\n    venv\n        Path to the virtualenv.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' virtualenv.get_site_packages /path/to/my/venv\n    '''\n    bin_path = _verify_virtualenv(venv)\n\n    ret = __salt__['cmd.exec_code_all'](\n        bin_path,\n        'from distutils import sysconfig; '\n            'print(sysconfig.get_python_lib())'\n    )\n\n    if ret['retcode'] != 0:\n        raise CommandExecutionError('{stdout}\\n{stderr}'.format(**ret))\n\n    return ret['stdout']", "code_tokens": ["def", "get_site_packages", "(", "venv", ")", ":", "bin_path", "=", "_verify_virtualenv", "(", "venv", ")", "ret", "=", "__salt__", "[", "'cmd.exec_code_all'", "]", "(", "bin_path", ",", "'from distutils import sysconfig; '", "'print(sysconfig.get_python_lib())'", ")", "if", "ret", "[", "'retcode'", "]", "!=", "0", ":", "raise", "CommandExecutionError", "(", "'{stdout}\\n{stderr}'", ".", "format", "(", "*", "*", "ret", ")", ")", "return", "ret", "[", "'stdout'", "]"], "docstring": "Return the path to the site-packages directory of a virtualenv\n\n    venv\n        Path to the virtualenv.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' virtualenv.get_site_packages /path/to/my/venv", "docstring_tokens": ["Return", "the", "path", "to", "the", "site", "-", "packages", "directory", "of", "a", "virtualenv"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/modules/virtualenv_mod.py#L319-L343", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/modules/virtualenv_mod.py", "func_name": "get_distribution_path", "original_string": "def get_distribution_path(venv, distribution):\n    '''\n    Return the path to a distribution installed inside a virtualenv\n\n    .. versionadded:: 2016.3.0\n\n    venv\n        Path to the virtualenv.\n    distribution\n        Name of the distribution. Note, all non-alphanumeric characters\n        will be converted to dashes.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' virtualenv.get_distribution_path /path/to/my/venv my_distribution\n    '''\n    _verify_safe_py_code(distribution)\n    bin_path = _verify_virtualenv(venv)\n\n    ret = __salt__['cmd.exec_code_all'](\n        bin_path,\n        'import pkg_resources; '\n            \"print(pkg_resources.get_distribution('{0}').location)\".format(\n                distribution\n            )\n    )\n\n    if ret['retcode'] != 0:\n        raise CommandExecutionError('{stdout}\\n{stderr}'.format(**ret))\n\n    return ret['stdout']", "language": "python", "code": "def get_distribution_path(venv, distribution):\n    '''\n    Return the path to a distribution installed inside a virtualenv\n\n    .. versionadded:: 2016.3.0\n\n    venv\n        Path to the virtualenv.\n    distribution\n        Name of the distribution. Note, all non-alphanumeric characters\n        will be converted to dashes.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' virtualenv.get_distribution_path /path/to/my/venv my_distribution\n    '''\n    _verify_safe_py_code(distribution)\n    bin_path = _verify_virtualenv(venv)\n\n    ret = __salt__['cmd.exec_code_all'](\n        bin_path,\n        'import pkg_resources; '\n            \"print(pkg_resources.get_distribution('{0}').location)\".format(\n                distribution\n            )\n    )\n\n    if ret['retcode'] != 0:\n        raise CommandExecutionError('{stdout}\\n{stderr}'.format(**ret))\n\n    return ret['stdout']", "code_tokens": ["def", "get_distribution_path", "(", "venv", ",", "distribution", ")", ":", "_verify_safe_py_code", "(", "distribution", ")", "bin_path", "=", "_verify_virtualenv", "(", "venv", ")", "ret", "=", "__salt__", "[", "'cmd.exec_code_all'", "]", "(", "bin_path", ",", "'import pkg_resources; '", "\"print(pkg_resources.get_distribution('{0}').location)\"", ".", "format", "(", "distribution", ")", ")", "if", "ret", "[", "'retcode'", "]", "!=", "0", ":", "raise", "CommandExecutionError", "(", "'{stdout}\\n{stderr}'", ".", "format", "(", "*", "*", "ret", ")", ")", "return", "ret", "[", "'stdout'", "]"], "docstring": "Return the path to a distribution installed inside a virtualenv\n\n    .. versionadded:: 2016.3.0\n\n    venv\n        Path to the virtualenv.\n    distribution\n        Name of the distribution. Note, all non-alphanumeric characters\n        will be converted to dashes.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' virtualenv.get_distribution_path /path/to/my/venv my_distribution", "docstring_tokens": ["Return", "the", "path", "to", "a", "distribution", "installed", "inside", "a", "virtualenv"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/modules/virtualenv_mod.py#L346-L378", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/modules/virtualenv_mod.py", "func_name": "get_resource_path", "original_string": "def get_resource_path(venv,\n                      package=None,\n                      resource=None):\n    '''\n    Return the path to a package resource installed inside a virtualenv\n\n    .. versionadded:: 2015.5.0\n\n    venv\n        Path to the virtualenv\n\n    package\n        Name of the package in which the resource resides\n\n        .. versionadded:: 2016.3.0\n\n    resource\n        Name of the resource of which the path is to be returned\n\n        .. versionadded:: 2016.3.0\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' virtualenv.get_resource_path /path/to/my/venv my_package my/resource.xml\n    '''\n    _verify_safe_py_code(package, resource)\n    bin_path = _verify_virtualenv(venv)\n\n    ret = __salt__['cmd.exec_code_all'](\n        bin_path,\n        'import pkg_resources; '\n            \"print(pkg_resources.resource_filename('{0}', '{1}'))\".format(\n                package,\n                resource\n        )\n    )\n\n    if ret['retcode'] != 0:\n        raise CommandExecutionError('{stdout}\\n{stderr}'.format(**ret))\n\n    return ret['stdout']", "language": "python", "code": "def get_resource_path(venv,\n                      package=None,\n                      resource=None):\n    '''\n    Return the path to a package resource installed inside a virtualenv\n\n    .. versionadded:: 2015.5.0\n\n    venv\n        Path to the virtualenv\n\n    package\n        Name of the package in which the resource resides\n\n        .. versionadded:: 2016.3.0\n\n    resource\n        Name of the resource of which the path is to be returned\n\n        .. versionadded:: 2016.3.0\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' virtualenv.get_resource_path /path/to/my/venv my_package my/resource.xml\n    '''\n    _verify_safe_py_code(package, resource)\n    bin_path = _verify_virtualenv(venv)\n\n    ret = __salt__['cmd.exec_code_all'](\n        bin_path,\n        'import pkg_resources; '\n            \"print(pkg_resources.resource_filename('{0}', '{1}'))\".format(\n                package,\n                resource\n        )\n    )\n\n    if ret['retcode'] != 0:\n        raise CommandExecutionError('{stdout}\\n{stderr}'.format(**ret))\n\n    return ret['stdout']", "code_tokens": ["def", "get_resource_path", "(", "venv", ",", "package", "=", "None", ",", "resource", "=", "None", ")", ":", "_verify_safe_py_code", "(", "package", ",", "resource", ")", "bin_path", "=", "_verify_virtualenv", "(", "venv", ")", "ret", "=", "__salt__", "[", "'cmd.exec_code_all'", "]", "(", "bin_path", ",", "'import pkg_resources; '", "\"print(pkg_resources.resource_filename('{0}', '{1}'))\"", ".", "format", "(", "package", ",", "resource", ")", ")", "if", "ret", "[", "'retcode'", "]", "!=", "0", ":", "raise", "CommandExecutionError", "(", "'{stdout}\\n{stderr}'", ".", "format", "(", "*", "*", "ret", ")", ")", "return", "ret", "[", "'stdout'", "]"], "docstring": "Return the path to a package resource installed inside a virtualenv\n\n    .. versionadded:: 2015.5.0\n\n    venv\n        Path to the virtualenv\n\n    package\n        Name of the package in which the resource resides\n\n        .. versionadded:: 2016.3.0\n\n    resource\n        Name of the resource of which the path is to be returned\n\n        .. versionadded:: 2016.3.0\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' virtualenv.get_resource_path /path/to/my/venv my_package my/resource.xml", "docstring_tokens": ["Return", "the", "path", "to", "a", "package", "resource", "installed", "inside", "a", "virtualenv"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/modules/virtualenv_mod.py#L381-L423", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/cloud/clouds/libvirt.py", "func_name": "list_nodes", "original_string": "def list_nodes(call=None):\n    '''\n    Return a list of the VMs\n\n    id (str)\n    image (str)\n    size (str)\n    state (str)\n    private_ips (list)\n    public_ips (list)\n\n    '''\n    if call == 'action':\n        raise SaltCloudSystemExit(\n            'The list_nodes function must be called '\n            'with -f or --function.'\n        )\n\n    providers = __opts__.get('providers', {})\n\n    ret = {}\n    providers_to_check = [_f for _f in [cfg.get('libvirt') for cfg in six.itervalues(providers)] if _f]\n    for provider in providers_to_check:\n        conn = __get_conn(provider['url'])\n        domains = conn.listAllDomains()\n        for domain in domains:\n            data = {\n                'id': domain.UUIDString(),\n                'image': '',\n                'size': '',\n                'state': VIRT_STATE_NAME_MAP[domain.state()[0]],\n                'private_ips': [],\n                'public_ips': get_domain_ips(domain, libvirt.VIR_DOMAIN_INTERFACE_ADDRESSES_SRC_LEASE)}\n            # TODO: Annoyingly name is not guaranteed to be unique, but the id will not work in other places\n            ret[domain.name()] = data\n\n    return ret", "language": "python", "code": "def list_nodes(call=None):\n    '''\n    Return a list of the VMs\n\n    id (str)\n    image (str)\n    size (str)\n    state (str)\n    private_ips (list)\n    public_ips (list)\n\n    '''\n    if call == 'action':\n        raise SaltCloudSystemExit(\n            'The list_nodes function must be called '\n            'with -f or --function.'\n        )\n\n    providers = __opts__.get('providers', {})\n\n    ret = {}\n    providers_to_check = [_f for _f in [cfg.get('libvirt') for cfg in six.itervalues(providers)] if _f]\n    for provider in providers_to_check:\n        conn = __get_conn(provider['url'])\n        domains = conn.listAllDomains()\n        for domain in domains:\n            data = {\n                'id': domain.UUIDString(),\n                'image': '',\n                'size': '',\n                'state': VIRT_STATE_NAME_MAP[domain.state()[0]],\n                'private_ips': [],\n                'public_ips': get_domain_ips(domain, libvirt.VIR_DOMAIN_INTERFACE_ADDRESSES_SRC_LEASE)}\n            # TODO: Annoyingly name is not guaranteed to be unique, but the id will not work in other places\n            ret[domain.name()] = data\n\n    return ret", "code_tokens": ["def", "list_nodes", "(", "call", "=", "None", ")", ":", "if", "call", "==", "'action'", ":", "raise", "SaltCloudSystemExit", "(", "'The list_nodes function must be called '", "'with -f or --function.'", ")", "providers", "=", "__opts__", ".", "get", "(", "'providers'", ",", "{", "}", ")", "ret", "=", "{", "}", "providers_to_check", "=", "[", "_f", "for", "_f", "in", "[", "cfg", ".", "get", "(", "'libvirt'", ")", "for", "cfg", "in", "six", ".", "itervalues", "(", "providers", ")", "]", "if", "_f", "]", "for", "provider", "in", "providers_to_check", ":", "conn", "=", "__get_conn", "(", "provider", "[", "'url'", "]", ")", "domains", "=", "conn", ".", "listAllDomains", "(", ")", "for", "domain", "in", "domains", ":", "data", "=", "{", "'id'", ":", "domain", ".", "UUIDString", "(", ")", ",", "'image'", ":", "''", ",", "'size'", ":", "''", ",", "'state'", ":", "VIRT_STATE_NAME_MAP", "[", "domain", ".", "state", "(", ")", "[", "0", "]", "]", ",", "'private_ips'", ":", "[", "]", ",", "'public_ips'", ":", "get_domain_ips", "(", "domain", ",", "libvirt", ".", "VIR_DOMAIN_INTERFACE_ADDRESSES_SRC_LEASE", ")", "}", "# TODO: Annoyingly name is not guaranteed to be unique, but the id will not work in other places", "ret", "[", "domain", ".", "name", "(", ")", "]", "=", "data", "return", "ret"], "docstring": "Return a list of the VMs\n\n    id (str)\n    image (str)\n    size (str)\n    state (str)\n    private_ips (list)\n    public_ips (list)", "docstring_tokens": ["Return", "a", "list", "of", "the", "VMs"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/cloud/clouds/libvirt.py#L162-L198", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/cloud/clouds/libvirt.py", "func_name": "list_nodes_select", "original_string": "def list_nodes_select(call=None):\n    '''\n    Return a list of the VMs that are on the provider, with select fields\n    '''\n    if call == 'action':\n        raise SaltCloudSystemExit(\n            'The list_nodes_select function must be called '\n            'with -f or --function.'\n        )\n\n    selection = __opts__.get('query.selection')\n\n    if not selection:\n        raise SaltCloudSystemExit(\n            'query.selection not found in /etc/salt/cloud'\n        )\n\n    # TODO: somewhat doubt the implementation of cloud.list_nodes_select\n    return salt.utils.cloud.list_nodes_select(\n        list_nodes_full(), selection, call,\n    )", "language": "python", "code": "def list_nodes_select(call=None):\n    '''\n    Return a list of the VMs that are on the provider, with select fields\n    '''\n    if call == 'action':\n        raise SaltCloudSystemExit(\n            'The list_nodes_select function must be called '\n            'with -f or --function.'\n        )\n\n    selection = __opts__.get('query.selection')\n\n    if not selection:\n        raise SaltCloudSystemExit(\n            'query.selection not found in /etc/salt/cloud'\n        )\n\n    # TODO: somewhat doubt the implementation of cloud.list_nodes_select\n    return salt.utils.cloud.list_nodes_select(\n        list_nodes_full(), selection, call,\n    )", "code_tokens": ["def", "list_nodes_select", "(", "call", "=", "None", ")", ":", "if", "call", "==", "'action'", ":", "raise", "SaltCloudSystemExit", "(", "'The list_nodes_select function must be called '", "'with -f or --function.'", ")", "selection", "=", "__opts__", ".", "get", "(", "'query.selection'", ")", "if", "not", "selection", ":", "raise", "SaltCloudSystemExit", "(", "'query.selection not found in /etc/salt/cloud'", ")", "# TODO: somewhat doubt the implementation of cloud.list_nodes_select", "return", "salt", ".", "utils", ".", "cloud", ".", "list_nodes_select", "(", "list_nodes_full", "(", ")", ",", "selection", ",", "call", ",", ")"], "docstring": "Return a list of the VMs that are on the provider, with select fields", "docstring_tokens": ["Return", "a", "list", "of", "the", "VMs", "that", "are", "on", "the", "provider", "with", "select", "fields"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/cloud/clouds/libvirt.py#L215-L235", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/cloud/clouds/libvirt.py", "func_name": "create", "original_string": "def create(vm_):\n    '''\n    Provision a single machine\n    '''\n    clone_strategy = vm_.get('clone_strategy') or 'full'\n\n    if clone_strategy not in ('quick', 'full'):\n        raise SaltCloudSystemExit(\"'clone_strategy' must be one of quick or full. Got '{0}'\".format(clone_strategy))\n\n    ip_source = vm_.get('ip_source') or 'ip-learning'\n\n    if ip_source not in ('ip-learning', 'qemu-agent'):\n        raise SaltCloudSystemExit(\"'ip_source' must be one of qemu-agent or ip-learning. Got '{0}'\".format(ip_source))\n\n    validate_xml = vm_.get('validate_xml') if vm_.get('validate_xml') is not None else True\n\n    log.info(\"Cloning '%s' with strategy '%s' validate_xml='%s'\", vm_['name'], clone_strategy, validate_xml)\n\n    try:\n        # Check for required profile parameters before sending any API calls.\n        if vm_['profile'] and config.is_profile_configured(__opts__,\n                                                           __active_provider_name__ or 'libvirt',\n                                                           vm_['profile']) is False:\n            return False\n    except AttributeError:\n        pass\n\n    # TODO: check name qemu/libvirt will choke on some characters (like '/')?\n    name = vm_['name']\n\n    __utils__['cloud.fire_event'](\n        'event',\n        'starting create',\n        'salt/cloud/{0}/creating'.format(name),\n        args=__utils__['cloud.filter_event']('creating', vm_, ['name', 'profile', 'provider', 'driver']),\n        sock_dir=__opts__['sock_dir'],\n        transport=__opts__['transport']\n    )\n\n    key_filename = config.get_cloud_config_value(\n        'private_key', vm_, __opts__, search_global=False, default=None\n    )\n    if key_filename is not None and not os.path.isfile(key_filename):\n        raise SaltCloudConfigError(\n            'The defined key_filename \\'{0}\\' does not exist'.format(\n                key_filename\n            )\n        )\n    vm_['key_filename'] = key_filename\n    # wait_for_instance requires private_key\n    vm_['private_key'] = key_filename\n\n    cleanup = []\n    try:\n        # clone the vm\n        base = vm_['base_domain']\n        conn = __get_conn(vm_['url'])\n\n        try:\n            # for idempotency the salt-bootstrap needs -F argument\n            #  script_args: -F\n            clone_domain = conn.lookupByName(name)\n        except libvirtError as e:\n            domain = conn.lookupByName(base)\n            # TODO: ensure base is shut down before cloning\n            xml = domain.XMLDesc(0)\n\n            kwargs = {\n                'name': name,\n                'base_domain': base,\n            }\n\n            __utils__['cloud.fire_event'](\n                'event',\n                'requesting instance',\n                'salt/cloud/{0}/requesting'.format(name),\n                args={\n                    'kwargs': __utils__['cloud.filter_event']('requesting', kwargs, list(kwargs)),\n                },\n                sock_dir=__opts__['sock_dir'],\n                transport=__opts__['transport']\n            )\n\n            log.debug(\"Source machine XML '%s'\", xml)\n\n            domain_xml = ElementTree.fromstring(xml)\n            domain_xml.find('./name').text = name\n            if domain_xml.find('./description') is None:\n                description_elem = ElementTree.Element('description')\n                domain_xml.insert(0, description_elem)\n            description = domain_xml.find('./description')\n            description.text = \"Cloned from {0}\".format(base)\n            domain_xml.remove(domain_xml.find('./uuid'))\n\n            for iface_xml in domain_xml.findall('./devices/interface'):\n                iface_xml.remove(iface_xml.find('./mac'))\n                # enable IP learning, this might be a default behaviour...\n                # Don't always enable since it can cause problems through libvirt-4.5\n                if ip_source == 'ip-learning' and iface_xml.find(\"./filterref/parameter[@name='CTRL_IP_LEARNING']\") is None:\n                    iface_xml.append(ElementTree.fromstring(IP_LEARNING_XML))\n\n            # If a qemu agent is defined we need to fix the path to its socket\n            # <channel type='unix'>\n            #   <source mode='bind' path='/var/lib/libvirt/qemu/channel/target/domain-<dom-name>/org.qemu.guest_agent.0'/>\n            #   <target type='virtio' name='org.qemu.guest_agent.0'/>\n            #   <address type='virtio-serial' controller='0' bus='0' port='2'/>\n            # </channel>\n            for agent_xml in domain_xml.findall(\"\"\"./devices/channel[@type='unix']\"\"\"):\n                #  is org.qemu.guest_agent.0 an option?\n                if agent_xml.find(\"\"\"./target[@type='virtio'][@name='org.qemu.guest_agent.0']\"\"\") is not None:\n                    source_element = agent_xml.find(\"\"\"./source[@mode='bind']\"\"\")\n                    # see if there is a path element that needs rewriting\n                    if source_element and 'path' in source_element.attrib:\n                        path = source_element.attrib['path']\n                        new_path = path.replace('/domain-{0}/'.format(base), '/domain-{0}/'.format(name))\n                        log.debug(\"Rewriting agent socket path to %s\", new_path)\n                        source_element.attrib['path'] = new_path\n\n            for disk in domain_xml.findall(\"\"\"./devices/disk[@device='disk'][@type='file']\"\"\"):\n                # print \"Disk: \", ElementTree.tostring(disk)\n                # check if we can clone\n                driver = disk.find(\"./driver[@name='qemu']\")\n                if driver is None:\n                    # Err on the safe side\n                    raise SaltCloudExecutionFailure(\"Non qemu driver disk encountered bailing out.\")\n                disk_type = driver.attrib.get('type')\n                log.info(\"disk attributes %s\", disk.attrib)\n                if disk_type == 'qcow2':\n                    source = disk.find(\"./source\").attrib['file']\n                    pool, volume = find_pool_and_volume(conn, source)\n                    if clone_strategy == 'quick':\n                        new_volume = pool.createXML(create_volume_with_backing_store_xml(volume), 0)\n                    else:\n                        new_volume = pool.createXMLFrom(create_volume_xml(volume), volume, 0)\n                    cleanup.append({'what': 'volume', 'item': new_volume})\n\n                    disk.find(\"./source\").attrib['file'] = new_volume.path()\n                elif disk_type == 'raw':\n                    source = disk.find(\"./source\").attrib['file']\n                    pool, volume = find_pool_and_volume(conn, source)\n                    # TODO: more control on the cloned disk type\n                    new_volume = pool.createXMLFrom(create_volume_xml(volume), volume, 0)\n                    cleanup.append({'what': 'volume', 'item': new_volume})\n\n                    disk.find(\"./source\").attrib['file'] = new_volume.path()\n                else:\n                    raise SaltCloudExecutionFailure(\"Disk type '{0}' not supported\".format(disk_type))\n\n            clone_xml = salt.utils.stringutils.to_str(ElementTree.tostring(domain_xml))\n            log.debug(\"Clone XML '%s'\", clone_xml)\n\n            validate_flags = libvirt.VIR_DOMAIN_DEFINE_VALIDATE if validate_xml else 0\n            clone_domain = conn.defineXMLFlags(clone_xml, validate_flags)\n\n            cleanup.append({'what': 'domain', 'item': clone_domain})\n            clone_domain.createWithFlags(libvirt.VIR_DOMAIN_START_FORCE_BOOT)\n\n        log.debug(\"VM '%s'\", vm_)\n\n        if ip_source == 'qemu-agent':\n            ip_source = libvirt.VIR_DOMAIN_INTERFACE_ADDRESSES_SRC_AGENT\n        elif ip_source == 'ip-learning':\n            ip_source = libvirt.VIR_DOMAIN_INTERFACE_ADDRESSES_SRC_LEASE\n\n        address = salt.utils.cloud.wait_for_ip(\n            get_domain_ip,\n            update_args=(clone_domain, 0, ip_source),\n            timeout=config.get_cloud_config_value('wait_for_ip_timeout', vm_, __opts__, default=10 * 60),\n            interval=config.get_cloud_config_value('wait_for_ip_interval', vm_, __opts__, default=10),\n            interval_multiplier=config.get_cloud_config_value('wait_for_ip_interval_multiplier', vm_, __opts__, default=1),\n        )\n\n        log.info('Address = %s', address)\n\n        vm_['ssh_host'] = address\n\n        # the bootstrap script needs to be installed first in /etc/salt/cloud.deploy.d/\n        # salt-cloud -u is your friend\n        ret = __utils__['cloud.bootstrap'](vm_, __opts__)\n\n        __utils__['cloud.fire_event'](\n            'event',\n            'created instance',\n            'salt/cloud/{0}/created'.format(name),\n            args=__utils__['cloud.filter_event']('created', vm_, ['name', 'profile', 'provider', 'driver']),\n            sock_dir=__opts__['sock_dir'],\n            transport=__opts__['transport']\n        )\n\n        return ret\n    except Exception as e:  # pylint: disable=broad-except\n        do_cleanup(cleanup)\n        # throw the root cause after cleanup\n        raise e", "language": "python", "code": "def create(vm_):\n    '''\n    Provision a single machine\n    '''\n    clone_strategy = vm_.get('clone_strategy') or 'full'\n\n    if clone_strategy not in ('quick', 'full'):\n        raise SaltCloudSystemExit(\"'clone_strategy' must be one of quick or full. Got '{0}'\".format(clone_strategy))\n\n    ip_source = vm_.get('ip_source') or 'ip-learning'\n\n    if ip_source not in ('ip-learning', 'qemu-agent'):\n        raise SaltCloudSystemExit(\"'ip_source' must be one of qemu-agent or ip-learning. Got '{0}'\".format(ip_source))\n\n    validate_xml = vm_.get('validate_xml') if vm_.get('validate_xml') is not None else True\n\n    log.info(\"Cloning '%s' with strategy '%s' validate_xml='%s'\", vm_['name'], clone_strategy, validate_xml)\n\n    try:\n        # Check for required profile parameters before sending any API calls.\n        if vm_['profile'] and config.is_profile_configured(__opts__,\n                                                           __active_provider_name__ or 'libvirt',\n                                                           vm_['profile']) is False:\n            return False\n    except AttributeError:\n        pass\n\n    # TODO: check name qemu/libvirt will choke on some characters (like '/')?\n    name = vm_['name']\n\n    __utils__['cloud.fire_event'](\n        'event',\n        'starting create',\n        'salt/cloud/{0}/creating'.format(name),\n        args=__utils__['cloud.filter_event']('creating', vm_, ['name', 'profile', 'provider', 'driver']),\n        sock_dir=__opts__['sock_dir'],\n        transport=__opts__['transport']\n    )\n\n    key_filename = config.get_cloud_config_value(\n        'private_key', vm_, __opts__, search_global=False, default=None\n    )\n    if key_filename is not None and not os.path.isfile(key_filename):\n        raise SaltCloudConfigError(\n            'The defined key_filename \\'{0}\\' does not exist'.format(\n                key_filename\n            )\n        )\n    vm_['key_filename'] = key_filename\n    # wait_for_instance requires private_key\n    vm_['private_key'] = key_filename\n\n    cleanup = []\n    try:\n        # clone the vm\n        base = vm_['base_domain']\n        conn = __get_conn(vm_['url'])\n\n        try:\n            # for idempotency the salt-bootstrap needs -F argument\n            #  script_args: -F\n            clone_domain = conn.lookupByName(name)\n        except libvirtError as e:\n            domain = conn.lookupByName(base)\n            # TODO: ensure base is shut down before cloning\n            xml = domain.XMLDesc(0)\n\n            kwargs = {\n                'name': name,\n                'base_domain': base,\n            }\n\n            __utils__['cloud.fire_event'](\n                'event',\n                'requesting instance',\n                'salt/cloud/{0}/requesting'.format(name),\n                args={\n                    'kwargs': __utils__['cloud.filter_event']('requesting', kwargs, list(kwargs)),\n                },\n                sock_dir=__opts__['sock_dir'],\n                transport=__opts__['transport']\n            )\n\n            log.debug(\"Source machine XML '%s'\", xml)\n\n            domain_xml = ElementTree.fromstring(xml)\n            domain_xml.find('./name').text = name\n            if domain_xml.find('./description') is None:\n                description_elem = ElementTree.Element('description')\n                domain_xml.insert(0, description_elem)\n            description = domain_xml.find('./description')\n            description.text = \"Cloned from {0}\".format(base)\n            domain_xml.remove(domain_xml.find('./uuid'))\n\n            for iface_xml in domain_xml.findall('./devices/interface'):\n                iface_xml.remove(iface_xml.find('./mac'))\n                # enable IP learning, this might be a default behaviour...\n                # Don't always enable since it can cause problems through libvirt-4.5\n                if ip_source == 'ip-learning' and iface_xml.find(\"./filterref/parameter[@name='CTRL_IP_LEARNING']\") is None:\n                    iface_xml.append(ElementTree.fromstring(IP_LEARNING_XML))\n\n            # If a qemu agent is defined we need to fix the path to its socket\n            # <channel type='unix'>\n            #   <source mode='bind' path='/var/lib/libvirt/qemu/channel/target/domain-<dom-name>/org.qemu.guest_agent.0'/>\n            #   <target type='virtio' name='org.qemu.guest_agent.0'/>\n            #   <address type='virtio-serial' controller='0' bus='0' port='2'/>\n            # </channel>\n            for agent_xml in domain_xml.findall(\"\"\"./devices/channel[@type='unix']\"\"\"):\n                #  is org.qemu.guest_agent.0 an option?\n                if agent_xml.find(\"\"\"./target[@type='virtio'][@name='org.qemu.guest_agent.0']\"\"\") is not None:\n                    source_element = agent_xml.find(\"\"\"./source[@mode='bind']\"\"\")\n                    # see if there is a path element that needs rewriting\n                    if source_element and 'path' in source_element.attrib:\n                        path = source_element.attrib['path']\n                        new_path = path.replace('/domain-{0}/'.format(base), '/domain-{0}/'.format(name))\n                        log.debug(\"Rewriting agent socket path to %s\", new_path)\n                        source_element.attrib['path'] = new_path\n\n            for disk in domain_xml.findall(\"\"\"./devices/disk[@device='disk'][@type='file']\"\"\"):\n                # print \"Disk: \", ElementTree.tostring(disk)\n                # check if we can clone\n                driver = disk.find(\"./driver[@name='qemu']\")\n                if driver is None:\n                    # Err on the safe side\n                    raise SaltCloudExecutionFailure(\"Non qemu driver disk encountered bailing out.\")\n                disk_type = driver.attrib.get('type')\n                log.info(\"disk attributes %s\", disk.attrib)\n                if disk_type == 'qcow2':\n                    source = disk.find(\"./source\").attrib['file']\n                    pool, volume = find_pool_and_volume(conn, source)\n                    if clone_strategy == 'quick':\n                        new_volume = pool.createXML(create_volume_with_backing_store_xml(volume), 0)\n                    else:\n                        new_volume = pool.createXMLFrom(create_volume_xml(volume), volume, 0)\n                    cleanup.append({'what': 'volume', 'item': new_volume})\n\n                    disk.find(\"./source\").attrib['file'] = new_volume.path()\n                elif disk_type == 'raw':\n                    source = disk.find(\"./source\").attrib['file']\n                    pool, volume = find_pool_and_volume(conn, source)\n                    # TODO: more control on the cloned disk type\n                    new_volume = pool.createXMLFrom(create_volume_xml(volume), volume, 0)\n                    cleanup.append({'what': 'volume', 'item': new_volume})\n\n                    disk.find(\"./source\").attrib['file'] = new_volume.path()\n                else:\n                    raise SaltCloudExecutionFailure(\"Disk type '{0}' not supported\".format(disk_type))\n\n            clone_xml = salt.utils.stringutils.to_str(ElementTree.tostring(domain_xml))\n            log.debug(\"Clone XML '%s'\", clone_xml)\n\n            validate_flags = libvirt.VIR_DOMAIN_DEFINE_VALIDATE if validate_xml else 0\n            clone_domain = conn.defineXMLFlags(clone_xml, validate_flags)\n\n            cleanup.append({'what': 'domain', 'item': clone_domain})\n            clone_domain.createWithFlags(libvirt.VIR_DOMAIN_START_FORCE_BOOT)\n\n        log.debug(\"VM '%s'\", vm_)\n\n        if ip_source == 'qemu-agent':\n            ip_source = libvirt.VIR_DOMAIN_INTERFACE_ADDRESSES_SRC_AGENT\n        elif ip_source == 'ip-learning':\n            ip_source = libvirt.VIR_DOMAIN_INTERFACE_ADDRESSES_SRC_LEASE\n\n        address = salt.utils.cloud.wait_for_ip(\n            get_domain_ip,\n            update_args=(clone_domain, 0, ip_source),\n            timeout=config.get_cloud_config_value('wait_for_ip_timeout', vm_, __opts__, default=10 * 60),\n            interval=config.get_cloud_config_value('wait_for_ip_interval', vm_, __opts__, default=10),\n            interval_multiplier=config.get_cloud_config_value('wait_for_ip_interval_multiplier', vm_, __opts__, default=1),\n        )\n\n        log.info('Address = %s', address)\n\n        vm_['ssh_host'] = address\n\n        # the bootstrap script needs to be installed first in /etc/salt/cloud.deploy.d/\n        # salt-cloud -u is your friend\n        ret = __utils__['cloud.bootstrap'](vm_, __opts__)\n\n        __utils__['cloud.fire_event'](\n            'event',\n            'created instance',\n            'salt/cloud/{0}/created'.format(name),\n            args=__utils__['cloud.filter_event']('created', vm_, ['name', 'profile', 'provider', 'driver']),\n            sock_dir=__opts__['sock_dir'],\n            transport=__opts__['transport']\n        )\n\n        return ret\n    except Exception as e:  # pylint: disable=broad-except\n        do_cleanup(cleanup)\n        # throw the root cause after cleanup\n        raise e", "code_tokens": ["def", "create", "(", "vm_", ")", ":", "clone_strategy", "=", "vm_", ".", "get", "(", "'clone_strategy'", ")", "or", "'full'", "if", "clone_strategy", "not", "in", "(", "'quick'", ",", "'full'", ")", ":", "raise", "SaltCloudSystemExit", "(", "\"'clone_strategy' must be one of quick or full. Got '{0}'\"", ".", "format", "(", "clone_strategy", ")", ")", "ip_source", "=", "vm_", ".", "get", "(", "'ip_source'", ")", "or", "'ip-learning'", "if", "ip_source", "not", "in", "(", "'ip-learning'", ",", "'qemu-agent'", ")", ":", "raise", "SaltCloudSystemExit", "(", "\"'ip_source' must be one of qemu-agent or ip-learning. Got '{0}'\"", ".", "format", "(", "ip_source", ")", ")", "validate_xml", "=", "vm_", ".", "get", "(", "'validate_xml'", ")", "if", "vm_", ".", "get", "(", "'validate_xml'", ")", "is", "not", "None", "else", "True", "log", ".", "info", "(", "\"Cloning '%s' with strategy '%s' validate_xml='%s'\"", ",", "vm_", "[", "'name'", "]", ",", "clone_strategy", ",", "validate_xml", ")", "try", ":", "# Check for required profile parameters before sending any API calls.", "if", "vm_", "[", "'profile'", "]", "and", "config", ".", "is_profile_configured", "(", "__opts__", ",", "__active_provider_name__", "or", "'libvirt'", ",", "vm_", "[", "'profile'", "]", ")", "is", "False", ":", "return", "False", "except", "AttributeError", ":", "pass", "# TODO: check name qemu/libvirt will choke on some characters (like '/')?", "name", "=", "vm_", "[", "'name'", "]", "__utils__", "[", "'cloud.fire_event'", "]", "(", "'event'", ",", "'starting create'", ",", "'salt/cloud/{0}/creating'", ".", "format", "(", "name", ")", ",", "args", "=", "__utils__", "[", "'cloud.filter_event'", "]", "(", "'creating'", ",", "vm_", ",", "[", "'name'", ",", "'profile'", ",", "'provider'", ",", "'driver'", "]", ")", ",", "sock_dir", "=", "__opts__", "[", "'sock_dir'", "]", ",", "transport", "=", "__opts__", "[", "'transport'", "]", ")", "key_filename", "=", "config", ".", "get_cloud_config_value", "(", "'private_key'", ",", "vm_", ",", "__opts__", ",", "search_global", "=", "False", ",", "default", "=", "None", ")", "if", "key_filename", "is", "not", "None", "and", "not", "os", ".", "path", ".", "isfile", "(", "key_filename", ")", ":", "raise", "SaltCloudConfigError", "(", "'The defined key_filename \\'{0}\\' does not exist'", ".", "format", "(", "key_filename", ")", ")", "vm_", "[", "'key_filename'", "]", "=", "key_filename", "# wait_for_instance requires private_key", "vm_", "[", "'private_key'", "]", "=", "key_filename", "cleanup", "=", "[", "]", "try", ":", "# clone the vm", "base", "=", "vm_", "[", "'base_domain'", "]", "conn", "=", "__get_conn", "(", "vm_", "[", "'url'", "]", ")", "try", ":", "# for idempotency the salt-bootstrap needs -F argument", "#  script_args: -F", "clone_domain", "=", "conn", ".", "lookupByName", "(", "name", ")", "except", "libvirtError", "as", "e", ":", "domain", "=", "conn", ".", "lookupByName", "(", "base", ")", "# TODO: ensure base is shut down before cloning", "xml", "=", "domain", ".", "XMLDesc", "(", "0", ")", "kwargs", "=", "{", "'name'", ":", "name", ",", "'base_domain'", ":", "base", ",", "}", "__utils__", "[", "'cloud.fire_event'", "]", "(", "'event'", ",", "'requesting instance'", ",", "'salt/cloud/{0}/requesting'", ".", "format", "(", "name", ")", ",", "args", "=", "{", "'kwargs'", ":", "__utils__", "[", "'cloud.filter_event'", "]", "(", "'requesting'", ",", "kwargs", ",", "list", "(", "kwargs", ")", ")", ",", "}", ",", "sock_dir", "=", "__opts__", "[", "'sock_dir'", "]", ",", "transport", "=", "__opts__", "[", "'transport'", "]", ")", "log", ".", "debug", "(", "\"Source machine XML '%s'\"", ",", "xml", ")", "domain_xml", "=", "ElementTree", ".", "fromstring", "(", "xml", ")", "domain_xml", ".", "find", "(", "'./name'", ")", ".", "text", "=", "name", "if", "domain_xml", ".", "find", "(", "'./description'", ")", "is", "None", ":", "description_elem", "=", "ElementTree", ".", "Element", "(", "'description'", ")", "domain_xml", ".", "insert", "(", "0", ",", "description_elem", ")", "description", "=", "domain_xml", ".", "find", "(", "'./description'", ")", "description", ".", "text", "=", "\"Cloned from {0}\"", ".", "format", "(", "base", ")", "domain_xml", ".", "remove", "(", "domain_xml", ".", "find", "(", "'./uuid'", ")", ")", "for", "iface_xml", "in", "domain_xml", ".", "findall", "(", "'./devices/interface'", ")", ":", "iface_xml", ".", "remove", "(", "iface_xml", ".", "find", "(", "'./mac'", ")", ")", "# enable IP learning, this might be a default behaviour...", "# Don't always enable since it can cause problems through libvirt-4.5", "if", "ip_source", "==", "'ip-learning'", "and", "iface_xml", ".", "find", "(", "\"./filterref/parameter[@name='CTRL_IP_LEARNING']\"", ")", "is", "None", ":", "iface_xml", ".", "append", "(", "ElementTree", ".", "fromstring", "(", "IP_LEARNING_XML", ")", ")", "# If a qemu agent is defined we need to fix the path to its socket", "# <channel type='unix'>", "#   <source mode='bind' path='/var/lib/libvirt/qemu/channel/target/domain-<dom-name>/org.qemu.guest_agent.0'/>", "#   <target type='virtio' name='org.qemu.guest_agent.0'/>", "#   <address type='virtio-serial' controller='0' bus='0' port='2'/>", "# </channel>", "for", "agent_xml", "in", "domain_xml", ".", "findall", "(", "\"\"\"./devices/channel[@type='unix']\"\"\"", ")", ":", "#  is org.qemu.guest_agent.0 an option?", "if", "agent_xml", ".", "find", "(", "\"\"\"./target[@type='virtio'][@name='org.qemu.guest_agent.0']\"\"\"", ")", "is", "not", "None", ":", "source_element", "=", "agent_xml", ".", "find", "(", "\"\"\"./source[@mode='bind']\"\"\"", ")", "# see if there is a path element that needs rewriting", "if", "source_element", "and", "'path'", "in", "source_element", ".", "attrib", ":", "path", "=", "source_element", ".", "attrib", "[", "'path'", "]", "new_path", "=", "path", ".", "replace", "(", "'/domain-{0}/'", ".", "format", "(", "base", ")", ",", "'/domain-{0}/'", ".", "format", "(", "name", ")", ")", "log", ".", "debug", "(", "\"Rewriting agent socket path to %s\"", ",", "new_path", ")", "source_element", ".", "attrib", "[", "'path'", "]", "=", "new_path", "for", "disk", "in", "domain_xml", ".", "findall", "(", "\"\"\"./devices/disk[@device='disk'][@type='file']\"\"\"", ")", ":", "# print \"Disk: \", ElementTree.tostring(disk)", "# check if we can clone", "driver", "=", "disk", ".", "find", "(", "\"./driver[@name='qemu']\"", ")", "if", "driver", "is", "None", ":", "# Err on the safe side", "raise", "SaltCloudExecutionFailure", "(", "\"Non qemu driver disk encountered bailing out.\"", ")", "disk_type", "=", "driver", ".", "attrib", ".", "get", "(", "'type'", ")", "log", ".", "info", "(", "\"disk attributes %s\"", ",", "disk", ".", "attrib", ")", "if", "disk_type", "==", "'qcow2'", ":", "source", "=", "disk", ".", "find", "(", "\"./source\"", ")", ".", "attrib", "[", "'file'", "]", "pool", ",", "volume", "=", "find_pool_and_volume", "(", "conn", ",", "source", ")", "if", "clone_strategy", "==", "'quick'", ":", "new_volume", "=", "pool", ".", "createXML", "(", "create_volume_with_backing_store_xml", "(", "volume", ")", ",", "0", ")", "else", ":", "new_volume", "=", "pool", ".", "createXMLFrom", "(", "create_volume_xml", "(", "volume", ")", ",", "volume", ",", "0", ")", "cleanup", ".", "append", "(", "{", "'what'", ":", "'volume'", ",", "'item'", ":", "new_volume", "}", ")", "disk", ".", "find", "(", "\"./source\"", ")", ".", "attrib", "[", "'file'", "]", "=", "new_volume", ".", "path", "(", ")", "elif", "disk_type", "==", "'raw'", ":", "source", "=", "disk", ".", "find", "(", "\"./source\"", ")", ".", "attrib", "[", "'file'", "]", "pool", ",", "volume", "=", "find_pool_and_volume", "(", "conn", ",", "source", ")", "# TODO: more control on the cloned disk type", "new_volume", "=", "pool", ".", "createXMLFrom", "(", "create_volume_xml", "(", "volume", ")", ",", "volume", ",", "0", ")", "cleanup", ".", "append", "(", "{", "'what'", ":", "'volume'", ",", "'item'", ":", "new_volume", "}", ")", "disk", ".", "find", "(", "\"./source\"", ")", ".", "attrib", "[", "'file'", "]", "=", "new_volume", ".", "path", "(", ")", "else", ":", "raise", "SaltCloudExecutionFailure", "(", "\"Disk type '{0}' not supported\"", ".", "format", "(", "disk_type", ")", ")", "clone_xml", "=", "salt", ".", "utils", ".", "stringutils", ".", "to_str", "(", "ElementTree", ".", "tostring", "(", "domain_xml", ")", ")", "log", ".", "debug", "(", "\"Clone XML '%s'\"", ",", "clone_xml", ")", "validate_flags", "=", "libvirt", ".", "VIR_DOMAIN_DEFINE_VALIDATE", "if", "validate_xml", "else", "0", "clone_domain", "=", "conn", ".", "defineXMLFlags", "(", "clone_xml", ",", "validate_flags", ")", "cleanup", ".", "append", "(", "{", "'what'", ":", "'domain'", ",", "'item'", ":", "clone_domain", "}", ")", "clone_domain", ".", "createWithFlags", "(", "libvirt", ".", "VIR_DOMAIN_START_FORCE_BOOT", ")", "log", ".", "debug", "(", "\"VM '%s'\"", ",", "vm_", ")", "if", "ip_source", "==", "'qemu-agent'", ":", "ip_source", "=", "libvirt", ".", "VIR_DOMAIN_INTERFACE_ADDRESSES_SRC_AGENT", "elif", "ip_source", "==", "'ip-learning'", ":", "ip_source", "=", "libvirt", ".", "VIR_DOMAIN_INTERFACE_ADDRESSES_SRC_LEASE", "address", "=", "salt", ".", "utils", ".", "cloud", ".", "wait_for_ip", "(", "get_domain_ip", ",", "update_args", "=", "(", "clone_domain", ",", "0", ",", "ip_source", ")", ",", "timeout", "=", "config", ".", "get_cloud_config_value", "(", "'wait_for_ip_timeout'", ",", "vm_", ",", "__opts__", ",", "default", "=", "10", "*", "60", ")", ",", "interval", "=", "config", ".", "get_cloud_config_value", "(", "'wait_for_ip_interval'", ",", "vm_", ",", "__opts__", ",", "default", "=", "10", ")", ",", "interval_multiplier", "=", "config", ".", "get_cloud_config_value", "(", "'wait_for_ip_interval_multiplier'", ",", "vm_", ",", "__opts__", ",", "default", "=", "1", ")", ",", ")", "log", ".", "info", "(", "'Address = %s'", ",", "address", ")", "vm_", "[", "'ssh_host'", "]", "=", "address", "# the bootstrap script needs to be installed first in /etc/salt/cloud.deploy.d/", "# salt-cloud -u is your friend", "ret", "=", "__utils__", "[", "'cloud.bootstrap'", "]", "(", "vm_", ",", "__opts__", ")", "__utils__", "[", "'cloud.fire_event'", "]", "(", "'event'", ",", "'created instance'", ",", "'salt/cloud/{0}/created'", ".", "format", "(", "name", ")", ",", "args", "=", "__utils__", "[", "'cloud.filter_event'", "]", "(", "'created'", ",", "vm_", ",", "[", "'name'", ",", "'profile'", ",", "'provider'", ",", "'driver'", "]", ")", ",", "sock_dir", "=", "__opts__", "[", "'sock_dir'", "]", ",", "transport", "=", "__opts__", "[", "'transport'", "]", ")", "return", "ret", "except", "Exception", "as", "e", ":", "# pylint: disable=broad-except", "do_cleanup", "(", "cleanup", ")", "# throw the root cause after cleanup", "raise", "e"], "docstring": "Provision a single machine", "docstring_tokens": ["Provision", "a", "single", "machine"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/cloud/clouds/libvirt.py#L278-L471", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/cloud/clouds/libvirt.py", "func_name": "do_cleanup", "original_string": "def do_cleanup(cleanup):\n    '''\n    Clean up clone domain leftovers as much as possible.\n\n    Extra robust clean up in order to deal with some small changes in libvirt\n    behavior over time. Passed in volumes and domains are deleted, any errors\n    are ignored. Used when cloning/provisioning a domain fails.\n\n    :param cleanup: list containing dictonaries with two keys: 'what' and 'item'.\n                    If 'what' is domain the 'item' is a libvirt domain object.\n                    If 'what' is volume then the item is a libvirt volume object.\n\n    Returns:\n        none\n\n    .. versionadded: 2017.7.3\n    '''\n    log.info('Cleaning up after exception')\n    for leftover in cleanup:\n        what = leftover['what']\n        item = leftover['item']\n        if what == 'domain':\n            log.info('Cleaning up %s %s', what, item.name())\n            try:\n                item.destroy()\n                log.debug('%s %s forced off', what, item.name())\n            except libvirtError:\n                pass\n            try:\n                item.undefineFlags(libvirt.VIR_DOMAIN_UNDEFINE_MANAGED_SAVE+\n                                   libvirt.VIR_DOMAIN_UNDEFINE_SNAPSHOTS_METADATA+\n                                   libvirt.VIR_DOMAIN_UNDEFINE_NVRAM)\n                log.debug('%s %s undefined', what, item.name())\n            except libvirtError:\n                pass\n        if what == 'volume':\n            try:\n                item.delete()\n                log.debug('%s %s cleaned up', what, item.name())\n            except libvirtError:\n                pass", "language": "python", "code": "def do_cleanup(cleanup):\n    '''\n    Clean up clone domain leftovers as much as possible.\n\n    Extra robust clean up in order to deal with some small changes in libvirt\n    behavior over time. Passed in volumes and domains are deleted, any errors\n    are ignored. Used when cloning/provisioning a domain fails.\n\n    :param cleanup: list containing dictonaries with two keys: 'what' and 'item'.\n                    If 'what' is domain the 'item' is a libvirt domain object.\n                    If 'what' is volume then the item is a libvirt volume object.\n\n    Returns:\n        none\n\n    .. versionadded: 2017.7.3\n    '''\n    log.info('Cleaning up after exception')\n    for leftover in cleanup:\n        what = leftover['what']\n        item = leftover['item']\n        if what == 'domain':\n            log.info('Cleaning up %s %s', what, item.name())\n            try:\n                item.destroy()\n                log.debug('%s %s forced off', what, item.name())\n            except libvirtError:\n                pass\n            try:\n                item.undefineFlags(libvirt.VIR_DOMAIN_UNDEFINE_MANAGED_SAVE+\n                                   libvirt.VIR_DOMAIN_UNDEFINE_SNAPSHOTS_METADATA+\n                                   libvirt.VIR_DOMAIN_UNDEFINE_NVRAM)\n                log.debug('%s %s undefined', what, item.name())\n            except libvirtError:\n                pass\n        if what == 'volume':\n            try:\n                item.delete()\n                log.debug('%s %s cleaned up', what, item.name())\n            except libvirtError:\n                pass", "code_tokens": ["def", "do_cleanup", "(", "cleanup", ")", ":", "log", ".", "info", "(", "'Cleaning up after exception'", ")", "for", "leftover", "in", "cleanup", ":", "what", "=", "leftover", "[", "'what'", "]", "item", "=", "leftover", "[", "'item'", "]", "if", "what", "==", "'domain'", ":", "log", ".", "info", "(", "'Cleaning up %s %s'", ",", "what", ",", "item", ".", "name", "(", ")", ")", "try", ":", "item", ".", "destroy", "(", ")", "log", ".", "debug", "(", "'%s %s forced off'", ",", "what", ",", "item", ".", "name", "(", ")", ")", "except", "libvirtError", ":", "pass", "try", ":", "item", ".", "undefineFlags", "(", "libvirt", ".", "VIR_DOMAIN_UNDEFINE_MANAGED_SAVE", "+", "libvirt", ".", "VIR_DOMAIN_UNDEFINE_SNAPSHOTS_METADATA", "+", "libvirt", ".", "VIR_DOMAIN_UNDEFINE_NVRAM", ")", "log", ".", "debug", "(", "'%s %s undefined'", ",", "what", ",", "item", ".", "name", "(", ")", ")", "except", "libvirtError", ":", "pass", "if", "what", "==", "'volume'", ":", "try", ":", "item", ".", "delete", "(", ")", "log", ".", "debug", "(", "'%s %s cleaned up'", ",", "what", ",", "item", ".", "name", "(", ")", ")", "except", "libvirtError", ":", "pass"], "docstring": "Clean up clone domain leftovers as much as possible.\n\n    Extra robust clean up in order to deal with some small changes in libvirt\n    behavior over time. Passed in volumes and domains are deleted, any errors\n    are ignored. Used when cloning/provisioning a domain fails.\n\n    :param cleanup: list containing dictonaries with two keys: 'what' and 'item'.\n                    If 'what' is domain the 'item' is a libvirt domain object.\n                    If 'what' is volume then the item is a libvirt volume object.\n\n    Returns:\n        none\n\n    .. versionadded: 2017.7.3", "docstring_tokens": ["Clean", "up", "clone", "domain", "leftovers", "as", "much", "as", "possible", "."], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/cloud/clouds/libvirt.py#L474-L514", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/cloud/clouds/libvirt.py", "func_name": "destroy", "original_string": "def destroy(name, call=None):\n    \"\"\"\n    This function irreversibly destroys a virtual machine on the cloud provider.\n    Before doing so, it should fire an event on the Salt event bus.\n\n    The tag for this event is `salt/cloud/<vm name>/destroying`.\n    Once the virtual machine has been destroyed, another event is fired.\n    The tag for that event is `salt/cloud/<vm name>/destroyed`.\n\n    Dependencies:\n        list_nodes\n\n    @param name:\n    @type name: str\n    @param call:\n    @type call:\n    @return: True if all went well, otherwise an error message\n    @rtype: bool|str\n    \"\"\"\n    log.info(\"Attempting to delete instance %s\", name)\n\n    if call == 'function':\n        raise SaltCloudSystemExit(\n            'The destroy action must be called with -d, --destroy, '\n            '-a or --action.'\n        )\n\n    found = []\n\n    providers = __opts__.get('providers', {})\n    providers_to_check = [_f for _f in [cfg.get('libvirt') for cfg in six.itervalues(providers)] if _f]\n    for provider in providers_to_check:\n        conn = __get_conn(provider['url'])\n        log.info(\"looking at %s\", provider['url'])\n        try:\n            domain = conn.lookupByName(name)\n            found.append({'domain': domain, 'conn': conn})\n        except libvirtError:\n            pass\n\n    if not found:\n        return \"{0} doesn't exist and can't be deleted\".format(name)\n\n    if len(found) > 1:\n        return \"{0} doesn't identify a unique machine leaving things\".format(name)\n\n    __utils__['cloud.fire_event'](\n        'event',\n        'destroying instance',\n        'salt/cloud/{0}/destroying'.format(name),\n        args={'name': name},\n        sock_dir=__opts__['sock_dir'],\n        transport=__opts__['transport']\n    )\n\n    destroy_domain(found[0]['conn'], found[0]['domain'])\n\n    __utils__['cloud.fire_event'](\n        'event',\n        'destroyed instance',\n        'salt/cloud/{0}/destroyed'.format(name),\n        args={'name': name},\n        sock_dir=__opts__['sock_dir'],\n        transport=__opts__['transport']\n    )", "language": "python", "code": "def destroy(name, call=None):\n    \"\"\"\n    This function irreversibly destroys a virtual machine on the cloud provider.\n    Before doing so, it should fire an event on the Salt event bus.\n\n    The tag for this event is `salt/cloud/<vm name>/destroying`.\n    Once the virtual machine has been destroyed, another event is fired.\n    The tag for that event is `salt/cloud/<vm name>/destroyed`.\n\n    Dependencies:\n        list_nodes\n\n    @param name:\n    @type name: str\n    @param call:\n    @type call:\n    @return: True if all went well, otherwise an error message\n    @rtype: bool|str\n    \"\"\"\n    log.info(\"Attempting to delete instance %s\", name)\n\n    if call == 'function':\n        raise SaltCloudSystemExit(\n            'The destroy action must be called with -d, --destroy, '\n            '-a or --action.'\n        )\n\n    found = []\n\n    providers = __opts__.get('providers', {})\n    providers_to_check = [_f for _f in [cfg.get('libvirt') for cfg in six.itervalues(providers)] if _f]\n    for provider in providers_to_check:\n        conn = __get_conn(provider['url'])\n        log.info(\"looking at %s\", provider['url'])\n        try:\n            domain = conn.lookupByName(name)\n            found.append({'domain': domain, 'conn': conn})\n        except libvirtError:\n            pass\n\n    if not found:\n        return \"{0} doesn't exist and can't be deleted\".format(name)\n\n    if len(found) > 1:\n        return \"{0} doesn't identify a unique machine leaving things\".format(name)\n\n    __utils__['cloud.fire_event'](\n        'event',\n        'destroying instance',\n        'salt/cloud/{0}/destroying'.format(name),\n        args={'name': name},\n        sock_dir=__opts__['sock_dir'],\n        transport=__opts__['transport']\n    )\n\n    destroy_domain(found[0]['conn'], found[0]['domain'])\n\n    __utils__['cloud.fire_event'](\n        'event',\n        'destroyed instance',\n        'salt/cloud/{0}/destroyed'.format(name),\n        args={'name': name},\n        sock_dir=__opts__['sock_dir'],\n        transport=__opts__['transport']\n    )", "code_tokens": ["def", "destroy", "(", "name", ",", "call", "=", "None", ")", ":", "log", ".", "info", "(", "\"Attempting to delete instance %s\"", ",", "name", ")", "if", "call", "==", "'function'", ":", "raise", "SaltCloudSystemExit", "(", "'The destroy action must be called with -d, --destroy, '", "'-a or --action.'", ")", "found", "=", "[", "]", "providers", "=", "__opts__", ".", "get", "(", "'providers'", ",", "{", "}", ")", "providers_to_check", "=", "[", "_f", "for", "_f", "in", "[", "cfg", ".", "get", "(", "'libvirt'", ")", "for", "cfg", "in", "six", ".", "itervalues", "(", "providers", ")", "]", "if", "_f", "]", "for", "provider", "in", "providers_to_check", ":", "conn", "=", "__get_conn", "(", "provider", "[", "'url'", "]", ")", "log", ".", "info", "(", "\"looking at %s\"", ",", "provider", "[", "'url'", "]", ")", "try", ":", "domain", "=", "conn", ".", "lookupByName", "(", "name", ")", "found", ".", "append", "(", "{", "'domain'", ":", "domain", ",", "'conn'", ":", "conn", "}", ")", "except", "libvirtError", ":", "pass", "if", "not", "found", ":", "return", "\"{0} doesn't exist and can't be deleted\"", ".", "format", "(", "name", ")", "if", "len", "(", "found", ")", ">", "1", ":", "return", "\"{0} doesn't identify a unique machine leaving things\"", ".", "format", "(", "name", ")", "__utils__", "[", "'cloud.fire_event'", "]", "(", "'event'", ",", "'destroying instance'", ",", "'salt/cloud/{0}/destroying'", ".", "format", "(", "name", ")", ",", "args", "=", "{", "'name'", ":", "name", "}", ",", "sock_dir", "=", "__opts__", "[", "'sock_dir'", "]", ",", "transport", "=", "__opts__", "[", "'transport'", "]", ")", "destroy_domain", "(", "found", "[", "0", "]", "[", "'conn'", "]", ",", "found", "[", "0", "]", "[", "'domain'", "]", ")", "__utils__", "[", "'cloud.fire_event'", "]", "(", "'event'", ",", "'destroyed instance'", ",", "'salt/cloud/{0}/destroyed'", ".", "format", "(", "name", ")", ",", "args", "=", "{", "'name'", ":", "name", "}", ",", "sock_dir", "=", "__opts__", "[", "'sock_dir'", "]", ",", "transport", "=", "__opts__", "[", "'transport'", "]", ")"], "docstring": "This function irreversibly destroys a virtual machine on the cloud provider.\n    Before doing so, it should fire an event on the Salt event bus.\n\n    The tag for this event is `salt/cloud/<vm name>/destroying`.\n    Once the virtual machine has been destroyed, another event is fired.\n    The tag for that event is `salt/cloud/<vm name>/destroyed`.\n\n    Dependencies:\n        list_nodes\n\n    @param name:\n    @type name: str\n    @param call:\n    @type call:\n    @return: True if all went well, otherwise an error message\n    @rtype: bool|str", "docstring_tokens": ["This", "function", "irreversibly", "destroys", "a", "virtual", "machine", "on", "the", "cloud", "provider", ".", "Before", "doing", "so", "it", "should", "fire", "an", "event", "on", "the", "Salt", "event", "bus", "."], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/cloud/clouds/libvirt.py#L517-L581", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/output/pprint_out.py", "func_name": "output", "original_string": "def output(data, **kwargs):  # pylint: disable=unused-argument\n    '''\n    Print out via pretty print\n    '''\n    if isinstance(data, Exception):\n        data = six.text_type(data)\n    if 'output_indent' in __opts__ and __opts__['output_indent'] >= 0:\n        return pprint.pformat(data, indent=__opts__['output_indent'])\n    return pprint.pformat(data)", "language": "python", "code": "def output(data, **kwargs):  # pylint: disable=unused-argument\n    '''\n    Print out via pretty print\n    '''\n    if isinstance(data, Exception):\n        data = six.text_type(data)\n    if 'output_indent' in __opts__ and __opts__['output_indent'] >= 0:\n        return pprint.pformat(data, indent=__opts__['output_indent'])\n    return pprint.pformat(data)", "code_tokens": ["def", "output", "(", "data", ",", "*", "*", "kwargs", ")", ":", "# pylint: disable=unused-argument", "if", "isinstance", "(", "data", ",", "Exception", ")", ":", "data", "=", "six", ".", "text_type", "(", "data", ")", "if", "'output_indent'", "in", "__opts__", "and", "__opts__", "[", "'output_indent'", "]", ">=", "0", ":", "return", "pprint", ".", "pformat", "(", "data", ",", "indent", "=", "__opts__", "[", "'output_indent'", "]", ")", "return", "pprint", ".", "pformat", "(", "data", ")"], "docstring": "Print out via pretty print", "docstring_tokens": ["Print", "out", "via", "pretty", "print"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/output/pprint_out.py#L34-L42", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/cloud/clouds/oneandone.py", "func_name": "get_size", "original_string": "def get_size(vm_):\n    '''\n    Return the VM's size object\n    '''\n    vm_size = config.get_cloud_config_value(\n        'fixed_instance_size', vm_, __opts__, default=None,\n        search_global=False\n    )\n    sizes = avail_sizes()\n\n    if not vm_size:\n        size = next((item for item in sizes if item['name'] == 'S'), None)\n        return size\n\n    size = next((item for item in sizes if item['name'] == vm_size or item['id'] == vm_size), None)\n    if size:\n        return size\n\n    raise SaltCloudNotFound(\n        'The specified size, \\'{0}\\', could not be found.'.format(vm_size)\n    )", "language": "python", "code": "def get_size(vm_):\n    '''\n    Return the VM's size object\n    '''\n    vm_size = config.get_cloud_config_value(\n        'fixed_instance_size', vm_, __opts__, default=None,\n        search_global=False\n    )\n    sizes = avail_sizes()\n\n    if not vm_size:\n        size = next((item for item in sizes if item['name'] == 'S'), None)\n        return size\n\n    size = next((item for item in sizes if item['name'] == vm_size or item['id'] == vm_size), None)\n    if size:\n        return size\n\n    raise SaltCloudNotFound(\n        'The specified size, \\'{0}\\', could not be found.'.format(vm_size)\n    )", "code_tokens": ["def", "get_size", "(", "vm_", ")", ":", "vm_size", "=", "config", ".", "get_cloud_config_value", "(", "'fixed_instance_size'", ",", "vm_", ",", "__opts__", ",", "default", "=", "None", ",", "search_global", "=", "False", ")", "sizes", "=", "avail_sizes", "(", ")", "if", "not", "vm_size", ":", "size", "=", "next", "(", "(", "item", "for", "item", "in", "sizes", "if", "item", "[", "'name'", "]", "==", "'S'", ")", ",", "None", ")", "return", "size", "size", "=", "next", "(", "(", "item", "for", "item", "in", "sizes", "if", "item", "[", "'name'", "]", "==", "vm_size", "or", "item", "[", "'id'", "]", "==", "vm_size", ")", ",", "None", ")", "if", "size", ":", "return", "size", "raise", "SaltCloudNotFound", "(", "'The specified size, \\'{0}\\', could not be found.'", ".", "format", "(", "vm_size", ")", ")"], "docstring": "Return the VM's size object", "docstring_tokens": ["Return", "the", "VM", "s", "size", "object"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/cloud/clouds/oneandone.py#L204-L224", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/cloud/clouds/oneandone.py", "func_name": "get_image", "original_string": "def get_image(vm_):\n    '''\n    Return the image object to use\n    '''\n    vm_image = config.get_cloud_config_value('image', vm_, __opts__).encode(\n        'ascii', 'salt-cloud-force-ascii'\n    )\n\n    images = avail_images()\n    for key, value in six.iteritems(images):\n        if vm_image and vm_image in (images[key]['id'], images[key]['name']):\n            return images[key]\n\n    raise SaltCloudNotFound(\n        'The specified image, \\'{0}\\', could not be found.'.format(vm_image)\n    )", "language": "python", "code": "def get_image(vm_):\n    '''\n    Return the image object to use\n    '''\n    vm_image = config.get_cloud_config_value('image', vm_, __opts__).encode(\n        'ascii', 'salt-cloud-force-ascii'\n    )\n\n    images = avail_images()\n    for key, value in six.iteritems(images):\n        if vm_image and vm_image in (images[key]['id'], images[key]['name']):\n            return images[key]\n\n    raise SaltCloudNotFound(\n        'The specified image, \\'{0}\\', could not be found.'.format(vm_image)\n    )", "code_tokens": ["def", "get_image", "(", "vm_", ")", ":", "vm_image", "=", "config", ".", "get_cloud_config_value", "(", "'image'", ",", "vm_", ",", "__opts__", ")", ".", "encode", "(", "'ascii'", ",", "'salt-cloud-force-ascii'", ")", "images", "=", "avail_images", "(", ")", "for", "key", ",", "value", "in", "six", ".", "iteritems", "(", "images", ")", ":", "if", "vm_image", "and", "vm_image", "in", "(", "images", "[", "key", "]", "[", "'id'", "]", ",", "images", "[", "key", "]", "[", "'name'", "]", ")", ":", "return", "images", "[", "key", "]", "raise", "SaltCloudNotFound", "(", "'The specified image, \\'{0}\\', could not be found.'", ".", "format", "(", "vm_image", ")", ")"], "docstring": "Return the image object to use", "docstring_tokens": ["Return", "the", "image", "object", "to", "use"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/cloud/clouds/oneandone.py#L227-L242", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/cloud/clouds/oneandone.py", "func_name": "avail_locations", "original_string": "def avail_locations(conn=None, call=None):\n    '''\n    List available locations/datacenters for 1&1\n    '''\n    if call == 'action':\n        raise SaltCloudSystemExit(\n            'The avail_locations function must be called with '\n            '-f or --function, or with the --list-locations option'\n        )\n\n    datacenters = []\n\n    if not conn:\n        conn = get_conn()\n\n    for datacenter in conn.list_datacenters():\n        datacenters.append({datacenter['country_code']: datacenter})\n\n    return {'Locations': datacenters}", "language": "python", "code": "def avail_locations(conn=None, call=None):\n    '''\n    List available locations/datacenters for 1&1\n    '''\n    if call == 'action':\n        raise SaltCloudSystemExit(\n            'The avail_locations function must be called with '\n            '-f or --function, or with the --list-locations option'\n        )\n\n    datacenters = []\n\n    if not conn:\n        conn = get_conn()\n\n    for datacenter in conn.list_datacenters():\n        datacenters.append({datacenter['country_code']: datacenter})\n\n    return {'Locations': datacenters}", "code_tokens": ["def", "avail_locations", "(", "conn", "=", "None", ",", "call", "=", "None", ")", ":", "if", "call", "==", "'action'", ":", "raise", "SaltCloudSystemExit", "(", "'The avail_locations function must be called with '", "'-f or --function, or with the --list-locations option'", ")", "datacenters", "=", "[", "]", "if", "not", "conn", ":", "conn", "=", "get_conn", "(", ")", "for", "datacenter", "in", "conn", ".", "list_datacenters", "(", ")", ":", "datacenters", ".", "append", "(", "{", "datacenter", "[", "'country_code'", "]", ":", "datacenter", "}", ")", "return", "{", "'Locations'", ":", "datacenters", "}"], "docstring": "List available locations/datacenters for 1&1", "docstring_tokens": ["List", "available", "locations", "/", "datacenters", "for", "1&1"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/cloud/clouds/oneandone.py#L245-L263", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/cloud/clouds/oneandone.py", "func_name": "create_block_storage", "original_string": "def create_block_storage(kwargs=None, call=None):\n    '''\n    Create a block storage\n    '''\n    if call == 'action':\n        raise SaltCloudSystemExit(\n            'The create_block_storage function must be called with '\n            '-f or --function'\n        )\n\n    conn = get_conn()\n\n    # Assemble the composite block storage object.\n    block_storage = _get_block_storage(kwargs)\n\n    data = conn.create_block_storage(block_storage=block_storage)\n\n    return {'BlockStorage': data}", "language": "python", "code": "def create_block_storage(kwargs=None, call=None):\n    '''\n    Create a block storage\n    '''\n    if call == 'action':\n        raise SaltCloudSystemExit(\n            'The create_block_storage function must be called with '\n            '-f or --function'\n        )\n\n    conn = get_conn()\n\n    # Assemble the composite block storage object.\n    block_storage = _get_block_storage(kwargs)\n\n    data = conn.create_block_storage(block_storage=block_storage)\n\n    return {'BlockStorage': data}", "code_tokens": ["def", "create_block_storage", "(", "kwargs", "=", "None", ",", "call", "=", "None", ")", ":", "if", "call", "==", "'action'", ":", "raise", "SaltCloudSystemExit", "(", "'The create_block_storage function must be called with '", "'-f or --function'", ")", "conn", "=", "get_conn", "(", ")", "# Assemble the composite block storage object.", "block_storage", "=", "_get_block_storage", "(", "kwargs", ")", "data", "=", "conn", ".", "create_block_storage", "(", "block_storage", "=", "block_storage", ")", "return", "{", "'BlockStorage'", ":", "data", "}"], "docstring": "Create a block storage", "docstring_tokens": ["Create", "a", "block", "storage"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/cloud/clouds/oneandone.py#L266-L283", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/cloud/clouds/oneandone.py", "func_name": "_get_block_storage", "original_string": "def _get_block_storage(kwargs):\n    '''\n    Construct a block storage instance from passed arguments\n    '''\n    if kwargs is None:\n        kwargs = {}\n\n    block_storage_name = kwargs.get('name', None)\n    block_storage_size = kwargs.get('size', None)\n    block_storage_description = kwargs.get('description', None)\n    datacenter_id = kwargs.get('datacenter_id', None)\n    server_id = kwargs.get('server_id', None)\n\n    block_storage = BlockStorage(\n        name=block_storage_name,\n        size=block_storage_size)\n\n    if block_storage_description:\n        block_storage.description = block_storage_description\n\n    if datacenter_id:\n        block_storage.datacenter_id = datacenter_id\n\n    if server_id:\n        block_storage.server_id = server_id\n\n    return block_storage", "language": "python", "code": "def _get_block_storage(kwargs):\n    '''\n    Construct a block storage instance from passed arguments\n    '''\n    if kwargs is None:\n        kwargs = {}\n\n    block_storage_name = kwargs.get('name', None)\n    block_storage_size = kwargs.get('size', None)\n    block_storage_description = kwargs.get('description', None)\n    datacenter_id = kwargs.get('datacenter_id', None)\n    server_id = kwargs.get('server_id', None)\n\n    block_storage = BlockStorage(\n        name=block_storage_name,\n        size=block_storage_size)\n\n    if block_storage_description:\n        block_storage.description = block_storage_description\n\n    if datacenter_id:\n        block_storage.datacenter_id = datacenter_id\n\n    if server_id:\n        block_storage.server_id = server_id\n\n    return block_storage", "code_tokens": ["def", "_get_block_storage", "(", "kwargs", ")", ":", "if", "kwargs", "is", "None", ":", "kwargs", "=", "{", "}", "block_storage_name", "=", "kwargs", ".", "get", "(", "'name'", ",", "None", ")", "block_storage_size", "=", "kwargs", ".", "get", "(", "'size'", ",", "None", ")", "block_storage_description", "=", "kwargs", ".", "get", "(", "'description'", ",", "None", ")", "datacenter_id", "=", "kwargs", ".", "get", "(", "'datacenter_id'", ",", "None", ")", "server_id", "=", "kwargs", ".", "get", "(", "'server_id'", ",", "None", ")", "block_storage", "=", "BlockStorage", "(", "name", "=", "block_storage_name", ",", "size", "=", "block_storage_size", ")", "if", "block_storage_description", ":", "block_storage", ".", "description", "=", "block_storage_description", "if", "datacenter_id", ":", "block_storage", ".", "datacenter_id", "=", "datacenter_id", "if", "server_id", ":", "block_storage", ".", "server_id", "=", "server_id", "return", "block_storage"], "docstring": "Construct a block storage instance from passed arguments", "docstring_tokens": ["Construct", "a", "block", "storage", "instance", "from", "passed", "arguments"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/cloud/clouds/oneandone.py#L286-L312", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/cloud/clouds/oneandone.py", "func_name": "_get_ssh_key", "original_string": "def _get_ssh_key(kwargs):\n    '''\n    Construct an SshKey instance from passed arguments\n    '''\n    ssh_key_name = kwargs.get('name', None)\n    ssh_key_description = kwargs.get('description', None)\n    public_key = kwargs.get('public_key', None)\n\n    return SshKey(\n        name=ssh_key_name,\n        description=ssh_key_description,\n        public_key=public_key\n    )", "language": "python", "code": "def _get_ssh_key(kwargs):\n    '''\n    Construct an SshKey instance from passed arguments\n    '''\n    ssh_key_name = kwargs.get('name', None)\n    ssh_key_description = kwargs.get('description', None)\n    public_key = kwargs.get('public_key', None)\n\n    return SshKey(\n        name=ssh_key_name,\n        description=ssh_key_description,\n        public_key=public_key\n    )", "code_tokens": ["def", "_get_ssh_key", "(", "kwargs", ")", ":", "ssh_key_name", "=", "kwargs", ".", "get", "(", "'name'", ",", "None", ")", "ssh_key_description", "=", "kwargs", ".", "get", "(", "'description'", ",", "None", ")", "public_key", "=", "kwargs", ".", "get", "(", "'public_key'", ",", "None", ")", "return", "SshKey", "(", "name", "=", "ssh_key_name", ",", "description", "=", "ssh_key_description", ",", "public_key", "=", "public_key", ")"], "docstring": "Construct an SshKey instance from passed arguments", "docstring_tokens": ["Construct", "an", "SshKey", "instance", "from", "passed", "arguments"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/cloud/clouds/oneandone.py#L315-L327", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/cloud/clouds/oneandone.py", "func_name": "create_ssh_key", "original_string": "def create_ssh_key(kwargs=None, call=None):\n    '''\n    Create an ssh key\n    '''\n    if call == 'action':\n        raise SaltCloudSystemExit(\n            'The create_ssh_key function must be called with '\n            '-f or --function'\n        )\n\n    conn = get_conn()\n\n    # Assemble the composite SshKey object.\n    ssh_key = _get_ssh_key(kwargs)\n\n    data = conn.create_ssh_key(ssh_key=ssh_key)\n\n    return {'SshKey': data}", "language": "python", "code": "def create_ssh_key(kwargs=None, call=None):\n    '''\n    Create an ssh key\n    '''\n    if call == 'action':\n        raise SaltCloudSystemExit(\n            'The create_ssh_key function must be called with '\n            '-f or --function'\n        )\n\n    conn = get_conn()\n\n    # Assemble the composite SshKey object.\n    ssh_key = _get_ssh_key(kwargs)\n\n    data = conn.create_ssh_key(ssh_key=ssh_key)\n\n    return {'SshKey': data}", "code_tokens": ["def", "create_ssh_key", "(", "kwargs", "=", "None", ",", "call", "=", "None", ")", ":", "if", "call", "==", "'action'", ":", "raise", "SaltCloudSystemExit", "(", "'The create_ssh_key function must be called with '", "'-f or --function'", ")", "conn", "=", "get_conn", "(", ")", "# Assemble the composite SshKey object.", "ssh_key", "=", "_get_ssh_key", "(", "kwargs", ")", "data", "=", "conn", ".", "create_ssh_key", "(", "ssh_key", "=", "ssh_key", ")", "return", "{", "'SshKey'", ":", "data", "}"], "docstring": "Create an ssh key", "docstring_tokens": ["Create", "an", "ssh", "key"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/cloud/clouds/oneandone.py#L330-L347", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/cloud/clouds/oneandone.py", "func_name": "_get_firewall_policy", "original_string": "def _get_firewall_policy(kwargs):\n    '''\n    Construct FirewallPolicy and FirewallPolicy instances from passed arguments\n    '''\n    fp_name = kwargs.get('name', None)\n    fp_description = kwargs.get('description', None)\n    firewallPolicy = FirewallPolicy(\n        name=fp_name,\n        description=fp_description\n    )\n\n    fpr_json = kwargs.get('rules', None)\n    jdata = json.loads(fpr_json)\n    rules = []\n    for fwpr in jdata:\n        firewallPolicyRule = FirewallPolicyRule()\n        if 'protocol' in fwpr:\n            firewallPolicyRule.rule_set['protocol'] = fwpr['protocol']\n        if 'port_from' in fwpr:\n            firewallPolicyRule.rule_set['port_from'] = fwpr['port_from']\n        if 'port_to' in fwpr:\n            firewallPolicyRule.rule_set['port_to'] = fwpr['port_to']\n        if 'source' in fwpr:\n            firewallPolicyRule.rule_set['source'] = fwpr['source']\n        if 'action' in fwpr:\n            firewallPolicyRule.rule_set['action'] = fwpr['action']\n        if 'description' in fwpr:\n            firewallPolicyRule.rule_set['description'] = fwpr['description']\n        if 'port' in fwpr:\n            firewallPolicyRule.rule_set['port'] = fwpr['port']\n        rules.append(firewallPolicyRule)\n\n    return {'firewall_policy': firewallPolicy, 'firewall_policy_rules': rules}", "language": "python", "code": "def _get_firewall_policy(kwargs):\n    '''\n    Construct FirewallPolicy and FirewallPolicy instances from passed arguments\n    '''\n    fp_name = kwargs.get('name', None)\n    fp_description = kwargs.get('description', None)\n    firewallPolicy = FirewallPolicy(\n        name=fp_name,\n        description=fp_description\n    )\n\n    fpr_json = kwargs.get('rules', None)\n    jdata = json.loads(fpr_json)\n    rules = []\n    for fwpr in jdata:\n        firewallPolicyRule = FirewallPolicyRule()\n        if 'protocol' in fwpr:\n            firewallPolicyRule.rule_set['protocol'] = fwpr['protocol']\n        if 'port_from' in fwpr:\n            firewallPolicyRule.rule_set['port_from'] = fwpr['port_from']\n        if 'port_to' in fwpr:\n            firewallPolicyRule.rule_set['port_to'] = fwpr['port_to']\n        if 'source' in fwpr:\n            firewallPolicyRule.rule_set['source'] = fwpr['source']\n        if 'action' in fwpr:\n            firewallPolicyRule.rule_set['action'] = fwpr['action']\n        if 'description' in fwpr:\n            firewallPolicyRule.rule_set['description'] = fwpr['description']\n        if 'port' in fwpr:\n            firewallPolicyRule.rule_set['port'] = fwpr['port']\n        rules.append(firewallPolicyRule)\n\n    return {'firewall_policy': firewallPolicy, 'firewall_policy_rules': rules}", "code_tokens": ["def", "_get_firewall_policy", "(", "kwargs", ")", ":", "fp_name", "=", "kwargs", ".", "get", "(", "'name'", ",", "None", ")", "fp_description", "=", "kwargs", ".", "get", "(", "'description'", ",", "None", ")", "firewallPolicy", "=", "FirewallPolicy", "(", "name", "=", "fp_name", ",", "description", "=", "fp_description", ")", "fpr_json", "=", "kwargs", ".", "get", "(", "'rules'", ",", "None", ")", "jdata", "=", "json", ".", "loads", "(", "fpr_json", ")", "rules", "=", "[", "]", "for", "fwpr", "in", "jdata", ":", "firewallPolicyRule", "=", "FirewallPolicyRule", "(", ")", "if", "'protocol'", "in", "fwpr", ":", "firewallPolicyRule", ".", "rule_set", "[", "'protocol'", "]", "=", "fwpr", "[", "'protocol'", "]", "if", "'port_from'", "in", "fwpr", ":", "firewallPolicyRule", ".", "rule_set", "[", "'port_from'", "]", "=", "fwpr", "[", "'port_from'", "]", "if", "'port_to'", "in", "fwpr", ":", "firewallPolicyRule", ".", "rule_set", "[", "'port_to'", "]", "=", "fwpr", "[", "'port_to'", "]", "if", "'source'", "in", "fwpr", ":", "firewallPolicyRule", ".", "rule_set", "[", "'source'", "]", "=", "fwpr", "[", "'source'", "]", "if", "'action'", "in", "fwpr", ":", "firewallPolicyRule", ".", "rule_set", "[", "'action'", "]", "=", "fwpr", "[", "'action'", "]", "if", "'description'", "in", "fwpr", ":", "firewallPolicyRule", ".", "rule_set", "[", "'description'", "]", "=", "fwpr", "[", "'description'", "]", "if", "'port'", "in", "fwpr", ":", "firewallPolicyRule", ".", "rule_set", "[", "'port'", "]", "=", "fwpr", "[", "'port'", "]", "rules", ".", "append", "(", "firewallPolicyRule", ")", "return", "{", "'firewall_policy'", ":", "firewallPolicy", ",", "'firewall_policy_rules'", ":", "rules", "}"], "docstring": "Construct FirewallPolicy and FirewallPolicy instances from passed arguments", "docstring_tokens": ["Construct", "FirewallPolicy", "and", "FirewallPolicy", "instances", "from", "passed", "arguments"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/cloud/clouds/oneandone.py#L350-L382", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/cloud/clouds/oneandone.py", "func_name": "create_firewall_policy", "original_string": "def create_firewall_policy(kwargs=None, call=None):\n    '''\n    Create a firewall policy\n    '''\n    if call == 'action':\n        raise SaltCloudSystemExit(\n            'The create_firewall_policy function must be called with '\n            '-f or --function'\n        )\n\n    conn = get_conn()\n\n    # Assemble the composite FirewallPolicy and FirewallPolicyRule[] objects.\n    getFwpResult = _get_firewall_policy(kwargs)\n\n    data = conn.create_firewall_policy(\n        firewall_policy=getFwpResult['firewall_policy'],\n        firewall_policy_rules=getFwpResult['firewall_policy_rules']\n    )\n\n    return {'FirewallPolicy': data}", "language": "python", "code": "def create_firewall_policy(kwargs=None, call=None):\n    '''\n    Create a firewall policy\n    '''\n    if call == 'action':\n        raise SaltCloudSystemExit(\n            'The create_firewall_policy function must be called with '\n            '-f or --function'\n        )\n\n    conn = get_conn()\n\n    # Assemble the composite FirewallPolicy and FirewallPolicyRule[] objects.\n    getFwpResult = _get_firewall_policy(kwargs)\n\n    data = conn.create_firewall_policy(\n        firewall_policy=getFwpResult['firewall_policy'],\n        firewall_policy_rules=getFwpResult['firewall_policy_rules']\n    )\n\n    return {'FirewallPolicy': data}", "code_tokens": ["def", "create_firewall_policy", "(", "kwargs", "=", "None", ",", "call", "=", "None", ")", ":", "if", "call", "==", "'action'", ":", "raise", "SaltCloudSystemExit", "(", "'The create_firewall_policy function must be called with '", "'-f or --function'", ")", "conn", "=", "get_conn", "(", ")", "# Assemble the composite FirewallPolicy and FirewallPolicyRule[] objects.", "getFwpResult", "=", "_get_firewall_policy", "(", "kwargs", ")", "data", "=", "conn", ".", "create_firewall_policy", "(", "firewall_policy", "=", "getFwpResult", "[", "'firewall_policy'", "]", ",", "firewall_policy_rules", "=", "getFwpResult", "[", "'firewall_policy_rules'", "]", ")", "return", "{", "'FirewallPolicy'", ":", "data", "}"], "docstring": "Create a firewall policy", "docstring_tokens": ["Create", "a", "firewall", "policy"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/cloud/clouds/oneandone.py#L385-L405", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/cloud/clouds/oneandone.py", "func_name": "avail_images", "original_string": "def avail_images(conn=None, call=None):\n    '''\n    Return a list of the server appliances that are on the provider\n    '''\n    if call == 'action':\n        raise SaltCloudSystemExit(\n            'The avail_images function must be called with '\n            '-f or --function, or with the --list-images option'\n        )\n\n    if not conn:\n        conn = get_conn()\n\n    ret = {}\n\n    for appliance in conn.list_appliances():\n        ret[appliance['name']] = appliance\n\n    return ret", "language": "python", "code": "def avail_images(conn=None, call=None):\n    '''\n    Return a list of the server appliances that are on the provider\n    '''\n    if call == 'action':\n        raise SaltCloudSystemExit(\n            'The avail_images function must be called with '\n            '-f or --function, or with the --list-images option'\n        )\n\n    if not conn:\n        conn = get_conn()\n\n    ret = {}\n\n    for appliance in conn.list_appliances():\n        ret[appliance['name']] = appliance\n\n    return ret", "code_tokens": ["def", "avail_images", "(", "conn", "=", "None", ",", "call", "=", "None", ")", ":", "if", "call", "==", "'action'", ":", "raise", "SaltCloudSystemExit", "(", "'The avail_images function must be called with '", "'-f or --function, or with the --list-images option'", ")", "if", "not", "conn", ":", "conn", "=", "get_conn", "(", ")", "ret", "=", "{", "}", "for", "appliance", "in", "conn", ".", "list_appliances", "(", ")", ":", "ret", "[", "appliance", "[", "'name'", "]", "]", "=", "appliance", "return", "ret"], "docstring": "Return a list of the server appliances that are on the provider", "docstring_tokens": ["Return", "a", "list", "of", "the", "server", "appliances", "that", "are", "on", "the", "provider"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/cloud/clouds/oneandone.py#L408-L426", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/cloud/clouds/oneandone.py", "func_name": "avail_baremetal_images", "original_string": "def avail_baremetal_images(conn=None, call=None):\n    '''\n    Return a list of the baremetal server appliances that are on the provider\n    '''\n    if call == 'action':\n        raise SaltCloudSystemExit(\n            'The avail_baremetal_images function must be called with '\n            '-f or --function'\n        )\n\n    if not conn:\n        conn = get_conn()\n\n    ret = {}\n\n    for appliance in conn.list_appliances(q='BAREMETAL'):\n        ret[appliance['name']] = appliance\n\n    return ret", "language": "python", "code": "def avail_baremetal_images(conn=None, call=None):\n    '''\n    Return a list of the baremetal server appliances that are on the provider\n    '''\n    if call == 'action':\n        raise SaltCloudSystemExit(\n            'The avail_baremetal_images function must be called with '\n            '-f or --function'\n        )\n\n    if not conn:\n        conn = get_conn()\n\n    ret = {}\n\n    for appliance in conn.list_appliances(q='BAREMETAL'):\n        ret[appliance['name']] = appliance\n\n    return ret", "code_tokens": ["def", "avail_baremetal_images", "(", "conn", "=", "None", ",", "call", "=", "None", ")", ":", "if", "call", "==", "'action'", ":", "raise", "SaltCloudSystemExit", "(", "'The avail_baremetal_images function must be called with '", "'-f or --function'", ")", "if", "not", "conn", ":", "conn", "=", "get_conn", "(", ")", "ret", "=", "{", "}", "for", "appliance", "in", "conn", ".", "list_appliances", "(", "q", "=", "'BAREMETAL'", ")", ":", "ret", "[", "appliance", "[", "'name'", "]", "]", "=", "appliance", "return", "ret"], "docstring": "Return a list of the baremetal server appliances that are on the provider", "docstring_tokens": ["Return", "a", "list", "of", "the", "baremetal", "server", "appliances", "that", "are", "on", "the", "provider"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/cloud/clouds/oneandone.py#L429-L447", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/cloud/clouds/oneandone.py", "func_name": "avail_sizes", "original_string": "def avail_sizes(call=None):\n    '''\n    Return a dict of all available VM sizes on the cloud provider with\n    relevant data.\n    '''\n    if call == 'action':\n        raise SaltCloudSystemExit(\n            'The avail_sizes function must be called with '\n            '-f or --function, or with the --list-sizes option'\n        )\n\n    conn = get_conn()\n\n    sizes = conn.fixed_server_flavors()\n\n    return sizes", "language": "python", "code": "def avail_sizes(call=None):\n    '''\n    Return a dict of all available VM sizes on the cloud provider with\n    relevant data.\n    '''\n    if call == 'action':\n        raise SaltCloudSystemExit(\n            'The avail_sizes function must be called with '\n            '-f or --function, or with the --list-sizes option'\n        )\n\n    conn = get_conn()\n\n    sizes = conn.fixed_server_flavors()\n\n    return sizes", "code_tokens": ["def", "avail_sizes", "(", "call", "=", "None", ")", ":", "if", "call", "==", "'action'", ":", "raise", "SaltCloudSystemExit", "(", "'The avail_sizes function must be called with '", "'-f or --function, or with the --list-sizes option'", ")", "conn", "=", "get_conn", "(", ")", "sizes", "=", "conn", ".", "fixed_server_flavors", "(", ")", "return", "sizes"], "docstring": "Return a dict of all available VM sizes on the cloud provider with\n    relevant data.", "docstring_tokens": ["Return", "a", "dict", "of", "all", "available", "VM", "sizes", "on", "the", "cloud", "provider", "with", "relevant", "data", "."], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/cloud/clouds/oneandone.py#L450-L465", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/cloud/clouds/oneandone.py", "func_name": "baremetal_models", "original_string": "def baremetal_models(call=None):\n    '''\n    Return a dict of all available baremetal models with relevant data.\n    '''\n    if call == 'action':\n        raise SaltCloudSystemExit(\n            'The baremetal_models function must be called with '\n            '-f or --function'\n        )\n\n    conn = get_conn()\n\n    bmodels = conn.list_baremetal_models()\n\n    return bmodels", "language": "python", "code": "def baremetal_models(call=None):\n    '''\n    Return a dict of all available baremetal models with relevant data.\n    '''\n    if call == 'action':\n        raise SaltCloudSystemExit(\n            'The baremetal_models function must be called with '\n            '-f or --function'\n        )\n\n    conn = get_conn()\n\n    bmodels = conn.list_baremetal_models()\n\n    return bmodels", "code_tokens": ["def", "baremetal_models", "(", "call", "=", "None", ")", ":", "if", "call", "==", "'action'", ":", "raise", "SaltCloudSystemExit", "(", "'The baremetal_models function must be called with '", "'-f or --function'", ")", "conn", "=", "get_conn", "(", ")", "bmodels", "=", "conn", ".", "list_baremetal_models", "(", ")", "return", "bmodels"], "docstring": "Return a dict of all available baremetal models with relevant data.", "docstring_tokens": ["Return", "a", "dict", "of", "all", "available", "baremetal", "models", "with", "relevant", "data", "."], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/cloud/clouds/oneandone.py#L468-L482", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/cloud/clouds/oneandone.py", "func_name": "list_nodes", "original_string": "def list_nodes(conn=None, call=None):\n    '''\n    Return a list of VMs that are on the provider\n    '''\n    if call == 'action':\n        raise SaltCloudSystemExit(\n            'The list_nodes function must be called with -f or --function.'\n        )\n\n    if not conn:\n        conn = get_conn()\n\n    ret = {}\n    nodes = conn.list_servers()\n\n    for node in nodes:\n        public_ips = []\n        private_ips = []\n        ret = {}\n\n        size = node.get('hardware').get('fixed_instance_size_id', 'Custom size')\n\n        if node.get('private_networks'):\n            for private_ip in node['private_networks']:\n                private_ips.append(private_ip)\n\n        if node.get('ips'):\n            for public_ip in node['ips']:\n                public_ips.append(public_ip['ip'])\n\n        server = {\n            'id': node['id'],\n            'image': node['image']['id'],\n            'size': size,\n            'state': node['status']['state'],\n            'private_ips': private_ips,\n            'public_ips': public_ips\n        }\n        ret[node['name']] = server\n\n    return ret", "language": "python", "code": "def list_nodes(conn=None, call=None):\n    '''\n    Return a list of VMs that are on the provider\n    '''\n    if call == 'action':\n        raise SaltCloudSystemExit(\n            'The list_nodes function must be called with -f or --function.'\n        )\n\n    if not conn:\n        conn = get_conn()\n\n    ret = {}\n    nodes = conn.list_servers()\n\n    for node in nodes:\n        public_ips = []\n        private_ips = []\n        ret = {}\n\n        size = node.get('hardware').get('fixed_instance_size_id', 'Custom size')\n\n        if node.get('private_networks'):\n            for private_ip in node['private_networks']:\n                private_ips.append(private_ip)\n\n        if node.get('ips'):\n            for public_ip in node['ips']:\n                public_ips.append(public_ip['ip'])\n\n        server = {\n            'id': node['id'],\n            'image': node['image']['id'],\n            'size': size,\n            'state': node['status']['state'],\n            'private_ips': private_ips,\n            'public_ips': public_ips\n        }\n        ret[node['name']] = server\n\n    return ret", "code_tokens": ["def", "list_nodes", "(", "conn", "=", "None", ",", "call", "=", "None", ")", ":", "if", "call", "==", "'action'", ":", "raise", "SaltCloudSystemExit", "(", "'The list_nodes function must be called with -f or --function.'", ")", "if", "not", "conn", ":", "conn", "=", "get_conn", "(", ")", "ret", "=", "{", "}", "nodes", "=", "conn", ".", "list_servers", "(", ")", "for", "node", "in", "nodes", ":", "public_ips", "=", "[", "]", "private_ips", "=", "[", "]", "ret", "=", "{", "}", "size", "=", "node", ".", "get", "(", "'hardware'", ")", ".", "get", "(", "'fixed_instance_size_id'", ",", "'Custom size'", ")", "if", "node", ".", "get", "(", "'private_networks'", ")", ":", "for", "private_ip", "in", "node", "[", "'private_networks'", "]", ":", "private_ips", ".", "append", "(", "private_ip", ")", "if", "node", ".", "get", "(", "'ips'", ")", ":", "for", "public_ip", "in", "node", "[", "'ips'", "]", ":", "public_ips", ".", "append", "(", "public_ip", "[", "'ip'", "]", ")", "server", "=", "{", "'id'", ":", "node", "[", "'id'", "]", ",", "'image'", ":", "node", "[", "'image'", "]", "[", "'id'", "]", ",", "'size'", ":", "size", ",", "'state'", ":", "node", "[", "'status'", "]", "[", "'state'", "]", ",", "'private_ips'", ":", "private_ips", ",", "'public_ips'", ":", "public_ips", "}", "ret", "[", "node", "[", "'name'", "]", "]", "=", "server", "return", "ret"], "docstring": "Return a list of VMs that are on the provider", "docstring_tokens": ["Return", "a", "list", "of", "VMs", "that", "are", "on", "the", "provider"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/cloud/clouds/oneandone.py#L499-L539", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/cloud/clouds/oneandone.py", "func_name": "list_nodes_full", "original_string": "def list_nodes_full(conn=None, call=None):\n    '''\n    Return a list of the VMs that are on the provider, with all fields\n    '''\n    if call == 'action':\n        raise SaltCloudSystemExit(\n            'The list_nodes_full function must be called with -f or '\n            '--function.'\n        )\n\n    if not conn:\n        conn = get_conn()\n\n    ret = {}\n    nodes = conn.list_servers()\n\n    for node in nodes:\n        ret[node['name']] = node\n\n    return ret", "language": "python", "code": "def list_nodes_full(conn=None, call=None):\n    '''\n    Return a list of the VMs that are on the provider, with all fields\n    '''\n    if call == 'action':\n        raise SaltCloudSystemExit(\n            'The list_nodes_full function must be called with -f or '\n            '--function.'\n        )\n\n    if not conn:\n        conn = get_conn()\n\n    ret = {}\n    nodes = conn.list_servers()\n\n    for node in nodes:\n        ret[node['name']] = node\n\n    return ret", "code_tokens": ["def", "list_nodes_full", "(", "conn", "=", "None", ",", "call", "=", "None", ")", ":", "if", "call", "==", "'action'", ":", "raise", "SaltCloudSystemExit", "(", "'The list_nodes_full function must be called with -f or '", "'--function.'", ")", "if", "not", "conn", ":", "conn", "=", "get_conn", "(", ")", "ret", "=", "{", "}", "nodes", "=", "conn", ".", "list_servers", "(", ")", "for", "node", "in", "nodes", ":", "ret", "[", "node", "[", "'name'", "]", "]", "=", "node", "return", "ret"], "docstring": "Return a list of the VMs that are on the provider, with all fields", "docstring_tokens": ["Return", "a", "list", "of", "the", "VMs", "that", "are", "on", "the", "provider", "with", "all", "fields"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/cloud/clouds/oneandone.py#L542-L561", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/cloud/clouds/oneandone.py", "func_name": "_get_server", "original_string": "def _get_server(vm_):\n    '''\n    Construct server instance from cloud profile config\n    '''\n    description = config.get_cloud_config_value(\n        'description', vm_, __opts__, default=None,\n        search_global=False\n    )\n\n    ssh_key = load_public_key(vm_)\n\n    server_type = config.get_cloud_config_value(\n        'server_type', vm_, __opts__, default='cloud',\n        search_global=False\n    )\n    vcore = None\n    cores_per_processor = None\n    ram = None\n    fixed_instance_size_id = None\n    baremetal_model_id = None\n\n    if 'fixed_instance_size' in vm_:\n        fixed_instance_size = get_size(vm_)\n        fixed_instance_size_id = fixed_instance_size['id']\n    elif 'vm_core' in vm_ and 'cores_per_processor' in vm_ and 'ram' in vm_ and 'hdds' in vm_:\n        vcore = config.get_cloud_config_value(\n            'vcore', vm_, __opts__, default=None,\n            search_global=False\n        )\n        cores_per_processor = config.get_cloud_config_value(\n            'cores_per_processor', vm_, __opts__, default=None,\n            search_global=False\n        )\n        ram = config.get_cloud_config_value(\n            'ram', vm_, __opts__, default=None,\n            search_global=False\n        )\n    elif 'baremetal_model_id' in vm_ and server_type == 'baremetal':\n        baremetal_model_id = config.get_cloud_config_value(\n            'baremetal_model_id', vm_, __opts__, default=None,\n            search_global=False\n        )\n    else:\n        raise SaltCloudConfigError(\"'fixed_instance_size' or 'vcore', \"\n                                   \"'cores_per_processor', 'ram', and 'hdds' \"\n                                   \"must be provided for 'cloud' server. \"\n                                   \"For 'baremetal' server, 'baremetal_model_id'\"\n                                   \"must be provided.\")\n\n    appliance_id = config.get_cloud_config_value(\n        'appliance_id', vm_, __opts__, default=None,\n        search_global=False\n    )\n\n    password = config.get_cloud_config_value(\n        'password', vm_, __opts__, default=None,\n        search_global=False\n    )\n\n    firewall_policy_id = config.get_cloud_config_value(\n        'firewall_policy_id', vm_, __opts__, default=None,\n        search_global=False\n    )\n\n    ip_id = config.get_cloud_config_value(\n        'ip_id', vm_, __opts__, default=None,\n        search_global=False\n    )\n\n    load_balancer_id = config.get_cloud_config_value(\n        'load_balancer_id', vm_, __opts__, default=None,\n        search_global=False\n    )\n\n    monitoring_policy_id = config.get_cloud_config_value(\n        'monitoring_policy_id', vm_, __opts__, default=None,\n        search_global=False\n    )\n\n    datacenter_id = config.get_cloud_config_value(\n        'datacenter_id', vm_, __opts__, default=None,\n        search_global=False\n    )\n\n    private_network_id = config.get_cloud_config_value(\n        'private_network_id', vm_, __opts__, default=None,\n        search_global=False\n    )\n\n    power_on = config.get_cloud_config_value(\n        'power_on', vm_, __opts__, default=True,\n        search_global=False\n    )\n\n    public_key = config.get_cloud_config_value(\n        'public_key_ids', vm_, __opts__, default=None,\n        search_global=False\n    )\n\n    # Contruct server object\n    return Server(\n        name=vm_['name'],\n        description=description,\n        fixed_instance_size_id=fixed_instance_size_id,\n        vcore=vcore,\n        cores_per_processor=cores_per_processor,\n        ram=ram,\n        appliance_id=appliance_id,\n        password=password,\n        power_on=power_on,\n        firewall_policy_id=firewall_policy_id,\n        ip_id=ip_id,\n        load_balancer_id=load_balancer_id,\n        monitoring_policy_id=monitoring_policy_id,\n        datacenter_id=datacenter_id,\n        rsa_key=ssh_key,\n        private_network_id=private_network_id,\n        public_key=public_key,\n        server_type=server_type,\n        baremetal_model_id=baremetal_model_id\n    )", "language": "python", "code": "def _get_server(vm_):\n    '''\n    Construct server instance from cloud profile config\n    '''\n    description = config.get_cloud_config_value(\n        'description', vm_, __opts__, default=None,\n        search_global=False\n    )\n\n    ssh_key = load_public_key(vm_)\n\n    server_type = config.get_cloud_config_value(\n        'server_type', vm_, __opts__, default='cloud',\n        search_global=False\n    )\n    vcore = None\n    cores_per_processor = None\n    ram = None\n    fixed_instance_size_id = None\n    baremetal_model_id = None\n\n    if 'fixed_instance_size' in vm_:\n        fixed_instance_size = get_size(vm_)\n        fixed_instance_size_id = fixed_instance_size['id']\n    elif 'vm_core' in vm_ and 'cores_per_processor' in vm_ and 'ram' in vm_ and 'hdds' in vm_:\n        vcore = config.get_cloud_config_value(\n            'vcore', vm_, __opts__, default=None,\n            search_global=False\n        )\n        cores_per_processor = config.get_cloud_config_value(\n            'cores_per_processor', vm_, __opts__, default=None,\n            search_global=False\n        )\n        ram = config.get_cloud_config_value(\n            'ram', vm_, __opts__, default=None,\n            search_global=False\n        )\n    elif 'baremetal_model_id' in vm_ and server_type == 'baremetal':\n        baremetal_model_id = config.get_cloud_config_value(\n            'baremetal_model_id', vm_, __opts__, default=None,\n            search_global=False\n        )\n    else:\n        raise SaltCloudConfigError(\"'fixed_instance_size' or 'vcore', \"\n                                   \"'cores_per_processor', 'ram', and 'hdds' \"\n                                   \"must be provided for 'cloud' server. \"\n                                   \"For 'baremetal' server, 'baremetal_model_id'\"\n                                   \"must be provided.\")\n\n    appliance_id = config.get_cloud_config_value(\n        'appliance_id', vm_, __opts__, default=None,\n        search_global=False\n    )\n\n    password = config.get_cloud_config_value(\n        'password', vm_, __opts__, default=None,\n        search_global=False\n    )\n\n    firewall_policy_id = config.get_cloud_config_value(\n        'firewall_policy_id', vm_, __opts__, default=None,\n        search_global=False\n    )\n\n    ip_id = config.get_cloud_config_value(\n        'ip_id', vm_, __opts__, default=None,\n        search_global=False\n    )\n\n    load_balancer_id = config.get_cloud_config_value(\n        'load_balancer_id', vm_, __opts__, default=None,\n        search_global=False\n    )\n\n    monitoring_policy_id = config.get_cloud_config_value(\n        'monitoring_policy_id', vm_, __opts__, default=None,\n        search_global=False\n    )\n\n    datacenter_id = config.get_cloud_config_value(\n        'datacenter_id', vm_, __opts__, default=None,\n        search_global=False\n    )\n\n    private_network_id = config.get_cloud_config_value(\n        'private_network_id', vm_, __opts__, default=None,\n        search_global=False\n    )\n\n    power_on = config.get_cloud_config_value(\n        'power_on', vm_, __opts__, default=True,\n        search_global=False\n    )\n\n    public_key = config.get_cloud_config_value(\n        'public_key_ids', vm_, __opts__, default=None,\n        search_global=False\n    )\n\n    # Contruct server object\n    return Server(\n        name=vm_['name'],\n        description=description,\n        fixed_instance_size_id=fixed_instance_size_id,\n        vcore=vcore,\n        cores_per_processor=cores_per_processor,\n        ram=ram,\n        appliance_id=appliance_id,\n        password=password,\n        power_on=power_on,\n        firewall_policy_id=firewall_policy_id,\n        ip_id=ip_id,\n        load_balancer_id=load_balancer_id,\n        monitoring_policy_id=monitoring_policy_id,\n        datacenter_id=datacenter_id,\n        rsa_key=ssh_key,\n        private_network_id=private_network_id,\n        public_key=public_key,\n        server_type=server_type,\n        baremetal_model_id=baremetal_model_id\n    )", "code_tokens": ["def", "_get_server", "(", "vm_", ")", ":", "description", "=", "config", ".", "get_cloud_config_value", "(", "'description'", ",", "vm_", ",", "__opts__", ",", "default", "=", "None", ",", "search_global", "=", "False", ")", "ssh_key", "=", "load_public_key", "(", "vm_", ")", "server_type", "=", "config", ".", "get_cloud_config_value", "(", "'server_type'", ",", "vm_", ",", "__opts__", ",", "default", "=", "'cloud'", ",", "search_global", "=", "False", ")", "vcore", "=", "None", "cores_per_processor", "=", "None", "ram", "=", "None", "fixed_instance_size_id", "=", "None", "baremetal_model_id", "=", "None", "if", "'fixed_instance_size'", "in", "vm_", ":", "fixed_instance_size", "=", "get_size", "(", "vm_", ")", "fixed_instance_size_id", "=", "fixed_instance_size", "[", "'id'", "]", "elif", "'vm_core'", "in", "vm_", "and", "'cores_per_processor'", "in", "vm_", "and", "'ram'", "in", "vm_", "and", "'hdds'", "in", "vm_", ":", "vcore", "=", "config", ".", "get_cloud_config_value", "(", "'vcore'", ",", "vm_", ",", "__opts__", ",", "default", "=", "None", ",", "search_global", "=", "False", ")", "cores_per_processor", "=", "config", ".", "get_cloud_config_value", "(", "'cores_per_processor'", ",", "vm_", ",", "__opts__", ",", "default", "=", "None", ",", "search_global", "=", "False", ")", "ram", "=", "config", ".", "get_cloud_config_value", "(", "'ram'", ",", "vm_", ",", "__opts__", ",", "default", "=", "None", ",", "search_global", "=", "False", ")", "elif", "'baremetal_model_id'", "in", "vm_", "and", "server_type", "==", "'baremetal'", ":", "baremetal_model_id", "=", "config", ".", "get_cloud_config_value", "(", "'baremetal_model_id'", ",", "vm_", ",", "__opts__", ",", "default", "=", "None", ",", "search_global", "=", "False", ")", "else", ":", "raise", "SaltCloudConfigError", "(", "\"'fixed_instance_size' or 'vcore', \"", "\"'cores_per_processor', 'ram', and 'hdds' \"", "\"must be provided for 'cloud' server. \"", "\"For 'baremetal' server, 'baremetal_model_id'\"", "\"must be provided.\"", ")", "appliance_id", "=", "config", ".", "get_cloud_config_value", "(", "'appliance_id'", ",", "vm_", ",", "__opts__", ",", "default", "=", "None", ",", "search_global", "=", "False", ")", "password", "=", "config", ".", "get_cloud_config_value", "(", "'password'", ",", "vm_", ",", "__opts__", ",", "default", "=", "None", ",", "search_global", "=", "False", ")", "firewall_policy_id", "=", "config", ".", "get_cloud_config_value", "(", "'firewall_policy_id'", ",", "vm_", ",", "__opts__", ",", "default", "=", "None", ",", "search_global", "=", "False", ")", "ip_id", "=", "config", ".", "get_cloud_config_value", "(", "'ip_id'", ",", "vm_", ",", "__opts__", ",", "default", "=", "None", ",", "search_global", "=", "False", ")", "load_balancer_id", "=", "config", ".", "get_cloud_config_value", "(", "'load_balancer_id'", ",", "vm_", ",", "__opts__", ",", "default", "=", "None", ",", "search_global", "=", "False", ")", "monitoring_policy_id", "=", "config", ".", "get_cloud_config_value", "(", "'monitoring_policy_id'", ",", "vm_", ",", "__opts__", ",", "default", "=", "None", ",", "search_global", "=", "False", ")", "datacenter_id", "=", "config", ".", "get_cloud_config_value", "(", "'datacenter_id'", ",", "vm_", ",", "__opts__", ",", "default", "=", "None", ",", "search_global", "=", "False", ")", "private_network_id", "=", "config", ".", "get_cloud_config_value", "(", "'private_network_id'", ",", "vm_", ",", "__opts__", ",", "default", "=", "None", ",", "search_global", "=", "False", ")", "power_on", "=", "config", ".", "get_cloud_config_value", "(", "'power_on'", ",", "vm_", ",", "__opts__", ",", "default", "=", "True", ",", "search_global", "=", "False", ")", "public_key", "=", "config", ".", "get_cloud_config_value", "(", "'public_key_ids'", ",", "vm_", ",", "__opts__", ",", "default", "=", "None", ",", "search_global", "=", "False", ")", "# Contruct server object", "return", "Server", "(", "name", "=", "vm_", "[", "'name'", "]", ",", "description", "=", "description", ",", "fixed_instance_size_id", "=", "fixed_instance_size_id", ",", "vcore", "=", "vcore", ",", "cores_per_processor", "=", "cores_per_processor", ",", "ram", "=", "ram", ",", "appliance_id", "=", "appliance_id", ",", "password", "=", "password", ",", "power_on", "=", "power_on", ",", "firewall_policy_id", "=", "firewall_policy_id", ",", "ip_id", "=", "ip_id", ",", "load_balancer_id", "=", "load_balancer_id", ",", "monitoring_policy_id", "=", "monitoring_policy_id", ",", "datacenter_id", "=", "datacenter_id", ",", "rsa_key", "=", "ssh_key", ",", "private_network_id", "=", "private_network_id", ",", "public_key", "=", "public_key", ",", "server_type", "=", "server_type", ",", "baremetal_model_id", "=", "baremetal_model_id", ")"], "docstring": "Construct server instance from cloud profile config", "docstring_tokens": ["Construct", "server", "instance", "from", "cloud", "profile", "config"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/cloud/clouds/oneandone.py#L596-L716", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/cloud/clouds/oneandone.py", "func_name": "_get_hdds", "original_string": "def _get_hdds(vm_):\n    '''\n    Construct VM hdds from cloud profile config\n    '''\n    _hdds = config.get_cloud_config_value(\n        'hdds', vm_, __opts__, default=None,\n        search_global=False\n    )\n\n    hdds = []\n\n    for hdd in _hdds:\n        hdds.append(\n            Hdd(\n                size=hdd['size'],\n                is_main=hdd['is_main']\n            )\n        )\n\n    return hdds", "language": "python", "code": "def _get_hdds(vm_):\n    '''\n    Construct VM hdds from cloud profile config\n    '''\n    _hdds = config.get_cloud_config_value(\n        'hdds', vm_, __opts__, default=None,\n        search_global=False\n    )\n\n    hdds = []\n\n    for hdd in _hdds:\n        hdds.append(\n            Hdd(\n                size=hdd['size'],\n                is_main=hdd['is_main']\n            )\n        )\n\n    return hdds", "code_tokens": ["def", "_get_hdds", "(", "vm_", ")", ":", "_hdds", "=", "config", ".", "get_cloud_config_value", "(", "'hdds'", ",", "vm_", ",", "__opts__", ",", "default", "=", "None", ",", "search_global", "=", "False", ")", "hdds", "=", "[", "]", "for", "hdd", "in", "_hdds", ":", "hdds", ".", "append", "(", "Hdd", "(", "size", "=", "hdd", "[", "'size'", "]", ",", "is_main", "=", "hdd", "[", "'is_main'", "]", ")", ")", "return", "hdds"], "docstring": "Construct VM hdds from cloud profile config", "docstring_tokens": ["Construct", "VM", "hdds", "from", "cloud", "profile", "config"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/cloud/clouds/oneandone.py#L719-L738", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/cloud/clouds/oneandone.py", "func_name": "create", "original_string": "def create(vm_):\n    '''\n    Create a single VM from a data dict\n    '''\n    try:\n        # Check for required profile parameters before sending any API calls.\n        if (vm_['profile'] and\n           config.is_profile_configured(__opts__,\n                                        (__active_provider_name__ or\n                                         'oneandone'),\n                                        vm_['profile']) is False):\n            return False\n    except AttributeError:\n        pass\n\n    data = None\n    conn = get_conn()\n    hdds = []\n\n    # Assemble the composite server object.\n    server = _get_server(vm_)\n\n    if not bool(server.specs['hardware']['fixed_instance_size_id'])\\\n        and not bool(server.specs['server_type'] == 'baremetal'):\n        # Assemble the hdds object.\n        hdds = _get_hdds(vm_)\n\n    __utils__['cloud.fire_event'](\n        'event',\n        'requesting instance',\n        'salt/cloud/{0}/requesting'.format(vm_['name']),\n        args={'name': vm_['name']},\n        sock_dir=__opts__['sock_dir'],\n        transport=__opts__['transport']\n    )\n\n    try:\n        data = conn.create_server(server=server, hdds=hdds)\n\n        _wait_for_completion(conn,\n                             get_wait_timeout(vm_),\n                             data['id'])\n    except Exception as exc:  # pylint: disable=W0703\n        log.error(\n            'Error creating %s on 1and1\\n\\n'\n            'The following exception was thrown by the 1and1 library '\n            'when trying to run the initial deployment: \\n%s',\n            vm_['name'], exc, exc_info_on_loglevel=logging.DEBUG\n        )\n        return False\n\n    vm_['server_id'] = data['id']\n    password = data['first_password']\n\n    def __query_node_data(vm_, data):\n        '''\n        Query node data until node becomes available.\n        '''\n        running = False\n        try:\n            data = show_instance(vm_['name'], 'action')\n            if not data:\n                return False\n            log.debug(\n                'Loaded node data for %s:\\nname: %s\\nstate: %s',\n                vm_['name'],\n                pprint.pformat(data['name']),\n                data['status']['state']\n            )\n        except Exception as err:\n            log.error(\n                'Failed to get nodes list: %s', err,\n                # Show the trackback if the debug logging level is enabled\n                exc_info_on_loglevel=logging.DEBUG\n            )\n            # Trigger a failure in the wait for IP function\n            return False\n\n        running = data['status']['state'].lower() == 'powered_on'\n        if not running:\n            # Still not running, trigger another iteration\n            return\n\n        vm_['ssh_host'] = data['ips'][0]['ip']\n\n        return data\n\n    try:\n        data = salt.utils.cloud.wait_for_ip(\n            __query_node_data,\n            update_args=(vm_, data),\n            timeout=config.get_cloud_config_value(\n                'wait_for_ip_timeout', vm_, __opts__, default=10 * 60),\n            interval=config.get_cloud_config_value(\n                'wait_for_ip_interval', vm_, __opts__, default=10),\n        )\n    except (SaltCloudExecutionTimeout, SaltCloudExecutionFailure) as exc:\n        try:\n            # It might be already up, let's destroy it!\n            destroy(vm_['name'])\n        except SaltCloudSystemExit:\n            pass\n        finally:\n            raise SaltCloudSystemExit(six.text_type(exc.message))\n\n    log.debug('VM is now running')\n    log.info('Created Cloud VM %s', vm_)\n    log.debug('%s VM creation details:\\n%s', vm_, pprint.pformat(data))\n\n    __utils__['cloud.fire_event'](\n        'event',\n        'created instance',\n        'salt/cloud/{0}/created'.format(vm_['name']),\n        args={\n            'name': vm_['name'],\n            'profile': vm_['profile'],\n            'provider': vm_['driver'],\n        },\n        sock_dir=__opts__['sock_dir'],\n        transport=__opts__['transport']\n    )\n\n    if 'ssh_host' in vm_:\n        vm_['password'] = password\n        vm_['key_filename'] = get_key_filename(vm_)\n        ret = __utils__['cloud.bootstrap'](vm_, __opts__)\n        ret.update(data)\n        return ret\n    else:\n        raise SaltCloudSystemExit('A valid IP address was not found.')", "language": "python", "code": "def create(vm_):\n    '''\n    Create a single VM from a data dict\n    '''\n    try:\n        # Check for required profile parameters before sending any API calls.\n        if (vm_['profile'] and\n           config.is_profile_configured(__opts__,\n                                        (__active_provider_name__ or\n                                         'oneandone'),\n                                        vm_['profile']) is False):\n            return False\n    except AttributeError:\n        pass\n\n    data = None\n    conn = get_conn()\n    hdds = []\n\n    # Assemble the composite server object.\n    server = _get_server(vm_)\n\n    if not bool(server.specs['hardware']['fixed_instance_size_id'])\\\n        and not bool(server.specs['server_type'] == 'baremetal'):\n        # Assemble the hdds object.\n        hdds = _get_hdds(vm_)\n\n    __utils__['cloud.fire_event'](\n        'event',\n        'requesting instance',\n        'salt/cloud/{0}/requesting'.format(vm_['name']),\n        args={'name': vm_['name']},\n        sock_dir=__opts__['sock_dir'],\n        transport=__opts__['transport']\n    )\n\n    try:\n        data = conn.create_server(server=server, hdds=hdds)\n\n        _wait_for_completion(conn,\n                             get_wait_timeout(vm_),\n                             data['id'])\n    except Exception as exc:  # pylint: disable=W0703\n        log.error(\n            'Error creating %s on 1and1\\n\\n'\n            'The following exception was thrown by the 1and1 library '\n            'when trying to run the initial deployment: \\n%s',\n            vm_['name'], exc, exc_info_on_loglevel=logging.DEBUG\n        )\n        return False\n\n    vm_['server_id'] = data['id']\n    password = data['first_password']\n\n    def __query_node_data(vm_, data):\n        '''\n        Query node data until node becomes available.\n        '''\n        running = False\n        try:\n            data = show_instance(vm_['name'], 'action')\n            if not data:\n                return False\n            log.debug(\n                'Loaded node data for %s:\\nname: %s\\nstate: %s',\n                vm_['name'],\n                pprint.pformat(data['name']),\n                data['status']['state']\n            )\n        except Exception as err:\n            log.error(\n                'Failed to get nodes list: %s', err,\n                # Show the trackback if the debug logging level is enabled\n                exc_info_on_loglevel=logging.DEBUG\n            )\n            # Trigger a failure in the wait for IP function\n            return False\n\n        running = data['status']['state'].lower() == 'powered_on'\n        if not running:\n            # Still not running, trigger another iteration\n            return\n\n        vm_['ssh_host'] = data['ips'][0]['ip']\n\n        return data\n\n    try:\n        data = salt.utils.cloud.wait_for_ip(\n            __query_node_data,\n            update_args=(vm_, data),\n            timeout=config.get_cloud_config_value(\n                'wait_for_ip_timeout', vm_, __opts__, default=10 * 60),\n            interval=config.get_cloud_config_value(\n                'wait_for_ip_interval', vm_, __opts__, default=10),\n        )\n    except (SaltCloudExecutionTimeout, SaltCloudExecutionFailure) as exc:\n        try:\n            # It might be already up, let's destroy it!\n            destroy(vm_['name'])\n        except SaltCloudSystemExit:\n            pass\n        finally:\n            raise SaltCloudSystemExit(six.text_type(exc.message))\n\n    log.debug('VM is now running')\n    log.info('Created Cloud VM %s', vm_)\n    log.debug('%s VM creation details:\\n%s', vm_, pprint.pformat(data))\n\n    __utils__['cloud.fire_event'](\n        'event',\n        'created instance',\n        'salt/cloud/{0}/created'.format(vm_['name']),\n        args={\n            'name': vm_['name'],\n            'profile': vm_['profile'],\n            'provider': vm_['driver'],\n        },\n        sock_dir=__opts__['sock_dir'],\n        transport=__opts__['transport']\n    )\n\n    if 'ssh_host' in vm_:\n        vm_['password'] = password\n        vm_['key_filename'] = get_key_filename(vm_)\n        ret = __utils__['cloud.bootstrap'](vm_, __opts__)\n        ret.update(data)\n        return ret\n    else:\n        raise SaltCloudSystemExit('A valid IP address was not found.')", "code_tokens": ["def", "create", "(", "vm_", ")", ":", "try", ":", "# Check for required profile parameters before sending any API calls.", "if", "(", "vm_", "[", "'profile'", "]", "and", "config", ".", "is_profile_configured", "(", "__opts__", ",", "(", "__active_provider_name__", "or", "'oneandone'", ")", ",", "vm_", "[", "'profile'", "]", ")", "is", "False", ")", ":", "return", "False", "except", "AttributeError", ":", "pass", "data", "=", "None", "conn", "=", "get_conn", "(", ")", "hdds", "=", "[", "]", "# Assemble the composite server object.", "server", "=", "_get_server", "(", "vm_", ")", "if", "not", "bool", "(", "server", ".", "specs", "[", "'hardware'", "]", "[", "'fixed_instance_size_id'", "]", ")", "and", "not", "bool", "(", "server", ".", "specs", "[", "'server_type'", "]", "==", "'baremetal'", ")", ":", "# Assemble the hdds object.", "hdds", "=", "_get_hdds", "(", "vm_", ")", "__utils__", "[", "'cloud.fire_event'", "]", "(", "'event'", ",", "'requesting instance'", ",", "'salt/cloud/{0}/requesting'", ".", "format", "(", "vm_", "[", "'name'", "]", ")", ",", "args", "=", "{", "'name'", ":", "vm_", "[", "'name'", "]", "}", ",", "sock_dir", "=", "__opts__", "[", "'sock_dir'", "]", ",", "transport", "=", "__opts__", "[", "'transport'", "]", ")", "try", ":", "data", "=", "conn", ".", "create_server", "(", "server", "=", "server", ",", "hdds", "=", "hdds", ")", "_wait_for_completion", "(", "conn", ",", "get_wait_timeout", "(", "vm_", ")", ",", "data", "[", "'id'", "]", ")", "except", "Exception", "as", "exc", ":", "# pylint: disable=W0703", "log", ".", "error", "(", "'Error creating %s on 1and1\\n\\n'", "'The following exception was thrown by the 1and1 library '", "'when trying to run the initial deployment: \\n%s'", ",", "vm_", "[", "'name'", "]", ",", "exc", ",", "exc_info_on_loglevel", "=", "logging", ".", "DEBUG", ")", "return", "False", "vm_", "[", "'server_id'", "]", "=", "data", "[", "'id'", "]", "password", "=", "data", "[", "'first_password'", "]", "def", "__query_node_data", "(", "vm_", ",", "data", ")", ":", "'''\n        Query node data until node becomes available.\n        '''", "running", "=", "False", "try", ":", "data", "=", "show_instance", "(", "vm_", "[", "'name'", "]", ",", "'action'", ")", "if", "not", "data", ":", "return", "False", "log", ".", "debug", "(", "'Loaded node data for %s:\\nname: %s\\nstate: %s'", ",", "vm_", "[", "'name'", "]", ",", "pprint", ".", "pformat", "(", "data", "[", "'name'", "]", ")", ",", "data", "[", "'status'", "]", "[", "'state'", "]", ")", "except", "Exception", "as", "err", ":", "log", ".", "error", "(", "'Failed to get nodes list: %s'", ",", "err", ",", "# Show the trackback if the debug logging level is enabled", "exc_info_on_loglevel", "=", "logging", ".", "DEBUG", ")", "# Trigger a failure in the wait for IP function", "return", "False", "running", "=", "data", "[", "'status'", "]", "[", "'state'", "]", ".", "lower", "(", ")", "==", "'powered_on'", "if", "not", "running", ":", "# Still not running, trigger another iteration", "return", "vm_", "[", "'ssh_host'", "]", "=", "data", "[", "'ips'", "]", "[", "0", "]", "[", "'ip'", "]", "return", "data", "try", ":", "data", "=", "salt", ".", "utils", ".", "cloud", ".", "wait_for_ip", "(", "__query_node_data", ",", "update_args", "=", "(", "vm_", ",", "data", ")", ",", "timeout", "=", "config", ".", "get_cloud_config_value", "(", "'wait_for_ip_timeout'", ",", "vm_", ",", "__opts__", ",", "default", "=", "10", "*", "60", ")", ",", "interval", "=", "config", ".", "get_cloud_config_value", "(", "'wait_for_ip_interval'", ",", "vm_", ",", "__opts__", ",", "default", "=", "10", ")", ",", ")", "except", "(", "SaltCloudExecutionTimeout", ",", "SaltCloudExecutionFailure", ")", "as", "exc", ":", "try", ":", "# It might be already up, let's destroy it!", "destroy", "(", "vm_", "[", "'name'", "]", ")", "except", "SaltCloudSystemExit", ":", "pass", "finally", ":", "raise", "SaltCloudSystemExit", "(", "six", ".", "text_type", "(", "exc", ".", "message", ")", ")", "log", ".", "debug", "(", "'VM is now running'", ")", "log", ".", "info", "(", "'Created Cloud VM %s'", ",", "vm_", ")", "log", ".", "debug", "(", "'%s VM creation details:\\n%s'", ",", "vm_", ",", "pprint", ".", "pformat", "(", "data", ")", ")", "__utils__", "[", "'cloud.fire_event'", "]", "(", "'event'", ",", "'created instance'", ",", "'salt/cloud/{0}/created'", ".", "format", "(", "vm_", "[", "'name'", "]", ")", ",", "args", "=", "{", "'name'", ":", "vm_", "[", "'name'", "]", ",", "'profile'", ":", "vm_", "[", "'profile'", "]", ",", "'provider'", ":", "vm_", "[", "'driver'", "]", ",", "}", ",", "sock_dir", "=", "__opts__", "[", "'sock_dir'", "]", ",", "transport", "=", "__opts__", "[", "'transport'", "]", ")", "if", "'ssh_host'", "in", "vm_", ":", "vm_", "[", "'password'", "]", "=", "password", "vm_", "[", "'key_filename'", "]", "=", "get_key_filename", "(", "vm_", ")", "ret", "=", "__utils__", "[", "'cloud.bootstrap'", "]", "(", "vm_", ",", "__opts__", ")", "ret", ".", "update", "(", "data", ")", "return", "ret", "else", ":", "raise", "SaltCloudSystemExit", "(", "'A valid IP address was not found.'", ")"], "docstring": "Create a single VM from a data dict", "docstring_tokens": ["Create", "a", "single", "VM", "from", "a", "data", "dict"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/cloud/clouds/oneandone.py#L741-L870", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/cloud/clouds/oneandone.py", "func_name": "destroy", "original_string": "def destroy(name, call=None):\n    '''\n    destroy a server by name\n\n    :param name: name given to the server\n    :param call: call value in this case is 'action'\n    :return: array of booleans , true if successfully stopped and true if\n             successfully removed\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt-cloud -d vm_name\n\n    '''\n    if call == 'function':\n        raise SaltCloudSystemExit(\n            'The destroy action must be called with -d, --destroy, '\n            '-a or --action.'\n        )\n\n    __utils__['cloud.fire_event'](\n        'event',\n        'destroying instance',\n        'salt/cloud/{0}/destroying'.format(name),\n        args={'name': name},\n        sock_dir=__opts__['sock_dir'],\n        transport=__opts__['transport']\n    )\n\n    conn = get_conn()\n    node = get_node(conn, name)\n\n    conn.delete_server(server_id=node['id'])\n\n    __utils__['cloud.fire_event'](\n        'event',\n        'destroyed instance',\n        'salt/cloud/{0}/destroyed'.format(name),\n        args={'name': name},\n        sock_dir=__opts__['sock_dir'],\n        transport=__opts__['transport']\n    )\n\n    if __opts__.get('update_cachedir', False) is True:\n        __utils__['cloud.delete_minion_cachedir'](\n            name,\n            __active_provider_name__.split(':')[0],\n            __opts__\n        )\n\n    return True", "language": "python", "code": "def destroy(name, call=None):\n    '''\n    destroy a server by name\n\n    :param name: name given to the server\n    :param call: call value in this case is 'action'\n    :return: array of booleans , true if successfully stopped and true if\n             successfully removed\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt-cloud -d vm_name\n\n    '''\n    if call == 'function':\n        raise SaltCloudSystemExit(\n            'The destroy action must be called with -d, --destroy, '\n            '-a or --action.'\n        )\n\n    __utils__['cloud.fire_event'](\n        'event',\n        'destroying instance',\n        'salt/cloud/{0}/destroying'.format(name),\n        args={'name': name},\n        sock_dir=__opts__['sock_dir'],\n        transport=__opts__['transport']\n    )\n\n    conn = get_conn()\n    node = get_node(conn, name)\n\n    conn.delete_server(server_id=node['id'])\n\n    __utils__['cloud.fire_event'](\n        'event',\n        'destroyed instance',\n        'salt/cloud/{0}/destroyed'.format(name),\n        args={'name': name},\n        sock_dir=__opts__['sock_dir'],\n        transport=__opts__['transport']\n    )\n\n    if __opts__.get('update_cachedir', False) is True:\n        __utils__['cloud.delete_minion_cachedir'](\n            name,\n            __active_provider_name__.split(':')[0],\n            __opts__\n        )\n\n    return True", "code_tokens": ["def", "destroy", "(", "name", ",", "call", "=", "None", ")", ":", "if", "call", "==", "'function'", ":", "raise", "SaltCloudSystemExit", "(", "'The destroy action must be called with -d, --destroy, '", "'-a or --action.'", ")", "__utils__", "[", "'cloud.fire_event'", "]", "(", "'event'", ",", "'destroying instance'", ",", "'salt/cloud/{0}/destroying'", ".", "format", "(", "name", ")", ",", "args", "=", "{", "'name'", ":", "name", "}", ",", "sock_dir", "=", "__opts__", "[", "'sock_dir'", "]", ",", "transport", "=", "__opts__", "[", "'transport'", "]", ")", "conn", "=", "get_conn", "(", ")", "node", "=", "get_node", "(", "conn", ",", "name", ")", "conn", ".", "delete_server", "(", "server_id", "=", "node", "[", "'id'", "]", ")", "__utils__", "[", "'cloud.fire_event'", "]", "(", "'event'", ",", "'destroyed instance'", ",", "'salt/cloud/{0}/destroyed'", ".", "format", "(", "name", ")", ",", "args", "=", "{", "'name'", ":", "name", "}", ",", "sock_dir", "=", "__opts__", "[", "'sock_dir'", "]", ",", "transport", "=", "__opts__", "[", "'transport'", "]", ")", "if", "__opts__", ".", "get", "(", "'update_cachedir'", ",", "False", ")", "is", "True", ":", "__utils__", "[", "'cloud.delete_minion_cachedir'", "]", "(", "name", ",", "__active_provider_name__", ".", "split", "(", "':'", ")", "[", "0", "]", ",", "__opts__", ")", "return", "True"], "docstring": "destroy a server by name\n\n    :param name: name given to the server\n    :param call: call value in this case is 'action'\n    :return: array of booleans , true if successfully stopped and true if\n             successfully removed\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt-cloud -d vm_name", "docstring_tokens": ["destroy", "a", "server", "by", "name"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/cloud/clouds/oneandone.py#L873-L925", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/cloud/clouds/oneandone.py", "func_name": "reboot", "original_string": "def reboot(name, call=None):\n    '''\n    reboot a server by name\n    :param name: name given to the machine\n    :param call: call value in this case is 'action'\n    :return: true if successful\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt-cloud -a reboot vm_name\n    '''\n    conn = get_conn()\n    node = get_node(conn, name)\n\n    conn.modify_server_status(server_id=node['id'], action='REBOOT')\n\n    return True", "language": "python", "code": "def reboot(name, call=None):\n    '''\n    reboot a server by name\n    :param name: name given to the machine\n    :param call: call value in this case is 'action'\n    :return: true if successful\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt-cloud -a reboot vm_name\n    '''\n    conn = get_conn()\n    node = get_node(conn, name)\n\n    conn.modify_server_status(server_id=node['id'], action='REBOOT')\n\n    return True", "code_tokens": ["def", "reboot", "(", "name", ",", "call", "=", "None", ")", ":", "conn", "=", "get_conn", "(", ")", "node", "=", "get_node", "(", "conn", ",", "name", ")", "conn", ".", "modify_server_status", "(", "server_id", "=", "node", "[", "'id'", "]", ",", "action", "=", "'REBOOT'", ")", "return", "True"], "docstring": "reboot a server by name\n    :param name: name given to the machine\n    :param call: call value in this case is 'action'\n    :return: true if successful\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt-cloud -a reboot vm_name", "docstring_tokens": ["reboot", "a", "server", "by", "name", ":", "param", "name", ":", "name", "given", "to", "the", "machine", ":", "param", "call", ":", "call", "value", "in", "this", "case", "is", "action", ":", "return", ":", "true", "if", "successful"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/cloud/clouds/oneandone.py#L928-L946", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/cloud/clouds/oneandone.py", "func_name": "get_node", "original_string": "def get_node(conn, name):\n    '''\n    Return a node for the named VM\n    '''\n    for node in conn.list_servers(per_page=1000):\n        if node['name'] == name:\n            return node", "language": "python", "code": "def get_node(conn, name):\n    '''\n    Return a node for the named VM\n    '''\n    for node in conn.list_servers(per_page=1000):\n        if node['name'] == name:\n            return node", "code_tokens": ["def", "get_node", "(", "conn", ",", "name", ")", ":", "for", "node", "in", "conn", ".", "list_servers", "(", "per_page", "=", "1000", ")", ":", "if", "node", "[", "'name'", "]", "==", "name", ":", "return", "node"], "docstring": "Return a node for the named VM", "docstring_tokens": ["Return", "a", "node", "for", "the", "named", "VM"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/cloud/clouds/oneandone.py#L992-L998", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/cloud/clouds/oneandone.py", "func_name": "load_public_key", "original_string": "def load_public_key(vm_):\n    '''\n    Load the public key file if exists.\n    '''\n    public_key_filename = config.get_cloud_config_value(\n        'ssh_public_key', vm_, __opts__, search_global=False, default=None\n    )\n    if public_key_filename is not None:\n        public_key_filename = os.path.expanduser(public_key_filename)\n        if not os.path.isfile(public_key_filename):\n            raise SaltCloudConfigError(\n                'The defined ssh_public_key \\'{0}\\' does not exist'.format(\n                    public_key_filename\n                )\n            )\n\n        with salt.utils.files.fopen(public_key_filename, 'r') as public_key:\n            key = salt.utils.stringutils.to_unicode(public_key.read().replace('\\n', ''))\n\n            return key", "language": "python", "code": "def load_public_key(vm_):\n    '''\n    Load the public key file if exists.\n    '''\n    public_key_filename = config.get_cloud_config_value(\n        'ssh_public_key', vm_, __opts__, search_global=False, default=None\n    )\n    if public_key_filename is not None:\n        public_key_filename = os.path.expanduser(public_key_filename)\n        if not os.path.isfile(public_key_filename):\n            raise SaltCloudConfigError(\n                'The defined ssh_public_key \\'{0}\\' does not exist'.format(\n                    public_key_filename\n                )\n            )\n\n        with salt.utils.files.fopen(public_key_filename, 'r') as public_key:\n            key = salt.utils.stringutils.to_unicode(public_key.read().replace('\\n', ''))\n\n            return key", "code_tokens": ["def", "load_public_key", "(", "vm_", ")", ":", "public_key_filename", "=", "config", ".", "get_cloud_config_value", "(", "'ssh_public_key'", ",", "vm_", ",", "__opts__", ",", "search_global", "=", "False", ",", "default", "=", "None", ")", "if", "public_key_filename", "is", "not", "None", ":", "public_key_filename", "=", "os", ".", "path", ".", "expanduser", "(", "public_key_filename", ")", "if", "not", "os", ".", "path", ".", "isfile", "(", "public_key_filename", ")", ":", "raise", "SaltCloudConfigError", "(", "'The defined ssh_public_key \\'{0}\\' does not exist'", ".", "format", "(", "public_key_filename", ")", ")", "with", "salt", ".", "utils", ".", "files", ".", "fopen", "(", "public_key_filename", ",", "'r'", ")", "as", "public_key", ":", "key", "=", "salt", ".", "utils", ".", "stringutils", ".", "to_unicode", "(", "public_key", ".", "read", "(", ")", ".", "replace", "(", "'\\n'", ",", "''", ")", ")", "return", "key"], "docstring": "Load the public key file if exists.", "docstring_tokens": ["Load", "the", "public", "key", "file", "if", "exists", "."], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/cloud/clouds/oneandone.py#L1020-L1039", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/cloud/clouds/oneandone.py", "func_name": "_wait_for_completion", "original_string": "def _wait_for_completion(conn, wait_timeout, server_id):\n    '''\n    Poll request status until resource is provisioned.\n    '''\n    wait_timeout = time.time() + wait_timeout\n    while wait_timeout > time.time():\n        time.sleep(5)\n\n        server = conn.get_server(server_id)\n        server_state = server['status']['state'].lower()\n\n        if server_state == \"powered_on\":\n            return\n        elif server_state == 'failed':\n            raise Exception('Server creation failed for {0}'.format(server_id))\n        elif server_state in ('active',\n                              'enabled',\n                              'deploying',\n                              'configuring'):\n            continue\n        else:\n            raise Exception(\n                'Unknown server state {0}'.format(server_state))\n    raise Exception(\n        'Timed out waiting for server create completion for {0}'.format(server_id)\n    )", "language": "python", "code": "def _wait_for_completion(conn, wait_timeout, server_id):\n    '''\n    Poll request status until resource is provisioned.\n    '''\n    wait_timeout = time.time() + wait_timeout\n    while wait_timeout > time.time():\n        time.sleep(5)\n\n        server = conn.get_server(server_id)\n        server_state = server['status']['state'].lower()\n\n        if server_state == \"powered_on\":\n            return\n        elif server_state == 'failed':\n            raise Exception('Server creation failed for {0}'.format(server_id))\n        elif server_state in ('active',\n                              'enabled',\n                              'deploying',\n                              'configuring'):\n            continue\n        else:\n            raise Exception(\n                'Unknown server state {0}'.format(server_state))\n    raise Exception(\n        'Timed out waiting for server create completion for {0}'.format(server_id)\n    )", "code_tokens": ["def", "_wait_for_completion", "(", "conn", ",", "wait_timeout", ",", "server_id", ")", ":", "wait_timeout", "=", "time", ".", "time", "(", ")", "+", "wait_timeout", "while", "wait_timeout", ">", "time", ".", "time", "(", ")", ":", "time", ".", "sleep", "(", "5", ")", "server", "=", "conn", ".", "get_server", "(", "server_id", ")", "server_state", "=", "server", "[", "'status'", "]", "[", "'state'", "]", ".", "lower", "(", ")", "if", "server_state", "==", "\"powered_on\"", ":", "return", "elif", "server_state", "==", "'failed'", ":", "raise", "Exception", "(", "'Server creation failed for {0}'", ".", "format", "(", "server_id", ")", ")", "elif", "server_state", "in", "(", "'active'", ",", "'enabled'", ",", "'deploying'", ",", "'configuring'", ")", ":", "continue", "else", ":", "raise", "Exception", "(", "'Unknown server state {0}'", ".", "format", "(", "server_state", ")", ")", "raise", "Exception", "(", "'Timed out waiting for server create completion for {0}'", ".", "format", "(", "server_id", ")", ")"], "docstring": "Poll request status until resource is provisioned.", "docstring_tokens": ["Poll", "request", "status", "until", "resource", "is", "provisioned", "."], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/cloud/clouds/oneandone.py#L1052-L1077", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/states/bigip.py", "func_name": "_load_result", "original_string": "def _load_result(response, ret):\n    '''\n    format the results of listing functions\n    '''\n\n    #were we able to connect?\n    if response['code'] is None:\n        ret['comment'] = response['content']\n    #forbidden?\n    elif response['code'] == 401:\n        ret['comment'] = '401 Forbidden: Authentication required!'\n    #Not found?\n    elif response['code'] == 404:\n        ret['comment'] = response['content']['message']\n    #200?\n    elif response['code'] == 200:\n        ret['result'] = True\n        ret['comment'] = 'Listing Current Configuration Only.  ' \\\n                         'Not action or changes occurred during the execution of this state.'\n        ret['changes'] = response['content']\n    #something bad\n    else:\n        ret['comment'] = response['content']['message']\n\n    return ret", "language": "python", "code": "def _load_result(response, ret):\n    '''\n    format the results of listing functions\n    '''\n\n    #were we able to connect?\n    if response['code'] is None:\n        ret['comment'] = response['content']\n    #forbidden?\n    elif response['code'] == 401:\n        ret['comment'] = '401 Forbidden: Authentication required!'\n    #Not found?\n    elif response['code'] == 404:\n        ret['comment'] = response['content']['message']\n    #200?\n    elif response['code'] == 200:\n        ret['result'] = True\n        ret['comment'] = 'Listing Current Configuration Only.  ' \\\n                         'Not action or changes occurred during the execution of this state.'\n        ret['changes'] = response['content']\n    #something bad\n    else:\n        ret['comment'] = response['content']['message']\n\n    return ret", "code_tokens": ["def", "_load_result", "(", "response", ",", "ret", ")", ":", "#were we able to connect?", "if", "response", "[", "'code'", "]", "is", "None", ":", "ret", "[", "'comment'", "]", "=", "response", "[", "'content'", "]", "#forbidden?", "elif", "response", "[", "'code'", "]", "==", "401", ":", "ret", "[", "'comment'", "]", "=", "'401 Forbidden: Authentication required!'", "#Not found?", "elif", "response", "[", "'code'", "]", "==", "404", ":", "ret", "[", "'comment'", "]", "=", "response", "[", "'content'", "]", "[", "'message'", "]", "#200?", "elif", "response", "[", "'code'", "]", "==", "200", ":", "ret", "[", "'result'", "]", "=", "True", "ret", "[", "'comment'", "]", "=", "'Listing Current Configuration Only.  '", "'Not action or changes occurred during the execution of this state.'", "ret", "[", "'changes'", "]", "=", "response", "[", "'content'", "]", "#something bad", "else", ":", "ret", "[", "'comment'", "]", "=", "response", "[", "'content'", "]", "[", "'message'", "]", "return", "ret"], "docstring": "format the results of listing functions", "docstring_tokens": ["format", "the", "results", "of", "listing", "functions"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/states/bigip.py#L26-L50", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/states/bigip.py", "func_name": "_strip_key", "original_string": "def _strip_key(dictionary, keyword):\n    '''\n    look for a certain key within a dictionary and nullify ti's contents, check within nested\n    dictionaries and lists as well.  Certain attributes such as \"generation\" will change even\n    when there were no changes made to the entity.\n    '''\n\n    for key, value in six.iteritems(dictionary):\n        if key == keyword:\n            dictionary[key] = None\n        elif isinstance(value, dict):\n            _strip_key(value, keyword)\n        elif isinstance(value, list):\n            for item in value:\n                if isinstance(item, dict):\n                    _strip_key(item, keyword)\n\n    return dictionary", "language": "python", "code": "def _strip_key(dictionary, keyword):\n    '''\n    look for a certain key within a dictionary and nullify ti's contents, check within nested\n    dictionaries and lists as well.  Certain attributes such as \"generation\" will change even\n    when there were no changes made to the entity.\n    '''\n\n    for key, value in six.iteritems(dictionary):\n        if key == keyword:\n            dictionary[key] = None\n        elif isinstance(value, dict):\n            _strip_key(value, keyword)\n        elif isinstance(value, list):\n            for item in value:\n                if isinstance(item, dict):\n                    _strip_key(item, keyword)\n\n    return dictionary", "code_tokens": ["def", "_strip_key", "(", "dictionary", ",", "keyword", ")", ":", "for", "key", ",", "value", "in", "six", ".", "iteritems", "(", "dictionary", ")", ":", "if", "key", "==", "keyword", ":", "dictionary", "[", "key", "]", "=", "None", "elif", "isinstance", "(", "value", ",", "dict", ")", ":", "_strip_key", "(", "value", ",", "keyword", ")", "elif", "isinstance", "(", "value", ",", "list", ")", ":", "for", "item", "in", "value", ":", "if", "isinstance", "(", "item", ",", "dict", ")", ":", "_strip_key", "(", "item", ",", "keyword", ")", "return", "dictionary"], "docstring": "look for a certain key within a dictionary and nullify ti's contents, check within nested\n    dictionaries and lists as well.  Certain attributes such as \"generation\" will change even\n    when there were no changes made to the entity.", "docstring_tokens": ["look", "for", "a", "certain", "key", "within", "a", "dictionary", "and", "nullify", "ti", "s", "contents", "check", "within", "nested", "dictionaries", "and", "lists", "as", "well", ".", "Certain", "attributes", "such", "as", "generation", "will", "change", "even", "when", "there", "were", "no", "changes", "made", "to", "the", "entity", "."], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/states/bigip.py#L53-L70", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/states/bigip.py", "func_name": "_check_for_changes", "original_string": "def _check_for_changes(entity_type, ret, existing, modified):\n    '''\n    take an existing entity and a modified entity and check for changes.\n    '''\n\n    ret['result'] = True\n\n    #were there any changes? generation always changes, remove it.\n\n    if isinstance(existing, dict) and isinstance(modified, dict):\n        if 'generation' in modified['content'].keys():\n            del modified['content']['generation']\n\n        if 'generation' in existing['content'].keys():\n            del existing['content']['generation']\n\n        if modified['content'] == existing['content']:\n            ret['comment'] = '{entity_type} is currently enforced to the desired state.  No changes made.'.format(entity_type=entity_type)\n        else:\n            ret['comment'] = '{entity_type} was enforced to the desired state.  Note: Only parameters specified ' \\\n                             'were enforced. See changes for details.'.format(entity_type=entity_type)\n            ret['changes']['old'] = existing['content']\n            ret['changes']['new'] = modified['content']\n\n    else:\n        if modified == existing:\n            ret['comment'] = '{entity_type} is currently enforced to the desired state.  No changes made.'.format(entity_type=entity_type)\n        else:\n            ret['comment'] = '{entity_type} was enforced to the desired state.  Note: Only parameters specified ' \\\n                             'were enforced. See changes for details.'.format(entity_type=entity_type)\n            ret['changes']['old'] = existing\n            ret['changes']['new'] = modified\n\n    return ret", "language": "python", "code": "def _check_for_changes(entity_type, ret, existing, modified):\n    '''\n    take an existing entity and a modified entity and check for changes.\n    '''\n\n    ret['result'] = True\n\n    #were there any changes? generation always changes, remove it.\n\n    if isinstance(existing, dict) and isinstance(modified, dict):\n        if 'generation' in modified['content'].keys():\n            del modified['content']['generation']\n\n        if 'generation' in existing['content'].keys():\n            del existing['content']['generation']\n\n        if modified['content'] == existing['content']:\n            ret['comment'] = '{entity_type} is currently enforced to the desired state.  No changes made.'.format(entity_type=entity_type)\n        else:\n            ret['comment'] = '{entity_type} was enforced to the desired state.  Note: Only parameters specified ' \\\n                             'were enforced. See changes for details.'.format(entity_type=entity_type)\n            ret['changes']['old'] = existing['content']\n            ret['changes']['new'] = modified['content']\n\n    else:\n        if modified == existing:\n            ret['comment'] = '{entity_type} is currently enforced to the desired state.  No changes made.'.format(entity_type=entity_type)\n        else:\n            ret['comment'] = '{entity_type} was enforced to the desired state.  Note: Only parameters specified ' \\\n                             'were enforced. See changes for details.'.format(entity_type=entity_type)\n            ret['changes']['old'] = existing\n            ret['changes']['new'] = modified\n\n    return ret", "code_tokens": ["def", "_check_for_changes", "(", "entity_type", ",", "ret", ",", "existing", ",", "modified", ")", ":", "ret", "[", "'result'", "]", "=", "True", "#were there any changes? generation always changes, remove it.", "if", "isinstance", "(", "existing", ",", "dict", ")", "and", "isinstance", "(", "modified", ",", "dict", ")", ":", "if", "'generation'", "in", "modified", "[", "'content'", "]", ".", "keys", "(", ")", ":", "del", "modified", "[", "'content'", "]", "[", "'generation'", "]", "if", "'generation'", "in", "existing", "[", "'content'", "]", ".", "keys", "(", ")", ":", "del", "existing", "[", "'content'", "]", "[", "'generation'", "]", "if", "modified", "[", "'content'", "]", "==", "existing", "[", "'content'", "]", ":", "ret", "[", "'comment'", "]", "=", "'{entity_type} is currently enforced to the desired state.  No changes made.'", ".", "format", "(", "entity_type", "=", "entity_type", ")", "else", ":", "ret", "[", "'comment'", "]", "=", "'{entity_type} was enforced to the desired state.  Note: Only parameters specified '", "'were enforced. See changes for details.'", ".", "format", "(", "entity_type", "=", "entity_type", ")", "ret", "[", "'changes'", "]", "[", "'old'", "]", "=", "existing", "[", "'content'", "]", "ret", "[", "'changes'", "]", "[", "'new'", "]", "=", "modified", "[", "'content'", "]", "else", ":", "if", "modified", "==", "existing", ":", "ret", "[", "'comment'", "]", "=", "'{entity_type} is currently enforced to the desired state.  No changes made.'", ".", "format", "(", "entity_type", "=", "entity_type", ")", "else", ":", "ret", "[", "'comment'", "]", "=", "'{entity_type} was enforced to the desired state.  Note: Only parameters specified '", "'were enforced. See changes for details.'", ".", "format", "(", "entity_type", "=", "entity_type", ")", "ret", "[", "'changes'", "]", "[", "'old'", "]", "=", "existing", "ret", "[", "'changes'", "]", "[", "'new'", "]", "=", "modified", "return", "ret"], "docstring": "take an existing entity and a modified entity and check for changes.", "docstring_tokens": ["take", "an", "existing", "entity", "and", "a", "modified", "entity", "and", "check", "for", "changes", "."], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/states/bigip.py#L73-L106", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/states/bigip.py", "func_name": "create_node", "original_string": "def create_node(hostname, username, password, name, address):\n    '''\n    Create a new node if it does not already exist.\n\n    hostname\n        The host/address of the bigip device\n    username\n        The iControl REST username\n    password\n        The iControl REST password\n    name\n        The name of the node to create\n    address\n        The address of the node\n    '''\n\n    ret = {'name': name, 'changes': {}, 'result': False, 'comment': ''}\n\n    if __opts__['test']:\n        return _test_output(ret, 'create', params={\n            'hostname': hostname,\n            'username': username,\n            'password': password,\n            'name': name,\n            'address': address\n        }\n        )\n\n    #is this node currently configured?\n    existing = __salt__['bigip.list_node'](hostname, username, password, name)\n\n    # if it exists\n    if existing['code'] == 200:\n\n        ret['result'] = True\n        ret['comment'] = 'A node by this name currently exists.  No change made.'\n\n    # if it doesn't exist\n    elif existing['code'] == 404:\n        response = __salt__['bigip.create_node'](hostname, username, password, name, address)\n\n        ret['result'] = True\n        ret['changes']['old'] = {}\n        ret['changes']['new'] = response['content']\n        ret['comment'] = 'Node was successfully created.'\n\n    # else something else was returned\n    else:\n        ret = _load_result(existing, ret)\n\n    return ret", "language": "python", "code": "def create_node(hostname, username, password, name, address):\n    '''\n    Create a new node if it does not already exist.\n\n    hostname\n        The host/address of the bigip device\n    username\n        The iControl REST username\n    password\n        The iControl REST password\n    name\n        The name of the node to create\n    address\n        The address of the node\n    '''\n\n    ret = {'name': name, 'changes': {}, 'result': False, 'comment': ''}\n\n    if __opts__['test']:\n        return _test_output(ret, 'create', params={\n            'hostname': hostname,\n            'username': username,\n            'password': password,\n            'name': name,\n            'address': address\n        }\n        )\n\n    #is this node currently configured?\n    existing = __salt__['bigip.list_node'](hostname, username, password, name)\n\n    # if it exists\n    if existing['code'] == 200:\n\n        ret['result'] = True\n        ret['comment'] = 'A node by this name currently exists.  No change made.'\n\n    # if it doesn't exist\n    elif existing['code'] == 404:\n        response = __salt__['bigip.create_node'](hostname, username, password, name, address)\n\n        ret['result'] = True\n        ret['changes']['old'] = {}\n        ret['changes']['new'] = response['content']\n        ret['comment'] = 'Node was successfully created.'\n\n    # else something else was returned\n    else:\n        ret = _load_result(existing, ret)\n\n    return ret", "code_tokens": ["def", "create_node", "(", "hostname", ",", "username", ",", "password", ",", "name", ",", "address", ")", ":", "ret", "=", "{", "'name'", ":", "name", ",", "'changes'", ":", "{", "}", ",", "'result'", ":", "False", ",", "'comment'", ":", "''", "}", "if", "__opts__", "[", "'test'", "]", ":", "return", "_test_output", "(", "ret", ",", "'create'", ",", "params", "=", "{", "'hostname'", ":", "hostname", ",", "'username'", ":", "username", ",", "'password'", ":", "password", ",", "'name'", ":", "name", ",", "'address'", ":", "address", "}", ")", "#is this node currently configured?", "existing", "=", "__salt__", "[", "'bigip.list_node'", "]", "(", "hostname", ",", "username", ",", "password", ",", "name", ")", "# if it exists", "if", "existing", "[", "'code'", "]", "==", "200", ":", "ret", "[", "'result'", "]", "=", "True", "ret", "[", "'comment'", "]", "=", "'A node by this name currently exists.  No change made.'", "# if it doesn't exist", "elif", "existing", "[", "'code'", "]", "==", "404", ":", "response", "=", "__salt__", "[", "'bigip.create_node'", "]", "(", "hostname", ",", "username", ",", "password", ",", "name", ",", "address", ")", "ret", "[", "'result'", "]", "=", "True", "ret", "[", "'changes'", "]", "[", "'old'", "]", "=", "{", "}", "ret", "[", "'changes'", "]", "[", "'new'", "]", "=", "response", "[", "'content'", "]", "ret", "[", "'comment'", "]", "=", "'Node was successfully created.'", "# else something else was returned", "else", ":", "ret", "=", "_load_result", "(", "existing", ",", "ret", ")", "return", "ret"], "docstring": "Create a new node if it does not already exist.\n\n    hostname\n        The host/address of the bigip device\n    username\n        The iControl REST username\n    password\n        The iControl REST password\n    name\n        The name of the node to create\n    address\n        The address of the node", "docstring_tokens": ["Create", "a", "new", "node", "if", "it", "does", "not", "already", "exist", "."], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/states/bigip.py#L165-L215", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/states/bigip.py", "func_name": "manage_node", "original_string": "def manage_node(hostname, username, password, name, address,\n                connection_limit=None,\n                description=None,\n                dynamic_ratio=None,\n                logging=None,\n                monitor=None,\n                rate_limit=None,\n                ratio=None,\n                session=None,\n                node_state=None):\n    '''\n    Manages a node of a given bigip device.  If the node does not exist it will be created, otherwise,\n    only the properties which are different than the existing will be updated.\n\n    hostname\n        The host/address of the bigip device\n    username\n        The iControl REST username\n    password\n        The iControl REST password\n    name\n        The name of the node to manage.\n    address\n        The address of the node\n    connection_limit\n        [integer]\n    description\n        [string]\n    dynam\n        c_ratio:        [integer]\n    logging\n        [enabled | disabled]\n    monitor\n        [[name] | none | default]\n    rate_limit\n        [integer]\n    ratio\n        [integer]\n    session\n        [user-enabled | user-disabled]\n    node_state (state)\n        [user-down | user-up ]\n    '''\n\n    ret = {'name': name, 'changes': {}, 'result': False, 'comment': ''}\n\n    if __opts__['test']:\n        return _test_output(ret, 'manage', params={\n            'hostname': hostname,\n            'username': username,\n            'password': password,\n            'name': name,\n            'address': address,\n            'connection_limit': connection_limit,\n            'description': description,\n            'dynamic_ratio': dynamic_ratio,\n            'logging': logging,\n            'monitor': monitor,\n            'rate_limit': rate_limit,\n            'ratio': ratio,\n            'session': session,\n            'state:': node_state\n        }\n        )\n\n    #is this node currently configured?\n    existing = __salt__['bigip.list_node'](hostname, username, password, name)\n\n    # if it exists by name\n    if existing['code'] == 200:\n\n        # ensure the address is the same, we don't want to modify a different node than what\n        # we think we are managing\n        if existing['content']['address'] != address:\n            ret['result'] = False\n            ret['comment'] = 'A node with this name exists but the address does not match.'\n\n        modified = __salt__['bigip.modify_node'](hostname=hostname,\n                                                 username=username,\n                                                 password=password,\n                                                 name=name,\n                                                 connection_limit=connection_limit,\n                                                 description=description,\n                                                 dynamic_ratio=dynamic_ratio,\n                                                 logging=logging,\n                                                 monitor=monitor,\n                                                 rate_limit=rate_limit,\n                                                 ratio=ratio,\n                                                 session=session,\n                                                 state=node_state)\n\n        #was the modification successful?\n        if modified['code'] == 200:\n            ret = _check_for_changes('Node', ret, existing, modified)\n        else:\n            ret = _load_result(modified, ret)\n\n    # not found, attempt to create it\n    elif existing['code'] == 404:\n\n        new = __salt__['bigip.create_node'](hostname, username, password, name, address)\n\n        # were we able to create it?\n        if new['code'] == 200:\n            # try modification\n\n            modified = __salt__['bigip.modify_node'](hostname=hostname,\n                                                     username=username,\n                                                     password=password,\n                                                     name=name,\n                                                     connection_limit=connection_limit,\n                                                     description=description,\n                                                     dynamic_ratio=dynamic_ratio,\n                                                     logging=logging,\n                                                     monitor=monitor,\n                                                     rate_limit=rate_limit,\n                                                     ratio=ratio,\n                                                     session=session,\n                                                     state=node_state)\n            #was the modification successful?\n            if modified['code'] == 200:\n\n                ret['result'] = True\n                ret['comment'] = 'Node was created and enforced to the desired state.  Note: Only parameters specified ' \\\n                                 'were enforced.  See changes for details.'\n                ret['changes']['old'] = {}\n                ret['changes']['new'] = modified['content']\n\n            # roll it back\n            else:\n\n                deleted = __salt__['bigip.delete_node'](hostname, username, password, name)\n                # did we get rid of it?\n                if deleted['code'] == 200:\n                    ret['comment'] = 'Node was successfully created but an error occurred during modification. ' \\\n                                     'The creation of the node has been rolled back. Message is as follows:\\n' \\\n                                     '{message}'.format(message=modified['content']['message'])\n                # something bad happened\n                else:\n                    ret['comment'] = 'Node was successfully created but an error occurred during modification. ' \\\n                                     'The creation of the node was not able to be rolled back. Message is as follows:' \\\n                                     '\\n {message}\\n{message_two}'.format(message=modified['content']['message'],\n                                                                          message_two=deleted['content']['message'])\n\n        # unable to create it\n        else:\n            ret = _load_result(new, ret)\n    # an error occurred\n    else:\n        ret = _load_result(existing, ret)\n\n    return ret", "language": "python", "code": "def manage_node(hostname, username, password, name, address,\n                connection_limit=None,\n                description=None,\n                dynamic_ratio=None,\n                logging=None,\n                monitor=None,\n                rate_limit=None,\n                ratio=None,\n                session=None,\n                node_state=None):\n    '''\n    Manages a node of a given bigip device.  If the node does not exist it will be created, otherwise,\n    only the properties which are different than the existing will be updated.\n\n    hostname\n        The host/address of the bigip device\n    username\n        The iControl REST username\n    password\n        The iControl REST password\n    name\n        The name of the node to manage.\n    address\n        The address of the node\n    connection_limit\n        [integer]\n    description\n        [string]\n    dynam\n        c_ratio:        [integer]\n    logging\n        [enabled | disabled]\n    monitor\n        [[name] | none | default]\n    rate_limit\n        [integer]\n    ratio\n        [integer]\n    session\n        [user-enabled | user-disabled]\n    node_state (state)\n        [user-down | user-up ]\n    '''\n\n    ret = {'name': name, 'changes': {}, 'result': False, 'comment': ''}\n\n    if __opts__['test']:\n        return _test_output(ret, 'manage', params={\n            'hostname': hostname,\n            'username': username,\n            'password': password,\n            'name': name,\n            'address': address,\n            'connection_limit': connection_limit,\n            'description': description,\n            'dynamic_ratio': dynamic_ratio,\n            'logging': logging,\n            'monitor': monitor,\n            'rate_limit': rate_limit,\n            'ratio': ratio,\n            'session': session,\n            'state:': node_state\n        }\n        )\n\n    #is this node currently configured?\n    existing = __salt__['bigip.list_node'](hostname, username, password, name)\n\n    # if it exists by name\n    if existing['code'] == 200:\n\n        # ensure the address is the same, we don't want to modify a different node than what\n        # we think we are managing\n        if existing['content']['address'] != address:\n            ret['result'] = False\n            ret['comment'] = 'A node with this name exists but the address does not match.'\n\n        modified = __salt__['bigip.modify_node'](hostname=hostname,\n                                                 username=username,\n                                                 password=password,\n                                                 name=name,\n                                                 connection_limit=connection_limit,\n                                                 description=description,\n                                                 dynamic_ratio=dynamic_ratio,\n                                                 logging=logging,\n                                                 monitor=monitor,\n                                                 rate_limit=rate_limit,\n                                                 ratio=ratio,\n                                                 session=session,\n                                                 state=node_state)\n\n        #was the modification successful?\n        if modified['code'] == 200:\n            ret = _check_for_changes('Node', ret, existing, modified)\n        else:\n            ret = _load_result(modified, ret)\n\n    # not found, attempt to create it\n    elif existing['code'] == 404:\n\n        new = __salt__['bigip.create_node'](hostname, username, password, name, address)\n\n        # were we able to create it?\n        if new['code'] == 200:\n            # try modification\n\n            modified = __salt__['bigip.modify_node'](hostname=hostname,\n                                                     username=username,\n                                                     password=password,\n                                                     name=name,\n                                                     connection_limit=connection_limit,\n                                                     description=description,\n                                                     dynamic_ratio=dynamic_ratio,\n                                                     logging=logging,\n                                                     monitor=monitor,\n                                                     rate_limit=rate_limit,\n                                                     ratio=ratio,\n                                                     session=session,\n                                                     state=node_state)\n            #was the modification successful?\n            if modified['code'] == 200:\n\n                ret['result'] = True\n                ret['comment'] = 'Node was created and enforced to the desired state.  Note: Only parameters specified ' \\\n                                 'were enforced.  See changes for details.'\n                ret['changes']['old'] = {}\n                ret['changes']['new'] = modified['content']\n\n            # roll it back\n            else:\n\n                deleted = __salt__['bigip.delete_node'](hostname, username, password, name)\n                # did we get rid of it?\n                if deleted['code'] == 200:\n                    ret['comment'] = 'Node was successfully created but an error occurred during modification. ' \\\n                                     'The creation of the node has been rolled back. Message is as follows:\\n' \\\n                                     '{message}'.format(message=modified['content']['message'])\n                # something bad happened\n                else:\n                    ret['comment'] = 'Node was successfully created but an error occurred during modification. ' \\\n                                     'The creation of the node was not able to be rolled back. Message is as follows:' \\\n                                     '\\n {message}\\n{message_two}'.format(message=modified['content']['message'],\n                                                                          message_two=deleted['content']['message'])\n\n        # unable to create it\n        else:\n            ret = _load_result(new, ret)\n    # an error occurred\n    else:\n        ret = _load_result(existing, ret)\n\n    return ret", "code_tokens": ["def", "manage_node", "(", "hostname", ",", "username", ",", "password", ",", "name", ",", "address", ",", "connection_limit", "=", "None", ",", "description", "=", "None", ",", "dynamic_ratio", "=", "None", ",", "logging", "=", "None", ",", "monitor", "=", "None", ",", "rate_limit", "=", "None", ",", "ratio", "=", "None", ",", "session", "=", "None", ",", "node_state", "=", "None", ")", ":", "ret", "=", "{", "'name'", ":", "name", ",", "'changes'", ":", "{", "}", ",", "'result'", ":", "False", ",", "'comment'", ":", "''", "}", "if", "__opts__", "[", "'test'", "]", ":", "return", "_test_output", "(", "ret", ",", "'manage'", ",", "params", "=", "{", "'hostname'", ":", "hostname", ",", "'username'", ":", "username", ",", "'password'", ":", "password", ",", "'name'", ":", "name", ",", "'address'", ":", "address", ",", "'connection_limit'", ":", "connection_limit", ",", "'description'", ":", "description", ",", "'dynamic_ratio'", ":", "dynamic_ratio", ",", "'logging'", ":", "logging", ",", "'monitor'", ":", "monitor", ",", "'rate_limit'", ":", "rate_limit", ",", "'ratio'", ":", "ratio", ",", "'session'", ":", "session", ",", "'state:'", ":", "node_state", "}", ")", "#is this node currently configured?", "existing", "=", "__salt__", "[", "'bigip.list_node'", "]", "(", "hostname", ",", "username", ",", "password", ",", "name", ")", "# if it exists by name", "if", "existing", "[", "'code'", "]", "==", "200", ":", "# ensure the address is the same, we don't want to modify a different node than what", "# we think we are managing", "if", "existing", "[", "'content'", "]", "[", "'address'", "]", "!=", "address", ":", "ret", "[", "'result'", "]", "=", "False", "ret", "[", "'comment'", "]", "=", "'A node with this name exists but the address does not match.'", "modified", "=", "__salt__", "[", "'bigip.modify_node'", "]", "(", "hostname", "=", "hostname", ",", "username", "=", "username", ",", "password", "=", "password", ",", "name", "=", "name", ",", "connection_limit", "=", "connection_limit", ",", "description", "=", "description", ",", "dynamic_ratio", "=", "dynamic_ratio", ",", "logging", "=", "logging", ",", "monitor", "=", "monitor", ",", "rate_limit", "=", "rate_limit", ",", "ratio", "=", "ratio", ",", "session", "=", "session", ",", "state", "=", "node_state", ")", "#was the modification successful?", "if", "modified", "[", "'code'", "]", "==", "200", ":", "ret", "=", "_check_for_changes", "(", "'Node'", ",", "ret", ",", "existing", ",", "modified", ")", "else", ":", "ret", "=", "_load_result", "(", "modified", ",", "ret", ")", "# not found, attempt to create it", "elif", "existing", "[", "'code'", "]", "==", "404", ":", "new", "=", "__salt__", "[", "'bigip.create_node'", "]", "(", "hostname", ",", "username", ",", "password", ",", "name", ",", "address", ")", "# were we able to create it?", "if", "new", "[", "'code'", "]", "==", "200", ":", "# try modification", "modified", "=", "__salt__", "[", "'bigip.modify_node'", "]", "(", "hostname", "=", "hostname", ",", "username", "=", "username", ",", "password", "=", "password", ",", "name", "=", "name", ",", "connection_limit", "=", "connection_limit", ",", "description", "=", "description", ",", "dynamic_ratio", "=", "dynamic_ratio", ",", "logging", "=", "logging", ",", "monitor", "=", "monitor", ",", "rate_limit", "=", "rate_limit", ",", "ratio", "=", "ratio", ",", "session", "=", "session", ",", "state", "=", "node_state", ")", "#was the modification successful?", "if", "modified", "[", "'code'", "]", "==", "200", ":", "ret", "[", "'result'", "]", "=", "True", "ret", "[", "'comment'", "]", "=", "'Node was created and enforced to the desired state.  Note: Only parameters specified '", "'were enforced.  See changes for details.'", "ret", "[", "'changes'", "]", "[", "'old'", "]", "=", "{", "}", "ret", "[", "'changes'", "]", "[", "'new'", "]", "=", "modified", "[", "'content'", "]", "# roll it back", "else", ":", "deleted", "=", "__salt__", "[", "'bigip.delete_node'", "]", "(", "hostname", ",", "username", ",", "password", ",", "name", ")", "# did we get rid of it?", "if", "deleted", "[", "'code'", "]", "==", "200", ":", "ret", "[", "'comment'", "]", "=", "'Node was successfully created but an error occurred during modification. '", "'The creation of the node has been rolled back. Message is as follows:\\n'", "'{message}'", ".", "format", "(", "message", "=", "modified", "[", "'content'", "]", "[", "'message'", "]", ")", "# something bad happened", "else", ":", "ret", "[", "'comment'", "]", "=", "'Node was successfully created but an error occurred during modification. '", "'The creation of the node was not able to be rolled back. Message is as follows:'", "'\\n {message}\\n{message_two}'", ".", "format", "(", "message", "=", "modified", "[", "'content'", "]", "[", "'message'", "]", ",", "message_two", "=", "deleted", "[", "'content'", "]", "[", "'message'", "]", ")", "# unable to create it", "else", ":", "ret", "=", "_load_result", "(", "new", ",", "ret", ")", "# an error occurred", "else", ":", "ret", "=", "_load_result", "(", "existing", ",", "ret", ")", "return", "ret"], "docstring": "Manages a node of a given bigip device.  If the node does not exist it will be created, otherwise,\n    only the properties which are different than the existing will be updated.\n\n    hostname\n        The host/address of the bigip device\n    username\n        The iControl REST username\n    password\n        The iControl REST password\n    name\n        The name of the node to manage.\n    address\n        The address of the node\n    connection_limit\n        [integer]\n    description\n        [string]\n    dynam\n        c_ratio:        [integer]\n    logging\n        [enabled | disabled]\n    monitor\n        [[name] | none | default]\n    rate_limit\n        [integer]\n    ratio\n        [integer]\n    session\n        [user-enabled | user-disabled]\n    node_state (state)\n        [user-down | user-up ]", "docstring_tokens": ["Manages", "a", "node", "of", "a", "given", "bigip", "device", ".", "If", "the", "node", "does", "not", "exist", "it", "will", "be", "created", "otherwise", "only", "the", "properties", "which", "are", "different", "than", "the", "existing", "will", "be", "updated", "."], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/states/bigip.py#L218-L369", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/states/bigip.py", "func_name": "modify_node", "original_string": "def modify_node(hostname, username, password, name,\n                connection_limit=None,\n                description=None,\n                dynamic_ratio=None,\n                logging=None,\n                monitor=None,\n                rate_limit=None,\n                ratio=None,\n                session=None,\n                node_state=None):\n    '''\n    Modify an existing node. Only a node which already exists will be modified and\n    only the parameters specified will be enforced.\n\n    hostname\n        The host/address of the bigip device\n    username\n        The iControl REST username\n    password\n        The iControl REST password\n    name\n        The name of the node to modify\n    connection_limit\n        [integer]\n    description\n        [string]\n    dynamic_ratio\n        [integer]\n    logging\n        [enabled | disabled]\n    monitor\n        [[name] | none | default]\n    rate_limit\n        [integer]\n    ratio\n        [integer]\n    session\n        [user-enabled | user-disabled]\n    node_state (state)\n        [user-down | user-up ]\n    '''\n\n    ret = {'name': name, 'changes': {}, 'result': False, 'comment': ''}\n\n    if __opts__['test']:\n        return _test_output(ret, 'modify', params={\n            'hostname': hostname,\n            'username': username,\n            'password': password,\n            'name': name,\n            'connection_limit': connection_limit,\n            'description': description,\n            'dynamic_ratio': dynamic_ratio,\n            'logging': logging,\n            'monitor': monitor,\n            'rate_limit': rate_limit,\n            'ratio': ratio,\n            'session': session,\n            'state:': node_state\n        }\n        )\n\n    #is this node currently configured?\n    existing = __salt__['bigip.list_node'](hostname, username, password, name)\n\n    # if it exists by name\n    if existing['code'] == 200:\n\n        modified = __salt__['bigip.modify_node'](hostname=hostname,\n                                                 username=username,\n                                                 password=password,\n                                                 name=name,\n                                                 connection_limit=connection_limit,\n                                                 description=description,\n                                                 dynamic_ratio=dynamic_ratio,\n                                                 logging=logging,\n                                                 monitor=monitor,\n                                                 rate_limit=rate_limit,\n                                                 ratio=ratio,\n                                                 session=session,\n                                                 state=node_state)\n\n        #was the modification successful?\n        if modified['code'] == 200:\n            ret = _check_for_changes('Node', ret, existing, modified)\n        else:\n            ret = _load_result(modified, ret)\n\n    # not found, attempt to create it\n    elif existing['code'] == 404:\n        ret['comment'] = 'A node with this name was not found.'\n    # an error occurred\n    else:\n        ret = _load_result(existing, ret)\n\n    return ret", "language": "python", "code": "def modify_node(hostname, username, password, name,\n                connection_limit=None,\n                description=None,\n                dynamic_ratio=None,\n                logging=None,\n                monitor=None,\n                rate_limit=None,\n                ratio=None,\n                session=None,\n                node_state=None):\n    '''\n    Modify an existing node. Only a node which already exists will be modified and\n    only the parameters specified will be enforced.\n\n    hostname\n        The host/address of the bigip device\n    username\n        The iControl REST username\n    password\n        The iControl REST password\n    name\n        The name of the node to modify\n    connection_limit\n        [integer]\n    description\n        [string]\n    dynamic_ratio\n        [integer]\n    logging\n        [enabled | disabled]\n    monitor\n        [[name] | none | default]\n    rate_limit\n        [integer]\n    ratio\n        [integer]\n    session\n        [user-enabled | user-disabled]\n    node_state (state)\n        [user-down | user-up ]\n    '''\n\n    ret = {'name': name, 'changes': {}, 'result': False, 'comment': ''}\n\n    if __opts__['test']:\n        return _test_output(ret, 'modify', params={\n            'hostname': hostname,\n            'username': username,\n            'password': password,\n            'name': name,\n            'connection_limit': connection_limit,\n            'description': description,\n            'dynamic_ratio': dynamic_ratio,\n            'logging': logging,\n            'monitor': monitor,\n            'rate_limit': rate_limit,\n            'ratio': ratio,\n            'session': session,\n            'state:': node_state\n        }\n        )\n\n    #is this node currently configured?\n    existing = __salt__['bigip.list_node'](hostname, username, password, name)\n\n    # if it exists by name\n    if existing['code'] == 200:\n\n        modified = __salt__['bigip.modify_node'](hostname=hostname,\n                                                 username=username,\n                                                 password=password,\n                                                 name=name,\n                                                 connection_limit=connection_limit,\n                                                 description=description,\n                                                 dynamic_ratio=dynamic_ratio,\n                                                 logging=logging,\n                                                 monitor=monitor,\n                                                 rate_limit=rate_limit,\n                                                 ratio=ratio,\n                                                 session=session,\n                                                 state=node_state)\n\n        #was the modification successful?\n        if modified['code'] == 200:\n            ret = _check_for_changes('Node', ret, existing, modified)\n        else:\n            ret = _load_result(modified, ret)\n\n    # not found, attempt to create it\n    elif existing['code'] == 404:\n        ret['comment'] = 'A node with this name was not found.'\n    # an error occurred\n    else:\n        ret = _load_result(existing, ret)\n\n    return ret", "code_tokens": ["def", "modify_node", "(", "hostname", ",", "username", ",", "password", ",", "name", ",", "connection_limit", "=", "None", ",", "description", "=", "None", ",", "dynamic_ratio", "=", "None", ",", "logging", "=", "None", ",", "monitor", "=", "None", ",", "rate_limit", "=", "None", ",", "ratio", "=", "None", ",", "session", "=", "None", ",", "node_state", "=", "None", ")", ":", "ret", "=", "{", "'name'", ":", "name", ",", "'changes'", ":", "{", "}", ",", "'result'", ":", "False", ",", "'comment'", ":", "''", "}", "if", "__opts__", "[", "'test'", "]", ":", "return", "_test_output", "(", "ret", ",", "'modify'", ",", "params", "=", "{", "'hostname'", ":", "hostname", ",", "'username'", ":", "username", ",", "'password'", ":", "password", ",", "'name'", ":", "name", ",", "'connection_limit'", ":", "connection_limit", ",", "'description'", ":", "description", ",", "'dynamic_ratio'", ":", "dynamic_ratio", ",", "'logging'", ":", "logging", ",", "'monitor'", ":", "monitor", ",", "'rate_limit'", ":", "rate_limit", ",", "'ratio'", ":", "ratio", ",", "'session'", ":", "session", ",", "'state:'", ":", "node_state", "}", ")", "#is this node currently configured?", "existing", "=", "__salt__", "[", "'bigip.list_node'", "]", "(", "hostname", ",", "username", ",", "password", ",", "name", ")", "# if it exists by name", "if", "existing", "[", "'code'", "]", "==", "200", ":", "modified", "=", "__salt__", "[", "'bigip.modify_node'", "]", "(", "hostname", "=", "hostname", ",", "username", "=", "username", ",", "password", "=", "password", ",", "name", "=", "name", ",", "connection_limit", "=", "connection_limit", ",", "description", "=", "description", ",", "dynamic_ratio", "=", "dynamic_ratio", ",", "logging", "=", "logging", ",", "monitor", "=", "monitor", ",", "rate_limit", "=", "rate_limit", ",", "ratio", "=", "ratio", ",", "session", "=", "session", ",", "state", "=", "node_state", ")", "#was the modification successful?", "if", "modified", "[", "'code'", "]", "==", "200", ":", "ret", "=", "_check_for_changes", "(", "'Node'", ",", "ret", ",", "existing", ",", "modified", ")", "else", ":", "ret", "=", "_load_result", "(", "modified", ",", "ret", ")", "# not found, attempt to create it", "elif", "existing", "[", "'code'", "]", "==", "404", ":", "ret", "[", "'comment'", "]", "=", "'A node with this name was not found.'", "# an error occurred", "else", ":", "ret", "=", "_load_result", "(", "existing", ",", "ret", ")", "return", "ret"], "docstring": "Modify an existing node. Only a node which already exists will be modified and\n    only the parameters specified will be enforced.\n\n    hostname\n        The host/address of the bigip device\n    username\n        The iControl REST username\n    password\n        The iControl REST password\n    name\n        The name of the node to modify\n    connection_limit\n        [integer]\n    description\n        [string]\n    dynamic_ratio\n        [integer]\n    logging\n        [enabled | disabled]\n    monitor\n        [[name] | none | default]\n    rate_limit\n        [integer]\n    ratio\n        [integer]\n    session\n        [user-enabled | user-disabled]\n    node_state (state)\n        [user-down | user-up ]", "docstring_tokens": ["Modify", "an", "existing", "node", ".", "Only", "a", "node", "which", "already", "exists", "will", "be", "modified", "and", "only", "the", "parameters", "specified", "will", "be", "enforced", "."], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/states/bigip.py#L372-L467", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/states/bigip.py", "func_name": "create_pool", "original_string": "def create_pool(hostname, username, password, name, members=None,\n                allow_nat=None,\n                allow_snat=None,\n                description=None,\n                gateway_failsafe_device=None,\n                ignore_persisted_weight=None,\n                ip_tos_to_client=None,\n                ip_tos_to_server=None,\n                link_qos_to_client=None,\n                link_qos_to_server=None,\n                load_balancing_mode=None,\n                min_active_members=None,\n                min_up_members=None,\n                min_up_members_action=None,\n                min_up_members_checking=None,\n                monitor=None,\n                profiles=None,\n                queue_depth_limit=None,\n                queue_on_connection_limit=None,\n                queue_time_limit=None,\n                reselect_tries=None,\n                service_down_action=None,\n                slow_ramp_time=None):\n    '''\n    Create a new node if it does not already exist.\n\n    hostname\n        The host/address of the bigip device\n    username\n        The iControl REST username\n    password\n        The iControl REST password\n    name\n        The name of the pool to create\n    members\n        List of members to be added to the pool\n    allow_nat\n        [yes | no]\n    allow_snat\n        [yes | no]\n    description\n        [string]\n    gateway_failsafe_device\n        [string]\n    ignore_persisted_weight\n        [enabled | disabled]\n    ip_tos_to_client\n        [pass-through | [integer]]\n    ip_tos_to_server\n        [pass-through | [integer]]\n    link_qos_to_client\n        [pass-through | [integer]]\n    link_qos_to_server\n        [pass-through | [integer]]\n    load_balancing_mode\n        [dynamic-ratio-member | dynamic-ratio-node |\n        fastest-app-response | fastest-node |\n        least-connections-members |\n        least-connections-node |\n        least-sessions |\n        observed-member | observed-node |\n        predictive-member | predictive-node |\n        ratio-least-connections-member |\n        ratio-least-connections-node |\n        ratio-member | ratio-node | ratio-session |\n        round-robin | weighted-least-connections-member |\n        weighted-least-connections-node]\n    min_active_members\n        [integer]\n    min_up_members\n        [integer]\n    min_up_members_action\n        [failover | reboot | restart-all]\n    min_up_members_checking\n        [enabled | disabled]\n    monitor\n        [name]\n    profiles\n        [none | profile_name]\n    queue_depth_limit\n        [integer]\n    queue_on_connection_limit\n        [enabled | disabled]\n    queue_time_limit\n        [integer]\n    reselect_tries\n        [integer]\n    service_down_action\n        [drop | none | reselect | reset]\n    slow_ramp_time\n        [integer]\n    '''\n\n    ret = {'name': name, 'changes': {}, 'result': False, 'comment': ''}\n\n    if __opts__['test']:\n        return _test_output(ret, 'create', params={\n            'hostname': hostname,\n            'username': username,\n            'password': password,\n            'name': name,\n            'members': members,\n            'allow_nat': allow_nat,\n            'allow_snat': allow_snat,\n            'description': description,\n            'gateway_failsafe_device': gateway_failsafe_device,\n            'ignore_persisted_weight': ignore_persisted_weight,\n            'ip_tos_client:': ip_tos_to_client,\n            'ip_tos_server': ip_tos_to_server,\n            'link_qos_to_client': link_qos_to_client,\n            'link_qos_to_server': link_qos_to_server,\n            'load_balancing_mode': load_balancing_mode,\n            'min_active_members': min_active_members,\n            'min_up_members': min_up_members,\n            'min_up_members_checking': min_up_members_checking,\n            'monitor': monitor,\n            'profiles': profiles,\n            'queue_depth_limit': queue_depth_limit,\n            'queue_on_connection_limit': queue_on_connection_limit,\n            'queue_time_limit': queue_time_limit,\n            'reselect_tries': reselect_tries,\n            'service_down_action': service_down_action,\n            'slow_ramp_time': slow_ramp_time\n            }\n        )\n\n    #is this pool currently configured?\n    existing = __salt__['bigip.list_pool'](hostname, username, password, name)\n\n    # if it exists\n    if existing['code'] == 200:\n\n        ret['result'] = True\n        ret['comment'] = 'A pool by this name currently exists.  No change made.'\n\n    # if it doesn't exist\n    elif existing['code'] == 404:\n\n        response = __salt__['bigip.create_pool'](hostname=hostname,\n                                                 username=username,\n                                                 password=password,\n                                                 name=name,\n                                                 members=members,\n                                                 allow_nat=allow_nat,\n                                                 allow_snat=allow_snat,\n                                                 description=description,\n                                                 gateway_failsafe_device=gateway_failsafe_device,\n                                                 ignore_persisted_weight=ignore_persisted_weight,\n                                                 ip_tos_to_client=ip_tos_to_client,\n                                                 ip_tos_to_server=ip_tos_to_server,\n                                                 link_qos_to_client=link_qos_to_client,\n                                                 link_qos_to_server=link_qos_to_server,\n                                                 load_balancing_mode=load_balancing_mode,\n                                                 min_active_members=min_active_members,\n                                                 min_up_members=min_up_members,\n                                                 min_up_members_action=min_up_members_action,\n                                                 min_up_members_checking=min_up_members_checking,\n                                                 monitor=monitor,\n                                                 profiles=profiles,\n                                                 queue_depth_limit=queue_depth_limit,\n                                                 queue_on_connection_limit=queue_on_connection_limit,\n                                                 queue_time_limit=queue_time_limit,\n                                                 reselect_tries=reselect_tries,\n                                                 service_down_action=service_down_action,\n                                                 slow_ramp_time=slow_ramp_time)\n        if response['code'] == 200:\n            ret['result'] = True\n            ret['changes']['old'] = {}\n            ret['changes']['new'] = response['content']\n            ret['comment'] = 'Pool was successfully created.'\n        else:\n            ret = _load_result(existing, ret)\n\n    # else something else was returned\n    else:\n        ret = _load_result(existing, ret)\n\n    return ret", "language": "python", "code": "def create_pool(hostname, username, password, name, members=None,\n                allow_nat=None,\n                allow_snat=None,\n                description=None,\n                gateway_failsafe_device=None,\n                ignore_persisted_weight=None,\n                ip_tos_to_client=None,\n                ip_tos_to_server=None,\n                link_qos_to_client=None,\n                link_qos_to_server=None,\n                load_balancing_mode=None,\n                min_active_members=None,\n                min_up_members=None,\n                min_up_members_action=None,\n                min_up_members_checking=None,\n                monitor=None,\n                profiles=None,\n                queue_depth_limit=None,\n                queue_on_connection_limit=None,\n                queue_time_limit=None,\n                reselect_tries=None,\n                service_down_action=None,\n                slow_ramp_time=None):\n    '''\n    Create a new node if it does not already exist.\n\n    hostname\n        The host/address of the bigip device\n    username\n        The iControl REST username\n    password\n        The iControl REST password\n    name\n        The name of the pool to create\n    members\n        List of members to be added to the pool\n    allow_nat\n        [yes | no]\n    allow_snat\n        [yes | no]\n    description\n        [string]\n    gateway_failsafe_device\n        [string]\n    ignore_persisted_weight\n        [enabled | disabled]\n    ip_tos_to_client\n        [pass-through | [integer]]\n    ip_tos_to_server\n        [pass-through | [integer]]\n    link_qos_to_client\n        [pass-through | [integer]]\n    link_qos_to_server\n        [pass-through | [integer]]\n    load_balancing_mode\n        [dynamic-ratio-member | dynamic-ratio-node |\n        fastest-app-response | fastest-node |\n        least-connections-members |\n        least-connections-node |\n        least-sessions |\n        observed-member | observed-node |\n        predictive-member | predictive-node |\n        ratio-least-connections-member |\n        ratio-least-connections-node |\n        ratio-member | ratio-node | ratio-session |\n        round-robin | weighted-least-connections-member |\n        weighted-least-connections-node]\n    min_active_members\n        [integer]\n    min_up_members\n        [integer]\n    min_up_members_action\n        [failover | reboot | restart-all]\n    min_up_members_checking\n        [enabled | disabled]\n    monitor\n        [name]\n    profiles\n        [none | profile_name]\n    queue_depth_limit\n        [integer]\n    queue_on_connection_limit\n        [enabled | disabled]\n    queue_time_limit\n        [integer]\n    reselect_tries\n        [integer]\n    service_down_action\n        [drop | none | reselect | reset]\n    slow_ramp_time\n        [integer]\n    '''\n\n    ret = {'name': name, 'changes': {}, 'result': False, 'comment': ''}\n\n    if __opts__['test']:\n        return _test_output(ret, 'create', params={\n            'hostname': hostname,\n            'username': username,\n            'password': password,\n            'name': name,\n            'members': members,\n            'allow_nat': allow_nat,\n            'allow_snat': allow_snat,\n            'description': description,\n            'gateway_failsafe_device': gateway_failsafe_device,\n            'ignore_persisted_weight': ignore_persisted_weight,\n            'ip_tos_client:': ip_tos_to_client,\n            'ip_tos_server': ip_tos_to_server,\n            'link_qos_to_client': link_qos_to_client,\n            'link_qos_to_server': link_qos_to_server,\n            'load_balancing_mode': load_balancing_mode,\n            'min_active_members': min_active_members,\n            'min_up_members': min_up_members,\n            'min_up_members_checking': min_up_members_checking,\n            'monitor': monitor,\n            'profiles': profiles,\n            'queue_depth_limit': queue_depth_limit,\n            'queue_on_connection_limit': queue_on_connection_limit,\n            'queue_time_limit': queue_time_limit,\n            'reselect_tries': reselect_tries,\n            'service_down_action': service_down_action,\n            'slow_ramp_time': slow_ramp_time\n            }\n        )\n\n    #is this pool currently configured?\n    existing = __salt__['bigip.list_pool'](hostname, username, password, name)\n\n    # if it exists\n    if existing['code'] == 200:\n\n        ret['result'] = True\n        ret['comment'] = 'A pool by this name currently exists.  No change made.'\n\n    # if it doesn't exist\n    elif existing['code'] == 404:\n\n        response = __salt__['bigip.create_pool'](hostname=hostname,\n                                                 username=username,\n                                                 password=password,\n                                                 name=name,\n                                                 members=members,\n                                                 allow_nat=allow_nat,\n                                                 allow_snat=allow_snat,\n                                                 description=description,\n                                                 gateway_failsafe_device=gateway_failsafe_device,\n                                                 ignore_persisted_weight=ignore_persisted_weight,\n                                                 ip_tos_to_client=ip_tos_to_client,\n                                                 ip_tos_to_server=ip_tos_to_server,\n                                                 link_qos_to_client=link_qos_to_client,\n                                                 link_qos_to_server=link_qos_to_server,\n                                                 load_balancing_mode=load_balancing_mode,\n                                                 min_active_members=min_active_members,\n                                                 min_up_members=min_up_members,\n                                                 min_up_members_action=min_up_members_action,\n                                                 min_up_members_checking=min_up_members_checking,\n                                                 monitor=monitor,\n                                                 profiles=profiles,\n                                                 queue_depth_limit=queue_depth_limit,\n                                                 queue_on_connection_limit=queue_on_connection_limit,\n                                                 queue_time_limit=queue_time_limit,\n                                                 reselect_tries=reselect_tries,\n                                                 service_down_action=service_down_action,\n                                                 slow_ramp_time=slow_ramp_time)\n        if response['code'] == 200:\n            ret['result'] = True\n            ret['changes']['old'] = {}\n            ret['changes']['new'] = response['content']\n            ret['comment'] = 'Pool was successfully created.'\n        else:\n            ret = _load_result(existing, ret)\n\n    # else something else was returned\n    else:\n        ret = _load_result(existing, ret)\n\n    return ret", "code_tokens": ["def", "create_pool", "(", "hostname", ",", "username", ",", "password", ",", "name", ",", "members", "=", "None", ",", "allow_nat", "=", "None", ",", "allow_snat", "=", "None", ",", "description", "=", "None", ",", "gateway_failsafe_device", "=", "None", ",", "ignore_persisted_weight", "=", "None", ",", "ip_tos_to_client", "=", "None", ",", "ip_tos_to_server", "=", "None", ",", "link_qos_to_client", "=", "None", ",", "link_qos_to_server", "=", "None", ",", "load_balancing_mode", "=", "None", ",", "min_active_members", "=", "None", ",", "min_up_members", "=", "None", ",", "min_up_members_action", "=", "None", ",", "min_up_members_checking", "=", "None", ",", "monitor", "=", "None", ",", "profiles", "=", "None", ",", "queue_depth_limit", "=", "None", ",", "queue_on_connection_limit", "=", "None", ",", "queue_time_limit", "=", "None", ",", "reselect_tries", "=", "None", ",", "service_down_action", "=", "None", ",", "slow_ramp_time", "=", "None", ")", ":", "ret", "=", "{", "'name'", ":", "name", ",", "'changes'", ":", "{", "}", ",", "'result'", ":", "False", ",", "'comment'", ":", "''", "}", "if", "__opts__", "[", "'test'", "]", ":", "return", "_test_output", "(", "ret", ",", "'create'", ",", "params", "=", "{", "'hostname'", ":", "hostname", ",", "'username'", ":", "username", ",", "'password'", ":", "password", ",", "'name'", ":", "name", ",", "'members'", ":", "members", ",", "'allow_nat'", ":", "allow_nat", ",", "'allow_snat'", ":", "allow_snat", ",", "'description'", ":", "description", ",", "'gateway_failsafe_device'", ":", "gateway_failsafe_device", ",", "'ignore_persisted_weight'", ":", "ignore_persisted_weight", ",", "'ip_tos_client:'", ":", "ip_tos_to_client", ",", "'ip_tos_server'", ":", "ip_tos_to_server", ",", "'link_qos_to_client'", ":", "link_qos_to_client", ",", "'link_qos_to_server'", ":", "link_qos_to_server", ",", "'load_balancing_mode'", ":", "load_balancing_mode", ",", "'min_active_members'", ":", "min_active_members", ",", "'min_up_members'", ":", "min_up_members", ",", "'min_up_members_checking'", ":", "min_up_members_checking", ",", "'monitor'", ":", "monitor", ",", "'profiles'", ":", "profiles", ",", "'queue_depth_limit'", ":", "queue_depth_limit", ",", "'queue_on_connection_limit'", ":", "queue_on_connection_limit", ",", "'queue_time_limit'", ":", "queue_time_limit", ",", "'reselect_tries'", ":", "reselect_tries", ",", "'service_down_action'", ":", "service_down_action", ",", "'slow_ramp_time'", ":", "slow_ramp_time", "}", ")", "#is this pool currently configured?", "existing", "=", "__salt__", "[", "'bigip.list_pool'", "]", "(", "hostname", ",", "username", ",", "password", ",", "name", ")", "# if it exists", "if", "existing", "[", "'code'", "]", "==", "200", ":", "ret", "[", "'result'", "]", "=", "True", "ret", "[", "'comment'", "]", "=", "'A pool by this name currently exists.  No change made.'", "# if it doesn't exist", "elif", "existing", "[", "'code'", "]", "==", "404", ":", "response", "=", "__salt__", "[", "'bigip.create_pool'", "]", "(", "hostname", "=", "hostname", ",", "username", "=", "username", ",", "password", "=", "password", ",", "name", "=", "name", ",", "members", "=", "members", ",", "allow_nat", "=", "allow_nat", ",", "allow_snat", "=", "allow_snat", ",", "description", "=", "description", ",", "gateway_failsafe_device", "=", "gateway_failsafe_device", ",", "ignore_persisted_weight", "=", "ignore_persisted_weight", ",", "ip_tos_to_client", "=", "ip_tos_to_client", ",", "ip_tos_to_server", "=", "ip_tos_to_server", ",", "link_qos_to_client", "=", "link_qos_to_client", ",", "link_qos_to_server", "=", "link_qos_to_server", ",", "load_balancing_mode", "=", "load_balancing_mode", ",", "min_active_members", "=", "min_active_members", ",", "min_up_members", "=", "min_up_members", ",", "min_up_members_action", "=", "min_up_members_action", ",", "min_up_members_checking", "=", "min_up_members_checking", ",", "monitor", "=", "monitor", ",", "profiles", "=", "profiles", ",", "queue_depth_limit", "=", "queue_depth_limit", ",", "queue_on_connection_limit", "=", "queue_on_connection_limit", ",", "queue_time_limit", "=", "queue_time_limit", ",", "reselect_tries", "=", "reselect_tries", ",", "service_down_action", "=", "service_down_action", ",", "slow_ramp_time", "=", "slow_ramp_time", ")", "if", "response", "[", "'code'", "]", "==", "200", ":", "ret", "[", "'result'", "]", "=", "True", "ret", "[", "'changes'", "]", "[", "'old'", "]", "=", "{", "}", "ret", "[", "'changes'", "]", "[", "'new'", "]", "=", "response", "[", "'content'", "]", "ret", "[", "'comment'", "]", "=", "'Pool was successfully created.'", "else", ":", "ret", "=", "_load_result", "(", "existing", ",", "ret", ")", "# else something else was returned", "else", ":", "ret", "=", "_load_result", "(", "existing", ",", "ret", ")", "return", "ret"], "docstring": "Create a new node if it does not already exist.\n\n    hostname\n        The host/address of the bigip device\n    username\n        The iControl REST username\n    password\n        The iControl REST password\n    name\n        The name of the pool to create\n    members\n        List of members to be added to the pool\n    allow_nat\n        [yes | no]\n    allow_snat\n        [yes | no]\n    description\n        [string]\n    gateway_failsafe_device\n        [string]\n    ignore_persisted_weight\n        [enabled | disabled]\n    ip_tos_to_client\n        [pass-through | [integer]]\n    ip_tos_to_server\n        [pass-through | [integer]]\n    link_qos_to_client\n        [pass-through | [integer]]\n    link_qos_to_server\n        [pass-through | [integer]]\n    load_balancing_mode\n        [dynamic-ratio-member | dynamic-ratio-node |\n        fastest-app-response | fastest-node |\n        least-connections-members |\n        least-connections-node |\n        least-sessions |\n        observed-member | observed-node |\n        predictive-member | predictive-node |\n        ratio-least-connections-member |\n        ratio-least-connections-node |\n        ratio-member | ratio-node | ratio-session |\n        round-robin | weighted-least-connections-member |\n        weighted-least-connections-node]\n    min_active_members\n        [integer]\n    min_up_members\n        [integer]\n    min_up_members_action\n        [failover | reboot | restart-all]\n    min_up_members_checking\n        [enabled | disabled]\n    monitor\n        [name]\n    profiles\n        [none | profile_name]\n    queue_depth_limit\n        [integer]\n    queue_on_connection_limit\n        [enabled | disabled]\n    queue_time_limit\n        [integer]\n    reselect_tries\n        [integer]\n    service_down_action\n        [drop | none | reselect | reset]\n    slow_ramp_time\n        [integer]", "docstring_tokens": ["Create", "a", "new", "node", "if", "it", "does", "not", "already", "exist", "."], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/states/bigip.py#L554-L731", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/states/bigip.py", "func_name": "manage_pool", "original_string": "def manage_pool(hostname, username, password, name,\n                allow_nat=None,\n                allow_snat=None,\n                description=None,\n                gateway_failsafe_device=None,\n                ignore_persisted_weight=None,\n                ip_tos_to_client=None,\n                ip_tos_to_server=None,\n                link_qos_to_client=None,\n                link_qos_to_server=None,\n                load_balancing_mode=None,\n                min_active_members=None,\n                min_up_members=None,\n                min_up_members_action=None,\n                min_up_members_checking=None,\n                monitor=None,\n                profiles=None,\n                queue_depth_limit=None,\n                queue_on_connection_limit=None,\n                queue_time_limit=None,\n                reselect_tries=None,\n                service_down_action=None,\n                slow_ramp_time=None):\n    '''\n    Create a new pool if it does not already exist. Pool members are managed separately. Only the\n    parameters specified are enforced.\n\n    hostname\n        The host/address of the bigip device\n    username\n        The iControl REST username\n    password\n        The iControl REST password\n    name\n        The name of the pool to create\n    allow_nat\n        [yes | no]\n    allow_snat\n        [yes | no]\n    description\n        [string]\n    gateway_failsafe_device\n        [string]\n    ignore_persisted_weight\n        [enabled | disabled]\n    ip_tos_to_client\n        [pass-through | [integer]]\n    ip_tos_to_server\n        [pass-through | [integer]]\n    link_qos_to_client\n        [pass-through | [integer]]\n    link_qos_to_server\n        [pass-through | [integer]]\n    load_balancing_mode\n        [dynamic-ratio-member | dynamic-ratio-node |\n        fastest-app-response | fastest-node |\n        least-connections-members |\n        least-connections-node |\n        least-sessions |\n        observed-member | observed-node |\n        predictive-member | predictive-node |\n        ratio-least-connections-member |\n        ratio-least-connections-node |\n        ratio-member | ratio-node | ratio-session |\n        round-robin | weighted-least-connections-member |\n        weighted-least-connections-node]\n    min_active_members\n        [integer]\n    min_up_members\n        [integer]\n    min_up_members_action\n        [failover | reboot | restart-all]\n    min_up_members_checking\n        [enabled | disabled]\n    monitor\n        [name]\n    profiles\n        [none | profile_name]\n    queue_depth_limit\n        [integer]\n    queue_on_connection_limit\n        [enabled | disabled]\n    queue_time_limit\n        [integer]\n    reselect_tries\n        [integer]\n    service_down_action\n        [drop | none | reselect | reset]\n    slow_ramp_time\n        [integer]\n\n    '''\n\n    ret = {'name': name, 'changes': {}, 'result': False, 'comment': ''}\n\n    if __opts__['test']:\n        return _test_output(ret, 'manage', params={\n            'hostname': hostname,\n            'username': username,\n            'password': password,\n            'name': name,\n            'allow_nat': allow_nat,\n            'allow_snat': allow_snat,\n            'description': description,\n            'gateway_failsafe_device': gateway_failsafe_device,\n            'ignore_persisted_weight': ignore_persisted_weight,\n            'ip_tos_client:': ip_tos_to_client,\n            'ip_tos_server': ip_tos_to_server,\n            'link_qos_to_client': link_qos_to_client,\n            'link_qos_to_server': link_qos_to_server,\n            'load_balancing_mode': load_balancing_mode,\n            'min_active_members': min_active_members,\n            'min_up_members': min_up_members,\n            'min_up_members_checking': min_up_members_checking,\n            'monitor': monitor,\n            'profiles': profiles,\n            'queue_depth_limit': queue_depth_limit,\n            'queue_on_connection_limit': queue_on_connection_limit,\n            'queue_time_limit': queue_time_limit,\n            'reselect_tries': reselect_tries,\n            'service_down_action': service_down_action,\n            'slow_ramp_time': slow_ramp_time\n        }\n        )\n\n    #is this pool currently configured?\n    existing = __salt__['bigip.list_pool'](hostname, username, password, name)\n\n    # if it exists\n    if existing['code'] == 200:\n\n        modified = __salt__['bigip.modify_pool'](hostname=hostname,\n                                                 username=username,\n                                                 password=password,\n                                                 name=name,\n                                                 allow_nat=allow_nat,\n                                                 allow_snat=allow_snat,\n                                                 description=description,\n                                                 gateway_failsafe_device=gateway_failsafe_device,\n                                                 ignore_persisted_weight=ignore_persisted_weight,\n                                                 ip_tos_to_client=ip_tos_to_client,\n                                                 ip_tos_to_server=ip_tos_to_server,\n                                                 link_qos_to_client=link_qos_to_client,\n                                                 link_qos_to_server=link_qos_to_server,\n                                                 load_balancing_mode=load_balancing_mode,\n                                                 min_active_members=min_active_members,\n                                                 min_up_members=min_up_members,\n                                                 min_up_members_action=min_up_members_action,\n                                                 min_up_members_checking=min_up_members_checking,\n                                                 monitor=monitor,\n                                                 profiles=profiles,\n                                                 queue_depth_limit=queue_depth_limit,\n                                                 queue_on_connection_limit=queue_on_connection_limit,\n                                                 queue_time_limit=queue_time_limit,\n                                                 reselect_tries=reselect_tries,\n                                                 service_down_action=service_down_action,\n                                                 slow_ramp_time=slow_ramp_time)\n\n        #was the modification successful?\n        if modified['code'] == 200:\n\n            #remove member listings and self-links\n            del existing['content']['membersReference']\n            del modified['content']['membersReference']\n            del existing['content']['selfLink']\n            del modified['content']['selfLink']\n\n            ret = _check_for_changes('Pool', ret, existing, modified)\n        else:\n            ret = _load_result(modified, ret)\n\n    # if it doesn't exist\n    elif existing['code'] == 404:\n\n        new = __salt__['bigip.create_pool'](hostname=hostname,\n                                            username=username,\n                                            password=password,\n                                            name=name,\n                                            allow_nat=allow_nat,\n                                            allow_snat=allow_snat,\n                                            description=description,\n                                            gateway_failsafe_device=gateway_failsafe_device,\n                                            ignore_persisted_weight=ignore_persisted_weight,\n                                            ip_tos_to_client=ip_tos_to_client,\n                                            ip_tos_to_server=ip_tos_to_server,\n                                            link_qos_to_client=link_qos_to_client,\n                                            link_qos_to_server=link_qos_to_server,\n                                            load_balancing_mode=load_balancing_mode,\n                                            min_active_members=min_active_members,\n                                            min_up_members=min_up_members,\n                                            min_up_members_action=min_up_members_action,\n                                            min_up_members_checking=min_up_members_checking,\n                                            monitor=monitor,\n                                            profiles=profiles,\n                                            queue_depth_limit=queue_depth_limit,\n                                            queue_on_connection_limit=queue_on_connection_limit,\n                                            queue_time_limit=queue_time_limit,\n                                            reselect_tries=reselect_tries,\n                                            service_down_action=service_down_action,\n                                            slow_ramp_time=slow_ramp_time)\n\n        # were we able to create it?\n        if new['code'] == 200:\n            ret['result'] = True\n            ret['comment'] = 'Pool was created and enforced to the desired state.  Note: Only parameters specified ' \\\n                             'were enforced.  See changes for details.'\n            ret['changes']['old'] = {}\n            ret['changes']['new'] = new['content']\n\n         # unable to create it\n        else:\n            ret = _load_result(new, ret)\n\n    # else something else was returned\n    else:\n        ret = _load_result(existing, ret)\n\n    return ret", "language": "python", "code": "def manage_pool(hostname, username, password, name,\n                allow_nat=None,\n                allow_snat=None,\n                description=None,\n                gateway_failsafe_device=None,\n                ignore_persisted_weight=None,\n                ip_tos_to_client=None,\n                ip_tos_to_server=None,\n                link_qos_to_client=None,\n                link_qos_to_server=None,\n                load_balancing_mode=None,\n                min_active_members=None,\n                min_up_members=None,\n                min_up_members_action=None,\n                min_up_members_checking=None,\n                monitor=None,\n                profiles=None,\n                queue_depth_limit=None,\n                queue_on_connection_limit=None,\n                queue_time_limit=None,\n                reselect_tries=None,\n                service_down_action=None,\n                slow_ramp_time=None):\n    '''\n    Create a new pool if it does not already exist. Pool members are managed separately. Only the\n    parameters specified are enforced.\n\n    hostname\n        The host/address of the bigip device\n    username\n        The iControl REST username\n    password\n        The iControl REST password\n    name\n        The name of the pool to create\n    allow_nat\n        [yes | no]\n    allow_snat\n        [yes | no]\n    description\n        [string]\n    gateway_failsafe_device\n        [string]\n    ignore_persisted_weight\n        [enabled | disabled]\n    ip_tos_to_client\n        [pass-through | [integer]]\n    ip_tos_to_server\n        [pass-through | [integer]]\n    link_qos_to_client\n        [pass-through | [integer]]\n    link_qos_to_server\n        [pass-through | [integer]]\n    load_balancing_mode\n        [dynamic-ratio-member | dynamic-ratio-node |\n        fastest-app-response | fastest-node |\n        least-connections-members |\n        least-connections-node |\n        least-sessions |\n        observed-member | observed-node |\n        predictive-member | predictive-node |\n        ratio-least-connections-member |\n        ratio-least-connections-node |\n        ratio-member | ratio-node | ratio-session |\n        round-robin | weighted-least-connections-member |\n        weighted-least-connections-node]\n    min_active_members\n        [integer]\n    min_up_members\n        [integer]\n    min_up_members_action\n        [failover | reboot | restart-all]\n    min_up_members_checking\n        [enabled | disabled]\n    monitor\n        [name]\n    profiles\n        [none | profile_name]\n    queue_depth_limit\n        [integer]\n    queue_on_connection_limit\n        [enabled | disabled]\n    queue_time_limit\n        [integer]\n    reselect_tries\n        [integer]\n    service_down_action\n        [drop | none | reselect | reset]\n    slow_ramp_time\n        [integer]\n\n    '''\n\n    ret = {'name': name, 'changes': {}, 'result': False, 'comment': ''}\n\n    if __opts__['test']:\n        return _test_output(ret, 'manage', params={\n            'hostname': hostname,\n            'username': username,\n            'password': password,\n            'name': name,\n            'allow_nat': allow_nat,\n            'allow_snat': allow_snat,\n            'description': description,\n            'gateway_failsafe_device': gateway_failsafe_device,\n            'ignore_persisted_weight': ignore_persisted_weight,\n            'ip_tos_client:': ip_tos_to_client,\n            'ip_tos_server': ip_tos_to_server,\n            'link_qos_to_client': link_qos_to_client,\n            'link_qos_to_server': link_qos_to_server,\n            'load_balancing_mode': load_balancing_mode,\n            'min_active_members': min_active_members,\n            'min_up_members': min_up_members,\n            'min_up_members_checking': min_up_members_checking,\n            'monitor': monitor,\n            'profiles': profiles,\n            'queue_depth_limit': queue_depth_limit,\n            'queue_on_connection_limit': queue_on_connection_limit,\n            'queue_time_limit': queue_time_limit,\n            'reselect_tries': reselect_tries,\n            'service_down_action': service_down_action,\n            'slow_ramp_time': slow_ramp_time\n        }\n        )\n\n    #is this pool currently configured?\n    existing = __salt__['bigip.list_pool'](hostname, username, password, name)\n\n    # if it exists\n    if existing['code'] == 200:\n\n        modified = __salt__['bigip.modify_pool'](hostname=hostname,\n                                                 username=username,\n                                                 password=password,\n                                                 name=name,\n                                                 allow_nat=allow_nat,\n                                                 allow_snat=allow_snat,\n                                                 description=description,\n                                                 gateway_failsafe_device=gateway_failsafe_device,\n                                                 ignore_persisted_weight=ignore_persisted_weight,\n                                                 ip_tos_to_client=ip_tos_to_client,\n                                                 ip_tos_to_server=ip_tos_to_server,\n                                                 link_qos_to_client=link_qos_to_client,\n                                                 link_qos_to_server=link_qos_to_server,\n                                                 load_balancing_mode=load_balancing_mode,\n                                                 min_active_members=min_active_members,\n                                                 min_up_members=min_up_members,\n                                                 min_up_members_action=min_up_members_action,\n                                                 min_up_members_checking=min_up_members_checking,\n                                                 monitor=monitor,\n                                                 profiles=profiles,\n                                                 queue_depth_limit=queue_depth_limit,\n                                                 queue_on_connection_limit=queue_on_connection_limit,\n                                                 queue_time_limit=queue_time_limit,\n                                                 reselect_tries=reselect_tries,\n                                                 service_down_action=service_down_action,\n                                                 slow_ramp_time=slow_ramp_time)\n\n        #was the modification successful?\n        if modified['code'] == 200:\n\n            #remove member listings and self-links\n            del existing['content']['membersReference']\n            del modified['content']['membersReference']\n            del existing['content']['selfLink']\n            del modified['content']['selfLink']\n\n            ret = _check_for_changes('Pool', ret, existing, modified)\n        else:\n            ret = _load_result(modified, ret)\n\n    # if it doesn't exist\n    elif existing['code'] == 404:\n\n        new = __salt__['bigip.create_pool'](hostname=hostname,\n                                            username=username,\n                                            password=password,\n                                            name=name,\n                                            allow_nat=allow_nat,\n                                            allow_snat=allow_snat,\n                                            description=description,\n                                            gateway_failsafe_device=gateway_failsafe_device,\n                                            ignore_persisted_weight=ignore_persisted_weight,\n                                            ip_tos_to_client=ip_tos_to_client,\n                                            ip_tos_to_server=ip_tos_to_server,\n                                            link_qos_to_client=link_qos_to_client,\n                                            link_qos_to_server=link_qos_to_server,\n                                            load_balancing_mode=load_balancing_mode,\n                                            min_active_members=min_active_members,\n                                            min_up_members=min_up_members,\n                                            min_up_members_action=min_up_members_action,\n                                            min_up_members_checking=min_up_members_checking,\n                                            monitor=monitor,\n                                            profiles=profiles,\n                                            queue_depth_limit=queue_depth_limit,\n                                            queue_on_connection_limit=queue_on_connection_limit,\n                                            queue_time_limit=queue_time_limit,\n                                            reselect_tries=reselect_tries,\n                                            service_down_action=service_down_action,\n                                            slow_ramp_time=slow_ramp_time)\n\n        # were we able to create it?\n        if new['code'] == 200:\n            ret['result'] = True\n            ret['comment'] = 'Pool was created and enforced to the desired state.  Note: Only parameters specified ' \\\n                             'were enforced.  See changes for details.'\n            ret['changes']['old'] = {}\n            ret['changes']['new'] = new['content']\n\n         # unable to create it\n        else:\n            ret = _load_result(new, ret)\n\n    # else something else was returned\n    else:\n        ret = _load_result(existing, ret)\n\n    return ret", "code_tokens": ["def", "manage_pool", "(", "hostname", ",", "username", ",", "password", ",", "name", ",", "allow_nat", "=", "None", ",", "allow_snat", "=", "None", ",", "description", "=", "None", ",", "gateway_failsafe_device", "=", "None", ",", "ignore_persisted_weight", "=", "None", ",", "ip_tos_to_client", "=", "None", ",", "ip_tos_to_server", "=", "None", ",", "link_qos_to_client", "=", "None", ",", "link_qos_to_server", "=", "None", ",", "load_balancing_mode", "=", "None", ",", "min_active_members", "=", "None", ",", "min_up_members", "=", "None", ",", "min_up_members_action", "=", "None", ",", "min_up_members_checking", "=", "None", ",", "monitor", "=", "None", ",", "profiles", "=", "None", ",", "queue_depth_limit", "=", "None", ",", "queue_on_connection_limit", "=", "None", ",", "queue_time_limit", "=", "None", ",", "reselect_tries", "=", "None", ",", "service_down_action", "=", "None", ",", "slow_ramp_time", "=", "None", ")", ":", "ret", "=", "{", "'name'", ":", "name", ",", "'changes'", ":", "{", "}", ",", "'result'", ":", "False", ",", "'comment'", ":", "''", "}", "if", "__opts__", "[", "'test'", "]", ":", "return", "_test_output", "(", "ret", ",", "'manage'", ",", "params", "=", "{", "'hostname'", ":", "hostname", ",", "'username'", ":", "username", ",", "'password'", ":", "password", ",", "'name'", ":", "name", ",", "'allow_nat'", ":", "allow_nat", ",", "'allow_snat'", ":", "allow_snat", ",", "'description'", ":", "description", ",", "'gateway_failsafe_device'", ":", "gateway_failsafe_device", ",", "'ignore_persisted_weight'", ":", "ignore_persisted_weight", ",", "'ip_tos_client:'", ":", "ip_tos_to_client", ",", "'ip_tos_server'", ":", "ip_tos_to_server", ",", "'link_qos_to_client'", ":", "link_qos_to_client", ",", "'link_qos_to_server'", ":", "link_qos_to_server", ",", "'load_balancing_mode'", ":", "load_balancing_mode", ",", "'min_active_members'", ":", "min_active_members", ",", "'min_up_members'", ":", "min_up_members", ",", "'min_up_members_checking'", ":", "min_up_members_checking", ",", "'monitor'", ":", "monitor", ",", "'profiles'", ":", "profiles", ",", "'queue_depth_limit'", ":", "queue_depth_limit", ",", "'queue_on_connection_limit'", ":", "queue_on_connection_limit", ",", "'queue_time_limit'", ":", "queue_time_limit", ",", "'reselect_tries'", ":", "reselect_tries", ",", "'service_down_action'", ":", "service_down_action", ",", "'slow_ramp_time'", ":", "slow_ramp_time", "}", ")", "#is this pool currently configured?", "existing", "=", "__salt__", "[", "'bigip.list_pool'", "]", "(", "hostname", ",", "username", ",", "password", ",", "name", ")", "# if it exists", "if", "existing", "[", "'code'", "]", "==", "200", ":", "modified", "=", "__salt__", "[", "'bigip.modify_pool'", "]", "(", "hostname", "=", "hostname", ",", "username", "=", "username", ",", "password", "=", "password", ",", "name", "=", "name", ",", "allow_nat", "=", "allow_nat", ",", "allow_snat", "=", "allow_snat", ",", "description", "=", "description", ",", "gateway_failsafe_device", "=", "gateway_failsafe_device", ",", "ignore_persisted_weight", "=", "ignore_persisted_weight", ",", "ip_tos_to_client", "=", "ip_tos_to_client", ",", "ip_tos_to_server", "=", "ip_tos_to_server", ",", "link_qos_to_client", "=", "link_qos_to_client", ",", "link_qos_to_server", "=", "link_qos_to_server", ",", "load_balancing_mode", "=", "load_balancing_mode", ",", "min_active_members", "=", "min_active_members", ",", "min_up_members", "=", "min_up_members", ",", "min_up_members_action", "=", "min_up_members_action", ",", "min_up_members_checking", "=", "min_up_members_checking", ",", "monitor", "=", "monitor", ",", "profiles", "=", "profiles", ",", "queue_depth_limit", "=", "queue_depth_limit", ",", "queue_on_connection_limit", "=", "queue_on_connection_limit", ",", "queue_time_limit", "=", "queue_time_limit", ",", "reselect_tries", "=", "reselect_tries", ",", "service_down_action", "=", "service_down_action", ",", "slow_ramp_time", "=", "slow_ramp_time", ")", "#was the modification successful?", "if", "modified", "[", "'code'", "]", "==", "200", ":", "#remove member listings and self-links", "del", "existing", "[", "'content'", "]", "[", "'membersReference'", "]", "del", "modified", "[", "'content'", "]", "[", "'membersReference'", "]", "del", "existing", "[", "'content'", "]", "[", "'selfLink'", "]", "del", "modified", "[", "'content'", "]", "[", "'selfLink'", "]", "ret", "=", "_check_for_changes", "(", "'Pool'", ",", "ret", ",", "existing", ",", "modified", ")", "else", ":", "ret", "=", "_load_result", "(", "modified", ",", "ret", ")", "# if it doesn't exist", "elif", "existing", "[", "'code'", "]", "==", "404", ":", "new", "=", "__salt__", "[", "'bigip.create_pool'", "]", "(", "hostname", "=", "hostname", ",", "username", "=", "username", ",", "password", "=", "password", ",", "name", "=", "name", ",", "allow_nat", "=", "allow_nat", ",", "allow_snat", "=", "allow_snat", ",", "description", "=", "description", ",", "gateway_failsafe_device", "=", "gateway_failsafe_device", ",", "ignore_persisted_weight", "=", "ignore_persisted_weight", ",", "ip_tos_to_client", "=", "ip_tos_to_client", ",", "ip_tos_to_server", "=", "ip_tos_to_server", ",", "link_qos_to_client", "=", "link_qos_to_client", ",", "link_qos_to_server", "=", "link_qos_to_server", ",", "load_balancing_mode", "=", "load_balancing_mode", ",", "min_active_members", "=", "min_active_members", ",", "min_up_members", "=", "min_up_members", ",", "min_up_members_action", "=", "min_up_members_action", ",", "min_up_members_checking", "=", "min_up_members_checking", ",", "monitor", "=", "monitor", ",", "profiles", "=", "profiles", ",", "queue_depth_limit", "=", "queue_depth_limit", ",", "queue_on_connection_limit", "=", "queue_on_connection_limit", ",", "queue_time_limit", "=", "queue_time_limit", ",", "reselect_tries", "=", "reselect_tries", ",", "service_down_action", "=", "service_down_action", ",", "slow_ramp_time", "=", "slow_ramp_time", ")", "# were we able to create it?", "if", "new", "[", "'code'", "]", "==", "200", ":", "ret", "[", "'result'", "]", "=", "True", "ret", "[", "'comment'", "]", "=", "'Pool was created and enforced to the desired state.  Note: Only parameters specified '", "'were enforced.  See changes for details.'", "ret", "[", "'changes'", "]", "[", "'old'", "]", "=", "{", "}", "ret", "[", "'changes'", "]", "[", "'new'", "]", "=", "new", "[", "'content'", "]", "# unable to create it", "else", ":", "ret", "=", "_load_result", "(", "new", ",", "ret", ")", "# else something else was returned", "else", ":", "ret", "=", "_load_result", "(", "existing", ",", "ret", ")", "return", "ret"], "docstring": "Create a new pool if it does not already exist. Pool members are managed separately. Only the\n    parameters specified are enforced.\n\n    hostname\n        The host/address of the bigip device\n    username\n        The iControl REST username\n    password\n        The iControl REST password\n    name\n        The name of the pool to create\n    allow_nat\n        [yes | no]\n    allow_snat\n        [yes | no]\n    description\n        [string]\n    gateway_failsafe_device\n        [string]\n    ignore_persisted_weight\n        [enabled | disabled]\n    ip_tos_to_client\n        [pass-through | [integer]]\n    ip_tos_to_server\n        [pass-through | [integer]]\n    link_qos_to_client\n        [pass-through | [integer]]\n    link_qos_to_server\n        [pass-through | [integer]]\n    load_balancing_mode\n        [dynamic-ratio-member | dynamic-ratio-node |\n        fastest-app-response | fastest-node |\n        least-connections-members |\n        least-connections-node |\n        least-sessions |\n        observed-member | observed-node |\n        predictive-member | predictive-node |\n        ratio-least-connections-member |\n        ratio-least-connections-node |\n        ratio-member | ratio-node | ratio-session |\n        round-robin | weighted-least-connections-member |\n        weighted-least-connections-node]\n    min_active_members\n        [integer]\n    min_up_members\n        [integer]\n    min_up_members_action\n        [failover | reboot | restart-all]\n    min_up_members_checking\n        [enabled | disabled]\n    monitor\n        [name]\n    profiles\n        [none | profile_name]\n    queue_depth_limit\n        [integer]\n    queue_on_connection_limit\n        [enabled | disabled]\n    queue_time_limit\n        [integer]\n    reselect_tries\n        [integer]\n    service_down_action\n        [drop | none | reselect | reset]\n    slow_ramp_time\n        [integer]", "docstring_tokens": ["Create", "a", "new", "pool", "if", "it", "does", "not", "already", "exist", ".", "Pool", "members", "are", "managed", "separately", ".", "Only", "the", "parameters", "specified", "are", "enforced", "."], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/states/bigip.py#L734-L951", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/states/bigip.py", "func_name": "delete_pool", "original_string": "def delete_pool(hostname, username, password, name):\n    '''\n    Delete an existing pool.\n\n    hostname\n        The host/address of the bigip device\n    username\n        The iControl REST username\n    password\n        The iControl REST password\n    name\n        The name of the pool which will be deleted\n    '''\n\n    ret = {'name': name, 'changes': {}, 'result': False, 'comment': ''}\n\n    if __opts__['test']:\n        return _test_output(ret, 'delete', params={\n            'hostname': hostname,\n            'username': username,\n            'password': password,\n            'name': name,\n        }\n        )\n\n    #is this pool currently configured?\n    existing = __salt__['bigip.list_pool'](hostname, username, password, name)\n    # if it exists by name\n    if existing['code'] == 200:\n\n        deleted = __salt__['bigip.delete_pool'](hostname, username, password, name)\n        # did we get rid of it?\n        if deleted['code'] == 200:\n            ret['result'] = True\n            ret['comment'] = 'Pool was successfully deleted.'\n            ret['changes']['old'] = existing['content']\n            ret['changes']['new'] = {}\n\n        # something bad happened\n        else:\n            ret = _load_result(deleted, ret)\n\n    # not found\n    elif existing['code'] == 404:\n        ret['result'] = True\n        ret['comment'] = 'This pool already does not exist. No changes made.'\n        ret['changes']['old'] = {}\n        ret['changes']['new'] = {}\n\n    else:\n        ret = _load_result(existing, ret)\n\n    return ret", "language": "python", "code": "def delete_pool(hostname, username, password, name):\n    '''\n    Delete an existing pool.\n\n    hostname\n        The host/address of the bigip device\n    username\n        The iControl REST username\n    password\n        The iControl REST password\n    name\n        The name of the pool which will be deleted\n    '''\n\n    ret = {'name': name, 'changes': {}, 'result': False, 'comment': ''}\n\n    if __opts__['test']:\n        return _test_output(ret, 'delete', params={\n            'hostname': hostname,\n            'username': username,\n            'password': password,\n            'name': name,\n        }\n        )\n\n    #is this pool currently configured?\n    existing = __salt__['bigip.list_pool'](hostname, username, password, name)\n    # if it exists by name\n    if existing['code'] == 200:\n\n        deleted = __salt__['bigip.delete_pool'](hostname, username, password, name)\n        # did we get rid of it?\n        if deleted['code'] == 200:\n            ret['result'] = True\n            ret['comment'] = 'Pool was successfully deleted.'\n            ret['changes']['old'] = existing['content']\n            ret['changes']['new'] = {}\n\n        # something bad happened\n        else:\n            ret = _load_result(deleted, ret)\n\n    # not found\n    elif existing['code'] == 404:\n        ret['result'] = True\n        ret['comment'] = 'This pool already does not exist. No changes made.'\n        ret['changes']['old'] = {}\n        ret['changes']['new'] = {}\n\n    else:\n        ret = _load_result(existing, ret)\n\n    return ret", "code_tokens": ["def", "delete_pool", "(", "hostname", ",", "username", ",", "password", ",", "name", ")", ":", "ret", "=", "{", "'name'", ":", "name", ",", "'changes'", ":", "{", "}", ",", "'result'", ":", "False", ",", "'comment'", ":", "''", "}", "if", "__opts__", "[", "'test'", "]", ":", "return", "_test_output", "(", "ret", ",", "'delete'", ",", "params", "=", "{", "'hostname'", ":", "hostname", ",", "'username'", ":", "username", ",", "'password'", ":", "password", ",", "'name'", ":", "name", ",", "}", ")", "#is this pool currently configured?", "existing", "=", "__salt__", "[", "'bigip.list_pool'", "]", "(", "hostname", ",", "username", ",", "password", ",", "name", ")", "# if it exists by name", "if", "existing", "[", "'code'", "]", "==", "200", ":", "deleted", "=", "__salt__", "[", "'bigip.delete_pool'", "]", "(", "hostname", ",", "username", ",", "password", ",", "name", ")", "# did we get rid of it?", "if", "deleted", "[", "'code'", "]", "==", "200", ":", "ret", "[", "'result'", "]", "=", "True", "ret", "[", "'comment'", "]", "=", "'Pool was successfully deleted.'", "ret", "[", "'changes'", "]", "[", "'old'", "]", "=", "existing", "[", "'content'", "]", "ret", "[", "'changes'", "]", "[", "'new'", "]", "=", "{", "}", "# something bad happened", "else", ":", "ret", "=", "_load_result", "(", "deleted", ",", "ret", ")", "# not found", "elif", "existing", "[", "'code'", "]", "==", "404", ":", "ret", "[", "'result'", "]", "=", "True", "ret", "[", "'comment'", "]", "=", "'This pool already does not exist. No changes made.'", "ret", "[", "'changes'", "]", "[", "'old'", "]", "=", "{", "}", "ret", "[", "'changes'", "]", "[", "'new'", "]", "=", "{", "}", "else", ":", "ret", "=", "_load_result", "(", "existing", ",", "ret", ")", "return", "ret"], "docstring": "Delete an existing pool.\n\n    hostname\n        The host/address of the bigip device\n    username\n        The iControl REST username\n    password\n        The iControl REST password\n    name\n        The name of the pool which will be deleted", "docstring_tokens": ["Delete", "an", "existing", "pool", "."], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/states/bigip.py#L1135-L1187", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/states/bigip.py", "func_name": "manage_pool_members", "original_string": "def manage_pool_members(hostname, username, password, name, members):\n    '''\n    Manage the members of an existing pool.  This function replaces all current pool members.\n    Only the parameters specified are enforced.\n\n    hostname\n        The host/address of the bigip device\n    username\n        The iControl REST username\n    password\n        The iControl REST password\n    name\n        The name of the pool to modify\n    members\n        list of pool members to manage.\n\n    '''\n\n    ret = {'name': name, 'changes': {}, 'result': False, 'comment': ''}\n\n    if __opts__['test']:\n        return _test_output(ret, 'manage', params={\n            'hostname': hostname,\n            'username': username,\n            'password': password,\n            'name': name,\n            'members': members\n        }\n        )\n\n    #is this pool currently configured?\n    existing = __salt__['bigip.list_pool'](hostname, username, password, name)\n\n    # if it exists\n    if existing['code'] == 200:\n\n        #what are the current members?\n        current_members = existing['content']['membersReference']['items']\n\n        modified = __salt__['bigip.replace_pool_members'](hostname, username, password, name, members)\n\n        #was the modification successful?\n        if modified['code'] == 200:\n\n            #re-list the pool with new membership\n            new_listing = __salt__['bigip.list_pool'](hostname, username, password, name)\n\n            #just in case something happened...\n            if new_listing['code'] != 200:\n                ret = _load_result(new_listing, ret)\n                ret['comment'] = 'modification of the pool was successful but an error occurred upon retrieving new' \\\n                                 ' listing.'\n                return ret\n\n            new_members = new_listing['content']['membersReference']['items']\n\n            #remove generation keys and create new lists indexed by integers\n            for current_member in current_members:\n                del current_member['generation']\n\n            for new_member in new_members:\n                del new_member['generation']\n\n            #anything changed?\n            ret = _check_for_changes('Pool Membership', ret, current_members, new_members)\n\n        else:\n            ret = _load_result(modified, ret)\n\n    #pool does not exists\n    elif existing['code'] == 404:\n        ret['comment'] = 'A pool with this name was not found.'\n\n    else:\n        ret = _load_result(existing, ret)\n\n    return ret", "language": "python", "code": "def manage_pool_members(hostname, username, password, name, members):\n    '''\n    Manage the members of an existing pool.  This function replaces all current pool members.\n    Only the parameters specified are enforced.\n\n    hostname\n        The host/address of the bigip device\n    username\n        The iControl REST username\n    password\n        The iControl REST password\n    name\n        The name of the pool to modify\n    members\n        list of pool members to manage.\n\n    '''\n\n    ret = {'name': name, 'changes': {}, 'result': False, 'comment': ''}\n\n    if __opts__['test']:\n        return _test_output(ret, 'manage', params={\n            'hostname': hostname,\n            'username': username,\n            'password': password,\n            'name': name,\n            'members': members\n        }\n        )\n\n    #is this pool currently configured?\n    existing = __salt__['bigip.list_pool'](hostname, username, password, name)\n\n    # if it exists\n    if existing['code'] == 200:\n\n        #what are the current members?\n        current_members = existing['content']['membersReference']['items']\n\n        modified = __salt__['bigip.replace_pool_members'](hostname, username, password, name, members)\n\n        #was the modification successful?\n        if modified['code'] == 200:\n\n            #re-list the pool with new membership\n            new_listing = __salt__['bigip.list_pool'](hostname, username, password, name)\n\n            #just in case something happened...\n            if new_listing['code'] != 200:\n                ret = _load_result(new_listing, ret)\n                ret['comment'] = 'modification of the pool was successful but an error occurred upon retrieving new' \\\n                                 ' listing.'\n                return ret\n\n            new_members = new_listing['content']['membersReference']['items']\n\n            #remove generation keys and create new lists indexed by integers\n            for current_member in current_members:\n                del current_member['generation']\n\n            for new_member in new_members:\n                del new_member['generation']\n\n            #anything changed?\n            ret = _check_for_changes('Pool Membership', ret, current_members, new_members)\n\n        else:\n            ret = _load_result(modified, ret)\n\n    #pool does not exists\n    elif existing['code'] == 404:\n        ret['comment'] = 'A pool with this name was not found.'\n\n    else:\n        ret = _load_result(existing, ret)\n\n    return ret", "code_tokens": ["def", "manage_pool_members", "(", "hostname", ",", "username", ",", "password", ",", "name", ",", "members", ")", ":", "ret", "=", "{", "'name'", ":", "name", ",", "'changes'", ":", "{", "}", ",", "'result'", ":", "False", ",", "'comment'", ":", "''", "}", "if", "__opts__", "[", "'test'", "]", ":", "return", "_test_output", "(", "ret", ",", "'manage'", ",", "params", "=", "{", "'hostname'", ":", "hostname", ",", "'username'", ":", "username", ",", "'password'", ":", "password", ",", "'name'", ":", "name", ",", "'members'", ":", "members", "}", ")", "#is this pool currently configured?", "existing", "=", "__salt__", "[", "'bigip.list_pool'", "]", "(", "hostname", ",", "username", ",", "password", ",", "name", ")", "# if it exists", "if", "existing", "[", "'code'", "]", "==", "200", ":", "#what are the current members?", "current_members", "=", "existing", "[", "'content'", "]", "[", "'membersReference'", "]", "[", "'items'", "]", "modified", "=", "__salt__", "[", "'bigip.replace_pool_members'", "]", "(", "hostname", ",", "username", ",", "password", ",", "name", ",", "members", ")", "#was the modification successful?", "if", "modified", "[", "'code'", "]", "==", "200", ":", "#re-list the pool with new membership", "new_listing", "=", "__salt__", "[", "'bigip.list_pool'", "]", "(", "hostname", ",", "username", ",", "password", ",", "name", ")", "#just in case something happened...", "if", "new_listing", "[", "'code'", "]", "!=", "200", ":", "ret", "=", "_load_result", "(", "new_listing", ",", "ret", ")", "ret", "[", "'comment'", "]", "=", "'modification of the pool was successful but an error occurred upon retrieving new'", "' listing.'", "return", "ret", "new_members", "=", "new_listing", "[", "'content'", "]", "[", "'membersReference'", "]", "[", "'items'", "]", "#remove generation keys and create new lists indexed by integers", "for", "current_member", "in", "current_members", ":", "del", "current_member", "[", "'generation'", "]", "for", "new_member", "in", "new_members", ":", "del", "new_member", "[", "'generation'", "]", "#anything changed?", "ret", "=", "_check_for_changes", "(", "'Pool Membership'", ",", "ret", ",", "current_members", ",", "new_members", ")", "else", ":", "ret", "=", "_load_result", "(", "modified", ",", "ret", ")", "#pool does not exists", "elif", "existing", "[", "'code'", "]", "==", "404", ":", "ret", "[", "'comment'", "]", "=", "'A pool with this name was not found.'", "else", ":", "ret", "=", "_load_result", "(", "existing", ",", "ret", ")", "return", "ret"], "docstring": "Manage the members of an existing pool.  This function replaces all current pool members.\n    Only the parameters specified are enforced.\n\n    hostname\n        The host/address of the bigip device\n    username\n        The iControl REST username\n    password\n        The iControl REST password\n    name\n        The name of the pool to modify\n    members\n        list of pool members to manage.", "docstring_tokens": ["Manage", "the", "members", "of", "an", "existing", "pool", ".", "This", "function", "replaces", "all", "current", "pool", "members", ".", "Only", "the", "parameters", "specified", "are", "enforced", "."], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/states/bigip.py#L1190-L1266", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/states/bigip.py", "func_name": "add_pool_member", "original_string": "def add_pool_member(hostname, username, password, name, member):\n    '''\n    A function to connect to a bigip device and add a new member to an existing pool.\n\n    hostname\n        The host/address of the bigip device\n    username\n        The iControl REST username\n    password\n        The iControl REST password\n    name\n        The name of the pool to modify\n    member\n        The member to add to the pool\n    '''\n\n    ret = {'name': name, 'changes': {}, 'result': False, 'comment': ''}\n\n    if __opts__['test']:\n        return _test_output(ret, 'add', params={\n            'hostname': hostname,\n            'username': username,\n            'password': password,\n            'name': name,\n            'members': member\n        }\n        )\n\n    #is this pool member currently configured?\n    existing_pool = __salt__['bigip.list_pool'](hostname, username, password, name)\n\n    if existing_pool['code'] == 200:\n\n        # for some reason iControl REST doesn't support listing a single pool member.\n        # the response from GET for listing a member will return 200 even if it doesn't exists.\n        # because of this we have to do some rather \"unnecessary\" searching within a pool.\n\n        #what are the current members?\n        current_members = existing_pool['content']['membersReference']['items']\n\n        #loop through them\n        exists = False\n        for current_member in current_members:\n            if current_member['name'] == member['name']:\n                exists = True\n                break\n\n        if exists:\n            ret['result'] = True\n            ret['comment'] = 'Member: {name} already exists within this pool.  No changes made.'.format(name=member['name'])\n            ret['changes']['old'] = {}\n            ret['changes']['new'] = {}\n        else:\n            new_member = __salt__['bigip.add_pool_member'](hostname, username, password, name, member)\n\n            if new_member['code'] == 200:\n                ret['result'] = True\n                ret['comment'] = 'Member: {name} has been successfully added to the pool.'.format(name=member['name'])\n                ret['changes']['old'] = {}\n\n                #look up the member again...\n                pool_listing = __salt__['bigip.list_pool'](hostname, username, password, name)\n\n                if pool_listing['code'] != 200:\n                    ret = _load_result(new_member, ret)\n                    return ret\n\n                members = pool_listing['content']['membersReference']['items']\n                #loop through them\n                for current_member in members:\n                    if current_member['name'] == member['name']:\n                        added_member = current_member\n                        break\n\n                ret['changes']['new'] = added_member\n\n            # member wasn't added\n            else:\n                ret = _load_result(new_member, ret)\n\n    #pool does not exists\n    elif existing_pool['code'] == 404:\n        ret['comment'] = 'A pool with this name was not found.'\n    else:\n        ret = _load_result(existing_pool, ret)\n\n    return ret", "language": "python", "code": "def add_pool_member(hostname, username, password, name, member):\n    '''\n    A function to connect to a bigip device and add a new member to an existing pool.\n\n    hostname\n        The host/address of the bigip device\n    username\n        The iControl REST username\n    password\n        The iControl REST password\n    name\n        The name of the pool to modify\n    member\n        The member to add to the pool\n    '''\n\n    ret = {'name': name, 'changes': {}, 'result': False, 'comment': ''}\n\n    if __opts__['test']:\n        return _test_output(ret, 'add', params={\n            'hostname': hostname,\n            'username': username,\n            'password': password,\n            'name': name,\n            'members': member\n        }\n        )\n\n    #is this pool member currently configured?\n    existing_pool = __salt__['bigip.list_pool'](hostname, username, password, name)\n\n    if existing_pool['code'] == 200:\n\n        # for some reason iControl REST doesn't support listing a single pool member.\n        # the response from GET for listing a member will return 200 even if it doesn't exists.\n        # because of this we have to do some rather \"unnecessary\" searching within a pool.\n\n        #what are the current members?\n        current_members = existing_pool['content']['membersReference']['items']\n\n        #loop through them\n        exists = False\n        for current_member in current_members:\n            if current_member['name'] == member['name']:\n                exists = True\n                break\n\n        if exists:\n            ret['result'] = True\n            ret['comment'] = 'Member: {name} already exists within this pool.  No changes made.'.format(name=member['name'])\n            ret['changes']['old'] = {}\n            ret['changes']['new'] = {}\n        else:\n            new_member = __salt__['bigip.add_pool_member'](hostname, username, password, name, member)\n\n            if new_member['code'] == 200:\n                ret['result'] = True\n                ret['comment'] = 'Member: {name} has been successfully added to the pool.'.format(name=member['name'])\n                ret['changes']['old'] = {}\n\n                #look up the member again...\n                pool_listing = __salt__['bigip.list_pool'](hostname, username, password, name)\n\n                if pool_listing['code'] != 200:\n                    ret = _load_result(new_member, ret)\n                    return ret\n\n                members = pool_listing['content']['membersReference']['items']\n                #loop through them\n                for current_member in members:\n                    if current_member['name'] == member['name']:\n                        added_member = current_member\n                        break\n\n                ret['changes']['new'] = added_member\n\n            # member wasn't added\n            else:\n                ret = _load_result(new_member, ret)\n\n    #pool does not exists\n    elif existing_pool['code'] == 404:\n        ret['comment'] = 'A pool with this name was not found.'\n    else:\n        ret = _load_result(existing_pool, ret)\n\n    return ret", "code_tokens": ["def", "add_pool_member", "(", "hostname", ",", "username", ",", "password", ",", "name", ",", "member", ")", ":", "ret", "=", "{", "'name'", ":", "name", ",", "'changes'", ":", "{", "}", ",", "'result'", ":", "False", ",", "'comment'", ":", "''", "}", "if", "__opts__", "[", "'test'", "]", ":", "return", "_test_output", "(", "ret", ",", "'add'", ",", "params", "=", "{", "'hostname'", ":", "hostname", ",", "'username'", ":", "username", ",", "'password'", ":", "password", ",", "'name'", ":", "name", ",", "'members'", ":", "member", "}", ")", "#is this pool member currently configured?", "existing_pool", "=", "__salt__", "[", "'bigip.list_pool'", "]", "(", "hostname", ",", "username", ",", "password", ",", "name", ")", "if", "existing_pool", "[", "'code'", "]", "==", "200", ":", "# for some reason iControl REST doesn't support listing a single pool member.", "# the response from GET for listing a member will return 200 even if it doesn't exists.", "# because of this we have to do some rather \"unnecessary\" searching within a pool.", "#what are the current members?", "current_members", "=", "existing_pool", "[", "'content'", "]", "[", "'membersReference'", "]", "[", "'items'", "]", "#loop through them", "exists", "=", "False", "for", "current_member", "in", "current_members", ":", "if", "current_member", "[", "'name'", "]", "==", "member", "[", "'name'", "]", ":", "exists", "=", "True", "break", "if", "exists", ":", "ret", "[", "'result'", "]", "=", "True", "ret", "[", "'comment'", "]", "=", "'Member: {name} already exists within this pool.  No changes made.'", ".", "format", "(", "name", "=", "member", "[", "'name'", "]", ")", "ret", "[", "'changes'", "]", "[", "'old'", "]", "=", "{", "}", "ret", "[", "'changes'", "]", "[", "'new'", "]", "=", "{", "}", "else", ":", "new_member", "=", "__salt__", "[", "'bigip.add_pool_member'", "]", "(", "hostname", ",", "username", ",", "password", ",", "name", ",", "member", ")", "if", "new_member", "[", "'code'", "]", "==", "200", ":", "ret", "[", "'result'", "]", "=", "True", "ret", "[", "'comment'", "]", "=", "'Member: {name} has been successfully added to the pool.'", ".", "format", "(", "name", "=", "member", "[", "'name'", "]", ")", "ret", "[", "'changes'", "]", "[", "'old'", "]", "=", "{", "}", "#look up the member again...", "pool_listing", "=", "__salt__", "[", "'bigip.list_pool'", "]", "(", "hostname", ",", "username", ",", "password", ",", "name", ")", "if", "pool_listing", "[", "'code'", "]", "!=", "200", ":", "ret", "=", "_load_result", "(", "new_member", ",", "ret", ")", "return", "ret", "members", "=", "pool_listing", "[", "'content'", "]", "[", "'membersReference'", "]", "[", "'items'", "]", "#loop through them", "for", "current_member", "in", "members", ":", "if", "current_member", "[", "'name'", "]", "==", "member", "[", "'name'", "]", ":", "added_member", "=", "current_member", "break", "ret", "[", "'changes'", "]", "[", "'new'", "]", "=", "added_member", "# member wasn't added", "else", ":", "ret", "=", "_load_result", "(", "new_member", ",", "ret", ")", "#pool does not exists", "elif", "existing_pool", "[", "'code'", "]", "==", "404", ":", "ret", "[", "'comment'", "]", "=", "'A pool with this name was not found.'", "else", ":", "ret", "=", "_load_result", "(", "existing_pool", ",", "ret", ")", "return", "ret"], "docstring": "A function to connect to a bigip device and add a new member to an existing pool.\n\n    hostname\n        The host/address of the bigip device\n    username\n        The iControl REST username\n    password\n        The iControl REST password\n    name\n        The name of the pool to modify\n    member\n        The member to add to the pool", "docstring_tokens": ["A", "function", "to", "connect", "to", "a", "bigip", "device", "and", "add", "a", "new", "member", "to", "an", "existing", "pool", "."], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/states/bigip.py#L1269-L1355", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/states/bigip.py", "func_name": "modify_pool_member", "original_string": "def modify_pool_member(hostname, username, password, name, member,\n                       connection_limit=None,\n                       description=None,\n                       dynamic_ratio=None,\n                       inherit_profile=None,\n                       logging=None,\n                       monitor=None,\n                       priority_group=None,\n                       profiles=None,\n                       rate_limit=None,\n                       ratio=None,\n                       session=None,\n                       member_state=None):\n    '''\n    A function to connect to a bigip device and modify a member of an existing pool.\n\n    hostname\n        The host/address of the bigip device\n    username\n        The iControl REST username\n    password\n        The iControl REST password\n    name\n        The name of the pool to modify\n    member\n        The member modify\n    connection_limit\n        [integer]\n    description\n        [string]\n    dynamic_ratio\n        [integer]\n    inherit_profile\n        [enabled | disabled]\n    logging\n        [enabled | disabled]\n    monitor\n        [name]\n    priority_group\n        [integer]\n    profiles\n        [none | profile_name]\n    rate_limit\n        [integer]\n    ratio\n        [integer]\n    session\n        [user-enabled | user-disabled]\n    member_state (state)\n        [ user-up | user-down ]\n\n    '''\n\n    ret = {'name': name, 'changes': {}, 'result': False, 'comment': ''}\n\n    if __opts__['test']:\n        return _test_output(ret, 'modify', params={\n            'hostname': hostname,\n            'username': username,\n            'password': password,\n            'name': name,\n            'members': member\n        }\n        )\n\n    #is this pool member currently configured?\n    existing_pool = __salt__['bigip.list_pool'](hostname, username, password, name)\n\n    if existing_pool['code'] == 200:\n\n        # for some reason iControl REST doesn't support listing a single pool member.\n        # the response from GET for listing a member will return 200 even if it doesn't exists.\n        # because of this we have to do some rather \"unnecessary\" searching within a pool.\n\n        #what are the current members?\n        current_members = existing_pool['content']['membersReference']['items']\n\n        #loop through them\n        exists = False\n        for current_member in current_members:\n            if current_member['name'] == member:\n                exists = True\n                existing_member = current_member\n                break\n\n        if exists:\n\n            #modify the pool member\n            modified = __salt__['bigip.modify_pool_member'](hostname=hostname,\n                                                            username=username,\n                                                            password=password,\n                                                            name=name,\n                                                            member=member,\n                                                            connection_limit=connection_limit,\n                                                            description=description,\n                                                            dynamic_ratio=dynamic_ratio,\n                                                            inherit_profile=inherit_profile,\n                                                            logging=logging,\n                                                            monitor=monitor,\n                                                            priority_group=priority_group,\n                                                            profiles=profiles,\n                                                            rate_limit=rate_limit,\n                                                            ratio=ratio,\n                                                            session=session,\n                                                            state=member_state)\n\n            #re-list the pool\n            new_pool = __salt__['bigip.list_pool'](hostname, username, password, name)\n\n            if modified['code'] == 200 and modified['code'] == 200:\n\n                #what are the new members?\n                new_members = new_pool['content']['membersReference']['items']\n\n                #loop through them\n                for new_member in new_members:\n                    if new_member['name'] == member:\n                        modified_member = new_member\n                        break\n\n                #check for changes\n                old = {'content': existing_member}\n                new = {'content': modified_member}\n                ret = _check_for_changes('Pool Member: {member}'.format(member=member), ret, old, new)\n\n            else:\n                ret = _load_result(modified, ret)\n        else:\n            ret['comment'] = 'Member: {name} does not exists within this pool.  No changes made.'.format(name=member['name'])\n\n    #pool does not exists\n    elif existing_pool['code'] == 404:\n        ret['comment'] = 'A pool with this name was not found.'\n    else:\n        ret = _load_result(existing_pool, ret)\n\n    return ret", "language": "python", "code": "def modify_pool_member(hostname, username, password, name, member,\n                       connection_limit=None,\n                       description=None,\n                       dynamic_ratio=None,\n                       inherit_profile=None,\n                       logging=None,\n                       monitor=None,\n                       priority_group=None,\n                       profiles=None,\n                       rate_limit=None,\n                       ratio=None,\n                       session=None,\n                       member_state=None):\n    '''\n    A function to connect to a bigip device and modify a member of an existing pool.\n\n    hostname\n        The host/address of the bigip device\n    username\n        The iControl REST username\n    password\n        The iControl REST password\n    name\n        The name of the pool to modify\n    member\n        The member modify\n    connection_limit\n        [integer]\n    description\n        [string]\n    dynamic_ratio\n        [integer]\n    inherit_profile\n        [enabled | disabled]\n    logging\n        [enabled | disabled]\n    monitor\n        [name]\n    priority_group\n        [integer]\n    profiles\n        [none | profile_name]\n    rate_limit\n        [integer]\n    ratio\n        [integer]\n    session\n        [user-enabled | user-disabled]\n    member_state (state)\n        [ user-up | user-down ]\n\n    '''\n\n    ret = {'name': name, 'changes': {}, 'result': False, 'comment': ''}\n\n    if __opts__['test']:\n        return _test_output(ret, 'modify', params={\n            'hostname': hostname,\n            'username': username,\n            'password': password,\n            'name': name,\n            'members': member\n        }\n        )\n\n    #is this pool member currently configured?\n    existing_pool = __salt__['bigip.list_pool'](hostname, username, password, name)\n\n    if existing_pool['code'] == 200:\n\n        # for some reason iControl REST doesn't support listing a single pool member.\n        # the response from GET for listing a member will return 200 even if it doesn't exists.\n        # because of this we have to do some rather \"unnecessary\" searching within a pool.\n\n        #what are the current members?\n        current_members = existing_pool['content']['membersReference']['items']\n\n        #loop through them\n        exists = False\n        for current_member in current_members:\n            if current_member['name'] == member:\n                exists = True\n                existing_member = current_member\n                break\n\n        if exists:\n\n            #modify the pool member\n            modified = __salt__['bigip.modify_pool_member'](hostname=hostname,\n                                                            username=username,\n                                                            password=password,\n                                                            name=name,\n                                                            member=member,\n                                                            connection_limit=connection_limit,\n                                                            description=description,\n                                                            dynamic_ratio=dynamic_ratio,\n                                                            inherit_profile=inherit_profile,\n                                                            logging=logging,\n                                                            monitor=monitor,\n                                                            priority_group=priority_group,\n                                                            profiles=profiles,\n                                                            rate_limit=rate_limit,\n                                                            ratio=ratio,\n                                                            session=session,\n                                                            state=member_state)\n\n            #re-list the pool\n            new_pool = __salt__['bigip.list_pool'](hostname, username, password, name)\n\n            if modified['code'] == 200 and modified['code'] == 200:\n\n                #what are the new members?\n                new_members = new_pool['content']['membersReference']['items']\n\n                #loop through them\n                for new_member in new_members:\n                    if new_member['name'] == member:\n                        modified_member = new_member\n                        break\n\n                #check for changes\n                old = {'content': existing_member}\n                new = {'content': modified_member}\n                ret = _check_for_changes('Pool Member: {member}'.format(member=member), ret, old, new)\n\n            else:\n                ret = _load_result(modified, ret)\n        else:\n            ret['comment'] = 'Member: {name} does not exists within this pool.  No changes made.'.format(name=member['name'])\n\n    #pool does not exists\n    elif existing_pool['code'] == 404:\n        ret['comment'] = 'A pool with this name was not found.'\n    else:\n        ret = _load_result(existing_pool, ret)\n\n    return ret", "code_tokens": ["def", "modify_pool_member", "(", "hostname", ",", "username", ",", "password", ",", "name", ",", "member", ",", "connection_limit", "=", "None", ",", "description", "=", "None", ",", "dynamic_ratio", "=", "None", ",", "inherit_profile", "=", "None", ",", "logging", "=", "None", ",", "monitor", "=", "None", ",", "priority_group", "=", "None", ",", "profiles", "=", "None", ",", "rate_limit", "=", "None", ",", "ratio", "=", "None", ",", "session", "=", "None", ",", "member_state", "=", "None", ")", ":", "ret", "=", "{", "'name'", ":", "name", ",", "'changes'", ":", "{", "}", ",", "'result'", ":", "False", ",", "'comment'", ":", "''", "}", "if", "__opts__", "[", "'test'", "]", ":", "return", "_test_output", "(", "ret", ",", "'modify'", ",", "params", "=", "{", "'hostname'", ":", "hostname", ",", "'username'", ":", "username", ",", "'password'", ":", "password", ",", "'name'", ":", "name", ",", "'members'", ":", "member", "}", ")", "#is this pool member currently configured?", "existing_pool", "=", "__salt__", "[", "'bigip.list_pool'", "]", "(", "hostname", ",", "username", ",", "password", ",", "name", ")", "if", "existing_pool", "[", "'code'", "]", "==", "200", ":", "# for some reason iControl REST doesn't support listing a single pool member.", "# the response from GET for listing a member will return 200 even if it doesn't exists.", "# because of this we have to do some rather \"unnecessary\" searching within a pool.", "#what are the current members?", "current_members", "=", "existing_pool", "[", "'content'", "]", "[", "'membersReference'", "]", "[", "'items'", "]", "#loop through them", "exists", "=", "False", "for", "current_member", "in", "current_members", ":", "if", "current_member", "[", "'name'", "]", "==", "member", ":", "exists", "=", "True", "existing_member", "=", "current_member", "break", "if", "exists", ":", "#modify the pool member", "modified", "=", "__salt__", "[", "'bigip.modify_pool_member'", "]", "(", "hostname", "=", "hostname", ",", "username", "=", "username", ",", "password", "=", "password", ",", "name", "=", "name", ",", "member", "=", "member", ",", "connection_limit", "=", "connection_limit", ",", "description", "=", "description", ",", "dynamic_ratio", "=", "dynamic_ratio", ",", "inherit_profile", "=", "inherit_profile", ",", "logging", "=", "logging", ",", "monitor", "=", "monitor", ",", "priority_group", "=", "priority_group", ",", "profiles", "=", "profiles", ",", "rate_limit", "=", "rate_limit", ",", "ratio", "=", "ratio", ",", "session", "=", "session", ",", "state", "=", "member_state", ")", "#re-list the pool", "new_pool", "=", "__salt__", "[", "'bigip.list_pool'", "]", "(", "hostname", ",", "username", ",", "password", ",", "name", ")", "if", "modified", "[", "'code'", "]", "==", "200", "and", "modified", "[", "'code'", "]", "==", "200", ":", "#what are the new members?", "new_members", "=", "new_pool", "[", "'content'", "]", "[", "'membersReference'", "]", "[", "'items'", "]", "#loop through them", "for", "new_member", "in", "new_members", ":", "if", "new_member", "[", "'name'", "]", "==", "member", ":", "modified_member", "=", "new_member", "break", "#check for changes", "old", "=", "{", "'content'", ":", "existing_member", "}", "new", "=", "{", "'content'", ":", "modified_member", "}", "ret", "=", "_check_for_changes", "(", "'Pool Member: {member}'", ".", "format", "(", "member", "=", "member", ")", ",", "ret", ",", "old", ",", "new", ")", "else", ":", "ret", "=", "_load_result", "(", "modified", ",", "ret", ")", "else", ":", "ret", "[", "'comment'", "]", "=", "'Member: {name} does not exists within this pool.  No changes made.'", ".", "format", "(", "name", "=", "member", "[", "'name'", "]", ")", "#pool does not exists", "elif", "existing_pool", "[", "'code'", "]", "==", "404", ":", "ret", "[", "'comment'", "]", "=", "'A pool with this name was not found.'", "else", ":", "ret", "=", "_load_result", "(", "existing_pool", ",", "ret", ")", "return", "ret"], "docstring": "A function to connect to a bigip device and modify a member of an existing pool.\n\n    hostname\n        The host/address of the bigip device\n    username\n        The iControl REST username\n    password\n        The iControl REST password\n    name\n        The name of the pool to modify\n    member\n        The member modify\n    connection_limit\n        [integer]\n    description\n        [string]\n    dynamic_ratio\n        [integer]\n    inherit_profile\n        [enabled | disabled]\n    logging\n        [enabled | disabled]\n    monitor\n        [name]\n    priority_group\n        [integer]\n    profiles\n        [none | profile_name]\n    rate_limit\n        [integer]\n    ratio\n        [integer]\n    session\n        [user-enabled | user-disabled]\n    member_state (state)\n        [ user-up | user-down ]", "docstring_tokens": ["A", "function", "to", "connect", "to", "a", "bigip", "device", "and", "modify", "a", "member", "of", "an", "existing", "pool", "."], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/states/bigip.py#L1358-L1494", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/states/bigip.py", "func_name": "delete_pool_member", "original_string": "def delete_pool_member(hostname, username, password, name, member):\n    '''\n    Delete an existing pool member.\n\n    hostname\n        The host/address of the bigip device\n    username\n        The iControl REST username\n    password\n        The iControl REST password\n    name\n        The name of the pool to be modified\n    member\n        The name of the member to delete from the pool\n    '''\n\n    ret = {'name': name, 'changes': {}, 'result': False, 'comment': ''}\n\n    if __opts__['test']:\n        return _test_output(ret, 'delete', params={\n            'hostname': hostname,\n            'username': username,\n            'password': password,\n            'name': name,\n            'members': member\n        }\n        )\n\n    #is this pool currently configured?\n    existing = __salt__['bigip.list_pool'](hostname, username, password, name)\n\n    # if it exists by name\n    if existing['code'] == 200:\n\n       #what are the current members?\n        current_members = existing['content']['membersReference']['items']\n\n        #loop through them\n        exists = False\n        for current_member in current_members:\n            if current_member['name'] == member:\n                exists = True\n                existing_member = current_member\n                break\n\n        if exists:\n            deleted = __salt__['bigip.delete_pool_member'](hostname, username, password, name, member)\n            # did we get rid of it?\n            if deleted['code'] == 200:\n                ret['result'] = True\n                ret['comment'] = 'Pool Member: {member} was successfully deleted.'.format(member=member)\n                ret['changes']['old'] = existing_member\n                ret['changes']['new'] = {}\n\n        # something bad happened\n        else:\n            ret['result'] = True\n            ret['comment'] = 'This pool member already does not exist. No changes made.'\n            ret['changes']['old'] = {}\n            ret['changes']['new'] = {}\n\n    else:\n        ret = _load_result(existing, ret)\n\n    return ret", "language": "python", "code": "def delete_pool_member(hostname, username, password, name, member):\n    '''\n    Delete an existing pool member.\n\n    hostname\n        The host/address of the bigip device\n    username\n        The iControl REST username\n    password\n        The iControl REST password\n    name\n        The name of the pool to be modified\n    member\n        The name of the member to delete from the pool\n    '''\n\n    ret = {'name': name, 'changes': {}, 'result': False, 'comment': ''}\n\n    if __opts__['test']:\n        return _test_output(ret, 'delete', params={\n            'hostname': hostname,\n            'username': username,\n            'password': password,\n            'name': name,\n            'members': member\n        }\n        )\n\n    #is this pool currently configured?\n    existing = __salt__['bigip.list_pool'](hostname, username, password, name)\n\n    # if it exists by name\n    if existing['code'] == 200:\n\n       #what are the current members?\n        current_members = existing['content']['membersReference']['items']\n\n        #loop through them\n        exists = False\n        for current_member in current_members:\n            if current_member['name'] == member:\n                exists = True\n                existing_member = current_member\n                break\n\n        if exists:\n            deleted = __salt__['bigip.delete_pool_member'](hostname, username, password, name, member)\n            # did we get rid of it?\n            if deleted['code'] == 200:\n                ret['result'] = True\n                ret['comment'] = 'Pool Member: {member} was successfully deleted.'.format(member=member)\n                ret['changes']['old'] = existing_member\n                ret['changes']['new'] = {}\n\n        # something bad happened\n        else:\n            ret['result'] = True\n            ret['comment'] = 'This pool member already does not exist. No changes made.'\n            ret['changes']['old'] = {}\n            ret['changes']['new'] = {}\n\n    else:\n        ret = _load_result(existing, ret)\n\n    return ret", "code_tokens": ["def", "delete_pool_member", "(", "hostname", ",", "username", ",", "password", ",", "name", ",", "member", ")", ":", "ret", "=", "{", "'name'", ":", "name", ",", "'changes'", ":", "{", "}", ",", "'result'", ":", "False", ",", "'comment'", ":", "''", "}", "if", "__opts__", "[", "'test'", "]", ":", "return", "_test_output", "(", "ret", ",", "'delete'", ",", "params", "=", "{", "'hostname'", ":", "hostname", ",", "'username'", ":", "username", ",", "'password'", ":", "password", ",", "'name'", ":", "name", ",", "'members'", ":", "member", "}", ")", "#is this pool currently configured?", "existing", "=", "__salt__", "[", "'bigip.list_pool'", "]", "(", "hostname", ",", "username", ",", "password", ",", "name", ")", "# if it exists by name", "if", "existing", "[", "'code'", "]", "==", "200", ":", "#what are the current members?", "current_members", "=", "existing", "[", "'content'", "]", "[", "'membersReference'", "]", "[", "'items'", "]", "#loop through them", "exists", "=", "False", "for", "current_member", "in", "current_members", ":", "if", "current_member", "[", "'name'", "]", "==", "member", ":", "exists", "=", "True", "existing_member", "=", "current_member", "break", "if", "exists", ":", "deleted", "=", "__salt__", "[", "'bigip.delete_pool_member'", "]", "(", "hostname", ",", "username", ",", "password", ",", "name", ",", "member", ")", "# did we get rid of it?", "if", "deleted", "[", "'code'", "]", "==", "200", ":", "ret", "[", "'result'", "]", "=", "True", "ret", "[", "'comment'", "]", "=", "'Pool Member: {member} was successfully deleted.'", ".", "format", "(", "member", "=", "member", ")", "ret", "[", "'changes'", "]", "[", "'old'", "]", "=", "existing_member", "ret", "[", "'changes'", "]", "[", "'new'", "]", "=", "{", "}", "# something bad happened", "else", ":", "ret", "[", "'result'", "]", "=", "True", "ret", "[", "'comment'", "]", "=", "'This pool member already does not exist. No changes made.'", "ret", "[", "'changes'", "]", "[", "'old'", "]", "=", "{", "}", "ret", "[", "'changes'", "]", "[", "'new'", "]", "=", "{", "}", "else", ":", "ret", "=", "_load_result", "(", "existing", ",", "ret", ")", "return", "ret"], "docstring": "Delete an existing pool member.\n\n    hostname\n        The host/address of the bigip device\n    username\n        The iControl REST username\n    password\n        The iControl REST password\n    name\n        The name of the pool to be modified\n    member\n        The name of the member to delete from the pool", "docstring_tokens": ["Delete", "an", "existing", "pool", "member", "."], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/states/bigip.py#L1497-L1561", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/states/bigip.py", "func_name": "list_virtual", "original_string": "def list_virtual(hostname, username, password, name):\n    '''\n    A function to list a specific virtual.\n\n    hostname\n        The host/address of the bigip device\n    username\n        The iControl REST username\n    password\n        The iControl REST password\n    name\n        The name of the virtual to list\n    '''\n\n    ret = {'name': name, 'changes': {}, 'result': False, 'comment': ''}\n\n    if __opts__['test']:\n        return _test_output(ret, 'list', params={\n            'hostname': hostname,\n            'username': username,\n            'password': password,\n            'name': name\n        }\n        )\n\n    response = __salt__['bigip.list_virtual'](hostname, username, password, name)\n    return _load_result(response, ret)", "language": "python", "code": "def list_virtual(hostname, username, password, name):\n    '''\n    A function to list a specific virtual.\n\n    hostname\n        The host/address of the bigip device\n    username\n        The iControl REST username\n    password\n        The iControl REST password\n    name\n        The name of the virtual to list\n    '''\n\n    ret = {'name': name, 'changes': {}, 'result': False, 'comment': ''}\n\n    if __opts__['test']:\n        return _test_output(ret, 'list', params={\n            'hostname': hostname,\n            'username': username,\n            'password': password,\n            'name': name\n        }\n        )\n\n    response = __salt__['bigip.list_virtual'](hostname, username, password, name)\n    return _load_result(response, ret)", "code_tokens": ["def", "list_virtual", "(", "hostname", ",", "username", ",", "password", ",", "name", ")", ":", "ret", "=", "{", "'name'", ":", "name", ",", "'changes'", ":", "{", "}", ",", "'result'", ":", "False", ",", "'comment'", ":", "''", "}", "if", "__opts__", "[", "'test'", "]", ":", "return", "_test_output", "(", "ret", ",", "'list'", ",", "params", "=", "{", "'hostname'", ":", "hostname", ",", "'username'", ":", "username", ",", "'password'", ":", "password", ",", "'name'", ":", "name", "}", ")", "response", "=", "__salt__", "[", "'bigip.list_virtual'", "]", "(", "hostname", ",", "username", ",", "password", ",", "name", ")", "return", "_load_result", "(", "response", ",", "ret", ")"], "docstring": "A function to list a specific virtual.\n\n    hostname\n        The host/address of the bigip device\n    username\n        The iControl REST username\n    password\n        The iControl REST password\n    name\n        The name of the virtual to list", "docstring_tokens": ["A", "function", "to", "list", "a", "specific", "virtual", "."], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/states/bigip.py#L1564-L1590", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/states/bigip.py", "func_name": "manage_virtual", "original_string": "def manage_virtual(hostname, username, password, name, destination,\n                   pool=None,\n                   address_status=None,\n                   auto_lasthop=None,\n                   bwc_policy=None,\n                   cmp_enabled=None,\n                   connection_limit=None,\n                   dhcp_relay=None,\n                   description=None,\n                   fallback_persistence=None,\n                   flow_eviction_policy=None,\n                   gtm_score=None,\n                   ip_forward=None,\n                   ip_protocol=None,\n                   internal=None,\n                   twelve_forward=None,\n                   last_hop_pool=None,\n                   mask=None,\n                   mirror=None,\n                   nat64=None,\n                   persist=None,\n                   profiles=None,\n                   policies=None,\n                   rate_class=None,\n                   rate_limit=None,\n                   rate_limit_mode=None,\n                   rate_limit_dst=None,\n                   rate_limit_src=None,\n                   rules=None,\n                   related_rules=None,\n                   reject=None,\n                   source=None,\n                   source_address_translation=None,\n                   source_port=None,\n                   virtual_state=None,\n                   traffic_classes=None,\n                   translate_address=None,\n                   translate_port=None,\n                   vlans=None):\n    '''\n    Manage a virtual server.  If a virtual does not exists it will be created, otherwise only the\n    parameters specified will be enforced.\n\n    hostname\n        The host/address of the bigip device\n    username\n        The iControl REST username\n    password\n        The iControl REST password\n    name\n        The name of the virtual to create\n    destination\n        [ [virtual_address_name:port] | [ipv4:port] | [ipv6.port] ]\n    pool\n        [ [pool_name] | none]\n    address_status\n        [yes | no]\n    auto_lasthop\n        [default | enabled | disabled ]\n    bwc_policy\n        [none] | string]\n    cmp_enabled\n        [yes | no]\n    dhcp_relay\n        [yes | no}\n    connection_limit\n        [integer]\n    description\n        [string]\n    state\n        [disabled | enabled]\n    fallback_persistence\n        [none | [profile name] ]\n    flow_eviction_policy\n        [none | [eviction policy name] ]\n    gtm_score\n        [integer]\n    ip_forward\n        [yes | no]\n    ip_protocol\n        [any | protocol]\n    internal\n        [yes | no]\n    twelve_forward(12-forward)\n        [yes | no]\n    last_hop-pool\n        [ [pool_name] | none]\n    mask\n        { [ipv4] | [ipv6] }\n    mirror\n        { [disabled | enabled | none] }\n    nat64\n        [enabled | disabled]\n    persist\n        [list]\n    profiles\n        [none | default | list ]\n    policies\n        [none | default | list ]\n    rate_class\n        [name]\n    rate_limit\n        [integer]\n    rate_limit-mode\n        [destination | object | object-destination |\n        object-source | object-source-destination |\n        source | source-destination]\n    rate_limit-dst\n        [integer]\n    rate_limit-src\n        [integer]\n    rules\n        [none | list ]\n    related_rules\n        [none | list ]\n    reject\n        [yes | no]\n    source\n        { [ipv4[/prefixlen]] | [ipv6[/prefixlen]] }\n    source_address_translation\n        [none | snat:pool_name | lsn | automap | dictionary ]\n    source_port\n        [change | preserve | preserve-strict]\n    state\n        [enabled | disabled]\n    traffic_classes\n        [none | default | list ]\n    translate_address\n        [enabled | disabled]\n    translate_port\n        [enabled | disabled]\n    vlans\n        [none | default | dictionary]\n\n        vlan_ids\n            [ list]\n        enabled\n            [ true | false ]\n    '''\n\n    ret = {'name': name, 'changes': {}, 'result': False, 'comment': ''}\n\n    if __opts__['test']:\n        return _test_output(ret, 'manage', params={\n            'hostname': hostname,\n            'username': username,\n            'password': password,\n            'name': name,\n            'destination': destination,\n            'pool': pool,\n            'address_status': address_status,\n            'auto_lasthop': auto_lasthop,\n            'bwc_policy': bwc_policy,\n            'cmp_enabled': cmp_enabled,\n            'connection_limit': connection_limit,\n            'dhcp_relay': dhcp_relay,\n            'description': description,\n            'fallback_persistence': fallback_persistence,\n            'flow_eviction_policy': flow_eviction_policy,\n            'gtm_score': gtm_score,\n            'ip_forward': ip_forward,\n            'ip_protocol': ip_protocol,\n            'internal': internal,\n            'twelve_forward': twelve_forward,\n            'last_hop_pool': last_hop_pool,\n            'mask': mask,\n            'mirror': mirror,\n            'nat64': nat64,\n            'persist': persist,\n            'profiles': profiles,\n            'policies': policies,\n            'rate_class': rate_class,\n            'rate_limit': rate_limit,\n            'rate_limit_mode': rate_limit_mode,\n            'rate_limit_dst': rate_limit_dst,\n            'rate_limit_src': rate_limit_src,\n            'rules': rules,\n            'related_rules': related_rules,\n            'reject': reject,\n            'source': source,\n            'source_address_translation': source_address_translation,\n            'source_port': source_port,\n            'virtual_state': virtual_state,\n            'traffic_classes': traffic_classes,\n            'translate_address': translate_address,\n            'translate_port': translate_port,\n            'vlans': vlans\n        }\n        )\n\n    existing = __salt__['bigip.list_virtual'](hostname, username, password, name)\n\n    # does this virtual exist?\n    if existing['code'] == 200:\n\n        # modify\n        modified = __salt__['bigip.modify_virtual'](hostname=hostname,\n                                                    username=username,\n                                                    password=password,\n                                                    name=name,\n                                                    destination=destination,\n                                                    description=description,\n                                                    pool=pool,\n                                                    address_status=address_status,\n                                                    auto_lasthop=auto_lasthop,\n                                                    bwc_policy=bwc_policy,\n                                                    cmp_enabled=cmp_enabled,\n                                                    connection_limit=connection_limit,\n                                                    dhcp_relay=dhcp_relay,\n                                                    fallback_persistence=fallback_persistence,\n                                                    flow_eviction_policy=flow_eviction_policy,\n                                                    gtm_score=gtm_score,\n                                                    ip_forward=ip_forward,\n                                                    ip_protocol=ip_protocol,\n                                                    internal=internal,\n                                                    twelve_forward=twelve_forward,\n                                                    last_hop_pool=last_hop_pool,\n                                                    mask=mask,\n                                                    mirror=mirror,\n                                                    nat64=nat64,\n                                                    persist=persist,\n                                                    profiles=profiles,\n                                                    policies=policies,\n                                                    rate_class=rate_class,\n                                                    rate_limit=rate_limit,\n                                                    rate_limit_mode=rate_limit_mode,\n                                                    rate_limit_dst=rate_limit_dst,\n                                                    rate_limit_src=rate_limit_src,\n                                                    rules=rules,\n                                                    related_rules=related_rules,\n                                                    reject=reject,\n                                                    source=source,\n                                                    source_address_translation=source_address_translation,\n                                                    source_port=source_port,\n                                                    state=virtual_state,\n                                                    traffic_classes=traffic_classes,\n                                                    translate_address=translate_address,\n                                                    translate_port=translate_port,\n                                                    vlans=vlans)\n\n        #was the modification successful?\n        if modified['code'] == 200:\n\n            #relist it to compare\n            relisting = __salt__['bigip.list_virtual'](hostname, username, password, name)\n\n            if relisting['code'] == 200:\n\n                relisting = _strip_key(relisting, 'generation')\n                existing = _strip_key(existing, 'generation')\n\n                ret = _check_for_changes('Virtual', ret, existing, relisting)\n            else:\n                ret = _load_result(relisting, ret)\n\n        else:\n            ret = _load_result(modified, ret)\n\n    elif existing['code'] == 404:\n\n        #create it\n        virtual = __salt__['bigip.create_virtual'](hostname=hostname,\n                                                   username=username,\n                                                   password=password,\n                                                   name=name,\n                                                   destination=destination,\n                                                   description=description,\n                                                   pool=pool,\n                                                   address_status=address_status,\n                                                   auto_lasthop=auto_lasthop,\n                                                   bwc_policy=bwc_policy,\n                                                   cmp_enabled=cmp_enabled,\n                                                   connection_limit=connection_limit,\n                                                   dhcp_relay=dhcp_relay,\n                                                   fallback_persistence=fallback_persistence,\n                                                   flow_eviction_policy=flow_eviction_policy,\n                                                   gtm_score=gtm_score,\n                                                   ip_forward=ip_forward,\n                                                   ip_protocol=ip_protocol,\n                                                   internal=internal,\n                                                   twelve_forward=twelve_forward,\n                                                   last_hop_pool=last_hop_pool,\n                                                   mask=mask,\n                                                   mirror=mirror,\n                                                   nat64=nat64,\n                                                   persist=persist,\n                                                   profiles=profiles,\n                                                   policies=policies,\n                                                   rate_class=rate_class,\n                                                   rate_limit=rate_limit,\n                                                   rate_limit_mode=rate_limit_mode,\n                                                   rate_limit_dst=rate_limit_dst,\n                                                   rate_limit_src=rate_limit_src,\n                                                   rules=rules,\n                                                   related_rules=related_rules,\n                                                   reject=reject,\n                                                   source=source,\n                                                   source_address_translation=source_address_translation,\n                                                   source_port=source_port,\n                                                   state=virtual_state,\n                                                   traffic_classes=traffic_classes,\n                                                   translate_address=translate_address,\n                                                   translate_port=translate_port,\n                                                   vlans=vlans)\n\n        #were we able to create it?\n        if virtual['code'] == 200:\n            ret['result'] = True\n            ret['changes']['old'] = {}\n            ret['changes']['new'] = virtual['content']\n            ret['comment'] = 'Virtual was successfully created and enforced to the desired state.'\n\n        else:\n            ret = _load_result(virtual, ret)\n\n    else:\n        ret = _load_result(existing, ret)\n\n    return ret", "language": "python", "code": "def manage_virtual(hostname, username, password, name, destination,\n                   pool=None,\n                   address_status=None,\n                   auto_lasthop=None,\n                   bwc_policy=None,\n                   cmp_enabled=None,\n                   connection_limit=None,\n                   dhcp_relay=None,\n                   description=None,\n                   fallback_persistence=None,\n                   flow_eviction_policy=None,\n                   gtm_score=None,\n                   ip_forward=None,\n                   ip_protocol=None,\n                   internal=None,\n                   twelve_forward=None,\n                   last_hop_pool=None,\n                   mask=None,\n                   mirror=None,\n                   nat64=None,\n                   persist=None,\n                   profiles=None,\n                   policies=None,\n                   rate_class=None,\n                   rate_limit=None,\n                   rate_limit_mode=None,\n                   rate_limit_dst=None,\n                   rate_limit_src=None,\n                   rules=None,\n                   related_rules=None,\n                   reject=None,\n                   source=None,\n                   source_address_translation=None,\n                   source_port=None,\n                   virtual_state=None,\n                   traffic_classes=None,\n                   translate_address=None,\n                   translate_port=None,\n                   vlans=None):\n    '''\n    Manage a virtual server.  If a virtual does not exists it will be created, otherwise only the\n    parameters specified will be enforced.\n\n    hostname\n        The host/address of the bigip device\n    username\n        The iControl REST username\n    password\n        The iControl REST password\n    name\n        The name of the virtual to create\n    destination\n        [ [virtual_address_name:port] | [ipv4:port] | [ipv6.port] ]\n    pool\n        [ [pool_name] | none]\n    address_status\n        [yes | no]\n    auto_lasthop\n        [default | enabled | disabled ]\n    bwc_policy\n        [none] | string]\n    cmp_enabled\n        [yes | no]\n    dhcp_relay\n        [yes | no}\n    connection_limit\n        [integer]\n    description\n        [string]\n    state\n        [disabled | enabled]\n    fallback_persistence\n        [none | [profile name] ]\n    flow_eviction_policy\n        [none | [eviction policy name] ]\n    gtm_score\n        [integer]\n    ip_forward\n        [yes | no]\n    ip_protocol\n        [any | protocol]\n    internal\n        [yes | no]\n    twelve_forward(12-forward)\n        [yes | no]\n    last_hop-pool\n        [ [pool_name] | none]\n    mask\n        { [ipv4] | [ipv6] }\n    mirror\n        { [disabled | enabled | none] }\n    nat64\n        [enabled | disabled]\n    persist\n        [list]\n    profiles\n        [none | default | list ]\n    policies\n        [none | default | list ]\n    rate_class\n        [name]\n    rate_limit\n        [integer]\n    rate_limit-mode\n        [destination | object | object-destination |\n        object-source | object-source-destination |\n        source | source-destination]\n    rate_limit-dst\n        [integer]\n    rate_limit-src\n        [integer]\n    rules\n        [none | list ]\n    related_rules\n        [none | list ]\n    reject\n        [yes | no]\n    source\n        { [ipv4[/prefixlen]] | [ipv6[/prefixlen]] }\n    source_address_translation\n        [none | snat:pool_name | lsn | automap | dictionary ]\n    source_port\n        [change | preserve | preserve-strict]\n    state\n        [enabled | disabled]\n    traffic_classes\n        [none | default | list ]\n    translate_address\n        [enabled | disabled]\n    translate_port\n        [enabled | disabled]\n    vlans\n        [none | default | dictionary]\n\n        vlan_ids\n            [ list]\n        enabled\n            [ true | false ]\n    '''\n\n    ret = {'name': name, 'changes': {}, 'result': False, 'comment': ''}\n\n    if __opts__['test']:\n        return _test_output(ret, 'manage', params={\n            'hostname': hostname,\n            'username': username,\n            'password': password,\n            'name': name,\n            'destination': destination,\n            'pool': pool,\n            'address_status': address_status,\n            'auto_lasthop': auto_lasthop,\n            'bwc_policy': bwc_policy,\n            'cmp_enabled': cmp_enabled,\n            'connection_limit': connection_limit,\n            'dhcp_relay': dhcp_relay,\n            'description': description,\n            'fallback_persistence': fallback_persistence,\n            'flow_eviction_policy': flow_eviction_policy,\n            'gtm_score': gtm_score,\n            'ip_forward': ip_forward,\n            'ip_protocol': ip_protocol,\n            'internal': internal,\n            'twelve_forward': twelve_forward,\n            'last_hop_pool': last_hop_pool,\n            'mask': mask,\n            'mirror': mirror,\n            'nat64': nat64,\n            'persist': persist,\n            'profiles': profiles,\n            'policies': policies,\n            'rate_class': rate_class,\n            'rate_limit': rate_limit,\n            'rate_limit_mode': rate_limit_mode,\n            'rate_limit_dst': rate_limit_dst,\n            'rate_limit_src': rate_limit_src,\n            'rules': rules,\n            'related_rules': related_rules,\n            'reject': reject,\n            'source': source,\n            'source_address_translation': source_address_translation,\n            'source_port': source_port,\n            'virtual_state': virtual_state,\n            'traffic_classes': traffic_classes,\n            'translate_address': translate_address,\n            'translate_port': translate_port,\n            'vlans': vlans\n        }\n        )\n\n    existing = __salt__['bigip.list_virtual'](hostname, username, password, name)\n\n    # does this virtual exist?\n    if existing['code'] == 200:\n\n        # modify\n        modified = __salt__['bigip.modify_virtual'](hostname=hostname,\n                                                    username=username,\n                                                    password=password,\n                                                    name=name,\n                                                    destination=destination,\n                                                    description=description,\n                                                    pool=pool,\n                                                    address_status=address_status,\n                                                    auto_lasthop=auto_lasthop,\n                                                    bwc_policy=bwc_policy,\n                                                    cmp_enabled=cmp_enabled,\n                                                    connection_limit=connection_limit,\n                                                    dhcp_relay=dhcp_relay,\n                                                    fallback_persistence=fallback_persistence,\n                                                    flow_eviction_policy=flow_eviction_policy,\n                                                    gtm_score=gtm_score,\n                                                    ip_forward=ip_forward,\n                                                    ip_protocol=ip_protocol,\n                                                    internal=internal,\n                                                    twelve_forward=twelve_forward,\n                                                    last_hop_pool=last_hop_pool,\n                                                    mask=mask,\n                                                    mirror=mirror,\n                                                    nat64=nat64,\n                                                    persist=persist,\n                                                    profiles=profiles,\n                                                    policies=policies,\n                                                    rate_class=rate_class,\n                                                    rate_limit=rate_limit,\n                                                    rate_limit_mode=rate_limit_mode,\n                                                    rate_limit_dst=rate_limit_dst,\n                                                    rate_limit_src=rate_limit_src,\n                                                    rules=rules,\n                                                    related_rules=related_rules,\n                                                    reject=reject,\n                                                    source=source,\n                                                    source_address_translation=source_address_translation,\n                                                    source_port=source_port,\n                                                    state=virtual_state,\n                                                    traffic_classes=traffic_classes,\n                                                    translate_address=translate_address,\n                                                    translate_port=translate_port,\n                                                    vlans=vlans)\n\n        #was the modification successful?\n        if modified['code'] == 200:\n\n            #relist it to compare\n            relisting = __salt__['bigip.list_virtual'](hostname, username, password, name)\n\n            if relisting['code'] == 200:\n\n                relisting = _strip_key(relisting, 'generation')\n                existing = _strip_key(existing, 'generation')\n\n                ret = _check_for_changes('Virtual', ret, existing, relisting)\n            else:\n                ret = _load_result(relisting, ret)\n\n        else:\n            ret = _load_result(modified, ret)\n\n    elif existing['code'] == 404:\n\n        #create it\n        virtual = __salt__['bigip.create_virtual'](hostname=hostname,\n                                                   username=username,\n                                                   password=password,\n                                                   name=name,\n                                                   destination=destination,\n                                                   description=description,\n                                                   pool=pool,\n                                                   address_status=address_status,\n                                                   auto_lasthop=auto_lasthop,\n                                                   bwc_policy=bwc_policy,\n                                                   cmp_enabled=cmp_enabled,\n                                                   connection_limit=connection_limit,\n                                                   dhcp_relay=dhcp_relay,\n                                                   fallback_persistence=fallback_persistence,\n                                                   flow_eviction_policy=flow_eviction_policy,\n                                                   gtm_score=gtm_score,\n                                                   ip_forward=ip_forward,\n                                                   ip_protocol=ip_protocol,\n                                                   internal=internal,\n                                                   twelve_forward=twelve_forward,\n                                                   last_hop_pool=last_hop_pool,\n                                                   mask=mask,\n                                                   mirror=mirror,\n                                                   nat64=nat64,\n                                                   persist=persist,\n                                                   profiles=profiles,\n                                                   policies=policies,\n                                                   rate_class=rate_class,\n                                                   rate_limit=rate_limit,\n                                                   rate_limit_mode=rate_limit_mode,\n                                                   rate_limit_dst=rate_limit_dst,\n                                                   rate_limit_src=rate_limit_src,\n                                                   rules=rules,\n                                                   related_rules=related_rules,\n                                                   reject=reject,\n                                                   source=source,\n                                                   source_address_translation=source_address_translation,\n                                                   source_port=source_port,\n                                                   state=virtual_state,\n                                                   traffic_classes=traffic_classes,\n                                                   translate_address=translate_address,\n                                                   translate_port=translate_port,\n                                                   vlans=vlans)\n\n        #were we able to create it?\n        if virtual['code'] == 200:\n            ret['result'] = True\n            ret['changes']['old'] = {}\n            ret['changes']['new'] = virtual['content']\n            ret['comment'] = 'Virtual was successfully created and enforced to the desired state.'\n\n        else:\n            ret = _load_result(virtual, ret)\n\n    else:\n        ret = _load_result(existing, ret)\n\n    return ret", "code_tokens": ["def", "manage_virtual", "(", "hostname", ",", "username", ",", "password", ",", "name", ",", "destination", ",", "pool", "=", "None", ",", "address_status", "=", "None", ",", "auto_lasthop", "=", "None", ",", "bwc_policy", "=", "None", ",", "cmp_enabled", "=", "None", ",", "connection_limit", "=", "None", ",", "dhcp_relay", "=", "None", ",", "description", "=", "None", ",", "fallback_persistence", "=", "None", ",", "flow_eviction_policy", "=", "None", ",", "gtm_score", "=", "None", ",", "ip_forward", "=", "None", ",", "ip_protocol", "=", "None", ",", "internal", "=", "None", ",", "twelve_forward", "=", "None", ",", "last_hop_pool", "=", "None", ",", "mask", "=", "None", ",", "mirror", "=", "None", ",", "nat64", "=", "None", ",", "persist", "=", "None", ",", "profiles", "=", "None", ",", "policies", "=", "None", ",", "rate_class", "=", "None", ",", "rate_limit", "=", "None", ",", "rate_limit_mode", "=", "None", ",", "rate_limit_dst", "=", "None", ",", "rate_limit_src", "=", "None", ",", "rules", "=", "None", ",", "related_rules", "=", "None", ",", "reject", "=", "None", ",", "source", "=", "None", ",", "source_address_translation", "=", "None", ",", "source_port", "=", "None", ",", "virtual_state", "=", "None", ",", "traffic_classes", "=", "None", ",", "translate_address", "=", "None", ",", "translate_port", "=", "None", ",", "vlans", "=", "None", ")", ":", "ret", "=", "{", "'name'", ":", "name", ",", "'changes'", ":", "{", "}", ",", "'result'", ":", "False", ",", "'comment'", ":", "''", "}", "if", "__opts__", "[", "'test'", "]", ":", "return", "_test_output", "(", "ret", ",", "'manage'", ",", "params", "=", "{", "'hostname'", ":", "hostname", ",", "'username'", ":", "username", ",", "'password'", ":", "password", ",", "'name'", ":", "name", ",", "'destination'", ":", "destination", ",", "'pool'", ":", "pool", ",", "'address_status'", ":", "address_status", ",", "'auto_lasthop'", ":", "auto_lasthop", ",", "'bwc_policy'", ":", "bwc_policy", ",", "'cmp_enabled'", ":", "cmp_enabled", ",", "'connection_limit'", ":", "connection_limit", ",", "'dhcp_relay'", ":", "dhcp_relay", ",", "'description'", ":", "description", ",", "'fallback_persistence'", ":", "fallback_persistence", ",", "'flow_eviction_policy'", ":", "flow_eviction_policy", ",", "'gtm_score'", ":", "gtm_score", ",", "'ip_forward'", ":", "ip_forward", ",", "'ip_protocol'", ":", "ip_protocol", ",", "'internal'", ":", "internal", ",", "'twelve_forward'", ":", "twelve_forward", ",", "'last_hop_pool'", ":", "last_hop_pool", ",", "'mask'", ":", "mask", ",", "'mirror'", ":", "mirror", ",", "'nat64'", ":", "nat64", ",", "'persist'", ":", "persist", ",", "'profiles'", ":", "profiles", ",", "'policies'", ":", "policies", ",", "'rate_class'", ":", "rate_class", ",", "'rate_limit'", ":", "rate_limit", ",", "'rate_limit_mode'", ":", "rate_limit_mode", ",", "'rate_limit_dst'", ":", "rate_limit_dst", ",", "'rate_limit_src'", ":", "rate_limit_src", ",", "'rules'", ":", "rules", ",", "'related_rules'", ":", "related_rules", ",", "'reject'", ":", "reject", ",", "'source'", ":", "source", ",", "'source_address_translation'", ":", "source_address_translation", ",", "'source_port'", ":", "source_port", ",", "'virtual_state'", ":", "virtual_state", ",", "'traffic_classes'", ":", "traffic_classes", ",", "'translate_address'", ":", "translate_address", ",", "'translate_port'", ":", "translate_port", ",", "'vlans'", ":", "vlans", "}", ")", "existing", "=", "__salt__", "[", "'bigip.list_virtual'", "]", "(", "hostname", ",", "username", ",", "password", ",", "name", ")", "# does this virtual exist?", "if", "existing", "[", "'code'", "]", "==", "200", ":", "# modify", "modified", "=", "__salt__", "[", "'bigip.modify_virtual'", "]", "(", "hostname", "=", "hostname", ",", "username", "=", "username", ",", "password", "=", "password", ",", "name", "=", "name", ",", "destination", "=", "destination", ",", "description", "=", "description", ",", "pool", "=", "pool", ",", "address_status", "=", "address_status", ",", "auto_lasthop", "=", "auto_lasthop", ",", "bwc_policy", "=", "bwc_policy", ",", "cmp_enabled", "=", "cmp_enabled", ",", "connection_limit", "=", "connection_limit", ",", "dhcp_relay", "=", "dhcp_relay", ",", "fallback_persistence", "=", "fallback_persistence", ",", "flow_eviction_policy", "=", "flow_eviction_policy", ",", "gtm_score", "=", "gtm_score", ",", "ip_forward", "=", "ip_forward", ",", "ip_protocol", "=", "ip_protocol", ",", "internal", "=", "internal", ",", "twelve_forward", "=", "twelve_forward", ",", "last_hop_pool", "=", "last_hop_pool", ",", "mask", "=", "mask", ",", "mirror", "=", "mirror", ",", "nat64", "=", "nat64", ",", "persist", "=", "persist", ",", "profiles", "=", "profiles", ",", "policies", "=", "policies", ",", "rate_class", "=", "rate_class", ",", "rate_limit", "=", "rate_limit", ",", "rate_limit_mode", "=", "rate_limit_mode", ",", "rate_limit_dst", "=", "rate_limit_dst", ",", "rate_limit_src", "=", "rate_limit_src", ",", "rules", "=", "rules", ",", "related_rules", "=", "related_rules", ",", "reject", "=", "reject", ",", "source", "=", "source", ",", "source_address_translation", "=", "source_address_translation", ",", "source_port", "=", "source_port", ",", "state", "=", "virtual_state", ",", "traffic_classes", "=", "traffic_classes", ",", "translate_address", "=", "translate_address", ",", "translate_port", "=", "translate_port", ",", "vlans", "=", "vlans", ")", "#was the modification successful?", "if", "modified", "[", "'code'", "]", "==", "200", ":", "#relist it to compare", "relisting", "=", "__salt__", "[", "'bigip.list_virtual'", "]", "(", "hostname", ",", "username", ",", "password", ",", "name", ")", "if", "relisting", "[", "'code'", "]", "==", "200", ":", "relisting", "=", "_strip_key", "(", "relisting", ",", "'generation'", ")", "existing", "=", "_strip_key", "(", "existing", ",", "'generation'", ")", "ret", "=", "_check_for_changes", "(", "'Virtual'", ",", "ret", ",", "existing", ",", "relisting", ")", "else", ":", "ret", "=", "_load_result", "(", "relisting", ",", "ret", ")", "else", ":", "ret", "=", "_load_result", "(", "modified", ",", "ret", ")", "elif", "existing", "[", "'code'", "]", "==", "404", ":", "#create it", "virtual", "=", "__salt__", "[", "'bigip.create_virtual'", "]", "(", "hostname", "=", "hostname", ",", "username", "=", "username", ",", "password", "=", "password", ",", "name", "=", "name", ",", "destination", "=", "destination", ",", "description", "=", "description", ",", "pool", "=", "pool", ",", "address_status", "=", "address_status", ",", "auto_lasthop", "=", "auto_lasthop", ",", "bwc_policy", "=", "bwc_policy", ",", "cmp_enabled", "=", "cmp_enabled", ",", "connection_limit", "=", "connection_limit", ",", "dhcp_relay", "=", "dhcp_relay", ",", "fallback_persistence", "=", "fallback_persistence", ",", "flow_eviction_policy", "=", "flow_eviction_policy", ",", "gtm_score", "=", "gtm_score", ",", "ip_forward", "=", "ip_forward", ",", "ip_protocol", "=", "ip_protocol", ",", "internal", "=", "internal", ",", "twelve_forward", "=", "twelve_forward", ",", "last_hop_pool", "=", "last_hop_pool", ",", "mask", "=", "mask", ",", "mirror", "=", "mirror", ",", "nat64", "=", "nat64", ",", "persist", "=", "persist", ",", "profiles", "=", "profiles", ",", "policies", "=", "policies", ",", "rate_class", "=", "rate_class", ",", "rate_limit", "=", "rate_limit", ",", "rate_limit_mode", "=", "rate_limit_mode", ",", "rate_limit_dst", "=", "rate_limit_dst", ",", "rate_limit_src", "=", "rate_limit_src", ",", "rules", "=", "rules", ",", "related_rules", "=", "related_rules", ",", "reject", "=", "reject", ",", "source", "=", "source", ",", "source_address_translation", "=", "source_address_translation", ",", "source_port", "=", "source_port", ",", "state", "=", "virtual_state", ",", "traffic_classes", "=", "traffic_classes", ",", "translate_address", "=", "translate_address", ",", "translate_port", "=", "translate_port", ",", "vlans", "=", "vlans", ")", "#were we able to create it?", "if", "virtual", "[", "'code'", "]", "==", "200", ":", "ret", "[", "'result'", "]", "=", "True", "ret", "[", "'changes'", "]", "[", "'old'", "]", "=", "{", "}", "ret", "[", "'changes'", "]", "[", "'new'", "]", "=", "virtual", "[", "'content'", "]", "ret", "[", "'comment'", "]", "=", "'Virtual was successfully created and enforced to the desired state.'", "else", ":", "ret", "=", "_load_result", "(", "virtual", ",", "ret", ")", "else", ":", "ret", "=", "_load_result", "(", "existing", ",", "ret", ")", "return", "ret"], "docstring": "Manage a virtual server.  If a virtual does not exists it will be created, otherwise only the\n    parameters specified will be enforced.\n\n    hostname\n        The host/address of the bigip device\n    username\n        The iControl REST username\n    password\n        The iControl REST password\n    name\n        The name of the virtual to create\n    destination\n        [ [virtual_address_name:port] | [ipv4:port] | [ipv6.port] ]\n    pool\n        [ [pool_name] | none]\n    address_status\n        [yes | no]\n    auto_lasthop\n        [default | enabled | disabled ]\n    bwc_policy\n        [none] | string]\n    cmp_enabled\n        [yes | no]\n    dhcp_relay\n        [yes | no}\n    connection_limit\n        [integer]\n    description\n        [string]\n    state\n        [disabled | enabled]\n    fallback_persistence\n        [none | [profile name] ]\n    flow_eviction_policy\n        [none | [eviction policy name] ]\n    gtm_score\n        [integer]\n    ip_forward\n        [yes | no]\n    ip_protocol\n        [any | protocol]\n    internal\n        [yes | no]\n    twelve_forward(12-forward)\n        [yes | no]\n    last_hop-pool\n        [ [pool_name] | none]\n    mask\n        { [ipv4] | [ipv6] }\n    mirror\n        { [disabled | enabled | none] }\n    nat64\n        [enabled | disabled]\n    persist\n        [list]\n    profiles\n        [none | default | list ]\n    policies\n        [none | default | list ]\n    rate_class\n        [name]\n    rate_limit\n        [integer]\n    rate_limit-mode\n        [destination | object | object-destination |\n        object-source | object-source-destination |\n        source | source-destination]\n    rate_limit-dst\n        [integer]\n    rate_limit-src\n        [integer]\n    rules\n        [none | list ]\n    related_rules\n        [none | list ]\n    reject\n        [yes | no]\n    source\n        { [ipv4[/prefixlen]] | [ipv6[/prefixlen]] }\n    source_address_translation\n        [none | snat:pool_name | lsn | automap | dictionary ]\n    source_port\n        [change | preserve | preserve-strict]\n    state\n        [enabled | disabled]\n    traffic_classes\n        [none | default | list ]\n    translate_address\n        [enabled | disabled]\n    translate_port\n        [enabled | disabled]\n    vlans\n        [none | default | dictionary]\n\n        vlan_ids\n            [ list]\n        enabled\n            [ true | false ]", "docstring_tokens": ["Manage", "a", "virtual", "server", ".", "If", "a", "virtual", "does", "not", "exists", "it", "will", "be", "created", "otherwise", "only", "the", "parameters", "specified", "will", "be", "enforced", "."], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/states/bigip.py#L1851-L2169", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/states/bigip.py", "func_name": "modify_virtual", "original_string": "def modify_virtual(hostname, username, password, name, destination,\n                   pool=None,\n                   address_status=None,\n                   auto_lasthop=None,\n                   bwc_policy=None,\n                   cmp_enabled=None,\n                   connection_limit=None,\n                   dhcp_relay=None,\n                   description=None,\n                   fallback_persistence=None,\n                   flow_eviction_policy=None,\n                   gtm_score=None,\n                   ip_forward=None,\n                   ip_protocol=None,\n                   internal=None,\n                   twelve_forward=None,\n                   last_hop_pool=None,\n                   mask=None,\n                   mirror=None,\n                   nat64=None,\n                   persist=None,\n                   profiles=None,\n                   policies=None,\n                   rate_class=None,\n                   rate_limit=None,\n                   rate_limit_mode=None,\n                   rate_limit_dst=None,\n                   rate_limit_src=None,\n                   rules=None,\n                   related_rules=None,\n                   reject=None,\n                   source=None,\n                   source_address_translation=None,\n                   source_port=None,\n                   virtual_state=None,\n                   traffic_classes=None,\n                   translate_address=None,\n                   translate_port=None,\n                   vlans=None):\n    '''\n    Modify an virtual server.  modify an existing virtual.  Only parameters specified will be enforced.\n\n    hostname\n        The host/address of the bigip device\n    username\n        The iControl REST username\n    password\n        The iControl REST password\n    name\n        The name of the virtual to create\n    destination\n        [ [virtual_address_name:port] | [ipv4:port] | [ipv6.port] ]\n    pool\n        [ [pool_name] | none]\n    address_status\n        [yes | no]\n    auto_lasthop\n        [default | enabled | disabled ]\n    bwc_policy\n        [none] | string]\n    cmp_enabled\n        [yes | no]\n    dhcp_relay\n        [yes | no}\n    connection_limit\n        [integer]\n    description\n        [string]\n    state\n        [disabled | enabled]\n    fallback_persistence\n        [none | [profile name] ]\n    flow_eviction_policy\n        [none | [eviction policy name] ]\n    gtm_score\n        [integer]\n    ip_forward\n        [yes | no]\n    ip_protocol\n        [any | protocol]\n    internal\n        [yes | no]\n    twelve_forward(12-forward)\n        [yes | no]\n    last_hop-pool\n        [ [pool_name] | none]\n    mask\n        { [ipv4] | [ipv6] }\n    mirror\n        { [disabled | enabled | none] }\n    nat64\n        [enabled | disabled]\n    persist\n        [list]\n    profiles\n        [none | default | list ]\n    policies\n        [none | default | list ]\n    rate_class\n        [name]\n    rate_limit\n        [integer]\n    rate_limit-mode\n        [destination | object | object-destination |\n        object-source | object-source-destination |\n        source | source-destination]\n    rate_limit_dst\n        [integer]\n    rate_limit_src\n        [integer]\n    rules\n        [none | list ]\n    related_rules\n        [none | list ]\n    reject\n        [yes | no]\n    source\n        { [ipv4[/prefixlen]] | [ipv6[/prefixlen]] }\n    source_address_translation\n        [none | snat:pool_name | lsn | automap | dictionary ]\n    source_port\n        [change | preserve | preserve-strict]\n    state\n        [enabled | disabled]\n    traffic_classes\n        [none | default | list ]\n    translate_address\n        [enabled | disabled]\n    translate_port\n        [enabled | disabled]\n    vlans\n        [none | default | dictionary ]\n\n        vlan_ids\n            [ list]\n        enabled\n            [ true | false ]\n\n    '''\n\n    ret = {'name': name, 'changes': {}, 'result': False, 'comment': ''}\n\n    if __opts__['test']:\n        return _test_output(ret, 'modify', params={\n            'hostname': hostname,\n            'username': username,\n            'password': password,\n            'name': name,\n            'destination': destination,\n            'pool': pool,\n            'address_status': address_status,\n            'auto_lasthop': auto_lasthop,\n            'bwc_policy': bwc_policy,\n            'cmp_enabled': cmp_enabled,\n            'connection_limit': connection_limit,\n            'dhcp_relay': dhcp_relay,\n            'description': description,\n            'fallback_persistence': fallback_persistence,\n            'flow_eviction_policy': flow_eviction_policy,\n            'gtm_score': gtm_score,\n            'ip_forward': ip_forward,\n            'ip_protocol': ip_protocol,\n            'internal': internal,\n            'twelve_forward': twelve_forward,\n            'last_hop_pool': last_hop_pool,\n            'mask': mask,\n            'mirror': mirror,\n            'nat64': nat64,\n            'persist': persist,\n            'profiles': profiles,\n            'policies': policies,\n            'rate_class': rate_class,\n            'rate_limit': rate_limit,\n            'rate_limit_mode': rate_limit_mode,\n            'rate_limit_dst': rate_limit_dst,\n            'rate_limit_src': rate_limit_src,\n            'rules': rules,\n            'related_rules': related_rules,\n            'reject': reject,\n            'source': source,\n            'source_address_translation': source_address_translation,\n            'source_port': source_port,\n            'virtual_state': virtual_state,\n            'traffic_classes': traffic_classes,\n            'translate_address': translate_address,\n            'translate_port': translate_port,\n            'vlans': vlans\n        }\n        )\n\n    existing = __salt__['bigip.list_virtual'](hostname, username, password, name)\n\n    # does this virtual exist?\n    if existing['code'] == 200:\n\n        # modify\n        modified = __salt__['bigip.modify_virtual'](hostname=hostname,\n                                                    username=username,\n                                                    password=password,\n                                                    name=name,\n                                                    destination=destination,\n                                                    description=description,\n                                                    pool=pool,\n                                                    address_status=address_status,\n                                                    auto_lasthop=auto_lasthop,\n                                                    bwc_policy=bwc_policy,\n                                                    cmp_enabled=cmp_enabled,\n                                                    connection_limit=connection_limit,\n                                                    dhcp_relay=dhcp_relay,\n                                                    fallback_persistence=fallback_persistence,\n                                                    flow_eviction_policy=flow_eviction_policy,\n                                                    gtm_score=gtm_score,\n                                                    ip_forward=ip_forward,\n                                                    ip_protocol=ip_protocol,\n                                                    internal=internal,\n                                                    twelve_forward=twelve_forward,\n                                                    last_hop_pool=last_hop_pool,\n                                                    mask=mask,\n                                                    mirror=mirror,\n                                                    nat64=nat64,\n                                                    persist=persist,\n                                                    profiles=profiles,\n                                                    policies=policies,\n                                                    rate_class=rate_class,\n                                                    rate_limit=rate_limit,\n                                                    rate_limit_mode=rate_limit_mode,\n                                                    rate_limit_dst=rate_limit_dst,\n                                                    rate_limit_src=rate_limit_src,\n                                                    rules=rules,\n                                                    related_rules=related_rules,\n                                                    reject=reject,\n                                                    source=source,\n                                                    source_address_translation=source_address_translation,\n                                                    source_port=source_port,\n                                                    state=virtual_state,\n                                                    traffic_classes=traffic_classes,\n                                                    translate_address=translate_address,\n                                                    translate_port=translate_port,\n                                                    vlans=vlans)\n\n        #was the modification successful?\n        if modified['code'] == 200:\n\n            #relist it to compare\n            relisting = __salt__['bigip.list_virtual'](hostname, username, password, name)\n\n            if relisting['code'] == 200:\n\n                relisting = _strip_key(relisting, 'generation')\n                existing = _strip_key(existing, 'generation')\n\n                ret = _check_for_changes('Virtual', ret, existing, relisting)\n            else:\n                ret = _load_result(relisting, ret)\n\n        else:\n            ret = _load_result(modified, ret)\n\n    elif existing['code'] == 404:\n        ret['comment'] = 'A Virtual with this name was not found.'\n        # else something else was returned\n    else:\n        ret = _load_result(existing, ret)\n\n    return ret", "language": "python", "code": "def modify_virtual(hostname, username, password, name, destination,\n                   pool=None,\n                   address_status=None,\n                   auto_lasthop=None,\n                   bwc_policy=None,\n                   cmp_enabled=None,\n                   connection_limit=None,\n                   dhcp_relay=None,\n                   description=None,\n                   fallback_persistence=None,\n                   flow_eviction_policy=None,\n                   gtm_score=None,\n                   ip_forward=None,\n                   ip_protocol=None,\n                   internal=None,\n                   twelve_forward=None,\n                   last_hop_pool=None,\n                   mask=None,\n                   mirror=None,\n                   nat64=None,\n                   persist=None,\n                   profiles=None,\n                   policies=None,\n                   rate_class=None,\n                   rate_limit=None,\n                   rate_limit_mode=None,\n                   rate_limit_dst=None,\n                   rate_limit_src=None,\n                   rules=None,\n                   related_rules=None,\n                   reject=None,\n                   source=None,\n                   source_address_translation=None,\n                   source_port=None,\n                   virtual_state=None,\n                   traffic_classes=None,\n                   translate_address=None,\n                   translate_port=None,\n                   vlans=None):\n    '''\n    Modify an virtual server.  modify an existing virtual.  Only parameters specified will be enforced.\n\n    hostname\n        The host/address of the bigip device\n    username\n        The iControl REST username\n    password\n        The iControl REST password\n    name\n        The name of the virtual to create\n    destination\n        [ [virtual_address_name:port] | [ipv4:port] | [ipv6.port] ]\n    pool\n        [ [pool_name] | none]\n    address_status\n        [yes | no]\n    auto_lasthop\n        [default | enabled | disabled ]\n    bwc_policy\n        [none] | string]\n    cmp_enabled\n        [yes | no]\n    dhcp_relay\n        [yes | no}\n    connection_limit\n        [integer]\n    description\n        [string]\n    state\n        [disabled | enabled]\n    fallback_persistence\n        [none | [profile name] ]\n    flow_eviction_policy\n        [none | [eviction policy name] ]\n    gtm_score\n        [integer]\n    ip_forward\n        [yes | no]\n    ip_protocol\n        [any | protocol]\n    internal\n        [yes | no]\n    twelve_forward(12-forward)\n        [yes | no]\n    last_hop-pool\n        [ [pool_name] | none]\n    mask\n        { [ipv4] | [ipv6] }\n    mirror\n        { [disabled | enabled | none] }\n    nat64\n        [enabled | disabled]\n    persist\n        [list]\n    profiles\n        [none | default | list ]\n    policies\n        [none | default | list ]\n    rate_class\n        [name]\n    rate_limit\n        [integer]\n    rate_limit-mode\n        [destination | object | object-destination |\n        object-source | object-source-destination |\n        source | source-destination]\n    rate_limit_dst\n        [integer]\n    rate_limit_src\n        [integer]\n    rules\n        [none | list ]\n    related_rules\n        [none | list ]\n    reject\n        [yes | no]\n    source\n        { [ipv4[/prefixlen]] | [ipv6[/prefixlen]] }\n    source_address_translation\n        [none | snat:pool_name | lsn | automap | dictionary ]\n    source_port\n        [change | preserve | preserve-strict]\n    state\n        [enabled | disabled]\n    traffic_classes\n        [none | default | list ]\n    translate_address\n        [enabled | disabled]\n    translate_port\n        [enabled | disabled]\n    vlans\n        [none | default | dictionary ]\n\n        vlan_ids\n            [ list]\n        enabled\n            [ true | false ]\n\n    '''\n\n    ret = {'name': name, 'changes': {}, 'result': False, 'comment': ''}\n\n    if __opts__['test']:\n        return _test_output(ret, 'modify', params={\n            'hostname': hostname,\n            'username': username,\n            'password': password,\n            'name': name,\n            'destination': destination,\n            'pool': pool,\n            'address_status': address_status,\n            'auto_lasthop': auto_lasthop,\n            'bwc_policy': bwc_policy,\n            'cmp_enabled': cmp_enabled,\n            'connection_limit': connection_limit,\n            'dhcp_relay': dhcp_relay,\n            'description': description,\n            'fallback_persistence': fallback_persistence,\n            'flow_eviction_policy': flow_eviction_policy,\n            'gtm_score': gtm_score,\n            'ip_forward': ip_forward,\n            'ip_protocol': ip_protocol,\n            'internal': internal,\n            'twelve_forward': twelve_forward,\n            'last_hop_pool': last_hop_pool,\n            'mask': mask,\n            'mirror': mirror,\n            'nat64': nat64,\n            'persist': persist,\n            'profiles': profiles,\n            'policies': policies,\n            'rate_class': rate_class,\n            'rate_limit': rate_limit,\n            'rate_limit_mode': rate_limit_mode,\n            'rate_limit_dst': rate_limit_dst,\n            'rate_limit_src': rate_limit_src,\n            'rules': rules,\n            'related_rules': related_rules,\n            'reject': reject,\n            'source': source,\n            'source_address_translation': source_address_translation,\n            'source_port': source_port,\n            'virtual_state': virtual_state,\n            'traffic_classes': traffic_classes,\n            'translate_address': translate_address,\n            'translate_port': translate_port,\n            'vlans': vlans\n        }\n        )\n\n    existing = __salt__['bigip.list_virtual'](hostname, username, password, name)\n\n    # does this virtual exist?\n    if existing['code'] == 200:\n\n        # modify\n        modified = __salt__['bigip.modify_virtual'](hostname=hostname,\n                                                    username=username,\n                                                    password=password,\n                                                    name=name,\n                                                    destination=destination,\n                                                    description=description,\n                                                    pool=pool,\n                                                    address_status=address_status,\n                                                    auto_lasthop=auto_lasthop,\n                                                    bwc_policy=bwc_policy,\n                                                    cmp_enabled=cmp_enabled,\n                                                    connection_limit=connection_limit,\n                                                    dhcp_relay=dhcp_relay,\n                                                    fallback_persistence=fallback_persistence,\n                                                    flow_eviction_policy=flow_eviction_policy,\n                                                    gtm_score=gtm_score,\n                                                    ip_forward=ip_forward,\n                                                    ip_protocol=ip_protocol,\n                                                    internal=internal,\n                                                    twelve_forward=twelve_forward,\n                                                    last_hop_pool=last_hop_pool,\n                                                    mask=mask,\n                                                    mirror=mirror,\n                                                    nat64=nat64,\n                                                    persist=persist,\n                                                    profiles=profiles,\n                                                    policies=policies,\n                                                    rate_class=rate_class,\n                                                    rate_limit=rate_limit,\n                                                    rate_limit_mode=rate_limit_mode,\n                                                    rate_limit_dst=rate_limit_dst,\n                                                    rate_limit_src=rate_limit_src,\n                                                    rules=rules,\n                                                    related_rules=related_rules,\n                                                    reject=reject,\n                                                    source=source,\n                                                    source_address_translation=source_address_translation,\n                                                    source_port=source_port,\n                                                    state=virtual_state,\n                                                    traffic_classes=traffic_classes,\n                                                    translate_address=translate_address,\n                                                    translate_port=translate_port,\n                                                    vlans=vlans)\n\n        #was the modification successful?\n        if modified['code'] == 200:\n\n            #relist it to compare\n            relisting = __salt__['bigip.list_virtual'](hostname, username, password, name)\n\n            if relisting['code'] == 200:\n\n                relisting = _strip_key(relisting, 'generation')\n                existing = _strip_key(existing, 'generation')\n\n                ret = _check_for_changes('Virtual', ret, existing, relisting)\n            else:\n                ret = _load_result(relisting, ret)\n\n        else:\n            ret = _load_result(modified, ret)\n\n    elif existing['code'] == 404:\n        ret['comment'] = 'A Virtual with this name was not found.'\n        # else something else was returned\n    else:\n        ret = _load_result(existing, ret)\n\n    return ret", "code_tokens": ["def", "modify_virtual", "(", "hostname", ",", "username", ",", "password", ",", "name", ",", "destination", ",", "pool", "=", "None", ",", "address_status", "=", "None", ",", "auto_lasthop", "=", "None", ",", "bwc_policy", "=", "None", ",", "cmp_enabled", "=", "None", ",", "connection_limit", "=", "None", ",", "dhcp_relay", "=", "None", ",", "description", "=", "None", ",", "fallback_persistence", "=", "None", ",", "flow_eviction_policy", "=", "None", ",", "gtm_score", "=", "None", ",", "ip_forward", "=", "None", ",", "ip_protocol", "=", "None", ",", "internal", "=", "None", ",", "twelve_forward", "=", "None", ",", "last_hop_pool", "=", "None", ",", "mask", "=", "None", ",", "mirror", "=", "None", ",", "nat64", "=", "None", ",", "persist", "=", "None", ",", "profiles", "=", "None", ",", "policies", "=", "None", ",", "rate_class", "=", "None", ",", "rate_limit", "=", "None", ",", "rate_limit_mode", "=", "None", ",", "rate_limit_dst", "=", "None", ",", "rate_limit_src", "=", "None", ",", "rules", "=", "None", ",", "related_rules", "=", "None", ",", "reject", "=", "None", ",", "source", "=", "None", ",", "source_address_translation", "=", "None", ",", "source_port", "=", "None", ",", "virtual_state", "=", "None", ",", "traffic_classes", "=", "None", ",", "translate_address", "=", "None", ",", "translate_port", "=", "None", ",", "vlans", "=", "None", ")", ":", "ret", "=", "{", "'name'", ":", "name", ",", "'changes'", ":", "{", "}", ",", "'result'", ":", "False", ",", "'comment'", ":", "''", "}", "if", "__opts__", "[", "'test'", "]", ":", "return", "_test_output", "(", "ret", ",", "'modify'", ",", "params", "=", "{", "'hostname'", ":", "hostname", ",", "'username'", ":", "username", ",", "'password'", ":", "password", ",", "'name'", ":", "name", ",", "'destination'", ":", "destination", ",", "'pool'", ":", "pool", ",", "'address_status'", ":", "address_status", ",", "'auto_lasthop'", ":", "auto_lasthop", ",", "'bwc_policy'", ":", "bwc_policy", ",", "'cmp_enabled'", ":", "cmp_enabled", ",", "'connection_limit'", ":", "connection_limit", ",", "'dhcp_relay'", ":", "dhcp_relay", ",", "'description'", ":", "description", ",", "'fallback_persistence'", ":", "fallback_persistence", ",", "'flow_eviction_policy'", ":", "flow_eviction_policy", ",", "'gtm_score'", ":", "gtm_score", ",", "'ip_forward'", ":", "ip_forward", ",", "'ip_protocol'", ":", "ip_protocol", ",", "'internal'", ":", "internal", ",", "'twelve_forward'", ":", "twelve_forward", ",", "'last_hop_pool'", ":", "last_hop_pool", ",", "'mask'", ":", "mask", ",", "'mirror'", ":", "mirror", ",", "'nat64'", ":", "nat64", ",", "'persist'", ":", "persist", ",", "'profiles'", ":", "profiles", ",", "'policies'", ":", "policies", ",", "'rate_class'", ":", "rate_class", ",", "'rate_limit'", ":", "rate_limit", ",", "'rate_limit_mode'", ":", "rate_limit_mode", ",", "'rate_limit_dst'", ":", "rate_limit_dst", ",", "'rate_limit_src'", ":", "rate_limit_src", ",", "'rules'", ":", "rules", ",", "'related_rules'", ":", "related_rules", ",", "'reject'", ":", "reject", ",", "'source'", ":", "source", ",", "'source_address_translation'", ":", "source_address_translation", ",", "'source_port'", ":", "source_port", ",", "'virtual_state'", ":", "virtual_state", ",", "'traffic_classes'", ":", "traffic_classes", ",", "'translate_address'", ":", "translate_address", ",", "'translate_port'", ":", "translate_port", ",", "'vlans'", ":", "vlans", "}", ")", "existing", "=", "__salt__", "[", "'bigip.list_virtual'", "]", "(", "hostname", ",", "username", ",", "password", ",", "name", ")", "# does this virtual exist?", "if", "existing", "[", "'code'", "]", "==", "200", ":", "# modify", "modified", "=", "__salt__", "[", "'bigip.modify_virtual'", "]", "(", "hostname", "=", "hostname", ",", "username", "=", "username", ",", "password", "=", "password", ",", "name", "=", "name", ",", "destination", "=", "destination", ",", "description", "=", "description", ",", "pool", "=", "pool", ",", "address_status", "=", "address_status", ",", "auto_lasthop", "=", "auto_lasthop", ",", "bwc_policy", "=", "bwc_policy", ",", "cmp_enabled", "=", "cmp_enabled", ",", "connection_limit", "=", "connection_limit", ",", "dhcp_relay", "=", "dhcp_relay", ",", "fallback_persistence", "=", "fallback_persistence", ",", "flow_eviction_policy", "=", "flow_eviction_policy", ",", "gtm_score", "=", "gtm_score", ",", "ip_forward", "=", "ip_forward", ",", "ip_protocol", "=", "ip_protocol", ",", "internal", "=", "internal", ",", "twelve_forward", "=", "twelve_forward", ",", "last_hop_pool", "=", "last_hop_pool", ",", "mask", "=", "mask", ",", "mirror", "=", "mirror", ",", "nat64", "=", "nat64", ",", "persist", "=", "persist", ",", "profiles", "=", "profiles", ",", "policies", "=", "policies", ",", "rate_class", "=", "rate_class", ",", "rate_limit", "=", "rate_limit", ",", "rate_limit_mode", "=", "rate_limit_mode", ",", "rate_limit_dst", "=", "rate_limit_dst", ",", "rate_limit_src", "=", "rate_limit_src", ",", "rules", "=", "rules", ",", "related_rules", "=", "related_rules", ",", "reject", "=", "reject", ",", "source", "=", "source", ",", "source_address_translation", "=", "source_address_translation", ",", "source_port", "=", "source_port", ",", "state", "=", "virtual_state", ",", "traffic_classes", "=", "traffic_classes", ",", "translate_address", "=", "translate_address", ",", "translate_port", "=", "translate_port", ",", "vlans", "=", "vlans", ")", "#was the modification successful?", "if", "modified", "[", "'code'", "]", "==", "200", ":", "#relist it to compare", "relisting", "=", "__salt__", "[", "'bigip.list_virtual'", "]", "(", "hostname", ",", "username", ",", "password", ",", "name", ")", "if", "relisting", "[", "'code'", "]", "==", "200", ":", "relisting", "=", "_strip_key", "(", "relisting", ",", "'generation'", ")", "existing", "=", "_strip_key", "(", "existing", ",", "'generation'", ")", "ret", "=", "_check_for_changes", "(", "'Virtual'", ",", "ret", ",", "existing", ",", "relisting", ")", "else", ":", "ret", "=", "_load_result", "(", "relisting", ",", "ret", ")", "else", ":", "ret", "=", "_load_result", "(", "modified", ",", "ret", ")", "elif", "existing", "[", "'code'", "]", "==", "404", ":", "ret", "[", "'comment'", "]", "=", "'A Virtual with this name was not found.'", "# else something else was returned", "else", ":", "ret", "=", "_load_result", "(", "existing", ",", "ret", ")", "return", "ret"], "docstring": "Modify an virtual server.  modify an existing virtual.  Only parameters specified will be enforced.\n\n    hostname\n        The host/address of the bigip device\n    username\n        The iControl REST username\n    password\n        The iControl REST password\n    name\n        The name of the virtual to create\n    destination\n        [ [virtual_address_name:port] | [ipv4:port] | [ipv6.port] ]\n    pool\n        [ [pool_name] | none]\n    address_status\n        [yes | no]\n    auto_lasthop\n        [default | enabled | disabled ]\n    bwc_policy\n        [none] | string]\n    cmp_enabled\n        [yes | no]\n    dhcp_relay\n        [yes | no}\n    connection_limit\n        [integer]\n    description\n        [string]\n    state\n        [disabled | enabled]\n    fallback_persistence\n        [none | [profile name] ]\n    flow_eviction_policy\n        [none | [eviction policy name] ]\n    gtm_score\n        [integer]\n    ip_forward\n        [yes | no]\n    ip_protocol\n        [any | protocol]\n    internal\n        [yes | no]\n    twelve_forward(12-forward)\n        [yes | no]\n    last_hop-pool\n        [ [pool_name] | none]\n    mask\n        { [ipv4] | [ipv6] }\n    mirror\n        { [disabled | enabled | none] }\n    nat64\n        [enabled | disabled]\n    persist\n        [list]\n    profiles\n        [none | default | list ]\n    policies\n        [none | default | list ]\n    rate_class\n        [name]\n    rate_limit\n        [integer]\n    rate_limit-mode\n        [destination | object | object-destination |\n        object-source | object-source-destination |\n        source | source-destination]\n    rate_limit_dst\n        [integer]\n    rate_limit_src\n        [integer]\n    rules\n        [none | list ]\n    related_rules\n        [none | list ]\n    reject\n        [yes | no]\n    source\n        { [ipv4[/prefixlen]] | [ipv6[/prefixlen]] }\n    source_address_translation\n        [none | snat:pool_name | lsn | automap | dictionary ]\n    source_port\n        [change | preserve | preserve-strict]\n    state\n        [enabled | disabled]\n    traffic_classes\n        [none | default | list ]\n    translate_address\n        [enabled | disabled]\n    translate_port\n        [enabled | disabled]\n    vlans\n        [none | default | dictionary ]\n\n        vlan_ids\n            [ list]\n        enabled\n            [ true | false ]", "docstring_tokens": ["Modify", "an", "virtual", "server", ".", "modify", "an", "existing", "virtual", ".", "Only", "parameters", "specified", "will", "be", "enforced", "."], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/states/bigip.py#L2172-L2436", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/states/bigip.py", "func_name": "create_monitor", "original_string": "def create_monitor(hostname, username, password, monitor_type, name, **kwargs):\n    '''\n    A function to connect to a bigip device and create a monitor.\n\n    hostname\n        The host/address of the bigip device\n    username\n        The iControl REST username\n    password\n        The iControl REST password\n    monitor_type\n        The type of monitor to create\n    name\n        The name of the monitor to create\n    kwargs\n        [ arg=val ] ...\n\n        Consult F5 BIGIP user guide for specific options for each monitor type.\n        Typically, tmsh arg names are used.\n    '''\n\n    ret = {'name': name, 'changes': {}, 'result': False, 'comment': ''}\n\n    if __opts__['test']:\n\n        params = {\n            'hostname': hostname,\n            'username': username,\n            'password': password,\n            'monitor_type': monitor_type,\n            'name': name\n        }\n\n        for key, value in six.iteritems(kwargs):\n            params[key] = value\n\n        return _test_output(ret, 'create', params)\n\n    #is this monitor currently configured?\n    existing = __salt__['bigip.list_monitor'](hostname, username, password, monitor_type, name)\n\n    # if it exists\n    if existing['code'] == 200:\n\n        ret['result'] = True\n        ret['comment'] = 'A monitor by this name currently exists.  No change made.'\n\n    # if it doesn't exist\n    elif existing['code'] == 404:\n\n        response = __salt__['bigip.create_monitor'](hostname, username, password, monitor_type, name, **kwargs)\n        if response['code'] == 200:\n            ret['result'] = True\n            ret['changes']['old'] = {}\n            ret['changes']['new'] = response['content']\n            ret['comment'] = 'Monitor was successfully created.'\n        else:\n            ret = _load_result(response, ret)\n\n    # else something else was returned\n    else:\n        ret = _load_result(existing, ret)\n\n    return ret", "language": "python", "code": "def create_monitor(hostname, username, password, monitor_type, name, **kwargs):\n    '''\n    A function to connect to a bigip device and create a monitor.\n\n    hostname\n        The host/address of the bigip device\n    username\n        The iControl REST username\n    password\n        The iControl REST password\n    monitor_type\n        The type of monitor to create\n    name\n        The name of the monitor to create\n    kwargs\n        [ arg=val ] ...\n\n        Consult F5 BIGIP user guide for specific options for each monitor type.\n        Typically, tmsh arg names are used.\n    '''\n\n    ret = {'name': name, 'changes': {}, 'result': False, 'comment': ''}\n\n    if __opts__['test']:\n\n        params = {\n            'hostname': hostname,\n            'username': username,\n            'password': password,\n            'monitor_type': monitor_type,\n            'name': name\n        }\n\n        for key, value in six.iteritems(kwargs):\n            params[key] = value\n\n        return _test_output(ret, 'create', params)\n\n    #is this monitor currently configured?\n    existing = __salt__['bigip.list_monitor'](hostname, username, password, monitor_type, name)\n\n    # if it exists\n    if existing['code'] == 200:\n\n        ret['result'] = True\n        ret['comment'] = 'A monitor by this name currently exists.  No change made.'\n\n    # if it doesn't exist\n    elif existing['code'] == 404:\n\n        response = __salt__['bigip.create_monitor'](hostname, username, password, monitor_type, name, **kwargs)\n        if response['code'] == 200:\n            ret['result'] = True\n            ret['changes']['old'] = {}\n            ret['changes']['new'] = response['content']\n            ret['comment'] = 'Monitor was successfully created.'\n        else:\n            ret = _load_result(response, ret)\n\n    # else something else was returned\n    else:\n        ret = _load_result(existing, ret)\n\n    return ret", "code_tokens": ["def", "create_monitor", "(", "hostname", ",", "username", ",", "password", ",", "monitor_type", ",", "name", ",", "*", "*", "kwargs", ")", ":", "ret", "=", "{", "'name'", ":", "name", ",", "'changes'", ":", "{", "}", ",", "'result'", ":", "False", ",", "'comment'", ":", "''", "}", "if", "__opts__", "[", "'test'", "]", ":", "params", "=", "{", "'hostname'", ":", "hostname", ",", "'username'", ":", "username", ",", "'password'", ":", "password", ",", "'monitor_type'", ":", "monitor_type", ",", "'name'", ":", "name", "}", "for", "key", ",", "value", "in", "six", ".", "iteritems", "(", "kwargs", ")", ":", "params", "[", "key", "]", "=", "value", "return", "_test_output", "(", "ret", ",", "'create'", ",", "params", ")", "#is this monitor currently configured?", "existing", "=", "__salt__", "[", "'bigip.list_monitor'", "]", "(", "hostname", ",", "username", ",", "password", ",", "monitor_type", ",", "name", ")", "# if it exists", "if", "existing", "[", "'code'", "]", "==", "200", ":", "ret", "[", "'result'", "]", "=", "True", "ret", "[", "'comment'", "]", "=", "'A monitor by this name currently exists.  No change made.'", "# if it doesn't exist", "elif", "existing", "[", "'code'", "]", "==", "404", ":", "response", "=", "__salt__", "[", "'bigip.create_monitor'", "]", "(", "hostname", ",", "username", ",", "password", ",", "monitor_type", ",", "name", ",", "*", "*", "kwargs", ")", "if", "response", "[", "'code'", "]", "==", "200", ":", "ret", "[", "'result'", "]", "=", "True", "ret", "[", "'changes'", "]", "[", "'old'", "]", "=", "{", "}", "ret", "[", "'changes'", "]", "[", "'new'", "]", "=", "response", "[", "'content'", "]", "ret", "[", "'comment'", "]", "=", "'Monitor was successfully created.'", "else", ":", "ret", "=", "_load_result", "(", "response", ",", "ret", ")", "# else something else was returned", "else", ":", "ret", "=", "_load_result", "(", "existing", ",", "ret", ")", "return", "ret"], "docstring": "A function to connect to a bigip device and create a monitor.\n\n    hostname\n        The host/address of the bigip device\n    username\n        The iControl REST username\n    password\n        The iControl REST password\n    monitor_type\n        The type of monitor to create\n    name\n        The name of the monitor to create\n    kwargs\n        [ arg=val ] ...\n\n        Consult F5 BIGIP user guide for specific options for each monitor type.\n        Typically, tmsh arg names are used.", "docstring_tokens": ["A", "function", "to", "connect", "to", "a", "bigip", "device", "and", "create", "a", "monitor", "."], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/states/bigip.py#L2524-L2587", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/states/bigip.py", "func_name": "create_profile", "original_string": "def create_profile(hostname, username, password, profile_type, name, **kwargs):\n    r'''\n    A function to connect to a bigip device and create a profile.\n\n    hostname\n        The host/address of the bigip device\n    username\n        The iControl REST username\n    password\n        The iControl REST password\n    profile_type\n        The type of profile to create\n    name\n        The name of the profile to create\n    kwargs\n        [ arg=val ] ...\n\n        Consult F5 BIGIP user guide for specific options for each profile type.\n        Typically, tmsh arg names are used.\n\n    Special Characters ``|``, ``,`` and ``:`` must be escaped using ``\\`` when\n    used within strings.\n\n    '''\n\n    ret = {'name': name, 'changes': {}, 'result': False, 'comment': ''}\n\n    if __opts__['test']:\n        return _test_output(ret, 'create', params={\n            'hostname': hostname,\n            'username': username,\n            'password': password,\n            'profile_type': profile_type,\n            'name': name\n        })\n\n    #is this profile currently configured?\n    existing = __salt__['bigip.list_profile'](hostname, username, password, profile_type, name)\n\n    # if it exists\n    if existing['code'] == 200:\n\n        ret['result'] = True\n        ret['comment'] = 'A profile by this name currently exists.  No change made.'\n\n    # if it doesn't exist\n    elif existing['code'] == 404:\n\n        response = __salt__['bigip.create_profile'](hostname, username, password, profile_type, name, **kwargs)\n\n        if response['code'] == 200:\n            ret['result'] = True\n            ret['changes']['old'] = {}\n            ret['changes']['new'] = response['content']\n            ret['comment'] = 'Profile was successfully created.'\n        else:\n            ret = _load_result(response, ret)\n\n    # else something else was returned\n    else:\n        ret = _load_result(existing, ret)\n\n    return ret", "language": "python", "code": "def create_profile(hostname, username, password, profile_type, name, **kwargs):\n    r'''\n    A function to connect to a bigip device and create a profile.\n\n    hostname\n        The host/address of the bigip device\n    username\n        The iControl REST username\n    password\n        The iControl REST password\n    profile_type\n        The type of profile to create\n    name\n        The name of the profile to create\n    kwargs\n        [ arg=val ] ...\n\n        Consult F5 BIGIP user guide for specific options for each profile type.\n        Typically, tmsh arg names are used.\n\n    Special Characters ``|``, ``,`` and ``:`` must be escaped using ``\\`` when\n    used within strings.\n\n    '''\n\n    ret = {'name': name, 'changes': {}, 'result': False, 'comment': ''}\n\n    if __opts__['test']:\n        return _test_output(ret, 'create', params={\n            'hostname': hostname,\n            'username': username,\n            'password': password,\n            'profile_type': profile_type,\n            'name': name\n        })\n\n    #is this profile currently configured?\n    existing = __salt__['bigip.list_profile'](hostname, username, password, profile_type, name)\n\n    # if it exists\n    if existing['code'] == 200:\n\n        ret['result'] = True\n        ret['comment'] = 'A profile by this name currently exists.  No change made.'\n\n    # if it doesn't exist\n    elif existing['code'] == 404:\n\n        response = __salt__['bigip.create_profile'](hostname, username, password, profile_type, name, **kwargs)\n\n        if response['code'] == 200:\n            ret['result'] = True\n            ret['changes']['old'] = {}\n            ret['changes']['new'] = response['content']\n            ret['comment'] = 'Profile was successfully created.'\n        else:\n            ret = _load_result(response, ret)\n\n    # else something else was returned\n    else:\n        ret = _load_result(existing, ret)\n\n    return ret", "code_tokens": ["def", "create_profile", "(", "hostname", ",", "username", ",", "password", ",", "profile_type", ",", "name", ",", "*", "*", "kwargs", ")", ":", "ret", "=", "{", "'name'", ":", "name", ",", "'changes'", ":", "{", "}", ",", "'result'", ":", "False", ",", "'comment'", ":", "''", "}", "if", "__opts__", "[", "'test'", "]", ":", "return", "_test_output", "(", "ret", ",", "'create'", ",", "params", "=", "{", "'hostname'", ":", "hostname", ",", "'username'", ":", "username", ",", "'password'", ":", "password", ",", "'profile_type'", ":", "profile_type", ",", "'name'", ":", "name", "}", ")", "#is this profile currently configured?", "existing", "=", "__salt__", "[", "'bigip.list_profile'", "]", "(", "hostname", ",", "username", ",", "password", ",", "profile_type", ",", "name", ")", "# if it exists", "if", "existing", "[", "'code'", "]", "==", "200", ":", "ret", "[", "'result'", "]", "=", "True", "ret", "[", "'comment'", "]", "=", "'A profile by this name currently exists.  No change made.'", "# if it doesn't exist", "elif", "existing", "[", "'code'", "]", "==", "404", ":", "response", "=", "__salt__", "[", "'bigip.create_profile'", "]", "(", "hostname", ",", "username", ",", "password", ",", "profile_type", ",", "name", ",", "*", "*", "kwargs", ")", "if", "response", "[", "'code'", "]", "==", "200", ":", "ret", "[", "'result'", "]", "=", "True", "ret", "[", "'changes'", "]", "[", "'old'", "]", "=", "{", "}", "ret", "[", "'changes'", "]", "[", "'new'", "]", "=", "response", "[", "'content'", "]", "ret", "[", "'comment'", "]", "=", "'Profile was successfully created.'", "else", ":", "ret", "=", "_load_result", "(", "response", ",", "ret", ")", "# else something else was returned", "else", ":", "ret", "=", "_load_result", "(", "existing", ",", "ret", ")", "return", "ret"], "docstring": "r'''\n    A function to connect to a bigip device and create a profile.\n\n    hostname\n        The host/address of the bigip device\n    username\n        The iControl REST username\n    password\n        The iControl REST password\n    profile_type\n        The type of profile to create\n    name\n        The name of the profile to create\n    kwargs\n        [ arg=val ] ...\n\n        Consult F5 BIGIP user guide for specific options for each profile type.\n        Typically, tmsh arg names are used.\n\n    Special Characters ``|``, ``,`` and ``:`` must be escaped using ``\\`` when\n    used within strings.", "docstring_tokens": ["r", "A", "function", "to", "connect", "to", "a", "bigip", "device", "and", "create", "a", "profile", "."], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/states/bigip.py#L2823-L2885", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/cloud/clouds/scaleway.py", "func_name": "avail_images", "original_string": "def avail_images(call=None):\n    ''' Return a list of the images that are on the provider.\n    '''\n    if call == 'action':\n        raise SaltCloudSystemExit(\n            'The avail_images function must be called with '\n            '-f or --function, or with the --list-images option'\n        )\n\n    items = query(method='images', root='marketplace_root')\n    ret = {}\n    for image in items['images']:\n        ret[image['id']] = {}\n        for item in image:\n            ret[image['id']][item] = six.text_type(image[item])\n\n    return ret", "language": "python", "code": "def avail_images(call=None):\n    ''' Return a list of the images that are on the provider.\n    '''\n    if call == 'action':\n        raise SaltCloudSystemExit(\n            'The avail_images function must be called with '\n            '-f or --function, or with the --list-images option'\n        )\n\n    items = query(method='images', root='marketplace_root')\n    ret = {}\n    for image in items['images']:\n        ret[image['id']] = {}\n        for item in image:\n            ret[image['id']][item] = six.text_type(image[item])\n\n    return ret", "code_tokens": ["def", "avail_images", "(", "call", "=", "None", ")", ":", "if", "call", "==", "'action'", ":", "raise", "SaltCloudSystemExit", "(", "'The avail_images function must be called with '", "'-f or --function, or with the --list-images option'", ")", "items", "=", "query", "(", "method", "=", "'images'", ",", "root", "=", "'marketplace_root'", ")", "ret", "=", "{", "}", "for", "image", "in", "items", "[", "'images'", "]", ":", "ret", "[", "image", "[", "'id'", "]", "]", "=", "{", "}", "for", "item", "in", "image", ":", "ret", "[", "image", "[", "'id'", "]", "]", "[", "item", "]", "=", "six", ".", "text_type", "(", "image", "[", "item", "]", ")", "return", "ret"], "docstring": "Return a list of the images that are on the provider.", "docstring_tokens": ["Return", "a", "list", "of", "the", "images", "that", "are", "on", "the", "provider", "."], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/cloud/clouds/scaleway.py#L72-L88", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/cloud/clouds/scaleway.py", "func_name": "list_nodes", "original_string": "def list_nodes(call=None):\n    ''' Return a list of the BareMetal servers that are on the provider.\n    '''\n    if call == 'action':\n        raise SaltCloudSystemExit(\n            'The list_nodes function must be called with -f or --function.'\n        )\n\n    items = query(method='servers')\n\n    ret = {}\n    for node in items['servers']:\n        public_ips = []\n        private_ips = []\n        image_id = ''\n\n        if node.get('public_ip'):\n            public_ips = [node['public_ip']['address']]\n\n        if node.get('private_ip'):\n            private_ips = [node['private_ip']]\n\n        if node.get('image'):\n            image_id = node['image']['id']\n\n        ret[node['name']] = {\n            'id': node['id'],\n            'image_id': image_id,\n            'public_ips': public_ips,\n            'private_ips': private_ips,\n            'size': node['volumes']['0']['size'],\n            'state': node['state'],\n        }\n    return ret", "language": "python", "code": "def list_nodes(call=None):\n    ''' Return a list of the BareMetal servers that are on the provider.\n    '''\n    if call == 'action':\n        raise SaltCloudSystemExit(\n            'The list_nodes function must be called with -f or --function.'\n        )\n\n    items = query(method='servers')\n\n    ret = {}\n    for node in items['servers']:\n        public_ips = []\n        private_ips = []\n        image_id = ''\n\n        if node.get('public_ip'):\n            public_ips = [node['public_ip']['address']]\n\n        if node.get('private_ip'):\n            private_ips = [node['private_ip']]\n\n        if node.get('image'):\n            image_id = node['image']['id']\n\n        ret[node['name']] = {\n            'id': node['id'],\n            'image_id': image_id,\n            'public_ips': public_ips,\n            'private_ips': private_ips,\n            'size': node['volumes']['0']['size'],\n            'state': node['state'],\n        }\n    return ret", "code_tokens": ["def", "list_nodes", "(", "call", "=", "None", ")", ":", "if", "call", "==", "'action'", ":", "raise", "SaltCloudSystemExit", "(", "'The list_nodes function must be called with -f or --function.'", ")", "items", "=", "query", "(", "method", "=", "'servers'", ")", "ret", "=", "{", "}", "for", "node", "in", "items", "[", "'servers'", "]", ":", "public_ips", "=", "[", "]", "private_ips", "=", "[", "]", "image_id", "=", "''", "if", "node", ".", "get", "(", "'public_ip'", ")", ":", "public_ips", "=", "[", "node", "[", "'public_ip'", "]", "[", "'address'", "]", "]", "if", "node", ".", "get", "(", "'private_ip'", ")", ":", "private_ips", "=", "[", "node", "[", "'private_ip'", "]", "]", "if", "node", ".", "get", "(", "'image'", ")", ":", "image_id", "=", "node", "[", "'image'", "]", "[", "'id'", "]", "ret", "[", "node", "[", "'name'", "]", "]", "=", "{", "'id'", ":", "node", "[", "'id'", "]", ",", "'image_id'", ":", "image_id", ",", "'public_ips'", ":", "public_ips", ",", "'private_ips'", ":", "private_ips", ",", "'size'", ":", "node", "[", "'volumes'", "]", "[", "'0'", "]", "[", "'size'", "]", ",", "'state'", ":", "node", "[", "'state'", "]", ",", "}", "return", "ret"], "docstring": "Return a list of the BareMetal servers that are on the provider.", "docstring_tokens": ["Return", "a", "list", "of", "the", "BareMetal", "servers", "that", "are", "on", "the", "provider", "."], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/cloud/clouds/scaleway.py#L91-L124", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/cloud/clouds/scaleway.py", "func_name": "list_nodes_full", "original_string": "def list_nodes_full(call=None):\n    ''' Return a list of the BareMetal servers that are on the provider.\n    '''\n    if call == 'action':\n        raise SaltCloudSystemExit(\n            'list_nodes_full must be called with -f or --function'\n        )\n\n    items = query(method='servers')\n\n    # For each server, iterate on its parameters.\n    ret = {}\n    for node in items['servers']:\n        ret[node['name']] = {}\n        for item in node:\n            value = node[item]\n            ret[node['name']][item] = value\n    return ret", "language": "python", "code": "def list_nodes_full(call=None):\n    ''' Return a list of the BareMetal servers that are on the provider.\n    '''\n    if call == 'action':\n        raise SaltCloudSystemExit(\n            'list_nodes_full must be called with -f or --function'\n        )\n\n    items = query(method='servers')\n\n    # For each server, iterate on its parameters.\n    ret = {}\n    for node in items['servers']:\n        ret[node['name']] = {}\n        for item in node:\n            value = node[item]\n            ret[node['name']][item] = value\n    return ret", "code_tokens": ["def", "list_nodes_full", "(", "call", "=", "None", ")", ":", "if", "call", "==", "'action'", ":", "raise", "SaltCloudSystemExit", "(", "'list_nodes_full must be called with -f or --function'", ")", "items", "=", "query", "(", "method", "=", "'servers'", ")", "# For each server, iterate on its parameters.", "ret", "=", "{", "}", "for", "node", "in", "items", "[", "'servers'", "]", ":", "ret", "[", "node", "[", "'name'", "]", "]", "=", "{", "}", "for", "item", "in", "node", ":", "value", "=", "node", "[", "item", "]", "ret", "[", "node", "[", "'name'", "]", "]", "[", "item", "]", "=", "value", "return", "ret"], "docstring": "Return a list of the BareMetal servers that are on the provider.", "docstring_tokens": ["Return", "a", "list", "of", "the", "BareMetal", "servers", "that", "are", "on", "the", "provider", "."], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/cloud/clouds/scaleway.py#L127-L144", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/cloud/clouds/scaleway.py", "func_name": "get_image", "original_string": "def get_image(server_):\n    ''' Return the image object to use.\n    '''\n    images = avail_images()\n    server_image = six.text_type(config.get_cloud_config_value(\n        'image', server_, __opts__, search_global=False\n    ))\n    for image in images:\n        if server_image in (images[image]['name'], images[image]['id']):\n            return images[image]['id']\n    raise SaltCloudNotFound(\n        'The specified image, \\'{0}\\', could not be found.'.format(server_image)\n    )", "language": "python", "code": "def get_image(server_):\n    ''' Return the image object to use.\n    '''\n    images = avail_images()\n    server_image = six.text_type(config.get_cloud_config_value(\n        'image', server_, __opts__, search_global=False\n    ))\n    for image in images:\n        if server_image in (images[image]['name'], images[image]['id']):\n            return images[image]['id']\n    raise SaltCloudNotFound(\n        'The specified image, \\'{0}\\', could not be found.'.format(server_image)\n    )", "code_tokens": ["def", "get_image", "(", "server_", ")", ":", "images", "=", "avail_images", "(", ")", "server_image", "=", "six", ".", "text_type", "(", "config", ".", "get_cloud_config_value", "(", "'image'", ",", "server_", ",", "__opts__", ",", "search_global", "=", "False", ")", ")", "for", "image", "in", "images", ":", "if", "server_image", "in", "(", "images", "[", "image", "]", "[", "'name'", "]", ",", "images", "[", "image", "]", "[", "'id'", "]", ")", ":", "return", "images", "[", "image", "]", "[", "'id'", "]", "raise", "SaltCloudNotFound", "(", "'The specified image, \\'{0}\\', could not be found.'", ".", "format", "(", "server_image", ")", ")"], "docstring": "Return the image object to use.", "docstring_tokens": ["Return", "the", "image", "object", "to", "use", "."], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/cloud/clouds/scaleway.py#L156-L168", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/cloud/clouds/scaleway.py", "func_name": "create_node", "original_string": "def create_node(args):\n    ''' Create a node.\n    '''\n    node = query(method='servers', args=args, http_method='POST')\n\n    action = query(\n        method='servers',\n        server_id=node['server']['id'],\n        command='action',\n        args={'action': 'poweron'},\n        http_method='POST'\n    )\n    return node", "language": "python", "code": "def create_node(args):\n    ''' Create a node.\n    '''\n    node = query(method='servers', args=args, http_method='POST')\n\n    action = query(\n        method='servers',\n        server_id=node['server']['id'],\n        command='action',\n        args={'action': 'poweron'},\n        http_method='POST'\n    )\n    return node", "code_tokens": ["def", "create_node", "(", "args", ")", ":", "node", "=", "query", "(", "method", "=", "'servers'", ",", "args", "=", "args", ",", "http_method", "=", "'POST'", ")", "action", "=", "query", "(", "method", "=", "'servers'", ",", "server_id", "=", "node", "[", "'server'", "]", "[", "'id'", "]", ",", "command", "=", "'action'", ",", "args", "=", "{", "'action'", ":", "'poweron'", "}", ",", "http_method", "=", "'POST'", ")", "return", "node"], "docstring": "Create a node.", "docstring_tokens": ["Create", "a", "node", "."], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/cloud/clouds/scaleway.py#L171-L183", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/cloud/clouds/scaleway.py", "func_name": "create", "original_string": "def create(server_):\n    '''\n    Create a single BareMetal server from a data dict.\n    '''\n    try:\n        # Check for required profile parameters before sending any API calls.\n        if server_['profile'] and config.is_profile_configured(__opts__,\n                                                               __active_provider_name__ or 'scaleway',\n                                                               server_['profile'],\n                                                               vm_=server_) is False:\n            return False\n    except AttributeError:\n        pass\n\n    __utils__['cloud.fire_event'](\n        'event',\n        'starting create',\n        'salt/cloud/{0}/creating'.format(server_['name']),\n        args=__utils__['cloud.filter_event']('creating', server_, ['name', 'profile', 'provider', 'driver']),\n        sock_dir=__opts__['sock_dir'],\n        transport=__opts__['transport']\n    )\n\n    log.info('Creating a BareMetal server %s', server_['name'])\n\n    access_key = config.get_cloud_config_value(\n        'access_key', get_configured_provider(), __opts__, search_global=False\n    )\n\n    commercial_type = config.get_cloud_config_value(\n        'commercial_type', server_, __opts__, default='C1'\n    )\n\n    key_filename = config.get_cloud_config_value(\n        'ssh_key_file', server_, __opts__, search_global=False, default=None\n    )\n\n    if key_filename is not None and not os.path.isfile(key_filename):\n        raise SaltCloudConfigError(\n            'The defined key_filename \\'{0}\\' does not exist'.format(\n                key_filename\n            )\n        )\n\n    ssh_password = config.get_cloud_config_value(\n        'ssh_password', server_, __opts__\n    )\n\n    kwargs = {\n        'name': server_['name'],\n        'organization': access_key,\n        'image': get_image(server_),\n        'commercial_type': commercial_type,\n    }\n\n    __utils__['cloud.fire_event'](\n        'event',\n        'requesting instance',\n        'salt/cloud/{0}/requesting'.format(server_['name']),\n        args={\n            'kwargs': __utils__['cloud.filter_event']('requesting', kwargs, list(kwargs)),\n        },\n        sock_dir=__opts__['sock_dir'],\n        transport=__opts__['transport']\n    )\n\n    try:\n        ret = create_node(kwargs)\n    except Exception as exc:\n        log.error(\n            'Error creating %s on Scaleway\\n\\n'\n            'The following exception was thrown when trying to '\n            'run the initial deployment: %s',\n            server_['name'], exc,\n            # Show the traceback if the debug logging level is enabled\n            exc_info_on_loglevel=logging.DEBUG\n        )\n        return False\n\n    def __query_node_data(server_name):\n        ''' Called to check if the server has a public IP address.\n        '''\n        data = show_instance(server_name, 'action')\n        if data and data.get('public_ip'):\n            return data\n        return False\n\n    try:\n        data = salt.utils.cloud.wait_for_ip(\n            __query_node_data,\n            update_args=(server_['name'],),\n            timeout=config.get_cloud_config_value(\n                'wait_for_ip_timeout', server_, __opts__, default=10 * 60),\n            interval=config.get_cloud_config_value(\n                'wait_for_ip_interval', server_, __opts__, default=10),\n        )\n    except (SaltCloudExecutionTimeout, SaltCloudExecutionFailure) as exc:\n        try:\n            # It might be already up, let's destroy it!\n            destroy(server_['name'])\n        except SaltCloudSystemExit:\n            pass\n        finally:\n            raise SaltCloudSystemExit(six.text_type(exc))\n\n    server_['ssh_host'] = data['public_ip']['address']\n    server_['ssh_password'] = ssh_password\n    server_['key_filename'] = key_filename\n    ret = __utils__['cloud.bootstrap'](server_, __opts__)\n\n    ret.update(data)\n\n    log.info('Created BareMetal server \\'%s\\'', server_['name'])\n    log.debug(\n        '\\'%s\\' BareMetal server creation details:\\n%s',\n        server_['name'], pprint.pformat(data)\n    )\n\n    __utils__['cloud.fire_event'](\n        'event',\n        'created instance',\n        'salt/cloud/{0}/created'.format(server_['name']),\n        args=__utils__['cloud.filter_event']('created', server_, ['name', 'profile', 'provider', 'driver']),\n        sock_dir=__opts__['sock_dir'],\n        transport=__opts__['transport']\n    )\n\n    return ret", "language": "python", "code": "def create(server_):\n    '''\n    Create a single BareMetal server from a data dict.\n    '''\n    try:\n        # Check for required profile parameters before sending any API calls.\n        if server_['profile'] and config.is_profile_configured(__opts__,\n                                                               __active_provider_name__ or 'scaleway',\n                                                               server_['profile'],\n                                                               vm_=server_) is False:\n            return False\n    except AttributeError:\n        pass\n\n    __utils__['cloud.fire_event'](\n        'event',\n        'starting create',\n        'salt/cloud/{0}/creating'.format(server_['name']),\n        args=__utils__['cloud.filter_event']('creating', server_, ['name', 'profile', 'provider', 'driver']),\n        sock_dir=__opts__['sock_dir'],\n        transport=__opts__['transport']\n    )\n\n    log.info('Creating a BareMetal server %s', server_['name'])\n\n    access_key = config.get_cloud_config_value(\n        'access_key', get_configured_provider(), __opts__, search_global=False\n    )\n\n    commercial_type = config.get_cloud_config_value(\n        'commercial_type', server_, __opts__, default='C1'\n    )\n\n    key_filename = config.get_cloud_config_value(\n        'ssh_key_file', server_, __opts__, search_global=False, default=None\n    )\n\n    if key_filename is not None and not os.path.isfile(key_filename):\n        raise SaltCloudConfigError(\n            'The defined key_filename \\'{0}\\' does not exist'.format(\n                key_filename\n            )\n        )\n\n    ssh_password = config.get_cloud_config_value(\n        'ssh_password', server_, __opts__\n    )\n\n    kwargs = {\n        'name': server_['name'],\n        'organization': access_key,\n        'image': get_image(server_),\n        'commercial_type': commercial_type,\n    }\n\n    __utils__['cloud.fire_event'](\n        'event',\n        'requesting instance',\n        'salt/cloud/{0}/requesting'.format(server_['name']),\n        args={\n            'kwargs': __utils__['cloud.filter_event']('requesting', kwargs, list(kwargs)),\n        },\n        sock_dir=__opts__['sock_dir'],\n        transport=__opts__['transport']\n    )\n\n    try:\n        ret = create_node(kwargs)\n    except Exception as exc:\n        log.error(\n            'Error creating %s on Scaleway\\n\\n'\n            'The following exception was thrown when trying to '\n            'run the initial deployment: %s',\n            server_['name'], exc,\n            # Show the traceback if the debug logging level is enabled\n            exc_info_on_loglevel=logging.DEBUG\n        )\n        return False\n\n    def __query_node_data(server_name):\n        ''' Called to check if the server has a public IP address.\n        '''\n        data = show_instance(server_name, 'action')\n        if data and data.get('public_ip'):\n            return data\n        return False\n\n    try:\n        data = salt.utils.cloud.wait_for_ip(\n            __query_node_data,\n            update_args=(server_['name'],),\n            timeout=config.get_cloud_config_value(\n                'wait_for_ip_timeout', server_, __opts__, default=10 * 60),\n            interval=config.get_cloud_config_value(\n                'wait_for_ip_interval', server_, __opts__, default=10),\n        )\n    except (SaltCloudExecutionTimeout, SaltCloudExecutionFailure) as exc:\n        try:\n            # It might be already up, let's destroy it!\n            destroy(server_['name'])\n        except SaltCloudSystemExit:\n            pass\n        finally:\n            raise SaltCloudSystemExit(six.text_type(exc))\n\n    server_['ssh_host'] = data['public_ip']['address']\n    server_['ssh_password'] = ssh_password\n    server_['key_filename'] = key_filename\n    ret = __utils__['cloud.bootstrap'](server_, __opts__)\n\n    ret.update(data)\n\n    log.info('Created BareMetal server \\'%s\\'', server_['name'])\n    log.debug(\n        '\\'%s\\' BareMetal server creation details:\\n%s',\n        server_['name'], pprint.pformat(data)\n    )\n\n    __utils__['cloud.fire_event'](\n        'event',\n        'created instance',\n        'salt/cloud/{0}/created'.format(server_['name']),\n        args=__utils__['cloud.filter_event']('created', server_, ['name', 'profile', 'provider', 'driver']),\n        sock_dir=__opts__['sock_dir'],\n        transport=__opts__['transport']\n    )\n\n    return ret", "code_tokens": ["def", "create", "(", "server_", ")", ":", "try", ":", "# Check for required profile parameters before sending any API calls.", "if", "server_", "[", "'profile'", "]", "and", "config", ".", "is_profile_configured", "(", "__opts__", ",", "__active_provider_name__", "or", "'scaleway'", ",", "server_", "[", "'profile'", "]", ",", "vm_", "=", "server_", ")", "is", "False", ":", "return", "False", "except", "AttributeError", ":", "pass", "__utils__", "[", "'cloud.fire_event'", "]", "(", "'event'", ",", "'starting create'", ",", "'salt/cloud/{0}/creating'", ".", "format", "(", "server_", "[", "'name'", "]", ")", ",", "args", "=", "__utils__", "[", "'cloud.filter_event'", "]", "(", "'creating'", ",", "server_", ",", "[", "'name'", ",", "'profile'", ",", "'provider'", ",", "'driver'", "]", ")", ",", "sock_dir", "=", "__opts__", "[", "'sock_dir'", "]", ",", "transport", "=", "__opts__", "[", "'transport'", "]", ")", "log", ".", "info", "(", "'Creating a BareMetal server %s'", ",", "server_", "[", "'name'", "]", ")", "access_key", "=", "config", ".", "get_cloud_config_value", "(", "'access_key'", ",", "get_configured_provider", "(", ")", ",", "__opts__", ",", "search_global", "=", "False", ")", "commercial_type", "=", "config", ".", "get_cloud_config_value", "(", "'commercial_type'", ",", "server_", ",", "__opts__", ",", "default", "=", "'C1'", ")", "key_filename", "=", "config", ".", "get_cloud_config_value", "(", "'ssh_key_file'", ",", "server_", ",", "__opts__", ",", "search_global", "=", "False", ",", "default", "=", "None", ")", "if", "key_filename", "is", "not", "None", "and", "not", "os", ".", "path", ".", "isfile", "(", "key_filename", ")", ":", "raise", "SaltCloudConfigError", "(", "'The defined key_filename \\'{0}\\' does not exist'", ".", "format", "(", "key_filename", ")", ")", "ssh_password", "=", "config", ".", "get_cloud_config_value", "(", "'ssh_password'", ",", "server_", ",", "__opts__", ")", "kwargs", "=", "{", "'name'", ":", "server_", "[", "'name'", "]", ",", "'organization'", ":", "access_key", ",", "'image'", ":", "get_image", "(", "server_", ")", ",", "'commercial_type'", ":", "commercial_type", ",", "}", "__utils__", "[", "'cloud.fire_event'", "]", "(", "'event'", ",", "'requesting instance'", ",", "'salt/cloud/{0}/requesting'", ".", "format", "(", "server_", "[", "'name'", "]", ")", ",", "args", "=", "{", "'kwargs'", ":", "__utils__", "[", "'cloud.filter_event'", "]", "(", "'requesting'", ",", "kwargs", ",", "list", "(", "kwargs", ")", ")", ",", "}", ",", "sock_dir", "=", "__opts__", "[", "'sock_dir'", "]", ",", "transport", "=", "__opts__", "[", "'transport'", "]", ")", "try", ":", "ret", "=", "create_node", "(", "kwargs", ")", "except", "Exception", "as", "exc", ":", "log", ".", "error", "(", "'Error creating %s on Scaleway\\n\\n'", "'The following exception was thrown when trying to '", "'run the initial deployment: %s'", ",", "server_", "[", "'name'", "]", ",", "exc", ",", "# Show the traceback if the debug logging level is enabled", "exc_info_on_loglevel", "=", "logging", ".", "DEBUG", ")", "return", "False", "def", "__query_node_data", "(", "server_name", ")", ":", "''' Called to check if the server has a public IP address.\n        '''", "data", "=", "show_instance", "(", "server_name", ",", "'action'", ")", "if", "data", "and", "data", ".", "get", "(", "'public_ip'", ")", ":", "return", "data", "return", "False", "try", ":", "data", "=", "salt", ".", "utils", ".", "cloud", ".", "wait_for_ip", "(", "__query_node_data", ",", "update_args", "=", "(", "server_", "[", "'name'", "]", ",", ")", ",", "timeout", "=", "config", ".", "get_cloud_config_value", "(", "'wait_for_ip_timeout'", ",", "server_", ",", "__opts__", ",", "default", "=", "10", "*", "60", ")", ",", "interval", "=", "config", ".", "get_cloud_config_value", "(", "'wait_for_ip_interval'", ",", "server_", ",", "__opts__", ",", "default", "=", "10", ")", ",", ")", "except", "(", "SaltCloudExecutionTimeout", ",", "SaltCloudExecutionFailure", ")", "as", "exc", ":", "try", ":", "# It might be already up, let's destroy it!", "destroy", "(", "server_", "[", "'name'", "]", ")", "except", "SaltCloudSystemExit", ":", "pass", "finally", ":", "raise", "SaltCloudSystemExit", "(", "six", ".", "text_type", "(", "exc", ")", ")", "server_", "[", "'ssh_host'", "]", "=", "data", "[", "'public_ip'", "]", "[", "'address'", "]", "server_", "[", "'ssh_password'", "]", "=", "ssh_password", "server_", "[", "'key_filename'", "]", "=", "key_filename", "ret", "=", "__utils__", "[", "'cloud.bootstrap'", "]", "(", "server_", ",", "__opts__", ")", "ret", ".", "update", "(", "data", ")", "log", ".", "info", "(", "'Created BareMetal server \\'%s\\''", ",", "server_", "[", "'name'", "]", ")", "log", ".", "debug", "(", "'\\'%s\\' BareMetal server creation details:\\n%s'", ",", "server_", "[", "'name'", "]", ",", "pprint", ".", "pformat", "(", "data", ")", ")", "__utils__", "[", "'cloud.fire_event'", "]", "(", "'event'", ",", "'created instance'", ",", "'salt/cloud/{0}/created'", ".", "format", "(", "server_", "[", "'name'", "]", ")", ",", "args", "=", "__utils__", "[", "'cloud.filter_event'", "]", "(", "'created'", ",", "server_", ",", "[", "'name'", ",", "'profile'", ",", "'provider'", ",", "'driver'", "]", ")", ",", "sock_dir", "=", "__opts__", "[", "'sock_dir'", "]", ",", "transport", "=", "__opts__", "[", "'transport'", "]", ")", "return", "ret"], "docstring": "Create a single BareMetal server from a data dict.", "docstring_tokens": ["Create", "a", "single", "BareMetal", "server", "from", "a", "data", "dict", "."], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/cloud/clouds/scaleway.py#L186-L313", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/cloud/clouds/scaleway.py", "func_name": "query", "original_string": "def query(method='servers', server_id=None, command=None, args=None,\n          http_method='GET', root='api_root'):\n    ''' Make a call to the Scaleway API.\n    '''\n\n    if root == 'api_root':\n        default_url = 'https://cp-par1.scaleway.com'\n    else:\n        default_url = 'https://api-marketplace.scaleway.com'\n\n    base_path = six.text_type(config.get_cloud_config_value(\n        root,\n        get_configured_provider(),\n        __opts__,\n        search_global=False,\n        default=default_url\n    ))\n\n    path = '{0}/{1}/'.format(base_path, method)\n\n    if server_id:\n        path += '{0}/'.format(server_id)\n\n    if command:\n        path += command\n\n    if not isinstance(args, dict):\n        args = {}\n\n    token = config.get_cloud_config_value(\n        'token', get_configured_provider(), __opts__, search_global=False\n    )\n\n    data = salt.utils.json.dumps(args)\n\n    request = __utils__[\"http.query\"](path,\n                                      method=http_method,\n                                      data=data,\n                                      status=True,\n                                      decode=True,\n                                      decode_type='json',\n                                      data_render=True,\n                                      data_renderer='json',\n                                      headers=True,\n                                      header_dict={'X-Auth-Token': token,\n                                                   'User-Agent': \"salt-cloud\",\n                                                   'Content-Type': 'application/json'})\n    if request['status'] > 299:\n        raise SaltCloudSystemExit(\n            'An error occurred while querying Scaleway. HTTP Code: {0}  '\n            'Error: \\'{1}\\''.format(\n                request['status'],\n                request['error']\n            )\n        )\n\n    # success without data\n    if request['status'] == 204:\n        return True\n\n    return salt.utils.json.loads(request['body'])", "language": "python", "code": "def query(method='servers', server_id=None, command=None, args=None,\n          http_method='GET', root='api_root'):\n    ''' Make a call to the Scaleway API.\n    '''\n\n    if root == 'api_root':\n        default_url = 'https://cp-par1.scaleway.com'\n    else:\n        default_url = 'https://api-marketplace.scaleway.com'\n\n    base_path = six.text_type(config.get_cloud_config_value(\n        root,\n        get_configured_provider(),\n        __opts__,\n        search_global=False,\n        default=default_url\n    ))\n\n    path = '{0}/{1}/'.format(base_path, method)\n\n    if server_id:\n        path += '{0}/'.format(server_id)\n\n    if command:\n        path += command\n\n    if not isinstance(args, dict):\n        args = {}\n\n    token = config.get_cloud_config_value(\n        'token', get_configured_provider(), __opts__, search_global=False\n    )\n\n    data = salt.utils.json.dumps(args)\n\n    request = __utils__[\"http.query\"](path,\n                                      method=http_method,\n                                      data=data,\n                                      status=True,\n                                      decode=True,\n                                      decode_type='json',\n                                      data_render=True,\n                                      data_renderer='json',\n                                      headers=True,\n                                      header_dict={'X-Auth-Token': token,\n                                                   'User-Agent': \"salt-cloud\",\n                                                   'Content-Type': 'application/json'})\n    if request['status'] > 299:\n        raise SaltCloudSystemExit(\n            'An error occurred while querying Scaleway. HTTP Code: {0}  '\n            'Error: \\'{1}\\''.format(\n                request['status'],\n                request['error']\n            )\n        )\n\n    # success without data\n    if request['status'] == 204:\n        return True\n\n    return salt.utils.json.loads(request['body'])", "code_tokens": ["def", "query", "(", "method", "=", "'servers'", ",", "server_id", "=", "None", ",", "command", "=", "None", ",", "args", "=", "None", ",", "http_method", "=", "'GET'", ",", "root", "=", "'api_root'", ")", ":", "if", "root", "==", "'api_root'", ":", "default_url", "=", "'https://cp-par1.scaleway.com'", "else", ":", "default_url", "=", "'https://api-marketplace.scaleway.com'", "base_path", "=", "six", ".", "text_type", "(", "config", ".", "get_cloud_config_value", "(", "root", ",", "get_configured_provider", "(", ")", ",", "__opts__", ",", "search_global", "=", "False", ",", "default", "=", "default_url", ")", ")", "path", "=", "'{0}/{1}/'", ".", "format", "(", "base_path", ",", "method", ")", "if", "server_id", ":", "path", "+=", "'{0}/'", ".", "format", "(", "server_id", ")", "if", "command", ":", "path", "+=", "command", "if", "not", "isinstance", "(", "args", ",", "dict", ")", ":", "args", "=", "{", "}", "token", "=", "config", ".", "get_cloud_config_value", "(", "'token'", ",", "get_configured_provider", "(", ")", ",", "__opts__", ",", "search_global", "=", "False", ")", "data", "=", "salt", ".", "utils", ".", "json", ".", "dumps", "(", "args", ")", "request", "=", "__utils__", "[", "\"http.query\"", "]", "(", "path", ",", "method", "=", "http_method", ",", "data", "=", "data", ",", "status", "=", "True", ",", "decode", "=", "True", ",", "decode_type", "=", "'json'", ",", "data_render", "=", "True", ",", "data_renderer", "=", "'json'", ",", "headers", "=", "True", ",", "header_dict", "=", "{", "'X-Auth-Token'", ":", "token", ",", "'User-Agent'", ":", "\"salt-cloud\"", ",", "'Content-Type'", ":", "'application/json'", "}", ")", "if", "request", "[", "'status'", "]", ">", "299", ":", "raise", "SaltCloudSystemExit", "(", "'An error occurred while querying Scaleway. HTTP Code: {0}  '", "'Error: \\'{1}\\''", ".", "format", "(", "request", "[", "'status'", "]", ",", "request", "[", "'error'", "]", ")", ")", "# success without data", "if", "request", "[", "'status'", "]", "==", "204", ":", "return", "True", "return", "salt", ".", "utils", ".", "json", ".", "loads", "(", "request", "[", "'body'", "]", ")"], "docstring": "Make a call to the Scaleway API.", "docstring_tokens": ["Make", "a", "call", "to", "the", "Scaleway", "API", "."], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/cloud/clouds/scaleway.py#L316-L376", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/cloud/clouds/scaleway.py", "func_name": "script", "original_string": "def script(server_):\n    ''' Return the script deployment object.\n    '''\n    return salt.utils.cloud.os_script(\n        config.get_cloud_config_value('script', server_, __opts__),\n        server_,\n        __opts__,\n        salt.utils.cloud.salt_config_to_yaml(\n            salt.utils.cloud.minion_config(__opts__, server_)\n        )\n    )", "language": "python", "code": "def script(server_):\n    ''' Return the script deployment object.\n    '''\n    return salt.utils.cloud.os_script(\n        config.get_cloud_config_value('script', server_, __opts__),\n        server_,\n        __opts__,\n        salt.utils.cloud.salt_config_to_yaml(\n            salt.utils.cloud.minion_config(__opts__, server_)\n        )\n    )", "code_tokens": ["def", "script", "(", "server_", ")", ":", "return", "salt", ".", "utils", ".", "cloud", ".", "os_script", "(", "config", ".", "get_cloud_config_value", "(", "'script'", ",", "server_", ",", "__opts__", ")", ",", "server_", ",", "__opts__", ",", "salt", ".", "utils", ".", "cloud", ".", "salt_config_to_yaml", "(", "salt", ".", "utils", ".", "cloud", ".", "minion_config", "(", "__opts__", ",", "server_", ")", ")", ")"], "docstring": "Return the script deployment object.", "docstring_tokens": ["Return", "the", "script", "deployment", "object", "."], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/cloud/clouds/scaleway.py#L379-L389", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/states/ssh_auth.py", "func_name": "present", "original_string": "def present(\n        name,\n        user,\n        enc='ssh-rsa',\n        comment='',\n        source='',\n        options=None,\n        config='.ssh/authorized_keys',\n        fingerprint_hash_type=None,\n        **kwargs):\n    '''\n    Verifies that the specified SSH key is present for the specified user\n\n    name\n        The SSH key to manage\n\n    user\n        The user who owns the SSH authorized keys file to modify\n\n    enc\n        Defines what type of key is being used; can be ed25519, ecdsa, ssh-rsa\n        or ssh-dss\n\n    comment\n        The comment to be placed with the SSH public key\n\n    source\n        The source file for the key(s). Can contain any number of public keys,\n        in standard \"authorized_keys\" format. If this is set, comment and enc\n        will be ignored.\n\n    .. note::\n        The source file must contain keys in the format ``<enc> <key>\n        <comment>``. If you have generated a keypair using PuTTYgen, then you\n        will need to do the following to retrieve an OpenSSH-compatible public\n        key.\n\n        1. In PuTTYgen, click ``Load``, and select the *private* key file (not\n           the public key), and click ``Open``.\n        2. Copy the public key from the box labeled ``Public key for pasting\n           into OpenSSH authorized_keys file``.\n        3. Paste it into a new file.\n\n    options\n        The options passed to the key, pass a list object\n\n    config\n        The location of the authorized keys file relative to the user's home\n        directory, defaults to \".ssh/authorized_keys\". Token expansion %u and\n        %h for username and home path supported.\n\n    fingerprint_hash_type\n        The public key fingerprint hash type that the public key fingerprint\n        was originally hashed with. This defaults to ``sha256`` if not specified.\n    '''\n    ret = {'name': name,\n           'changes': {},\n           'result': True,\n           'comment': ''}\n\n    if source == '':\n        # check if this is of form {options} {enc} {key} {comment}\n        sshre = re.compile(r'^(.*?)\\s?((?:ssh\\-|ecds)[\\w-]+\\s.+)$')\n        fullkey = sshre.search(name)\n        # if it is {key} [comment]\n        if not fullkey:\n            key_and_comment = name.split(None, 1)\n            name = key_and_comment[0]\n            if len(key_and_comment) == 2:\n                comment = key_and_comment[1]\n        else:\n            # if there are options, set them\n            if fullkey.group(1):\n                options = fullkey.group(1).split(',')\n            # key is of format: {enc} {key} [comment]\n            comps = fullkey.group(2).split(None, 2)\n            enc = comps[0]\n            name = comps[1]\n            if len(comps) == 3:\n                comment = comps[2]\n\n    if __opts__['test']:\n        ret['result'], ret['comment'] = _present_test(\n                user,\n                name,\n                enc,\n                comment,\n                options or [],\n                source,\n                config,\n                fingerprint_hash_type)\n        return ret\n\n    # Get only the path to the file without env referrences to check if exists\n    if source != '':\n        source_path = __salt__['cp.get_url'](\n                        source,\n                        None,\n                        saltenv=__env__)\n\n    if source != '' and not source_path:\n        data = 'no key'\n    elif source != '' and source_path:\n        key = __salt__['cp.get_file_str'](\n                source,\n                saltenv=__env__)\n        filehasoptions = False\n        # check if this is of form {options} {enc} {key} {comment}\n        sshre = re.compile(r'^(ssh\\-|ecds).*')\n        key = key.rstrip().split('\\n')\n        for keyline in key:\n            filehasoptions = sshre.match(keyline)\n            if not filehasoptions:\n                data = __salt__['ssh.set_auth_key_from_file'](\n                        user,\n                        source,\n                        config=config,\n                        saltenv=__env__,\n                        fingerprint_hash_type=fingerprint_hash_type)\n            else:\n                # Split keyline to get key and comment\n                keyline = keyline.split(' ')\n                key_type = keyline[0]\n                key_value = keyline[1]\n                key_comment = keyline[2] if len(keyline) > 2 else ''\n                data = __salt__['ssh.set_auth_key'](\n                        user,\n                        key_value,\n                        enc=key_type,\n                        comment=key_comment,\n                        options=options or [],\n                        config=config,\n                        fingerprint_hash_type=fingerprint_hash_type)\n    else:\n        data = __salt__['ssh.set_auth_key'](\n                user,\n                name,\n                enc=enc,\n                comment=comment,\n                options=options or [],\n                config=config,\n                fingerprint_hash_type=fingerprint_hash_type)\n\n    if data == 'replace':\n        ret['changes'][name] = 'Updated'\n        ret['comment'] = ('The authorized host key {0} for user {1} was '\n                          'updated'.format(name, user))\n        return ret\n    elif data == 'no change':\n        ret['comment'] = ('The authorized host key {0} is already present '\n                          'for user {1}'.format(name, user))\n    elif data == 'new':\n        ret['changes'][name] = 'New'\n        ret['comment'] = ('The authorized host key {0} for user {1} was added'\n                          .format(name, user))\n    elif data == 'no key':\n        ret['result'] = False\n        ret['comment'] = ('Failed to add the ssh key. Source file {0} is '\n                          'missing'.format(source))\n    elif data == 'fail':\n        ret['result'] = False\n        err = sys.modules[\n            __salt__['test.ping'].__module__\n        ].__context__.pop('ssh_auth.error', None)\n        if err:\n            ret['comment'] = err\n        else:\n            ret['comment'] = ('Failed to add the ssh key. Is the home '\n                              'directory available, and/or does the key file '\n                              'exist?')\n    elif data == 'invalid' or data == 'Invalid public key':\n        ret['result'] = False\n        ret['comment'] = 'Invalid public ssh key, most likely has spaces or invalid syntax'\n\n    return ret", "language": "python", "code": "def present(\n        name,\n        user,\n        enc='ssh-rsa',\n        comment='',\n        source='',\n        options=None,\n        config='.ssh/authorized_keys',\n        fingerprint_hash_type=None,\n        **kwargs):\n    '''\n    Verifies that the specified SSH key is present for the specified user\n\n    name\n        The SSH key to manage\n\n    user\n        The user who owns the SSH authorized keys file to modify\n\n    enc\n        Defines what type of key is being used; can be ed25519, ecdsa, ssh-rsa\n        or ssh-dss\n\n    comment\n        The comment to be placed with the SSH public key\n\n    source\n        The source file for the key(s). Can contain any number of public keys,\n        in standard \"authorized_keys\" format. If this is set, comment and enc\n        will be ignored.\n\n    .. note::\n        The source file must contain keys in the format ``<enc> <key>\n        <comment>``. If you have generated a keypair using PuTTYgen, then you\n        will need to do the following to retrieve an OpenSSH-compatible public\n        key.\n\n        1. In PuTTYgen, click ``Load``, and select the *private* key file (not\n           the public key), and click ``Open``.\n        2. Copy the public key from the box labeled ``Public key for pasting\n           into OpenSSH authorized_keys file``.\n        3. Paste it into a new file.\n\n    options\n        The options passed to the key, pass a list object\n\n    config\n        The location of the authorized keys file relative to the user's home\n        directory, defaults to \".ssh/authorized_keys\". Token expansion %u and\n        %h for username and home path supported.\n\n    fingerprint_hash_type\n        The public key fingerprint hash type that the public key fingerprint\n        was originally hashed with. This defaults to ``sha256`` if not specified.\n    '''\n    ret = {'name': name,\n           'changes': {},\n           'result': True,\n           'comment': ''}\n\n    if source == '':\n        # check if this is of form {options} {enc} {key} {comment}\n        sshre = re.compile(r'^(.*?)\\s?((?:ssh\\-|ecds)[\\w-]+\\s.+)$')\n        fullkey = sshre.search(name)\n        # if it is {key} [comment]\n        if not fullkey:\n            key_and_comment = name.split(None, 1)\n            name = key_and_comment[0]\n            if len(key_and_comment) == 2:\n                comment = key_and_comment[1]\n        else:\n            # if there are options, set them\n            if fullkey.group(1):\n                options = fullkey.group(1).split(',')\n            # key is of format: {enc} {key} [comment]\n            comps = fullkey.group(2).split(None, 2)\n            enc = comps[0]\n            name = comps[1]\n            if len(comps) == 3:\n                comment = comps[2]\n\n    if __opts__['test']:\n        ret['result'], ret['comment'] = _present_test(\n                user,\n                name,\n                enc,\n                comment,\n                options or [],\n                source,\n                config,\n                fingerprint_hash_type)\n        return ret\n\n    # Get only the path to the file without env referrences to check if exists\n    if source != '':\n        source_path = __salt__['cp.get_url'](\n                        source,\n                        None,\n                        saltenv=__env__)\n\n    if source != '' and not source_path:\n        data = 'no key'\n    elif source != '' and source_path:\n        key = __salt__['cp.get_file_str'](\n                source,\n                saltenv=__env__)\n        filehasoptions = False\n        # check if this is of form {options} {enc} {key} {comment}\n        sshre = re.compile(r'^(ssh\\-|ecds).*')\n        key = key.rstrip().split('\\n')\n        for keyline in key:\n            filehasoptions = sshre.match(keyline)\n            if not filehasoptions:\n                data = __salt__['ssh.set_auth_key_from_file'](\n                        user,\n                        source,\n                        config=config,\n                        saltenv=__env__,\n                        fingerprint_hash_type=fingerprint_hash_type)\n            else:\n                # Split keyline to get key and comment\n                keyline = keyline.split(' ')\n                key_type = keyline[0]\n                key_value = keyline[1]\n                key_comment = keyline[2] if len(keyline) > 2 else ''\n                data = __salt__['ssh.set_auth_key'](\n                        user,\n                        key_value,\n                        enc=key_type,\n                        comment=key_comment,\n                        options=options or [],\n                        config=config,\n                        fingerprint_hash_type=fingerprint_hash_type)\n    else:\n        data = __salt__['ssh.set_auth_key'](\n                user,\n                name,\n                enc=enc,\n                comment=comment,\n                options=options or [],\n                config=config,\n                fingerprint_hash_type=fingerprint_hash_type)\n\n    if data == 'replace':\n        ret['changes'][name] = 'Updated'\n        ret['comment'] = ('The authorized host key {0} for user {1} was '\n                          'updated'.format(name, user))\n        return ret\n    elif data == 'no change':\n        ret['comment'] = ('The authorized host key {0} is already present '\n                          'for user {1}'.format(name, user))\n    elif data == 'new':\n        ret['changes'][name] = 'New'\n        ret['comment'] = ('The authorized host key {0} for user {1} was added'\n                          .format(name, user))\n    elif data == 'no key':\n        ret['result'] = False\n        ret['comment'] = ('Failed to add the ssh key. Source file {0} is '\n                          'missing'.format(source))\n    elif data == 'fail':\n        ret['result'] = False\n        err = sys.modules[\n            __salt__['test.ping'].__module__\n        ].__context__.pop('ssh_auth.error', None)\n        if err:\n            ret['comment'] = err\n        else:\n            ret['comment'] = ('Failed to add the ssh key. Is the home '\n                              'directory available, and/or does the key file '\n                              'exist?')\n    elif data == 'invalid' or data == 'Invalid public key':\n        ret['result'] = False\n        ret['comment'] = 'Invalid public ssh key, most likely has spaces or invalid syntax'\n\n    return ret", "code_tokens": ["def", "present", "(", "name", ",", "user", ",", "enc", "=", "'ssh-rsa'", ",", "comment", "=", "''", ",", "source", "=", "''", ",", "options", "=", "None", ",", "config", "=", "'.ssh/authorized_keys'", ",", "fingerprint_hash_type", "=", "None", ",", "*", "*", "kwargs", ")", ":", "ret", "=", "{", "'name'", ":", "name", ",", "'changes'", ":", "{", "}", ",", "'result'", ":", "True", ",", "'comment'", ":", "''", "}", "if", "source", "==", "''", ":", "# check if this is of form {options} {enc} {key} {comment}", "sshre", "=", "re", ".", "compile", "(", "r'^(.*?)\\s?((?:ssh\\-|ecds)[\\w-]+\\s.+)$'", ")", "fullkey", "=", "sshre", ".", "search", "(", "name", ")", "# if it is {key} [comment]", "if", "not", "fullkey", ":", "key_and_comment", "=", "name", ".", "split", "(", "None", ",", "1", ")", "name", "=", "key_and_comment", "[", "0", "]", "if", "len", "(", "key_and_comment", ")", "==", "2", ":", "comment", "=", "key_and_comment", "[", "1", "]", "else", ":", "# if there are options, set them", "if", "fullkey", ".", "group", "(", "1", ")", ":", "options", "=", "fullkey", ".", "group", "(", "1", ")", ".", "split", "(", "','", ")", "# key is of format: {enc} {key} [comment]", "comps", "=", "fullkey", ".", "group", "(", "2", ")", ".", "split", "(", "None", ",", "2", ")", "enc", "=", "comps", "[", "0", "]", "name", "=", "comps", "[", "1", "]", "if", "len", "(", "comps", ")", "==", "3", ":", "comment", "=", "comps", "[", "2", "]", "if", "__opts__", "[", "'test'", "]", ":", "ret", "[", "'result'", "]", ",", "ret", "[", "'comment'", "]", "=", "_present_test", "(", "user", ",", "name", ",", "enc", ",", "comment", ",", "options", "or", "[", "]", ",", "source", ",", "config", ",", "fingerprint_hash_type", ")", "return", "ret", "# Get only the path to the file without env referrences to check if exists", "if", "source", "!=", "''", ":", "source_path", "=", "__salt__", "[", "'cp.get_url'", "]", "(", "source", ",", "None", ",", "saltenv", "=", "__env__", ")", "if", "source", "!=", "''", "and", "not", "source_path", ":", "data", "=", "'no key'", "elif", "source", "!=", "''", "and", "source_path", ":", "key", "=", "__salt__", "[", "'cp.get_file_str'", "]", "(", "source", ",", "saltenv", "=", "__env__", ")", "filehasoptions", "=", "False", "# check if this is of form {options} {enc} {key} {comment}", "sshre", "=", "re", ".", "compile", "(", "r'^(ssh\\-|ecds).*'", ")", "key", "=", "key", ".", "rstrip", "(", ")", ".", "split", "(", "'\\n'", ")", "for", "keyline", "in", "key", ":", "filehasoptions", "=", "sshre", ".", "match", "(", "keyline", ")", "if", "not", "filehasoptions", ":", "data", "=", "__salt__", "[", "'ssh.set_auth_key_from_file'", "]", "(", "user", ",", "source", ",", "config", "=", "config", ",", "saltenv", "=", "__env__", ",", "fingerprint_hash_type", "=", "fingerprint_hash_type", ")", "else", ":", "# Split keyline to get key and comment", "keyline", "=", "keyline", ".", "split", "(", "' '", ")", "key_type", "=", "keyline", "[", "0", "]", "key_value", "=", "keyline", "[", "1", "]", "key_comment", "=", "keyline", "[", "2", "]", "if", "len", "(", "keyline", ")", ">", "2", "else", "''", "data", "=", "__salt__", "[", "'ssh.set_auth_key'", "]", "(", "user", ",", "key_value", ",", "enc", "=", "key_type", ",", "comment", "=", "key_comment", ",", "options", "=", "options", "or", "[", "]", ",", "config", "=", "config", ",", "fingerprint_hash_type", "=", "fingerprint_hash_type", ")", "else", ":", "data", "=", "__salt__", "[", "'ssh.set_auth_key'", "]", "(", "user", ",", "name", ",", "enc", "=", "enc", ",", "comment", "=", "comment", ",", "options", "=", "options", "or", "[", "]", ",", "config", "=", "config", ",", "fingerprint_hash_type", "=", "fingerprint_hash_type", ")", "if", "data", "==", "'replace'", ":", "ret", "[", "'changes'", "]", "[", "name", "]", "=", "'Updated'", "ret", "[", "'comment'", "]", "=", "(", "'The authorized host key {0} for user {1} was '", "'updated'", ".", "format", "(", "name", ",", "user", ")", ")", "return", "ret", "elif", "data", "==", "'no change'", ":", "ret", "[", "'comment'", "]", "=", "(", "'The authorized host key {0} is already present '", "'for user {1}'", ".", "format", "(", "name", ",", "user", ")", ")", "elif", "data", "==", "'new'", ":", "ret", "[", "'changes'", "]", "[", "name", "]", "=", "'New'", "ret", "[", "'comment'", "]", "=", "(", "'The authorized host key {0} for user {1} was added'", ".", "format", "(", "name", ",", "user", ")", ")", "elif", "data", "==", "'no key'", ":", "ret", "[", "'result'", "]", "=", "False", "ret", "[", "'comment'", "]", "=", "(", "'Failed to add the ssh key. Source file {0} is '", "'missing'", ".", "format", "(", "source", ")", ")", "elif", "data", "==", "'fail'", ":", "ret", "[", "'result'", "]", "=", "False", "err", "=", "sys", ".", "modules", "[", "__salt__", "[", "'test.ping'", "]", ".", "__module__", "]", ".", "__context__", ".", "pop", "(", "'ssh_auth.error'", ",", "None", ")", "if", "err", ":", "ret", "[", "'comment'", "]", "=", "err", "else", ":", "ret", "[", "'comment'", "]", "=", "(", "'Failed to add the ssh key. Is the home '", "'directory available, and/or does the key file '", "'exist?'", ")", "elif", "data", "==", "'invalid'", "or", "data", "==", "'Invalid public key'", ":", "ret", "[", "'result'", "]", "=", "False", "ret", "[", "'comment'", "]", "=", "'Invalid public ssh key, most likely has spaces or invalid syntax'", "return", "ret"], "docstring": "Verifies that the specified SSH key is present for the specified user\n\n    name\n        The SSH key to manage\n\n    user\n        The user who owns the SSH authorized keys file to modify\n\n    enc\n        Defines what type of key is being used; can be ed25519, ecdsa, ssh-rsa\n        or ssh-dss\n\n    comment\n        The comment to be placed with the SSH public key\n\n    source\n        The source file for the key(s). Can contain any number of public keys,\n        in standard \"authorized_keys\" format. If this is set, comment and enc\n        will be ignored.\n\n    .. note::\n        The source file must contain keys in the format ``<enc> <key>\n        <comment>``. If you have generated a keypair using PuTTYgen, then you\n        will need to do the following to retrieve an OpenSSH-compatible public\n        key.\n\n        1. In PuTTYgen, click ``Load``, and select the *private* key file (not\n           the public key), and click ``Open``.\n        2. Copy the public key from the box labeled ``Public key for pasting\n           into OpenSSH authorized_keys file``.\n        3. Paste it into a new file.\n\n    options\n        The options passed to the key, pass a list object\n\n    config\n        The location of the authorized keys file relative to the user's home\n        directory, defaults to \".ssh/authorized_keys\". Token expansion %u and\n        %h for username and home path supported.\n\n    fingerprint_hash_type\n        The public key fingerprint hash type that the public key fingerprint\n        was originally hashed with. This defaults to ``sha256`` if not specified.", "docstring_tokens": ["Verifies", "that", "the", "specified", "SSH", "key", "is", "present", "for", "the", "specified", "user"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/states/ssh_auth.py#L215-L389", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/states/ssh_auth.py", "func_name": "absent", "original_string": "def absent(name,\n           user,\n           enc='ssh-rsa',\n           comment='',\n           source='',\n           options=None,\n           config='.ssh/authorized_keys',\n           fingerprint_hash_type=None):\n    '''\n    Verifies that the specified SSH key is absent\n\n    name\n        The SSH key to manage\n\n    user\n        The user who owns the SSH authorized keys file to modify\n\n    enc\n        Defines what type of key is being used; can be ed25519, ecdsa, ssh-rsa\n        or ssh-dss\n\n    comment\n        The comment to be placed with the SSH public key\n\n    options\n        The options passed to the key, pass a list object\n\n    source\n        The source file for the key(s). Can contain any number of public keys,\n        in standard \"authorized_keys\" format. If this is set, comment, enc and\n        options will be ignored.\n\n        .. versionadded:: 2015.8.0\n\n    config\n        The location of the authorized keys file relative to the user's home\n        directory, defaults to \".ssh/authorized_keys\". Token expansion %u and\n        %h for username and home path supported.\n\n    fingerprint_hash_type\n        The public key fingerprint hash type that the public key fingerprint\n        was originally hashed with. This defaults to ``sha256`` if not specified.\n\n        .. versionadded:: 2016.11.7\n    '''\n    ret = {'name': name,\n           'changes': {},\n           'result': True,\n           'comment': ''}\n\n    if __opts__['test']:\n        ret['result'], ret['comment'] = _absent_test(\n                user,\n                name,\n                enc,\n                comment,\n                options or [],\n                source,\n                config,\n                fingerprint_hash_type)\n        return ret\n\n    # Extract Key from file if source is present\n    if source != '':\n        key = __salt__['cp.get_file_str'](\n                source,\n                saltenv=__env__)\n        filehasoptions = False\n        # check if this is of form {options} {enc} {key} {comment}\n        sshre = re.compile(r'^(ssh\\-|ecds).*')\n        key = key.rstrip().split('\\n')\n        for keyline in key:\n            filehasoptions = sshre.match(keyline)\n            if not filehasoptions:\n                ret['comment'] = __salt__['ssh.rm_auth_key_from_file'](user,\n                                                                       source,\n                                                                       config,\n                                                                       saltenv=__env__,\n                                                                       fingerprint_hash_type=fingerprint_hash_type)\n            else:\n                # Split keyline to get key\n                keyline = keyline.split(' ')\n                ret['comment'] = __salt__['ssh.rm_auth_key'](user,\n                                                             keyline[1],\n                                                             config=config,\n                                                             fingerprint_hash_type=fingerprint_hash_type)\n    else:\n        # Get just the key\n        sshre = re.compile(r'^(.*?)\\s?((?:ssh\\-|ecds)[\\w-]+\\s.+)$')\n        fullkey = sshre.search(name)\n        # if it is {key} [comment]\n        if not fullkey:\n            key_and_comment = name.split(None, 1)\n            name = key_and_comment[0]\n            if len(key_and_comment) == 2:\n                comment = key_and_comment[1]\n        else:\n            # if there are options, set them\n            if fullkey.group(1):\n                options = fullkey.group(1).split(',')\n            # key is of format: {enc} {key} [comment]\n            comps = fullkey.group(2).split()\n            enc = comps[0]\n            name = comps[1]\n            if len(comps) == 3:\n                comment = comps[2]\n        ret['comment'] = __salt__['ssh.rm_auth_key'](user,\n                                                     name,\n                                                     config=config,\n                                                     fingerprint_hash_type=fingerprint_hash_type)\n\n    if ret['comment'] == 'User authorized keys file not present':\n        ret['result'] = False\n        return ret\n    elif ret['comment'] == 'Key removed':\n        ret['changes'][name] = 'Removed'\n\n    return ret", "language": "python", "code": "def absent(name,\n           user,\n           enc='ssh-rsa',\n           comment='',\n           source='',\n           options=None,\n           config='.ssh/authorized_keys',\n           fingerprint_hash_type=None):\n    '''\n    Verifies that the specified SSH key is absent\n\n    name\n        The SSH key to manage\n\n    user\n        The user who owns the SSH authorized keys file to modify\n\n    enc\n        Defines what type of key is being used; can be ed25519, ecdsa, ssh-rsa\n        or ssh-dss\n\n    comment\n        The comment to be placed with the SSH public key\n\n    options\n        The options passed to the key, pass a list object\n\n    source\n        The source file for the key(s). Can contain any number of public keys,\n        in standard \"authorized_keys\" format. If this is set, comment, enc and\n        options will be ignored.\n\n        .. versionadded:: 2015.8.0\n\n    config\n        The location of the authorized keys file relative to the user's home\n        directory, defaults to \".ssh/authorized_keys\". Token expansion %u and\n        %h for username and home path supported.\n\n    fingerprint_hash_type\n        The public key fingerprint hash type that the public key fingerprint\n        was originally hashed with. This defaults to ``sha256`` if not specified.\n\n        .. versionadded:: 2016.11.7\n    '''\n    ret = {'name': name,\n           'changes': {},\n           'result': True,\n           'comment': ''}\n\n    if __opts__['test']:\n        ret['result'], ret['comment'] = _absent_test(\n                user,\n                name,\n                enc,\n                comment,\n                options or [],\n                source,\n                config,\n                fingerprint_hash_type)\n        return ret\n\n    # Extract Key from file if source is present\n    if source != '':\n        key = __salt__['cp.get_file_str'](\n                source,\n                saltenv=__env__)\n        filehasoptions = False\n        # check if this is of form {options} {enc} {key} {comment}\n        sshre = re.compile(r'^(ssh\\-|ecds).*')\n        key = key.rstrip().split('\\n')\n        for keyline in key:\n            filehasoptions = sshre.match(keyline)\n            if not filehasoptions:\n                ret['comment'] = __salt__['ssh.rm_auth_key_from_file'](user,\n                                                                       source,\n                                                                       config,\n                                                                       saltenv=__env__,\n                                                                       fingerprint_hash_type=fingerprint_hash_type)\n            else:\n                # Split keyline to get key\n                keyline = keyline.split(' ')\n                ret['comment'] = __salt__['ssh.rm_auth_key'](user,\n                                                             keyline[1],\n                                                             config=config,\n                                                             fingerprint_hash_type=fingerprint_hash_type)\n    else:\n        # Get just the key\n        sshre = re.compile(r'^(.*?)\\s?((?:ssh\\-|ecds)[\\w-]+\\s.+)$')\n        fullkey = sshre.search(name)\n        # if it is {key} [comment]\n        if not fullkey:\n            key_and_comment = name.split(None, 1)\n            name = key_and_comment[0]\n            if len(key_and_comment) == 2:\n                comment = key_and_comment[1]\n        else:\n            # if there are options, set them\n            if fullkey.group(1):\n                options = fullkey.group(1).split(',')\n            # key is of format: {enc} {key} [comment]\n            comps = fullkey.group(2).split()\n            enc = comps[0]\n            name = comps[1]\n            if len(comps) == 3:\n                comment = comps[2]\n        ret['comment'] = __salt__['ssh.rm_auth_key'](user,\n                                                     name,\n                                                     config=config,\n                                                     fingerprint_hash_type=fingerprint_hash_type)\n\n    if ret['comment'] == 'User authorized keys file not present':\n        ret['result'] = False\n        return ret\n    elif ret['comment'] == 'Key removed':\n        ret['changes'][name] = 'Removed'\n\n    return ret", "code_tokens": ["def", "absent", "(", "name", ",", "user", ",", "enc", "=", "'ssh-rsa'", ",", "comment", "=", "''", ",", "source", "=", "''", ",", "options", "=", "None", ",", "config", "=", "'.ssh/authorized_keys'", ",", "fingerprint_hash_type", "=", "None", ")", ":", "ret", "=", "{", "'name'", ":", "name", ",", "'changes'", ":", "{", "}", ",", "'result'", ":", "True", ",", "'comment'", ":", "''", "}", "if", "__opts__", "[", "'test'", "]", ":", "ret", "[", "'result'", "]", ",", "ret", "[", "'comment'", "]", "=", "_absent_test", "(", "user", ",", "name", ",", "enc", ",", "comment", ",", "options", "or", "[", "]", ",", "source", ",", "config", ",", "fingerprint_hash_type", ")", "return", "ret", "# Extract Key from file if source is present", "if", "source", "!=", "''", ":", "key", "=", "__salt__", "[", "'cp.get_file_str'", "]", "(", "source", ",", "saltenv", "=", "__env__", ")", "filehasoptions", "=", "False", "# check if this is of form {options} {enc} {key} {comment}", "sshre", "=", "re", ".", "compile", "(", "r'^(ssh\\-|ecds).*'", ")", "key", "=", "key", ".", "rstrip", "(", ")", ".", "split", "(", "'\\n'", ")", "for", "keyline", "in", "key", ":", "filehasoptions", "=", "sshre", ".", "match", "(", "keyline", ")", "if", "not", "filehasoptions", ":", "ret", "[", "'comment'", "]", "=", "__salt__", "[", "'ssh.rm_auth_key_from_file'", "]", "(", "user", ",", "source", ",", "config", ",", "saltenv", "=", "__env__", ",", "fingerprint_hash_type", "=", "fingerprint_hash_type", ")", "else", ":", "# Split keyline to get key", "keyline", "=", "keyline", ".", "split", "(", "' '", ")", "ret", "[", "'comment'", "]", "=", "__salt__", "[", "'ssh.rm_auth_key'", "]", "(", "user", ",", "keyline", "[", "1", "]", ",", "config", "=", "config", ",", "fingerprint_hash_type", "=", "fingerprint_hash_type", ")", "else", ":", "# Get just the key", "sshre", "=", "re", ".", "compile", "(", "r'^(.*?)\\s?((?:ssh\\-|ecds)[\\w-]+\\s.+)$'", ")", "fullkey", "=", "sshre", ".", "search", "(", "name", ")", "# if it is {key} [comment]", "if", "not", "fullkey", ":", "key_and_comment", "=", "name", ".", "split", "(", "None", ",", "1", ")", "name", "=", "key_and_comment", "[", "0", "]", "if", "len", "(", "key_and_comment", ")", "==", "2", ":", "comment", "=", "key_and_comment", "[", "1", "]", "else", ":", "# if there are options, set them", "if", "fullkey", ".", "group", "(", "1", ")", ":", "options", "=", "fullkey", ".", "group", "(", "1", ")", ".", "split", "(", "','", ")", "# key is of format: {enc} {key} [comment]", "comps", "=", "fullkey", ".", "group", "(", "2", ")", ".", "split", "(", ")", "enc", "=", "comps", "[", "0", "]", "name", "=", "comps", "[", "1", "]", "if", "len", "(", "comps", ")", "==", "3", ":", "comment", "=", "comps", "[", "2", "]", "ret", "[", "'comment'", "]", "=", "__salt__", "[", "'ssh.rm_auth_key'", "]", "(", "user", ",", "name", ",", "config", "=", "config", ",", "fingerprint_hash_type", "=", "fingerprint_hash_type", ")", "if", "ret", "[", "'comment'", "]", "==", "'User authorized keys file not present'", ":", "ret", "[", "'result'", "]", "=", "False", "return", "ret", "elif", "ret", "[", "'comment'", "]", "==", "'Key removed'", ":", "ret", "[", "'changes'", "]", "[", "name", "]", "=", "'Removed'", "return", "ret"], "docstring": "Verifies that the specified SSH key is absent\n\n    name\n        The SSH key to manage\n\n    user\n        The user who owns the SSH authorized keys file to modify\n\n    enc\n        Defines what type of key is being used; can be ed25519, ecdsa, ssh-rsa\n        or ssh-dss\n\n    comment\n        The comment to be placed with the SSH public key\n\n    options\n        The options passed to the key, pass a list object\n\n    source\n        The source file for the key(s). Can contain any number of public keys,\n        in standard \"authorized_keys\" format. If this is set, comment, enc and\n        options will be ignored.\n\n        .. versionadded:: 2015.8.0\n\n    config\n        The location of the authorized keys file relative to the user's home\n        directory, defaults to \".ssh/authorized_keys\". Token expansion %u and\n        %h for username and home path supported.\n\n    fingerprint_hash_type\n        The public key fingerprint hash type that the public key fingerprint\n        was originally hashed with. This defaults to ``sha256`` if not specified.\n\n        .. versionadded:: 2016.11.7", "docstring_tokens": ["Verifies", "that", "the", "specified", "SSH", "key", "is", "absent"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/states/ssh_auth.py#L392-L509", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/states/ssh_auth.py", "func_name": "manage", "original_string": "def manage(\n        name,\n        ssh_keys,\n        user,\n        enc='ssh-rsa',\n        comment='',\n        source='',\n        options=None,\n        config='.ssh/authorized_keys',\n        fingerprint_hash_type=None,\n        **kwargs):\n    '''\n    .. versionadded:: Neon\n\n    Ensures that only the specified ssh_keys are present for the specified user\n\n    ssh_keys\n        The SSH key to manage\n\n    user\n        The user who owns the SSH authorized keys file to modify\n\n    enc\n        Defines what type of key is being used; can be ed25519, ecdsa, ssh-rsa\n        or ssh-dss\n\n    comment\n        The comment to be placed with the SSH public key\n\n    source\n        The source file for the key(s). Can contain any number of public keys,\n        in standard \"authorized_keys\" format. If this is set, comment and enc\n        will be ignored.\n\n    .. note::\n        The source file must contain keys in the format ``<enc> <key>\n        <comment>``. If you have generated a keypair using PuTTYgen, then you\n        will need to do the following to retrieve an OpenSSH-compatible public\n        key.\n\n        1. In PuTTYgen, click ``Load``, and select the *private* key file (not\n           the public key), and click ``Open``.\n        2. Copy the public key from the box labeled ``Public key for pasting\n           into OpenSSH authorized_keys file``.\n        3. Paste it into a new file.\n\n    options\n        The options passed to the keys, pass a list object\n\n    config\n        The location of the authorized keys file relative to the user's home\n        directory, defaults to \".ssh/authorized_keys\". Token expansion %u and\n        %h for username and home path supported.\n\n    fingerprint_hash_type\n        The public key fingerprint hash type that the public key fingerprint\n        was originally hashed with. This defaults to ``sha256`` if not specified.\n    '''\n    ret = {'name': '',\n           'changes': {},\n           'result': True,\n           'comment': ''}\n\n    all_potential_keys = []\n    for ssh_key in ssh_keys:\n        # gather list potential ssh keys for removal comparison\n        # options, enc, and comments could be in the mix\n        all_potential_keys.extend(ssh_key.split(' '))\n    existing_keys = __salt__['ssh.auth_keys'](user=user).keys()\n    remove_keys = set(existing_keys).difference(all_potential_keys)\n    for remove_key in remove_keys:\n        if __opts__['test']:\n            remove_comment = '{0} Key set for removal'.format(remove_key)\n            ret['comment'] = remove_comment\n            ret['result'] = None\n        else:\n            remove_comment = absent(remove_key, user)['comment']\n            ret['changes'][remove_key] = remove_comment\n\n    for ssh_key in ssh_keys:\n        run_return = present(ssh_key, user, enc, comment, source,\n                             options, config, fingerprint_hash_type, **kwargs)\n        if run_return['changes']:\n            ret['changes'].update(run_return['changes'])\n        else:\n            ret['comment'] += '\\n' + run_return['comment']\n            ret['comment'].strip()\n\n        if run_return['result'] is None:\n            ret['result'] = None\n        elif not run_return['result']:\n            ret['result'] = False\n\n    return ret", "language": "python", "code": "def manage(\n        name,\n        ssh_keys,\n        user,\n        enc='ssh-rsa',\n        comment='',\n        source='',\n        options=None,\n        config='.ssh/authorized_keys',\n        fingerprint_hash_type=None,\n        **kwargs):\n    '''\n    .. versionadded:: Neon\n\n    Ensures that only the specified ssh_keys are present for the specified user\n\n    ssh_keys\n        The SSH key to manage\n\n    user\n        The user who owns the SSH authorized keys file to modify\n\n    enc\n        Defines what type of key is being used; can be ed25519, ecdsa, ssh-rsa\n        or ssh-dss\n\n    comment\n        The comment to be placed with the SSH public key\n\n    source\n        The source file for the key(s). Can contain any number of public keys,\n        in standard \"authorized_keys\" format. If this is set, comment and enc\n        will be ignored.\n\n    .. note::\n        The source file must contain keys in the format ``<enc> <key>\n        <comment>``. If you have generated a keypair using PuTTYgen, then you\n        will need to do the following to retrieve an OpenSSH-compatible public\n        key.\n\n        1. In PuTTYgen, click ``Load``, and select the *private* key file (not\n           the public key), and click ``Open``.\n        2. Copy the public key from the box labeled ``Public key for pasting\n           into OpenSSH authorized_keys file``.\n        3. Paste it into a new file.\n\n    options\n        The options passed to the keys, pass a list object\n\n    config\n        The location of the authorized keys file relative to the user's home\n        directory, defaults to \".ssh/authorized_keys\". Token expansion %u and\n        %h for username and home path supported.\n\n    fingerprint_hash_type\n        The public key fingerprint hash type that the public key fingerprint\n        was originally hashed with. This defaults to ``sha256`` if not specified.\n    '''\n    ret = {'name': '',\n           'changes': {},\n           'result': True,\n           'comment': ''}\n\n    all_potential_keys = []\n    for ssh_key in ssh_keys:\n        # gather list potential ssh keys for removal comparison\n        # options, enc, and comments could be in the mix\n        all_potential_keys.extend(ssh_key.split(' '))\n    existing_keys = __salt__['ssh.auth_keys'](user=user).keys()\n    remove_keys = set(existing_keys).difference(all_potential_keys)\n    for remove_key in remove_keys:\n        if __opts__['test']:\n            remove_comment = '{0} Key set for removal'.format(remove_key)\n            ret['comment'] = remove_comment\n            ret['result'] = None\n        else:\n            remove_comment = absent(remove_key, user)['comment']\n            ret['changes'][remove_key] = remove_comment\n\n    for ssh_key in ssh_keys:\n        run_return = present(ssh_key, user, enc, comment, source,\n                             options, config, fingerprint_hash_type, **kwargs)\n        if run_return['changes']:\n            ret['changes'].update(run_return['changes'])\n        else:\n            ret['comment'] += '\\n' + run_return['comment']\n            ret['comment'].strip()\n\n        if run_return['result'] is None:\n            ret['result'] = None\n        elif not run_return['result']:\n            ret['result'] = False\n\n    return ret", "code_tokens": ["def", "manage", "(", "name", ",", "ssh_keys", ",", "user", ",", "enc", "=", "'ssh-rsa'", ",", "comment", "=", "''", ",", "source", "=", "''", ",", "options", "=", "None", ",", "config", "=", "'.ssh/authorized_keys'", ",", "fingerprint_hash_type", "=", "None", ",", "*", "*", "kwargs", ")", ":", "ret", "=", "{", "'name'", ":", "''", ",", "'changes'", ":", "{", "}", ",", "'result'", ":", "True", ",", "'comment'", ":", "''", "}", "all_potential_keys", "=", "[", "]", "for", "ssh_key", "in", "ssh_keys", ":", "# gather list potential ssh keys for removal comparison", "# options, enc, and comments could be in the mix", "all_potential_keys", ".", "extend", "(", "ssh_key", ".", "split", "(", "' '", ")", ")", "existing_keys", "=", "__salt__", "[", "'ssh.auth_keys'", "]", "(", "user", "=", "user", ")", ".", "keys", "(", ")", "remove_keys", "=", "set", "(", "existing_keys", ")", ".", "difference", "(", "all_potential_keys", ")", "for", "remove_key", "in", "remove_keys", ":", "if", "__opts__", "[", "'test'", "]", ":", "remove_comment", "=", "'{0} Key set for removal'", ".", "format", "(", "remove_key", ")", "ret", "[", "'comment'", "]", "=", "remove_comment", "ret", "[", "'result'", "]", "=", "None", "else", ":", "remove_comment", "=", "absent", "(", "remove_key", ",", "user", ")", "[", "'comment'", "]", "ret", "[", "'changes'", "]", "[", "remove_key", "]", "=", "remove_comment", "for", "ssh_key", "in", "ssh_keys", ":", "run_return", "=", "present", "(", "ssh_key", ",", "user", ",", "enc", ",", "comment", ",", "source", ",", "options", ",", "config", ",", "fingerprint_hash_type", ",", "*", "*", "kwargs", ")", "if", "run_return", "[", "'changes'", "]", ":", "ret", "[", "'changes'", "]", ".", "update", "(", "run_return", "[", "'changes'", "]", ")", "else", ":", "ret", "[", "'comment'", "]", "+=", "'\\n'", "+", "run_return", "[", "'comment'", "]", "ret", "[", "'comment'", "]", ".", "strip", "(", ")", "if", "run_return", "[", "'result'", "]", "is", "None", ":", "ret", "[", "'result'", "]", "=", "None", "elif", "not", "run_return", "[", "'result'", "]", ":", "ret", "[", "'result'", "]", "=", "False", "return", "ret"], "docstring": ".. versionadded:: Neon\n\n    Ensures that only the specified ssh_keys are present for the specified user\n\n    ssh_keys\n        The SSH key to manage\n\n    user\n        The user who owns the SSH authorized keys file to modify\n\n    enc\n        Defines what type of key is being used; can be ed25519, ecdsa, ssh-rsa\n        or ssh-dss\n\n    comment\n        The comment to be placed with the SSH public key\n\n    source\n        The source file for the key(s). Can contain any number of public keys,\n        in standard \"authorized_keys\" format. If this is set, comment and enc\n        will be ignored.\n\n    .. note::\n        The source file must contain keys in the format ``<enc> <key>\n        <comment>``. If you have generated a keypair using PuTTYgen, then you\n        will need to do the following to retrieve an OpenSSH-compatible public\n        key.\n\n        1. In PuTTYgen, click ``Load``, and select the *private* key file (not\n           the public key), and click ``Open``.\n        2. Copy the public key from the box labeled ``Public key for pasting\n           into OpenSSH authorized_keys file``.\n        3. Paste it into a new file.\n\n    options\n        The options passed to the keys, pass a list object\n\n    config\n        The location of the authorized keys file relative to the user's home\n        directory, defaults to \".ssh/authorized_keys\". Token expansion %u and\n        %h for username and home path supported.\n\n    fingerprint_hash_type\n        The public key fingerprint hash type that the public key fingerprint\n        was originally hashed with. This defaults to ``sha256`` if not specified.", "docstring_tokens": ["..", "versionadded", "::", "Neon"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/states/ssh_auth.py#L512-L605", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/runners/smartos_vmadm.py", "func_name": "_action", "original_string": "def _action(action='get', search=None, one=True, force=False):\n    '''\n    Multi action helper for start, stop, get, ...\n    '''\n    vms = {}\n    matched_vms = []\n    client = salt.client.get_local_client(__opts__['conf_file'])\n\n    ## lookup vms\n    try:\n        vmadm_args = {}\n        vmadm_args['order'] = 'uuid,alias,hostname,state'\n        if '=' in search:\n            vmadm_args['search'] = search\n        for cn in client.cmd_iter('G@virtual:physical and G@os:smartos',\n                                  'vmadm.list', kwarg=vmadm_args,\n                                  tgt_type='compound'):\n            if not cn:\n                continue\n            node = next(six.iterkeys(cn))\n            if not isinstance(cn[node], dict) or \\\n                    'ret' not in cn[node] or \\\n                    not isinstance(cn[node]['ret'], dict):\n                continue\n            for vm in cn[node]['ret']:\n                vmcfg = cn[node]['ret'][vm]\n                vmcfg['node'] = node\n                vms[vm] = vmcfg\n    except SaltClientError as client_error:\n        pass\n\n    ## check if we have vms\n    if not vms:\n        return {'Error': 'No vms found.'}\n\n    ## simple search\n    if '=' not in search:\n        loop_pass = 0\n        while loop_pass < 3:\n            ## each pass will try a different field\n            if loop_pass == 0:\n                field = 'uuid'\n            elif loop_pass == 1:\n                field = 'hostname'\n            else:\n                field = 'alias'\n\n            ## loop vms and try to match\n            for vm in vms:\n                if field == 'uuid' and vm == search:\n                    matched_vms.append(vm)\n                    break  # exit for on uuid match (max = 1)\n                elif field in vms[vm] and vms[vm][field] == search:\n                    matched_vms.append(vm)\n\n            ## exit on match(es) or try again\n            if matched_vms:\n                break\n            else:\n                loop_pass += 1\n    else:\n        for vm in vms:\n            matched_vms.append(vm)\n\n    ## check if we have vms\n    if not matched_vms:\n        return {'Error': 'No vms matched.'}\n\n    ## multiple allowed?\n    if one and len(matched_vms) > 1:\n        return {\n            'Error': 'Matched {0} vms, only one allowed!'.format(len(matched_vms)),\n            'Matches': matched_vms\n        }\n\n    ## perform action\n    ret = {}\n    if action in ['start', 'stop', 'reboot', 'get']:\n        for vm in matched_vms:\n            vmadm_args = {\n                'key': 'uuid',\n                'vm': vm\n            }\n            try:\n                for vmadm_res in client.cmd_iter(vms[vm]['node'], 'vmadm.{0}'.format(action), kwarg=vmadm_args):\n                    if not vmadm_res:\n                        continue\n                    if vms[vm]['node'] in vmadm_res:\n                        ret[vm] = vmadm_res[vms[vm]['node']]['ret']\n            except SaltClientError as client_error:\n                ret[vm] = False\n    elif action in ['is_running']:\n        ret = True\n        for vm in matched_vms:\n            if vms[vm]['state'] != 'running':\n                ret = False\n                break\n    return ret", "language": "python", "code": "def _action(action='get', search=None, one=True, force=False):\n    '''\n    Multi action helper for start, stop, get, ...\n    '''\n    vms = {}\n    matched_vms = []\n    client = salt.client.get_local_client(__opts__['conf_file'])\n\n    ## lookup vms\n    try:\n        vmadm_args = {}\n        vmadm_args['order'] = 'uuid,alias,hostname,state'\n        if '=' in search:\n            vmadm_args['search'] = search\n        for cn in client.cmd_iter('G@virtual:physical and G@os:smartos',\n                                  'vmadm.list', kwarg=vmadm_args,\n                                  tgt_type='compound'):\n            if not cn:\n                continue\n            node = next(six.iterkeys(cn))\n            if not isinstance(cn[node], dict) or \\\n                    'ret' not in cn[node] or \\\n                    not isinstance(cn[node]['ret'], dict):\n                continue\n            for vm in cn[node]['ret']:\n                vmcfg = cn[node]['ret'][vm]\n                vmcfg['node'] = node\n                vms[vm] = vmcfg\n    except SaltClientError as client_error:\n        pass\n\n    ## check if we have vms\n    if not vms:\n        return {'Error': 'No vms found.'}\n\n    ## simple search\n    if '=' not in search:\n        loop_pass = 0\n        while loop_pass < 3:\n            ## each pass will try a different field\n            if loop_pass == 0:\n                field = 'uuid'\n            elif loop_pass == 1:\n                field = 'hostname'\n            else:\n                field = 'alias'\n\n            ## loop vms and try to match\n            for vm in vms:\n                if field == 'uuid' and vm == search:\n                    matched_vms.append(vm)\n                    break  # exit for on uuid match (max = 1)\n                elif field in vms[vm] and vms[vm][field] == search:\n                    matched_vms.append(vm)\n\n            ## exit on match(es) or try again\n            if matched_vms:\n                break\n            else:\n                loop_pass += 1\n    else:\n        for vm in vms:\n            matched_vms.append(vm)\n\n    ## check if we have vms\n    if not matched_vms:\n        return {'Error': 'No vms matched.'}\n\n    ## multiple allowed?\n    if one and len(matched_vms) > 1:\n        return {\n            'Error': 'Matched {0} vms, only one allowed!'.format(len(matched_vms)),\n            'Matches': matched_vms\n        }\n\n    ## perform action\n    ret = {}\n    if action in ['start', 'stop', 'reboot', 'get']:\n        for vm in matched_vms:\n            vmadm_args = {\n                'key': 'uuid',\n                'vm': vm\n            }\n            try:\n                for vmadm_res in client.cmd_iter(vms[vm]['node'], 'vmadm.{0}'.format(action), kwarg=vmadm_args):\n                    if not vmadm_res:\n                        continue\n                    if vms[vm]['node'] in vmadm_res:\n                        ret[vm] = vmadm_res[vms[vm]['node']]['ret']\n            except SaltClientError as client_error:\n                ret[vm] = False\n    elif action in ['is_running']:\n        ret = True\n        for vm in matched_vms:\n            if vms[vm]['state'] != 'running':\n                ret = False\n                break\n    return ret", "code_tokens": ["def", "_action", "(", "action", "=", "'get'", ",", "search", "=", "None", ",", "one", "=", "True", ",", "force", "=", "False", ")", ":", "vms", "=", "{", "}", "matched_vms", "=", "[", "]", "client", "=", "salt", ".", "client", ".", "get_local_client", "(", "__opts__", "[", "'conf_file'", "]", ")", "## lookup vms", "try", ":", "vmadm_args", "=", "{", "}", "vmadm_args", "[", "'order'", "]", "=", "'uuid,alias,hostname,state'", "if", "'='", "in", "search", ":", "vmadm_args", "[", "'search'", "]", "=", "search", "for", "cn", "in", "client", ".", "cmd_iter", "(", "'G@virtual:physical and G@os:smartos'", ",", "'vmadm.list'", ",", "kwarg", "=", "vmadm_args", ",", "tgt_type", "=", "'compound'", ")", ":", "if", "not", "cn", ":", "continue", "node", "=", "next", "(", "six", ".", "iterkeys", "(", "cn", ")", ")", "if", "not", "isinstance", "(", "cn", "[", "node", "]", ",", "dict", ")", "or", "'ret'", "not", "in", "cn", "[", "node", "]", "or", "not", "isinstance", "(", "cn", "[", "node", "]", "[", "'ret'", "]", ",", "dict", ")", ":", "continue", "for", "vm", "in", "cn", "[", "node", "]", "[", "'ret'", "]", ":", "vmcfg", "=", "cn", "[", "node", "]", "[", "'ret'", "]", "[", "vm", "]", "vmcfg", "[", "'node'", "]", "=", "node", "vms", "[", "vm", "]", "=", "vmcfg", "except", "SaltClientError", "as", "client_error", ":", "pass", "## check if we have vms", "if", "not", "vms", ":", "return", "{", "'Error'", ":", "'No vms found.'", "}", "## simple search", "if", "'='", "not", "in", "search", ":", "loop_pass", "=", "0", "while", "loop_pass", "<", "3", ":", "## each pass will try a different field", "if", "loop_pass", "==", "0", ":", "field", "=", "'uuid'", "elif", "loop_pass", "==", "1", ":", "field", "=", "'hostname'", "else", ":", "field", "=", "'alias'", "## loop vms and try to match", "for", "vm", "in", "vms", ":", "if", "field", "==", "'uuid'", "and", "vm", "==", "search", ":", "matched_vms", ".", "append", "(", "vm", ")", "break", "# exit for on uuid match (max = 1)", "elif", "field", "in", "vms", "[", "vm", "]", "and", "vms", "[", "vm", "]", "[", "field", "]", "==", "search", ":", "matched_vms", ".", "append", "(", "vm", ")", "## exit on match(es) or try again", "if", "matched_vms", ":", "break", "else", ":", "loop_pass", "+=", "1", "else", ":", "for", "vm", "in", "vms", ":", "matched_vms", ".", "append", "(", "vm", ")", "## check if we have vms", "if", "not", "matched_vms", ":", "return", "{", "'Error'", ":", "'No vms matched.'", "}", "## multiple allowed?", "if", "one", "and", "len", "(", "matched_vms", ")", ">", "1", ":", "return", "{", "'Error'", ":", "'Matched {0} vms, only one allowed!'", ".", "format", "(", "len", "(", "matched_vms", ")", ")", ",", "'Matches'", ":", "matched_vms", "}", "## perform action", "ret", "=", "{", "}", "if", "action", "in", "[", "'start'", ",", "'stop'", ",", "'reboot'", ",", "'get'", "]", ":", "for", "vm", "in", "matched_vms", ":", "vmadm_args", "=", "{", "'key'", ":", "'uuid'", ",", "'vm'", ":", "vm", "}", "try", ":", "for", "vmadm_res", "in", "client", ".", "cmd_iter", "(", "vms", "[", "vm", "]", "[", "'node'", "]", ",", "'vmadm.{0}'", ".", "format", "(", "action", ")", ",", "kwarg", "=", "vmadm_args", ")", ":", "if", "not", "vmadm_res", ":", "continue", "if", "vms", "[", "vm", "]", "[", "'node'", "]", "in", "vmadm_res", ":", "ret", "[", "vm", "]", "=", "vmadm_res", "[", "vms", "[", "vm", "]", "[", "'node'", "]", "]", "[", "'ret'", "]", "except", "SaltClientError", "as", "client_error", ":", "ret", "[", "vm", "]", "=", "False", "elif", "action", "in", "[", "'is_running'", "]", ":", "ret", "=", "True", "for", "vm", "in", "matched_vms", ":", "if", "vms", "[", "vm", "]", "[", "'state'", "]", "!=", "'running'", ":", "ret", "=", "False", "break", "return", "ret"], "docstring": "Multi action helper for start, stop, get, ...", "docstring_tokens": ["Multi", "action", "helper", "for", "start", "stop", "get", "..."], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/runners/smartos_vmadm.py#L36-L133", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/runners/smartos_vmadm.py", "func_name": "nodes", "original_string": "def nodes(verbose=False):\n    '''\n    List all compute nodes\n\n    verbose : boolean\n        print additional information about the node\n        e.g. platform version, hvm capable, ...\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt-run vmadm.nodes\n        salt-run vmadm.nodes verbose=True\n    '''\n    ret = {} if verbose else []\n    client = salt.client.get_local_client(__opts__['conf_file'])\n\n    ## get list of nodes\n    try:\n        for cn in client.cmd_iter('G@virtual:physical and G@os:smartos',\n                                  'grains.items', tgt_type='compound'):\n            if not cn:\n                continue\n            node = next(six.iterkeys(cn))\n            if not isinstance(cn[node], dict) or \\\n                    'ret' not in cn[node] or \\\n                    not isinstance(cn[node]['ret'], dict):\n                continue\n            if verbose:\n                ret[node] = {}\n                ret[node]['version'] = {}\n                ret[node]['version']['platform'] = cn[node]['ret']['osrelease']\n                if 'computenode_sdc_version' in cn[node]['ret']:\n                    ret[node]['version']['sdc'] = cn[node]['ret']['computenode_sdc_version']\n                ret[node]['vms'] = {}\n                if 'computenode_vm_capable' in cn[node]['ret'] and \\\n                        cn[node]['ret']['computenode_vm_capable'] and \\\n                        'computenode_vm_hw_virt' in cn[node]['ret']:\n                    ret[node]['vms']['hw_cap'] = cn[node]['ret']['computenode_vm_hw_virt']\n                else:\n                    ret[node]['vms']['hw_cap'] = False\n                if 'computenode_vms_running' in cn[node]['ret']:\n                    ret[node]['vms']['running'] = cn[node]['ret']['computenode_vms_running']\n            else:\n                ret.append(node)\n    except SaltClientError as client_error:\n        return \"{0}\".format(client_error)\n\n    if not verbose:\n        ret.sort()\n    return ret", "language": "python", "code": "def nodes(verbose=False):\n    '''\n    List all compute nodes\n\n    verbose : boolean\n        print additional information about the node\n        e.g. platform version, hvm capable, ...\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt-run vmadm.nodes\n        salt-run vmadm.nodes verbose=True\n    '''\n    ret = {} if verbose else []\n    client = salt.client.get_local_client(__opts__['conf_file'])\n\n    ## get list of nodes\n    try:\n        for cn in client.cmd_iter('G@virtual:physical and G@os:smartos',\n                                  'grains.items', tgt_type='compound'):\n            if not cn:\n                continue\n            node = next(six.iterkeys(cn))\n            if not isinstance(cn[node], dict) or \\\n                    'ret' not in cn[node] or \\\n                    not isinstance(cn[node]['ret'], dict):\n                continue\n            if verbose:\n                ret[node] = {}\n                ret[node]['version'] = {}\n                ret[node]['version']['platform'] = cn[node]['ret']['osrelease']\n                if 'computenode_sdc_version' in cn[node]['ret']:\n                    ret[node]['version']['sdc'] = cn[node]['ret']['computenode_sdc_version']\n                ret[node]['vms'] = {}\n                if 'computenode_vm_capable' in cn[node]['ret'] and \\\n                        cn[node]['ret']['computenode_vm_capable'] and \\\n                        'computenode_vm_hw_virt' in cn[node]['ret']:\n                    ret[node]['vms']['hw_cap'] = cn[node]['ret']['computenode_vm_hw_virt']\n                else:\n                    ret[node]['vms']['hw_cap'] = False\n                if 'computenode_vms_running' in cn[node]['ret']:\n                    ret[node]['vms']['running'] = cn[node]['ret']['computenode_vms_running']\n            else:\n                ret.append(node)\n    except SaltClientError as client_error:\n        return \"{0}\".format(client_error)\n\n    if not verbose:\n        ret.sort()\n    return ret", "code_tokens": ["def", "nodes", "(", "verbose", "=", "False", ")", ":", "ret", "=", "{", "}", "if", "verbose", "else", "[", "]", "client", "=", "salt", ".", "client", ".", "get_local_client", "(", "__opts__", "[", "'conf_file'", "]", ")", "## get list of nodes", "try", ":", "for", "cn", "in", "client", ".", "cmd_iter", "(", "'G@virtual:physical and G@os:smartos'", ",", "'grains.items'", ",", "tgt_type", "=", "'compound'", ")", ":", "if", "not", "cn", ":", "continue", "node", "=", "next", "(", "six", ".", "iterkeys", "(", "cn", ")", ")", "if", "not", "isinstance", "(", "cn", "[", "node", "]", ",", "dict", ")", "or", "'ret'", "not", "in", "cn", "[", "node", "]", "or", "not", "isinstance", "(", "cn", "[", "node", "]", "[", "'ret'", "]", ",", "dict", ")", ":", "continue", "if", "verbose", ":", "ret", "[", "node", "]", "=", "{", "}", "ret", "[", "node", "]", "[", "'version'", "]", "=", "{", "}", "ret", "[", "node", "]", "[", "'version'", "]", "[", "'platform'", "]", "=", "cn", "[", "node", "]", "[", "'ret'", "]", "[", "'osrelease'", "]", "if", "'computenode_sdc_version'", "in", "cn", "[", "node", "]", "[", "'ret'", "]", ":", "ret", "[", "node", "]", "[", "'version'", "]", "[", "'sdc'", "]", "=", "cn", "[", "node", "]", "[", "'ret'", "]", "[", "'computenode_sdc_version'", "]", "ret", "[", "node", "]", "[", "'vms'", "]", "=", "{", "}", "if", "'computenode_vm_capable'", "in", "cn", "[", "node", "]", "[", "'ret'", "]", "and", "cn", "[", "node", "]", "[", "'ret'", "]", "[", "'computenode_vm_capable'", "]", "and", "'computenode_vm_hw_virt'", "in", "cn", "[", "node", "]", "[", "'ret'", "]", ":", "ret", "[", "node", "]", "[", "'vms'", "]", "[", "'hw_cap'", "]", "=", "cn", "[", "node", "]", "[", "'ret'", "]", "[", "'computenode_vm_hw_virt'", "]", "else", ":", "ret", "[", "node", "]", "[", "'vms'", "]", "[", "'hw_cap'", "]", "=", "False", "if", "'computenode_vms_running'", "in", "cn", "[", "node", "]", "[", "'ret'", "]", ":", "ret", "[", "node", "]", "[", "'vms'", "]", "[", "'running'", "]", "=", "cn", "[", "node", "]", "[", "'ret'", "]", "[", "'computenode_vms_running'", "]", "else", ":", "ret", ".", "append", "(", "node", ")", "except", "SaltClientError", "as", "client_error", ":", "return", "\"{0}\"", ".", "format", "(", "client_error", ")", "if", "not", "verbose", ":", "ret", ".", "sort", "(", ")", "return", "ret"], "docstring": "List all compute nodes\n\n    verbose : boolean\n        print additional information about the node\n        e.g. platform version, hvm capable, ...\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt-run vmadm.nodes\n        salt-run vmadm.nodes verbose=True", "docstring_tokens": ["List", "all", "compute", "nodes"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/runners/smartos_vmadm.py#L136-L187", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/runners/smartos_vmadm.py", "func_name": "list_vms", "original_string": "def list_vms(search=None, verbose=False):\n    '''\n    List all vms\n\n    search : string\n        filter vms, see the execution module\n    verbose : boolean\n        print additional information about the vm\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt-run vmadm.list\n        salt-run vmadm.list search='type=KVM'\n        salt-run vmadm.list verbose=True\n    '''\n    ret = OrderedDict() if verbose else []\n    client = salt.client.get_local_client(__opts__['conf_file'])\n    try:\n        vmadm_args = {}\n        vmadm_args['order'] = 'uuid,alias,hostname,state,type,cpu_cap,vcpus,ram'\n        if search:\n            vmadm_args['search'] = search\n        for cn in client.cmd_iter('G@virtual:physical and G@os:smartos',\n                                  'vmadm.list', kwarg=vmadm_args,\n                                  tgt_type='compound'):\n            if not cn:\n                continue\n            node = next(six.iterkeys(cn))\n            if not isinstance(cn[node], dict) or \\\n                    'ret' not in cn[node] or \\\n                    not isinstance(cn[node]['ret'], dict):\n                continue\n            for vm in cn[node]['ret']:\n                vmcfg = cn[node]['ret'][vm]\n                if verbose:\n                    ret[vm] = OrderedDict()\n                    ret[vm]['hostname'] = vmcfg['hostname']\n                    ret[vm]['alias'] = vmcfg['alias']\n                    ret[vm]['computenode'] = node\n                    ret[vm]['state'] = vmcfg['state']\n                    ret[vm]['resources'] = OrderedDict()\n                    ret[vm]['resources']['memory'] = vmcfg['ram']\n                    if vmcfg['type'] == 'KVM':\n                        ret[vm]['resources']['cpu'] = \"{0:.2f}\".format(int(vmcfg['vcpus']))\n                    else:\n                        if vmcfg['cpu_cap'] != '':\n                            ret[vm]['resources']['cpu'] = \"{0:.2f}\".format(int(vmcfg['cpu_cap'])/100)\n                else:\n                    ret.append(vm)\n    except SaltClientError as client_error:\n        return \"{0}\".format(client_error)\n\n    if not verbose:\n        ret = sorted(ret)\n\n    return ret", "language": "python", "code": "def list_vms(search=None, verbose=False):\n    '''\n    List all vms\n\n    search : string\n        filter vms, see the execution module\n    verbose : boolean\n        print additional information about the vm\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt-run vmadm.list\n        salt-run vmadm.list search='type=KVM'\n        salt-run vmadm.list verbose=True\n    '''\n    ret = OrderedDict() if verbose else []\n    client = salt.client.get_local_client(__opts__['conf_file'])\n    try:\n        vmadm_args = {}\n        vmadm_args['order'] = 'uuid,alias,hostname,state,type,cpu_cap,vcpus,ram'\n        if search:\n            vmadm_args['search'] = search\n        for cn in client.cmd_iter('G@virtual:physical and G@os:smartos',\n                                  'vmadm.list', kwarg=vmadm_args,\n                                  tgt_type='compound'):\n            if not cn:\n                continue\n            node = next(six.iterkeys(cn))\n            if not isinstance(cn[node], dict) or \\\n                    'ret' not in cn[node] or \\\n                    not isinstance(cn[node]['ret'], dict):\n                continue\n            for vm in cn[node]['ret']:\n                vmcfg = cn[node]['ret'][vm]\n                if verbose:\n                    ret[vm] = OrderedDict()\n                    ret[vm]['hostname'] = vmcfg['hostname']\n                    ret[vm]['alias'] = vmcfg['alias']\n                    ret[vm]['computenode'] = node\n                    ret[vm]['state'] = vmcfg['state']\n                    ret[vm]['resources'] = OrderedDict()\n                    ret[vm]['resources']['memory'] = vmcfg['ram']\n                    if vmcfg['type'] == 'KVM':\n                        ret[vm]['resources']['cpu'] = \"{0:.2f}\".format(int(vmcfg['vcpus']))\n                    else:\n                        if vmcfg['cpu_cap'] != '':\n                            ret[vm]['resources']['cpu'] = \"{0:.2f}\".format(int(vmcfg['cpu_cap'])/100)\n                else:\n                    ret.append(vm)\n    except SaltClientError as client_error:\n        return \"{0}\".format(client_error)\n\n    if not verbose:\n        ret = sorted(ret)\n\n    return ret", "code_tokens": ["def", "list_vms", "(", "search", "=", "None", ",", "verbose", "=", "False", ")", ":", "ret", "=", "OrderedDict", "(", ")", "if", "verbose", "else", "[", "]", "client", "=", "salt", ".", "client", ".", "get_local_client", "(", "__opts__", "[", "'conf_file'", "]", ")", "try", ":", "vmadm_args", "=", "{", "}", "vmadm_args", "[", "'order'", "]", "=", "'uuid,alias,hostname,state,type,cpu_cap,vcpus,ram'", "if", "search", ":", "vmadm_args", "[", "'search'", "]", "=", "search", "for", "cn", "in", "client", ".", "cmd_iter", "(", "'G@virtual:physical and G@os:smartos'", ",", "'vmadm.list'", ",", "kwarg", "=", "vmadm_args", ",", "tgt_type", "=", "'compound'", ")", ":", "if", "not", "cn", ":", "continue", "node", "=", "next", "(", "six", ".", "iterkeys", "(", "cn", ")", ")", "if", "not", "isinstance", "(", "cn", "[", "node", "]", ",", "dict", ")", "or", "'ret'", "not", "in", "cn", "[", "node", "]", "or", "not", "isinstance", "(", "cn", "[", "node", "]", "[", "'ret'", "]", ",", "dict", ")", ":", "continue", "for", "vm", "in", "cn", "[", "node", "]", "[", "'ret'", "]", ":", "vmcfg", "=", "cn", "[", "node", "]", "[", "'ret'", "]", "[", "vm", "]", "if", "verbose", ":", "ret", "[", "vm", "]", "=", "OrderedDict", "(", ")", "ret", "[", "vm", "]", "[", "'hostname'", "]", "=", "vmcfg", "[", "'hostname'", "]", "ret", "[", "vm", "]", "[", "'alias'", "]", "=", "vmcfg", "[", "'alias'", "]", "ret", "[", "vm", "]", "[", "'computenode'", "]", "=", "node", "ret", "[", "vm", "]", "[", "'state'", "]", "=", "vmcfg", "[", "'state'", "]", "ret", "[", "vm", "]", "[", "'resources'", "]", "=", "OrderedDict", "(", ")", "ret", "[", "vm", "]", "[", "'resources'", "]", "[", "'memory'", "]", "=", "vmcfg", "[", "'ram'", "]", "if", "vmcfg", "[", "'type'", "]", "==", "'KVM'", ":", "ret", "[", "vm", "]", "[", "'resources'", "]", "[", "'cpu'", "]", "=", "\"{0:.2f}\"", ".", "format", "(", "int", "(", "vmcfg", "[", "'vcpus'", "]", ")", ")", "else", ":", "if", "vmcfg", "[", "'cpu_cap'", "]", "!=", "''", ":", "ret", "[", "vm", "]", "[", "'resources'", "]", "[", "'cpu'", "]", "=", "\"{0:.2f}\"", ".", "format", "(", "int", "(", "vmcfg", "[", "'cpu_cap'", "]", ")", "/", "100", ")", "else", ":", "ret", ".", "append", "(", "vm", ")", "except", "SaltClientError", "as", "client_error", ":", "return", "\"{0}\"", ".", "format", "(", "client_error", ")", "if", "not", "verbose", ":", "ret", "=", "sorted", "(", "ret", ")", "return", "ret"], "docstring": "List all vms\n\n    search : string\n        filter vms, see the execution module\n    verbose : boolean\n        print additional information about the vm\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt-run vmadm.list\n        salt-run vmadm.list search='type=KVM'\n        salt-run vmadm.list verbose=True", "docstring_tokens": ["List", "all", "vms"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/runners/smartos_vmadm.py#L190-L247", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/runners/smartos_vmadm.py", "func_name": "reboot", "original_string": "def reboot(search, one=True, force=False):\n    '''\n    Reboot one or more vms\n\n    search : string\n        filter vms, see the execution module.\n    one : boolean\n        reboot only one vm\n    force : boolean\n        force reboot, faster but no graceful shutdown\n\n    .. note::\n        If the search parameter does not contain an equal (=) symbol it will be\n        assumed it will be tried as uuid, hostname, and alias.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt-run vmadm.reboot 91244bba-1146-e4ec-c07e-e825e0223aa9\n        salt-run vmadm.reboot search='alias=marije'\n        salt-run vmadm.reboot search='type=KVM' one=False\n    '''\n    return _action('reboot', search, one, force)", "language": "python", "code": "def reboot(search, one=True, force=False):\n    '''\n    Reboot one or more vms\n\n    search : string\n        filter vms, see the execution module.\n    one : boolean\n        reboot only one vm\n    force : boolean\n        force reboot, faster but no graceful shutdown\n\n    .. note::\n        If the search parameter does not contain an equal (=) symbol it will be\n        assumed it will be tried as uuid, hostname, and alias.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt-run vmadm.reboot 91244bba-1146-e4ec-c07e-e825e0223aa9\n        salt-run vmadm.reboot search='alias=marije'\n        salt-run vmadm.reboot search='type=KVM' one=False\n    '''\n    return _action('reboot', search, one, force)", "code_tokens": ["def", "reboot", "(", "search", ",", "one", "=", "True", ",", "force", "=", "False", ")", ":", "return", "_action", "(", "'reboot'", ",", "search", ",", "one", ",", "force", ")"], "docstring": "Reboot one or more vms\n\n    search : string\n        filter vms, see the execution module.\n    one : boolean\n        reboot only one vm\n    force : boolean\n        force reboot, faster but no graceful shutdown\n\n    .. note::\n        If the search parameter does not contain an equal (=) symbol it will be\n        assumed it will be tried as uuid, hostname, and alias.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt-run vmadm.reboot 91244bba-1146-e4ec-c07e-e825e0223aa9\n        salt-run vmadm.reboot search='alias=marije'\n        salt-run vmadm.reboot search='type=KVM' one=False", "docstring_tokens": ["Reboot", "one", "or", "more", "vms"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/runners/smartos_vmadm.py#L298-L321", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/cloud/clouds/ec2.py", "func_name": "_xml_to_dict", "original_string": "def _xml_to_dict(xmltree):\n    '''\n    Convert an XML tree into a dict\n    '''\n    if sys.version_info < (2, 7):\n        children_len = len(xmltree.getchildren())\n    else:\n        children_len = len(xmltree)\n\n    if children_len < 1:\n        name = xmltree.tag\n        if '}' in name:\n            comps = name.split('}')\n            name = comps[1]\n        return {name: xmltree.text}\n\n    xmldict = {}\n    for item in xmltree:\n        name = item.tag\n        if '}' in name:\n            comps = name.split('}')\n            name = comps[1]\n        if name not in xmldict:\n            if sys.version_info < (2, 7):\n                children_len = len(item.getchildren())\n            else:\n                children_len = len(item)\n\n            if children_len > 0:\n                xmldict[name] = _xml_to_dict(item)\n            else:\n                xmldict[name] = item.text\n        else:\n            if not isinstance(xmldict[name], list):\n                tempvar = xmldict[name]\n                xmldict[name] = []\n                xmldict[name].append(tempvar)\n            xmldict[name].append(_xml_to_dict(item))\n    return xmldict", "language": "python", "code": "def _xml_to_dict(xmltree):\n    '''\n    Convert an XML tree into a dict\n    '''\n    if sys.version_info < (2, 7):\n        children_len = len(xmltree.getchildren())\n    else:\n        children_len = len(xmltree)\n\n    if children_len < 1:\n        name = xmltree.tag\n        if '}' in name:\n            comps = name.split('}')\n            name = comps[1]\n        return {name: xmltree.text}\n\n    xmldict = {}\n    for item in xmltree:\n        name = item.tag\n        if '}' in name:\n            comps = name.split('}')\n            name = comps[1]\n        if name not in xmldict:\n            if sys.version_info < (2, 7):\n                children_len = len(item.getchildren())\n            else:\n                children_len = len(item)\n\n            if children_len > 0:\n                xmldict[name] = _xml_to_dict(item)\n            else:\n                xmldict[name] = item.text\n        else:\n            if not isinstance(xmldict[name], list):\n                tempvar = xmldict[name]\n                xmldict[name] = []\n                xmldict[name].append(tempvar)\n            xmldict[name].append(_xml_to_dict(item))\n    return xmldict", "code_tokens": ["def", "_xml_to_dict", "(", "xmltree", ")", ":", "if", "sys", ".", "version_info", "<", "(", "2", ",", "7", ")", ":", "children_len", "=", "len", "(", "xmltree", ".", "getchildren", "(", ")", ")", "else", ":", "children_len", "=", "len", "(", "xmltree", ")", "if", "children_len", "<", "1", ":", "name", "=", "xmltree", ".", "tag", "if", "'}'", "in", "name", ":", "comps", "=", "name", ".", "split", "(", "'}'", ")", "name", "=", "comps", "[", "1", "]", "return", "{", "name", ":", "xmltree", ".", "text", "}", "xmldict", "=", "{", "}", "for", "item", "in", "xmltree", ":", "name", "=", "item", ".", "tag", "if", "'}'", "in", "name", ":", "comps", "=", "name", ".", "split", "(", "'}'", ")", "name", "=", "comps", "[", "1", "]", "if", "name", "not", "in", "xmldict", ":", "if", "sys", ".", "version_info", "<", "(", "2", ",", "7", ")", ":", "children_len", "=", "len", "(", "item", ".", "getchildren", "(", ")", ")", "else", ":", "children_len", "=", "len", "(", "item", ")", "if", "children_len", ">", "0", ":", "xmldict", "[", "name", "]", "=", "_xml_to_dict", "(", "item", ")", "else", ":", "xmldict", "[", "name", "]", "=", "item", ".", "text", "else", ":", "if", "not", "isinstance", "(", "xmldict", "[", "name", "]", ",", "list", ")", ":", "tempvar", "=", "xmldict", "[", "name", "]", "xmldict", "[", "name", "]", "=", "[", "]", "xmldict", "[", "name", "]", ".", "append", "(", "tempvar", ")", "xmldict", "[", "name", "]", ".", "append", "(", "_xml_to_dict", "(", "item", ")", ")", "return", "xmldict"], "docstring": "Convert an XML tree into a dict", "docstring_tokens": ["Convert", "an", "XML", "tree", "into", "a", "dict"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/cloud/clouds/ec2.py#L225-L263", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/cloud/clouds/ec2.py", "func_name": "optimize_providers", "original_string": "def optimize_providers(providers):\n    '''\n    Return an optimized list of providers.\n\n    We want to reduce the duplication of querying\n    the same region.\n\n    If a provider is using the same credentials for the same region\n    the same data will be returned for each provider, thus causing\n    un-wanted duplicate data and API calls to EC2.\n\n    '''\n    tmp_providers = {}\n    optimized_providers = {}\n\n    for name, data in six.iteritems(providers):\n        if 'location' not in data:\n            data['location'] = DEFAULT_LOCATION\n\n        if data['location'] not in tmp_providers:\n            tmp_providers[data['location']] = {}\n\n        creds = (data['id'], data['key'])\n        if creds not in tmp_providers[data['location']]:\n            tmp_providers[data['location']][creds] = {'name': name,\n                                                      'data': data,\n                                                      }\n\n    for location, tmp_data in six.iteritems(tmp_providers):\n        for creds, data in six.iteritems(tmp_data):\n            _id, _key = creds\n            _name = data['name']\n            _data = data['data']\n            if _name not in optimized_providers:\n                optimized_providers[_name] = _data\n\n    return optimized_providers", "language": "python", "code": "def optimize_providers(providers):\n    '''\n    Return an optimized list of providers.\n\n    We want to reduce the duplication of querying\n    the same region.\n\n    If a provider is using the same credentials for the same region\n    the same data will be returned for each provider, thus causing\n    un-wanted duplicate data and API calls to EC2.\n\n    '''\n    tmp_providers = {}\n    optimized_providers = {}\n\n    for name, data in six.iteritems(providers):\n        if 'location' not in data:\n            data['location'] = DEFAULT_LOCATION\n\n        if data['location'] not in tmp_providers:\n            tmp_providers[data['location']] = {}\n\n        creds = (data['id'], data['key'])\n        if creds not in tmp_providers[data['location']]:\n            tmp_providers[data['location']][creds] = {'name': name,\n                                                      'data': data,\n                                                      }\n\n    for location, tmp_data in six.iteritems(tmp_providers):\n        for creds, data in six.iteritems(tmp_data):\n            _id, _key = creds\n            _name = data['name']\n            _data = data['data']\n            if _name not in optimized_providers:\n                optimized_providers[_name] = _data\n\n    return optimized_providers", "code_tokens": ["def", "optimize_providers", "(", "providers", ")", ":", "tmp_providers", "=", "{", "}", "optimized_providers", "=", "{", "}", "for", "name", ",", "data", "in", "six", ".", "iteritems", "(", "providers", ")", ":", "if", "'location'", "not", "in", "data", ":", "data", "[", "'location'", "]", "=", "DEFAULT_LOCATION", "if", "data", "[", "'location'", "]", "not", "in", "tmp_providers", ":", "tmp_providers", "[", "data", "[", "'location'", "]", "]", "=", "{", "}", "creds", "=", "(", "data", "[", "'id'", "]", ",", "data", "[", "'key'", "]", ")", "if", "creds", "not", "in", "tmp_providers", "[", "data", "[", "'location'", "]", "]", ":", "tmp_providers", "[", "data", "[", "'location'", "]", "]", "[", "creds", "]", "=", "{", "'name'", ":", "name", ",", "'data'", ":", "data", ",", "}", "for", "location", ",", "tmp_data", "in", "six", ".", "iteritems", "(", "tmp_providers", ")", ":", "for", "creds", ",", "data", "in", "six", ".", "iteritems", "(", "tmp_data", ")", ":", "_id", ",", "_key", "=", "creds", "_name", "=", "data", "[", "'name'", "]", "_data", "=", "data", "[", "'data'", "]", "if", "_name", "not", "in", "optimized_providers", ":", "optimized_providers", "[", "_name", "]", "=", "_data", "return", "optimized_providers"], "docstring": "Return an optimized list of providers.\n\n    We want to reduce the duplication of querying\n    the same region.\n\n    If a provider is using the same credentials for the same region\n    the same data will be returned for each provider, thus causing\n    un-wanted duplicate data and API calls to EC2.", "docstring_tokens": ["Return", "an", "optimized", "list", "of", "providers", "."], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/cloud/clouds/ec2.py#L266-L302", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/cloud/clouds/ec2.py", "func_name": "_wait_for_spot_instance", "original_string": "def _wait_for_spot_instance(update_callback,\n                            update_args=None,\n                            update_kwargs=None,\n                            timeout=10 * 60,\n                            interval=30,\n                            interval_multiplier=1,\n                            max_failures=10):\n    '''\n    Helper function that waits for a spot instance request to become active\n    for a specific maximum amount of time.\n\n    :param update_callback: callback function which queries the cloud provider\n                            for spot instance request. It must return None if\n                            the required data, running instance included, is\n                            not available yet.\n    :param update_args: Arguments to pass to update_callback\n    :param update_kwargs: Keyword arguments to pass to update_callback\n    :param timeout: The maximum amount of time(in seconds) to wait for the IP\n                    address.\n    :param interval: The looping interval, i.e., the amount of time to sleep\n                     before the next iteration.\n    :param interval_multiplier: Increase the interval by this multiplier after\n                                each request; helps with throttling\n    :param max_failures: If update_callback returns ``False`` it's considered\n                         query failure. This value is the amount of failures\n                         accepted before giving up.\n    :returns: The update_callback returned data\n    :raises: SaltCloudExecutionTimeout\n\n    '''\n    if update_args is None:\n        update_args = ()\n    if update_kwargs is None:\n        update_kwargs = {}\n\n    duration = timeout\n    while True:\n        log.debug(\n            'Waiting for spot instance reservation. Giving up in '\n            '00:%02d:%02d', int(timeout // 60), int(timeout % 60)\n        )\n        data = update_callback(*update_args, **update_kwargs)\n        if data is False:\n            log.debug(\n                'update_callback has returned False which is considered a '\n                'failure. Remaining Failures: %s', max_failures\n            )\n            max_failures -= 1\n            if max_failures <= 0:\n                raise SaltCloudExecutionFailure(\n                    'Too many failures occurred while waiting for '\n                    'the spot instance reservation to become active.'\n                )\n        elif data is not None:\n            return data\n\n        if timeout < 0:\n            raise SaltCloudExecutionTimeout(\n                'Unable to get an active spot instance request for '\n                '00:{0:02d}:{1:02d}'.format(\n                    int(duration // 60),\n                    int(duration % 60)\n                )\n            )\n        time.sleep(interval)\n        timeout -= interval\n\n        if interval_multiplier > 1:\n            interval *= interval_multiplier\n            if interval > timeout:\n                interval = timeout + 1\n            log.info('Interval multiplier in effect; interval is '\n                     'now %ss', interval)", "language": "python", "code": "def _wait_for_spot_instance(update_callback,\n                            update_args=None,\n                            update_kwargs=None,\n                            timeout=10 * 60,\n                            interval=30,\n                            interval_multiplier=1,\n                            max_failures=10):\n    '''\n    Helper function that waits for a spot instance request to become active\n    for a specific maximum amount of time.\n\n    :param update_callback: callback function which queries the cloud provider\n                            for spot instance request. It must return None if\n                            the required data, running instance included, is\n                            not available yet.\n    :param update_args: Arguments to pass to update_callback\n    :param update_kwargs: Keyword arguments to pass to update_callback\n    :param timeout: The maximum amount of time(in seconds) to wait for the IP\n                    address.\n    :param interval: The looping interval, i.e., the amount of time to sleep\n                     before the next iteration.\n    :param interval_multiplier: Increase the interval by this multiplier after\n                                each request; helps with throttling\n    :param max_failures: If update_callback returns ``False`` it's considered\n                         query failure. This value is the amount of failures\n                         accepted before giving up.\n    :returns: The update_callback returned data\n    :raises: SaltCloudExecutionTimeout\n\n    '''\n    if update_args is None:\n        update_args = ()\n    if update_kwargs is None:\n        update_kwargs = {}\n\n    duration = timeout\n    while True:\n        log.debug(\n            'Waiting for spot instance reservation. Giving up in '\n            '00:%02d:%02d', int(timeout // 60), int(timeout % 60)\n        )\n        data = update_callback(*update_args, **update_kwargs)\n        if data is False:\n            log.debug(\n                'update_callback has returned False which is considered a '\n                'failure. Remaining Failures: %s', max_failures\n            )\n            max_failures -= 1\n            if max_failures <= 0:\n                raise SaltCloudExecutionFailure(\n                    'Too many failures occurred while waiting for '\n                    'the spot instance reservation to become active.'\n                )\n        elif data is not None:\n            return data\n\n        if timeout < 0:\n            raise SaltCloudExecutionTimeout(\n                'Unable to get an active spot instance request for '\n                '00:{0:02d}:{1:02d}'.format(\n                    int(duration // 60),\n                    int(duration % 60)\n                )\n            )\n        time.sleep(interval)\n        timeout -= interval\n\n        if interval_multiplier > 1:\n            interval *= interval_multiplier\n            if interval > timeout:\n                interval = timeout + 1\n            log.info('Interval multiplier in effect; interval is '\n                     'now %ss', interval)", "code_tokens": ["def", "_wait_for_spot_instance", "(", "update_callback", ",", "update_args", "=", "None", ",", "update_kwargs", "=", "None", ",", "timeout", "=", "10", "*", "60", ",", "interval", "=", "30", ",", "interval_multiplier", "=", "1", ",", "max_failures", "=", "10", ")", ":", "if", "update_args", "is", "None", ":", "update_args", "=", "(", ")", "if", "update_kwargs", "is", "None", ":", "update_kwargs", "=", "{", "}", "duration", "=", "timeout", "while", "True", ":", "log", ".", "debug", "(", "'Waiting for spot instance reservation. Giving up in '", "'00:%02d:%02d'", ",", "int", "(", "timeout", "//", "60", ")", ",", "int", "(", "timeout", "%", "60", ")", ")", "data", "=", "update_callback", "(", "*", "update_args", ",", "*", "*", "update_kwargs", ")", "if", "data", "is", "False", ":", "log", ".", "debug", "(", "'update_callback has returned False which is considered a '", "'failure. Remaining Failures: %s'", ",", "max_failures", ")", "max_failures", "-=", "1", "if", "max_failures", "<=", "0", ":", "raise", "SaltCloudExecutionFailure", "(", "'Too many failures occurred while waiting for '", "'the spot instance reservation to become active.'", ")", "elif", "data", "is", "not", "None", ":", "return", "data", "if", "timeout", "<", "0", ":", "raise", "SaltCloudExecutionTimeout", "(", "'Unable to get an active spot instance request for '", "'00:{0:02d}:{1:02d}'", ".", "format", "(", "int", "(", "duration", "//", "60", ")", ",", "int", "(", "duration", "%", "60", ")", ")", ")", "time", ".", "sleep", "(", "interval", ")", "timeout", "-=", "interval", "if", "interval_multiplier", ">", "1", ":", "interval", "*=", "interval_multiplier", "if", "interval", ">", "timeout", ":", "interval", "=", "timeout", "+", "1", "log", ".", "info", "(", "'Interval multiplier in effect; interval is '", "'now %ss'", ",", "interval", ")"], "docstring": "Helper function that waits for a spot instance request to become active\n    for a specific maximum amount of time.\n\n    :param update_callback: callback function which queries the cloud provider\n                            for spot instance request. It must return None if\n                            the required data, running instance included, is\n                            not available yet.\n    :param update_args: Arguments to pass to update_callback\n    :param update_kwargs: Keyword arguments to pass to update_callback\n    :param timeout: The maximum amount of time(in seconds) to wait for the IP\n                    address.\n    :param interval: The looping interval, i.e., the amount of time to sleep\n                     before the next iteration.\n    :param interval_multiplier: Increase the interval by this multiplier after\n                                each request; helps with throttling\n    :param max_failures: If update_callback returns ``False`` it's considered\n                         query failure. This value is the amount of failures\n                         accepted before giving up.\n    :returns: The update_callback returned data\n    :raises: SaltCloudExecutionTimeout", "docstring_tokens": ["Helper", "function", "that", "waits", "for", "a", "spot", "instance", "request", "to", "become", "active", "for", "a", "specific", "maximum", "amount", "of", "time", "."], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/cloud/clouds/ec2.py#L476-L548", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/cloud/clouds/ec2.py", "func_name": "avail_images", "original_string": "def avail_images(kwargs=None, call=None):\n    '''\n    Return a dict of all available VM images on the cloud provider.\n    '''\n    if call == 'action':\n        raise SaltCloudSystemExit(\n            'The avail_images function must be called with '\n            '-f or --function, or with the --list-images option'\n        )\n\n    if not isinstance(kwargs, dict):\n        kwargs = {}\n\n    if 'owner' in kwargs:\n        owner = kwargs['owner']\n    else:\n        provider = get_configured_provider()\n\n        owner = config.get_cloud_config_value(\n            'owner', provider, __opts__, default='amazon'\n        )\n\n    ret = {}\n    params = {'Action': 'DescribeImages',\n              'Owner': owner}\n    images = aws.query(params,\n                       location=get_location(),\n                       provider=get_provider(),\n                       opts=__opts__,\n                       sigver='4')\n\n    for image in images:\n        ret[image['imageId']] = image\n    return ret", "language": "python", "code": "def avail_images(kwargs=None, call=None):\n    '''\n    Return a dict of all available VM images on the cloud provider.\n    '''\n    if call == 'action':\n        raise SaltCloudSystemExit(\n            'The avail_images function must be called with '\n            '-f or --function, or with the --list-images option'\n        )\n\n    if not isinstance(kwargs, dict):\n        kwargs = {}\n\n    if 'owner' in kwargs:\n        owner = kwargs['owner']\n    else:\n        provider = get_configured_provider()\n\n        owner = config.get_cloud_config_value(\n            'owner', provider, __opts__, default='amazon'\n        )\n\n    ret = {}\n    params = {'Action': 'DescribeImages',\n              'Owner': owner}\n    images = aws.query(params,\n                       location=get_location(),\n                       provider=get_provider(),\n                       opts=__opts__,\n                       sigver='4')\n\n    for image in images:\n        ret[image['imageId']] = image\n    return ret", "code_tokens": ["def", "avail_images", "(", "kwargs", "=", "None", ",", "call", "=", "None", ")", ":", "if", "call", "==", "'action'", ":", "raise", "SaltCloudSystemExit", "(", "'The avail_images function must be called with '", "'-f or --function, or with the --list-images option'", ")", "if", "not", "isinstance", "(", "kwargs", ",", "dict", ")", ":", "kwargs", "=", "{", "}", "if", "'owner'", "in", "kwargs", ":", "owner", "=", "kwargs", "[", "'owner'", "]", "else", ":", "provider", "=", "get_configured_provider", "(", ")", "owner", "=", "config", ".", "get_cloud_config_value", "(", "'owner'", ",", "provider", ",", "__opts__", ",", "default", "=", "'amazon'", ")", "ret", "=", "{", "}", "params", "=", "{", "'Action'", ":", "'DescribeImages'", ",", "'Owner'", ":", "owner", "}", "images", "=", "aws", ".", "query", "(", "params", ",", "location", "=", "get_location", "(", ")", ",", "provider", "=", "get_provider", "(", ")", ",", "opts", "=", "__opts__", ",", "sigver", "=", "'4'", ")", "for", "image", "in", "images", ":", "ret", "[", "image", "[", "'imageId'", "]", "]", "=", "image", "return", "ret"], "docstring": "Return a dict of all available VM images on the cloud provider.", "docstring_tokens": ["Return", "a", "dict", "of", "all", "available", "VM", "images", "on", "the", "cloud", "provider", "."], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/cloud/clouds/ec2.py#L942-L975", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/cloud/clouds/ec2.py", "func_name": "ssh_interface", "original_string": "def ssh_interface(vm_):\n    '''\n    Return the ssh_interface type to connect to. Either 'public_ips' (default)\n    or 'private_ips'.\n    '''\n    ret = config.get_cloud_config_value(\n        'ssh_interface', vm_, __opts__, default='public_ips',\n        search_global=False\n    )\n    if ret not in ('public_ips', 'private_ips'):\n        log.warning(\n            'Invalid ssh_interface: %s. '\n            'Allowed options are (\"public_ips\", \"private_ips\"). '\n            'Defaulting to \"public_ips\".', ret\n        )\n        ret = 'public_ips'\n    return ret", "language": "python", "code": "def ssh_interface(vm_):\n    '''\n    Return the ssh_interface type to connect to. Either 'public_ips' (default)\n    or 'private_ips'.\n    '''\n    ret = config.get_cloud_config_value(\n        'ssh_interface', vm_, __opts__, default='public_ips',\n        search_global=False\n    )\n    if ret not in ('public_ips', 'private_ips'):\n        log.warning(\n            'Invalid ssh_interface: %s. '\n            'Allowed options are (\"public_ips\", \"private_ips\"). '\n            'Defaulting to \"public_ips\".', ret\n        )\n        ret = 'public_ips'\n    return ret", "code_tokens": ["def", "ssh_interface", "(", "vm_", ")", ":", "ret", "=", "config", ".", "get_cloud_config_value", "(", "'ssh_interface'", ",", "vm_", ",", "__opts__", ",", "default", "=", "'public_ips'", ",", "search_global", "=", "False", ")", "if", "ret", "not", "in", "(", "'public_ips'", ",", "'private_ips'", ")", ":", "log", ".", "warning", "(", "'Invalid ssh_interface: %s. '", "'Allowed options are (\"public_ips\", \"private_ips\"). '", "'Defaulting to \"public_ips\".'", ",", "ret", ")", "ret", "=", "'public_ips'", "return", "ret"], "docstring": "Return the ssh_interface type to connect to. Either 'public_ips' (default)\n    or 'private_ips'.", "docstring_tokens": ["Return", "the", "ssh_interface", "type", "to", "connect", "to", ".", "Either", "public_ips", "(", "default", ")", "or", "private_ips", "."], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/cloud/clouds/ec2.py#L1034-L1050", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/cloud/clouds/ec2.py", "func_name": "get_ssh_gateway_config", "original_string": "def get_ssh_gateway_config(vm_):\n    '''\n    Return the ssh_gateway configuration.\n    '''\n    ssh_gateway = config.get_cloud_config_value(\n        'ssh_gateway', vm_, __opts__, default=None,\n        search_global=False\n    )\n\n    # Check to see if a SSH Gateway will be used.\n    if not isinstance(ssh_gateway, six.string_types):\n        return None\n\n    # Create dictionary of configuration items\n\n    # ssh_gateway\n    ssh_gateway_config = {'ssh_gateway': ssh_gateway}\n\n    # ssh_gateway_port\n    ssh_gateway_config['ssh_gateway_port'] = config.get_cloud_config_value(\n        'ssh_gateway_port', vm_, __opts__, default=None,\n        search_global=False\n    )\n\n    # ssh_gateway_username\n    ssh_gateway_config['ssh_gateway_user'] = config.get_cloud_config_value(\n        'ssh_gateway_username', vm_, __opts__, default=None,\n        search_global=False\n    )\n\n    # ssh_gateway_private_key\n    ssh_gateway_config['ssh_gateway_key'] = config.get_cloud_config_value(\n        'ssh_gateway_private_key', vm_, __opts__, default=None,\n        search_global=False\n    )\n\n    # ssh_gateway_password\n    ssh_gateway_config['ssh_gateway_password'] = config.get_cloud_config_value(\n        'ssh_gateway_password', vm_, __opts__, default=None,\n        search_global=False\n    )\n\n    # ssh_gateway_command\n    ssh_gateway_config['ssh_gateway_command'] = config.get_cloud_config_value(\n        'ssh_gateway_command', vm_, __opts__, default=None,\n        search_global=False\n    )\n\n    # Check if private key exists\n    key_filename = ssh_gateway_config['ssh_gateway_key']\n    if key_filename is not None and not os.path.isfile(key_filename):\n        raise SaltCloudConfigError(\n            'The defined ssh_gateway_private_key \\'{0}\\' does not exist'\n            .format(key_filename)\n        )\n    elif (\n        key_filename is None and\n        not ssh_gateway_config['ssh_gateway_password']\n    ):\n        raise SaltCloudConfigError(\n            'No authentication method. Please define: '\n            ' ssh_gateway_password or ssh_gateway_private_key'\n        )\n\n    return ssh_gateway_config", "language": "python", "code": "def get_ssh_gateway_config(vm_):\n    '''\n    Return the ssh_gateway configuration.\n    '''\n    ssh_gateway = config.get_cloud_config_value(\n        'ssh_gateway', vm_, __opts__, default=None,\n        search_global=False\n    )\n\n    # Check to see if a SSH Gateway will be used.\n    if not isinstance(ssh_gateway, six.string_types):\n        return None\n\n    # Create dictionary of configuration items\n\n    # ssh_gateway\n    ssh_gateway_config = {'ssh_gateway': ssh_gateway}\n\n    # ssh_gateway_port\n    ssh_gateway_config['ssh_gateway_port'] = config.get_cloud_config_value(\n        'ssh_gateway_port', vm_, __opts__, default=None,\n        search_global=False\n    )\n\n    # ssh_gateway_username\n    ssh_gateway_config['ssh_gateway_user'] = config.get_cloud_config_value(\n        'ssh_gateway_username', vm_, __opts__, default=None,\n        search_global=False\n    )\n\n    # ssh_gateway_private_key\n    ssh_gateway_config['ssh_gateway_key'] = config.get_cloud_config_value(\n        'ssh_gateway_private_key', vm_, __opts__, default=None,\n        search_global=False\n    )\n\n    # ssh_gateway_password\n    ssh_gateway_config['ssh_gateway_password'] = config.get_cloud_config_value(\n        'ssh_gateway_password', vm_, __opts__, default=None,\n        search_global=False\n    )\n\n    # ssh_gateway_command\n    ssh_gateway_config['ssh_gateway_command'] = config.get_cloud_config_value(\n        'ssh_gateway_command', vm_, __opts__, default=None,\n        search_global=False\n    )\n\n    # Check if private key exists\n    key_filename = ssh_gateway_config['ssh_gateway_key']\n    if key_filename is not None and not os.path.isfile(key_filename):\n        raise SaltCloudConfigError(\n            'The defined ssh_gateway_private_key \\'{0}\\' does not exist'\n            .format(key_filename)\n        )\n    elif (\n        key_filename is None and\n        not ssh_gateway_config['ssh_gateway_password']\n    ):\n        raise SaltCloudConfigError(\n            'No authentication method. Please define: '\n            ' ssh_gateway_password or ssh_gateway_private_key'\n        )\n\n    return ssh_gateway_config", "code_tokens": ["def", "get_ssh_gateway_config", "(", "vm_", ")", ":", "ssh_gateway", "=", "config", ".", "get_cloud_config_value", "(", "'ssh_gateway'", ",", "vm_", ",", "__opts__", ",", "default", "=", "None", ",", "search_global", "=", "False", ")", "# Check to see if a SSH Gateway will be used.", "if", "not", "isinstance", "(", "ssh_gateway", ",", "six", ".", "string_types", ")", ":", "return", "None", "# Create dictionary of configuration items", "# ssh_gateway", "ssh_gateway_config", "=", "{", "'ssh_gateway'", ":", "ssh_gateway", "}", "# ssh_gateway_port", "ssh_gateway_config", "[", "'ssh_gateway_port'", "]", "=", "config", ".", "get_cloud_config_value", "(", "'ssh_gateway_port'", ",", "vm_", ",", "__opts__", ",", "default", "=", "None", ",", "search_global", "=", "False", ")", "# ssh_gateway_username", "ssh_gateway_config", "[", "'ssh_gateway_user'", "]", "=", "config", ".", "get_cloud_config_value", "(", "'ssh_gateway_username'", ",", "vm_", ",", "__opts__", ",", "default", "=", "None", ",", "search_global", "=", "False", ")", "# ssh_gateway_private_key", "ssh_gateway_config", "[", "'ssh_gateway_key'", "]", "=", "config", ".", "get_cloud_config_value", "(", "'ssh_gateway_private_key'", ",", "vm_", ",", "__opts__", ",", "default", "=", "None", ",", "search_global", "=", "False", ")", "# ssh_gateway_password", "ssh_gateway_config", "[", "'ssh_gateway_password'", "]", "=", "config", ".", "get_cloud_config_value", "(", "'ssh_gateway_password'", ",", "vm_", ",", "__opts__", ",", "default", "=", "None", ",", "search_global", "=", "False", ")", "# ssh_gateway_command", "ssh_gateway_config", "[", "'ssh_gateway_command'", "]", "=", "config", ".", "get_cloud_config_value", "(", "'ssh_gateway_command'", ",", "vm_", ",", "__opts__", ",", "default", "=", "None", ",", "search_global", "=", "False", ")", "# Check if private key exists", "key_filename", "=", "ssh_gateway_config", "[", "'ssh_gateway_key'", "]", "if", "key_filename", "is", "not", "None", "and", "not", "os", ".", "path", ".", "isfile", "(", "key_filename", ")", ":", "raise", "SaltCloudConfigError", "(", "'The defined ssh_gateway_private_key \\'{0}\\' does not exist'", ".", "format", "(", "key_filename", ")", ")", "elif", "(", "key_filename", "is", "None", "and", "not", "ssh_gateway_config", "[", "'ssh_gateway_password'", "]", ")", ":", "raise", "SaltCloudConfigError", "(", "'No authentication method. Please define: '", "' ssh_gateway_password or ssh_gateway_private_key'", ")", "return", "ssh_gateway_config"], "docstring": "Return the ssh_gateway configuration.", "docstring_tokens": ["Return", "the", "ssh_gateway", "configuration", "."], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/cloud/clouds/ec2.py#L1053-L1117", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/cloud/clouds/ec2.py", "func_name": "avail_locations", "original_string": "def avail_locations(call=None):\n    '''\n    List all available locations\n    '''\n    if call == 'action':\n        raise SaltCloudSystemExit(\n            'The avail_locations function must be called with '\n            '-f or --function, or with the --list-locations option'\n        )\n\n    ret = {}\n\n    params = {'Action': 'DescribeRegions'}\n    result = aws.query(params,\n                       location=get_location(),\n                       provider=get_provider(),\n                       opts=__opts__,\n                       sigver='4')\n\n    for region in result:\n        ret[region['regionName']] = {\n            'name': region['regionName'],\n            'endpoint': region['regionEndpoint'],\n        }\n\n    return ret", "language": "python", "code": "def avail_locations(call=None):\n    '''\n    List all available locations\n    '''\n    if call == 'action':\n        raise SaltCloudSystemExit(\n            'The avail_locations function must be called with '\n            '-f or --function, or with the --list-locations option'\n        )\n\n    ret = {}\n\n    params = {'Action': 'DescribeRegions'}\n    result = aws.query(params,\n                       location=get_location(),\n                       provider=get_provider(),\n                       opts=__opts__,\n                       sigver='4')\n\n    for region in result:\n        ret[region['regionName']] = {\n            'name': region['regionName'],\n            'endpoint': region['regionEndpoint'],\n        }\n\n    return ret", "code_tokens": ["def", "avail_locations", "(", "call", "=", "None", ")", ":", "if", "call", "==", "'action'", ":", "raise", "SaltCloudSystemExit", "(", "'The avail_locations function must be called with '", "'-f or --function, or with the --list-locations option'", ")", "ret", "=", "{", "}", "params", "=", "{", "'Action'", ":", "'DescribeRegions'", "}", "result", "=", "aws", ".", "query", "(", "params", ",", "location", "=", "get_location", "(", ")", ",", "provider", "=", "get_provider", "(", ")", ",", "opts", "=", "__opts__", ",", "sigver", "=", "'4'", ")", "for", "region", "in", "result", ":", "ret", "[", "region", "[", "'regionName'", "]", "]", "=", "{", "'name'", ":", "region", "[", "'regionName'", "]", ",", "'endpoint'", ":", "region", "[", "'regionEndpoint'", "]", ",", "}", "return", "ret"], "docstring": "List all available locations", "docstring_tokens": ["List", "all", "available", "locations"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/cloud/clouds/ec2.py#L1139-L1164", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/cloud/clouds/ec2.py", "func_name": "get_availability_zone", "original_string": "def get_availability_zone(vm_):\n    '''\n    Return the availability zone to use\n    '''\n    avz = config.get_cloud_config_value(\n        'availability_zone', vm_, __opts__, search_global=False\n    )\n\n    if avz is None:\n        return None\n\n    zones = _list_availability_zones(vm_)\n\n    # Validate user-specified AZ\n    if avz not in zones:\n        raise SaltCloudException(\n            'The specified availability zone isn\\'t valid in this region: '\n            '{0}\\n'.format(\n                avz\n            )\n        )\n\n    # check specified AZ is available\n    elif zones[avz] != 'available':\n        raise SaltCloudException(\n            'The specified availability zone isn\\'t currently available: '\n            '{0}\\n'.format(\n                avz\n            )\n        )\n\n    return avz", "language": "python", "code": "def get_availability_zone(vm_):\n    '''\n    Return the availability zone to use\n    '''\n    avz = config.get_cloud_config_value(\n        'availability_zone', vm_, __opts__, search_global=False\n    )\n\n    if avz is None:\n        return None\n\n    zones = _list_availability_zones(vm_)\n\n    # Validate user-specified AZ\n    if avz not in zones:\n        raise SaltCloudException(\n            'The specified availability zone isn\\'t valid in this region: '\n            '{0}\\n'.format(\n                avz\n            )\n        )\n\n    # check specified AZ is available\n    elif zones[avz] != 'available':\n        raise SaltCloudException(\n            'The specified availability zone isn\\'t currently available: '\n            '{0}\\n'.format(\n                avz\n            )\n        )\n\n    return avz", "code_tokens": ["def", "get_availability_zone", "(", "vm_", ")", ":", "avz", "=", "config", ".", "get_cloud_config_value", "(", "'availability_zone'", ",", "vm_", ",", "__opts__", ",", "search_global", "=", "False", ")", "if", "avz", "is", "None", ":", "return", "None", "zones", "=", "_list_availability_zones", "(", "vm_", ")", "# Validate user-specified AZ", "if", "avz", "not", "in", "zones", ":", "raise", "SaltCloudException", "(", "'The specified availability zone isn\\'t valid in this region: '", "'{0}\\n'", ".", "format", "(", "avz", ")", ")", "# check specified AZ is available", "elif", "zones", "[", "avz", "]", "!=", "'available'", ":", "raise", "SaltCloudException", "(", "'The specified availability zone isn\\'t currently available: '", "'{0}\\n'", ".", "format", "(", "avz", ")", ")", "return", "avz"], "docstring": "Return the availability zone to use", "docstring_tokens": ["Return", "the", "availability", "zone", "to", "use"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/cloud/clouds/ec2.py#L1167-L1198", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/cloud/clouds/ec2.py", "func_name": "get_imageid", "original_string": "def get_imageid(vm_):\n    '''\n    Returns the ImageId to use\n    '''\n    image = config.get_cloud_config_value(\n        'image', vm_, __opts__, search_global=False\n    )\n    if image.startswith('ami-'):\n        return image\n    # a poor man's cache\n    if not hasattr(get_imageid, 'images'):\n        get_imageid.images = {}\n    elif image in get_imageid.images:\n        return get_imageid.images[image]\n    params = {'Action': 'DescribeImages',\n              'Filter.0.Name': 'name',\n              'Filter.0.Value.0': image}\n    # Query AWS, sort by 'creationDate' and get the last imageId\n    _t = lambda x: datetime.datetime.strptime(x['creationDate'], '%Y-%m-%dT%H:%M:%S.%fZ')\n    image_id = sorted(aws.query(params, location=get_location(),\n                                 provider=get_provider(), opts=__opts__, sigver='4'),\n                      lambda i, j: salt.utils.compat.cmp(_t(i), _t(j))\n                      )[-1]['imageId']\n    get_imageid.images[image] = image_id\n    return image_id", "language": "python", "code": "def get_imageid(vm_):\n    '''\n    Returns the ImageId to use\n    '''\n    image = config.get_cloud_config_value(\n        'image', vm_, __opts__, search_global=False\n    )\n    if image.startswith('ami-'):\n        return image\n    # a poor man's cache\n    if not hasattr(get_imageid, 'images'):\n        get_imageid.images = {}\n    elif image in get_imageid.images:\n        return get_imageid.images[image]\n    params = {'Action': 'DescribeImages',\n              'Filter.0.Name': 'name',\n              'Filter.0.Value.0': image}\n    # Query AWS, sort by 'creationDate' and get the last imageId\n    _t = lambda x: datetime.datetime.strptime(x['creationDate'], '%Y-%m-%dT%H:%M:%S.%fZ')\n    image_id = sorted(aws.query(params, location=get_location(),\n                                 provider=get_provider(), opts=__opts__, sigver='4'),\n                      lambda i, j: salt.utils.compat.cmp(_t(i), _t(j))\n                      )[-1]['imageId']\n    get_imageid.images[image] = image_id\n    return image_id", "code_tokens": ["def", "get_imageid", "(", "vm_", ")", ":", "image", "=", "config", ".", "get_cloud_config_value", "(", "'image'", ",", "vm_", ",", "__opts__", ",", "search_global", "=", "False", ")", "if", "image", ".", "startswith", "(", "'ami-'", ")", ":", "return", "image", "# a poor man's cache", "if", "not", "hasattr", "(", "get_imageid", ",", "'images'", ")", ":", "get_imageid", ".", "images", "=", "{", "}", "elif", "image", "in", "get_imageid", ".", "images", ":", "return", "get_imageid", ".", "images", "[", "image", "]", "params", "=", "{", "'Action'", ":", "'DescribeImages'", ",", "'Filter.0.Name'", ":", "'name'", ",", "'Filter.0.Value.0'", ":", "image", "}", "# Query AWS, sort by 'creationDate' and get the last imageId", "_t", "=", "lambda", "x", ":", "datetime", ".", "datetime", ".", "strptime", "(", "x", "[", "'creationDate'", "]", ",", "'%Y-%m-%dT%H:%M:%S.%fZ'", ")", "image_id", "=", "sorted", "(", "aws", ".", "query", "(", "params", ",", "location", "=", "get_location", "(", ")", ",", "provider", "=", "get_provider", "(", ")", ",", "opts", "=", "__opts__", ",", "sigver", "=", "'4'", ")", ",", "lambda", "i", ",", "j", ":", "salt", ".", "utils", ".", "compat", ".", "cmp", "(", "_t", "(", "i", ")", ",", "_t", "(", "j", ")", ")", ")", "[", "-", "1", "]", "[", "'imageId'", "]", "get_imageid", ".", "images", "[", "image", "]", "=", "image_id", "return", "image_id"], "docstring": "Returns the ImageId to use", "docstring_tokens": ["Returns", "the", "ImageId", "to", "use"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/cloud/clouds/ec2.py#L1212-L1236", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/cloud/clouds/ec2.py", "func_name": "_get_subnetname_id", "original_string": "def _get_subnetname_id(subnetname):\n    '''\n    Returns the SubnetId of a SubnetName to use\n    '''\n    params = {'Action': 'DescribeSubnets'}\n    for subnet in aws.query(params, location=get_location(),\n               provider=get_provider(), opts=__opts__, sigver='4'):\n        tags = subnet.get('tagSet', {}).get('item', {})\n        if not isinstance(tags, list):\n            tags = [tags]\n        for tag in tags:\n            if tag['key'] == 'Name' and tag['value'] == subnetname:\n                log.debug(\n                    'AWS Subnet ID of %s is %s',\n                    subnetname, subnet['subnetId']\n                )\n                return subnet['subnetId']\n    return None", "language": "python", "code": "def _get_subnetname_id(subnetname):\n    '''\n    Returns the SubnetId of a SubnetName to use\n    '''\n    params = {'Action': 'DescribeSubnets'}\n    for subnet in aws.query(params, location=get_location(),\n               provider=get_provider(), opts=__opts__, sigver='4'):\n        tags = subnet.get('tagSet', {}).get('item', {})\n        if not isinstance(tags, list):\n            tags = [tags]\n        for tag in tags:\n            if tag['key'] == 'Name' and tag['value'] == subnetname:\n                log.debug(\n                    'AWS Subnet ID of %s is %s',\n                    subnetname, subnet['subnetId']\n                )\n                return subnet['subnetId']\n    return None", "code_tokens": ["def", "_get_subnetname_id", "(", "subnetname", ")", ":", "params", "=", "{", "'Action'", ":", "'DescribeSubnets'", "}", "for", "subnet", "in", "aws", ".", "query", "(", "params", ",", "location", "=", "get_location", "(", ")", ",", "provider", "=", "get_provider", "(", ")", ",", "opts", "=", "__opts__", ",", "sigver", "=", "'4'", ")", ":", "tags", "=", "subnet", ".", "get", "(", "'tagSet'", ",", "{", "}", ")", ".", "get", "(", "'item'", ",", "{", "}", ")", "if", "not", "isinstance", "(", "tags", ",", "list", ")", ":", "tags", "=", "[", "tags", "]", "for", "tag", "in", "tags", ":", "if", "tag", "[", "'key'", "]", "==", "'Name'", "and", "tag", "[", "'value'", "]", "==", "subnetname", ":", "log", ".", "debug", "(", "'AWS Subnet ID of %s is %s'", ",", "subnetname", ",", "subnet", "[", "'subnetId'", "]", ")", "return", "subnet", "[", "'subnetId'", "]", "return", "None"], "docstring": "Returns the SubnetId of a SubnetName to use", "docstring_tokens": ["Returns", "the", "SubnetId", "of", "a", "SubnetName", "to", "use"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/cloud/clouds/ec2.py#L1239-L1256", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/cloud/clouds/ec2.py", "func_name": "get_subnetid", "original_string": "def get_subnetid(vm_):\n    '''\n    Returns the SubnetId to use\n    '''\n    subnetid = config.get_cloud_config_value(\n        'subnetid', vm_, __opts__, search_global=False\n    )\n    if subnetid:\n        return subnetid\n\n    subnetname = config.get_cloud_config_value(\n        'subnetname', vm_, __opts__, search_global=False\n    )\n    if subnetname:\n        return _get_subnetname_id(subnetname)\n    return None", "language": "python", "code": "def get_subnetid(vm_):\n    '''\n    Returns the SubnetId to use\n    '''\n    subnetid = config.get_cloud_config_value(\n        'subnetid', vm_, __opts__, search_global=False\n    )\n    if subnetid:\n        return subnetid\n\n    subnetname = config.get_cloud_config_value(\n        'subnetname', vm_, __opts__, search_global=False\n    )\n    if subnetname:\n        return _get_subnetname_id(subnetname)\n    return None", "code_tokens": ["def", "get_subnetid", "(", "vm_", ")", ":", "subnetid", "=", "config", ".", "get_cloud_config_value", "(", "'subnetid'", ",", "vm_", ",", "__opts__", ",", "search_global", "=", "False", ")", "if", "subnetid", ":", "return", "subnetid", "subnetname", "=", "config", ".", "get_cloud_config_value", "(", "'subnetname'", ",", "vm_", ",", "__opts__", ",", "search_global", "=", "False", ")", "if", "subnetname", ":", "return", "_get_subnetname_id", "(", "subnetname", ")", "return", "None"], "docstring": "Returns the SubnetId to use", "docstring_tokens": ["Returns", "the", "SubnetId", "to", "use"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/cloud/clouds/ec2.py#L1259-L1274", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/cloud/clouds/ec2.py", "func_name": "_get_securitygroupname_id", "original_string": "def _get_securitygroupname_id(securitygroupname_list):\n    '''\n    Returns the SecurityGroupId of a SecurityGroupName to use\n    '''\n    securitygroupid_set = set()\n    if not isinstance(securitygroupname_list, list):\n        securitygroupname_list = [securitygroupname_list]\n    params = {'Action': 'DescribeSecurityGroups'}\n    for sg in aws.query(params, location=get_location(),\n                        provider=get_provider(), opts=__opts__, sigver='4'):\n        if sg['groupName'] in securitygroupname_list:\n            log.debug(\n                'AWS SecurityGroup ID of %s is %s',\n                sg['groupName'], sg['groupId']\n            )\n            securitygroupid_set.add(sg['groupId'])\n    return list(securitygroupid_set)", "language": "python", "code": "def _get_securitygroupname_id(securitygroupname_list):\n    '''\n    Returns the SecurityGroupId of a SecurityGroupName to use\n    '''\n    securitygroupid_set = set()\n    if not isinstance(securitygroupname_list, list):\n        securitygroupname_list = [securitygroupname_list]\n    params = {'Action': 'DescribeSecurityGroups'}\n    for sg in aws.query(params, location=get_location(),\n                        provider=get_provider(), opts=__opts__, sigver='4'):\n        if sg['groupName'] in securitygroupname_list:\n            log.debug(\n                'AWS SecurityGroup ID of %s is %s',\n                sg['groupName'], sg['groupId']\n            )\n            securitygroupid_set.add(sg['groupId'])\n    return list(securitygroupid_set)", "code_tokens": ["def", "_get_securitygroupname_id", "(", "securitygroupname_list", ")", ":", "securitygroupid_set", "=", "set", "(", ")", "if", "not", "isinstance", "(", "securitygroupname_list", ",", "list", ")", ":", "securitygroupname_list", "=", "[", "securitygroupname_list", "]", "params", "=", "{", "'Action'", ":", "'DescribeSecurityGroups'", "}", "for", "sg", "in", "aws", ".", "query", "(", "params", ",", "location", "=", "get_location", "(", ")", ",", "provider", "=", "get_provider", "(", ")", ",", "opts", "=", "__opts__", ",", "sigver", "=", "'4'", ")", ":", "if", "sg", "[", "'groupName'", "]", "in", "securitygroupname_list", ":", "log", ".", "debug", "(", "'AWS SecurityGroup ID of %s is %s'", ",", "sg", "[", "'groupName'", "]", ",", "sg", "[", "'groupId'", "]", ")", "securitygroupid_set", ".", "add", "(", "sg", "[", "'groupId'", "]", ")", "return", "list", "(", "securitygroupid_set", ")"], "docstring": "Returns the SecurityGroupId of a SecurityGroupName to use", "docstring_tokens": ["Returns", "the", "SecurityGroupId", "of", "a", "SecurityGroupName", "to", "use"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/cloud/clouds/ec2.py#L1277-L1293", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/cloud/clouds/ec2.py", "func_name": "securitygroupid", "original_string": "def securitygroupid(vm_):\n    '''\n    Returns the SecurityGroupId\n    '''\n    securitygroupid_set = set()\n    securitygroupid_list = config.get_cloud_config_value(\n        'securitygroupid',\n        vm_,\n        __opts__,\n        search_global=False\n    )\n    # If the list is None, then the set will remain empty\n    # If the list is already a set then calling 'set' on it is a no-op\n    # If the list is a string, then calling 'set' generates a one-element set\n    # If the list is anything else, stacktrace\n    if securitygroupid_list:\n        securitygroupid_set = securitygroupid_set.union(set(securitygroupid_list))\n\n    securitygroupname_list = config.get_cloud_config_value(\n        'securitygroupname', vm_, __opts__, search_global=False\n    )\n    if securitygroupname_list:\n        if not isinstance(securitygroupname_list, list):\n            securitygroupname_list = [securitygroupname_list]\n        params = {'Action': 'DescribeSecurityGroups'}\n        for sg in aws.query(params, location=get_location(),\n                            provider=get_provider(), opts=__opts__, sigver='4'):\n            if sg['groupName'] in securitygroupname_list:\n                log.debug(\n                    'AWS SecurityGroup ID of %s is %s',\n                    sg['groupName'], sg['groupId']\n                )\n                securitygroupid_set.add(sg['groupId'])\n    return list(securitygroupid_set)", "language": "python", "code": "def securitygroupid(vm_):\n    '''\n    Returns the SecurityGroupId\n    '''\n    securitygroupid_set = set()\n    securitygroupid_list = config.get_cloud_config_value(\n        'securitygroupid',\n        vm_,\n        __opts__,\n        search_global=False\n    )\n    # If the list is None, then the set will remain empty\n    # If the list is already a set then calling 'set' on it is a no-op\n    # If the list is a string, then calling 'set' generates a one-element set\n    # If the list is anything else, stacktrace\n    if securitygroupid_list:\n        securitygroupid_set = securitygroupid_set.union(set(securitygroupid_list))\n\n    securitygroupname_list = config.get_cloud_config_value(\n        'securitygroupname', vm_, __opts__, search_global=False\n    )\n    if securitygroupname_list:\n        if not isinstance(securitygroupname_list, list):\n            securitygroupname_list = [securitygroupname_list]\n        params = {'Action': 'DescribeSecurityGroups'}\n        for sg in aws.query(params, location=get_location(),\n                            provider=get_provider(), opts=__opts__, sigver='4'):\n            if sg['groupName'] in securitygroupname_list:\n                log.debug(\n                    'AWS SecurityGroup ID of %s is %s',\n                    sg['groupName'], sg['groupId']\n                )\n                securitygroupid_set.add(sg['groupId'])\n    return list(securitygroupid_set)", "code_tokens": ["def", "securitygroupid", "(", "vm_", ")", ":", "securitygroupid_set", "=", "set", "(", ")", "securitygroupid_list", "=", "config", ".", "get_cloud_config_value", "(", "'securitygroupid'", ",", "vm_", ",", "__opts__", ",", "search_global", "=", "False", ")", "# If the list is None, then the set will remain empty", "# If the list is already a set then calling 'set' on it is a no-op", "# If the list is a string, then calling 'set' generates a one-element set", "# If the list is anything else, stacktrace", "if", "securitygroupid_list", ":", "securitygroupid_set", "=", "securitygroupid_set", ".", "union", "(", "set", "(", "securitygroupid_list", ")", ")", "securitygroupname_list", "=", "config", ".", "get_cloud_config_value", "(", "'securitygroupname'", ",", "vm_", ",", "__opts__", ",", "search_global", "=", "False", ")", "if", "securitygroupname_list", ":", "if", "not", "isinstance", "(", "securitygroupname_list", ",", "list", ")", ":", "securitygroupname_list", "=", "[", "securitygroupname_list", "]", "params", "=", "{", "'Action'", ":", "'DescribeSecurityGroups'", "}", "for", "sg", "in", "aws", ".", "query", "(", "params", ",", "location", "=", "get_location", "(", ")", ",", "provider", "=", "get_provider", "(", ")", ",", "opts", "=", "__opts__", ",", "sigver", "=", "'4'", ")", ":", "if", "sg", "[", "'groupName'", "]", "in", "securitygroupname_list", ":", "log", ".", "debug", "(", "'AWS SecurityGroup ID of %s is %s'", ",", "sg", "[", "'groupName'", "]", ",", "sg", "[", "'groupId'", "]", ")", "securitygroupid_set", ".", "add", "(", "sg", "[", "'groupId'", "]", ")", "return", "list", "(", "securitygroupid_set", ")"], "docstring": "Returns the SecurityGroupId", "docstring_tokens": ["Returns", "the", "SecurityGroupId"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/cloud/clouds/ec2.py#L1296-L1329", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/cloud/clouds/ec2.py", "func_name": "get_provider", "original_string": "def get_provider(vm_=None):\n    '''\n    Extract the provider name from vm\n    '''\n    if vm_ is None:\n        provider = __active_provider_name__ or 'ec2'\n    else:\n        provider = vm_.get('provider', 'ec2')\n\n    if ':' in provider:\n        prov_comps = provider.split(':')\n        provider = prov_comps[0]\n    return provider", "language": "python", "code": "def get_provider(vm_=None):\n    '''\n    Extract the provider name from vm\n    '''\n    if vm_ is None:\n        provider = __active_provider_name__ or 'ec2'\n    else:\n        provider = vm_.get('provider', 'ec2')\n\n    if ':' in provider:\n        prov_comps = provider.split(':')\n        provider = prov_comps[0]\n    return provider", "code_tokens": ["def", "get_provider", "(", "vm_", "=", "None", ")", ":", "if", "vm_", "is", "None", ":", "provider", "=", "__active_provider_name__", "or", "'ec2'", "else", ":", "provider", "=", "vm_", ".", "get", "(", "'provider'", ",", "'ec2'", ")", "if", "':'", "in", "provider", ":", "prov_comps", "=", "provider", ".", "split", "(", "':'", ")", "provider", "=", "prov_comps", "[", "0", "]", "return", "provider"], "docstring": "Extract the provider name from vm", "docstring_tokens": ["Extract", "the", "provider", "name", "from", "vm"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/cloud/clouds/ec2.py#L1350-L1362", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/cloud/clouds/ec2.py", "func_name": "_list_availability_zones", "original_string": "def _list_availability_zones(vm_=None):\n    '''\n    List all availability zones in the current region\n    '''\n    ret = {}\n\n    params = {'Action': 'DescribeAvailabilityZones',\n              'Filter.0.Name': 'region-name',\n              'Filter.0.Value.0': get_location(vm_)}\n    result = aws.query(params,\n                       location=get_location(vm_),\n                       provider=get_provider(),\n                       opts=__opts__,\n                       sigver='4')\n\n    for zone in result:\n        ret[zone['zoneName']] = zone['zoneState']\n\n    return ret", "language": "python", "code": "def _list_availability_zones(vm_=None):\n    '''\n    List all availability zones in the current region\n    '''\n    ret = {}\n\n    params = {'Action': 'DescribeAvailabilityZones',\n              'Filter.0.Name': 'region-name',\n              'Filter.0.Value.0': get_location(vm_)}\n    result = aws.query(params,\n                       location=get_location(vm_),\n                       provider=get_provider(),\n                       opts=__opts__,\n                       sigver='4')\n\n    for zone in result:\n        ret[zone['zoneName']] = zone['zoneState']\n\n    return ret", "code_tokens": ["def", "_list_availability_zones", "(", "vm_", "=", "None", ")", ":", "ret", "=", "{", "}", "params", "=", "{", "'Action'", ":", "'DescribeAvailabilityZones'", ",", "'Filter.0.Name'", ":", "'region-name'", ",", "'Filter.0.Value.0'", ":", "get_location", "(", "vm_", ")", "}", "result", "=", "aws", ".", "query", "(", "params", ",", "location", "=", "get_location", "(", "vm_", ")", ",", "provider", "=", "get_provider", "(", ")", ",", "opts", "=", "__opts__", ",", "sigver", "=", "'4'", ")", "for", "zone", "in", "result", ":", "ret", "[", "zone", "[", "'zoneName'", "]", "]", "=", "zone", "[", "'zoneState'", "]", "return", "ret"], "docstring": "List all availability zones in the current region", "docstring_tokens": ["List", "all", "availability", "zones", "in", "the", "current", "region"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/cloud/clouds/ec2.py#L1365-L1383", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/cloud/clouds/ec2.py", "func_name": "_request_eip", "original_string": "def _request_eip(interface, vm_):\n    '''\n    Request and return Elastic IP\n    '''\n    params = {'Action': 'AllocateAddress'}\n    params['Domain'] = interface.setdefault('domain', 'vpc')\n    eips = aws.query(params,\n                     return_root=True,\n                     location=get_location(vm_),\n                     provider=get_provider(),\n                     opts=__opts__,\n                     sigver='4')\n    for eip in eips:\n        if 'allocationId' in eip:\n            return eip['allocationId']\n    return None", "language": "python", "code": "def _request_eip(interface, vm_):\n    '''\n    Request and return Elastic IP\n    '''\n    params = {'Action': 'AllocateAddress'}\n    params['Domain'] = interface.setdefault('domain', 'vpc')\n    eips = aws.query(params,\n                     return_root=True,\n                     location=get_location(vm_),\n                     provider=get_provider(),\n                     opts=__opts__,\n                     sigver='4')\n    for eip in eips:\n        if 'allocationId' in eip:\n            return eip['allocationId']\n    return None", "code_tokens": ["def", "_request_eip", "(", "interface", ",", "vm_", ")", ":", "params", "=", "{", "'Action'", ":", "'AllocateAddress'", "}", "params", "[", "'Domain'", "]", "=", "interface", ".", "setdefault", "(", "'domain'", ",", "'vpc'", ")", "eips", "=", "aws", ".", "query", "(", "params", ",", "return_root", "=", "True", ",", "location", "=", "get_location", "(", "vm_", ")", ",", "provider", "=", "get_provider", "(", ")", ",", "opts", "=", "__opts__", ",", "sigver", "=", "'4'", ")", "for", "eip", "in", "eips", ":", "if", "'allocationId'", "in", "eip", ":", "return", "eip", "[", "'allocationId'", "]", "return", "None"], "docstring": "Request and return Elastic IP", "docstring_tokens": ["Request", "and", "return", "Elastic", "IP"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/cloud/clouds/ec2.py#L1400-L1415", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/cloud/clouds/ec2.py", "func_name": "_create_eni_if_necessary", "original_string": "def _create_eni_if_necessary(interface, vm_):\n    '''\n    Create an Elastic Interface if necessary and return a Network Interface Specification\n    '''\n    if 'NetworkInterfaceId' in interface and interface['NetworkInterfaceId'] is not None:\n        return {'DeviceIndex': interface['DeviceIndex'],\n                'NetworkInterfaceId': interface['NetworkInterfaceId']}\n\n    params = {'Action': 'DescribeSubnets'}\n    subnet_query = aws.query(params,\n                             return_root=True,\n                             location=get_location(vm_),\n                             provider=get_provider(),\n                             opts=__opts__,\n                             sigver='4')\n\n    if 'SecurityGroupId' not in interface and 'securitygroupname' in interface:\n        interface['SecurityGroupId'] = _get_securitygroupname_id(interface['securitygroupname'])\n    if 'SubnetId' not in interface and 'subnetname' in interface:\n        interface['SubnetId'] = _get_subnetname_id(interface['subnetname'])\n\n    subnet_id = _get_subnet_id_for_interface(subnet_query, interface)\n    if not subnet_id:\n        raise SaltCloudConfigError(\n            'No such subnet <{0}>'.format(interface.get('SubnetId'))\n        )\n    params = {'SubnetId': subnet_id}\n\n    for k in 'Description', 'PrivateIpAddress', 'SecondaryPrivateIpAddressCount':\n        if k in interface:\n            params[k] = interface[k]\n\n    for k in 'PrivateIpAddresses', 'SecurityGroupId':\n        if k in interface:\n            params.update(_param_from_config(k, interface[k]))\n\n    if 'AssociatePublicIpAddress' in interface:\n        # Associating a public address in a VPC only works when the interface is not\n        # created beforehand, but as a part of the machine creation request.\n        for k in ('DeviceIndex', 'AssociatePublicIpAddress', 'NetworkInterfaceId'):\n            if k in interface:\n                params[k] = interface[k]\n        params['DeleteOnTermination'] = interface.get('delete_interface_on_terminate', True)\n        return params\n\n    params['Action'] = 'CreateNetworkInterface'\n\n    result = aws.query(params,\n                       return_root=True,\n                       location=get_location(vm_),\n                       provider=get_provider(),\n                       opts=__opts__,\n                       sigver='4')\n\n    eni_desc = result[1]\n    if not eni_desc or not eni_desc.get('networkInterfaceId'):\n        raise SaltCloudException('Failed to create interface: {0}'.format(result))\n\n    eni_id = eni_desc.get('networkInterfaceId')\n    log.debug(\n        'Created network interface %s inst %s',\n        eni_id, interface['DeviceIndex']\n    )\n\n    associate_public_ip = interface.get('AssociatePublicIpAddress', False)\n    if isinstance(associate_public_ip, six.string_types):\n        # Assume id of EIP as value\n        _associate_eip_with_interface(eni_id, associate_public_ip, vm_=vm_)\n\n    if interface.get('associate_eip'):\n        _associate_eip_with_interface(eni_id, interface.get('associate_eip'), vm_=vm_)\n    elif interface.get('allocate_new_eip'):\n        _new_eip = _request_eip(interface, vm_)\n        _associate_eip_with_interface(eni_id, _new_eip, vm_=vm_)\n    elif interface.get('allocate_new_eips'):\n        addr_list = _list_interface_private_addrs(eni_desc)\n        eip_list = []\n        for idx, addr in enumerate(addr_list):\n            eip_list.append(_request_eip(interface, vm_))\n        for idx, addr in enumerate(addr_list):\n            _associate_eip_with_interface(eni_id, eip_list[idx], addr, vm_=vm_)\n\n    if 'Name' in interface:\n        tag_params = {'Action': 'CreateTags',\n                      'ResourceId.0': eni_id,\n                      'Tag.0.Key': 'Name',\n                      'Tag.0.Value': interface['Name']}\n        tag_response = aws.query(tag_params,\n                                 return_root=True,\n                                 location=get_location(vm_),\n                                 provider=get_provider(),\n                                 opts=__opts__,\n                                 sigver='4')\n        if 'error' in tag_response:\n            log.error('Failed to set name of interface {0}')\n\n    return {'DeviceIndex': interface['DeviceIndex'],\n            'NetworkInterfaceId': eni_id}", "language": "python", "code": "def _create_eni_if_necessary(interface, vm_):\n    '''\n    Create an Elastic Interface if necessary and return a Network Interface Specification\n    '''\n    if 'NetworkInterfaceId' in interface and interface['NetworkInterfaceId'] is not None:\n        return {'DeviceIndex': interface['DeviceIndex'],\n                'NetworkInterfaceId': interface['NetworkInterfaceId']}\n\n    params = {'Action': 'DescribeSubnets'}\n    subnet_query = aws.query(params,\n                             return_root=True,\n                             location=get_location(vm_),\n                             provider=get_provider(),\n                             opts=__opts__,\n                             sigver='4')\n\n    if 'SecurityGroupId' not in interface and 'securitygroupname' in interface:\n        interface['SecurityGroupId'] = _get_securitygroupname_id(interface['securitygroupname'])\n    if 'SubnetId' not in interface and 'subnetname' in interface:\n        interface['SubnetId'] = _get_subnetname_id(interface['subnetname'])\n\n    subnet_id = _get_subnet_id_for_interface(subnet_query, interface)\n    if not subnet_id:\n        raise SaltCloudConfigError(\n            'No such subnet <{0}>'.format(interface.get('SubnetId'))\n        )\n    params = {'SubnetId': subnet_id}\n\n    for k in 'Description', 'PrivateIpAddress', 'SecondaryPrivateIpAddressCount':\n        if k in interface:\n            params[k] = interface[k]\n\n    for k in 'PrivateIpAddresses', 'SecurityGroupId':\n        if k in interface:\n            params.update(_param_from_config(k, interface[k]))\n\n    if 'AssociatePublicIpAddress' in interface:\n        # Associating a public address in a VPC only works when the interface is not\n        # created beforehand, but as a part of the machine creation request.\n        for k in ('DeviceIndex', 'AssociatePublicIpAddress', 'NetworkInterfaceId'):\n            if k in interface:\n                params[k] = interface[k]\n        params['DeleteOnTermination'] = interface.get('delete_interface_on_terminate', True)\n        return params\n\n    params['Action'] = 'CreateNetworkInterface'\n\n    result = aws.query(params,\n                       return_root=True,\n                       location=get_location(vm_),\n                       provider=get_provider(),\n                       opts=__opts__,\n                       sigver='4')\n\n    eni_desc = result[1]\n    if not eni_desc or not eni_desc.get('networkInterfaceId'):\n        raise SaltCloudException('Failed to create interface: {0}'.format(result))\n\n    eni_id = eni_desc.get('networkInterfaceId')\n    log.debug(\n        'Created network interface %s inst %s',\n        eni_id, interface['DeviceIndex']\n    )\n\n    associate_public_ip = interface.get('AssociatePublicIpAddress', False)\n    if isinstance(associate_public_ip, six.string_types):\n        # Assume id of EIP as value\n        _associate_eip_with_interface(eni_id, associate_public_ip, vm_=vm_)\n\n    if interface.get('associate_eip'):\n        _associate_eip_with_interface(eni_id, interface.get('associate_eip'), vm_=vm_)\n    elif interface.get('allocate_new_eip'):\n        _new_eip = _request_eip(interface, vm_)\n        _associate_eip_with_interface(eni_id, _new_eip, vm_=vm_)\n    elif interface.get('allocate_new_eips'):\n        addr_list = _list_interface_private_addrs(eni_desc)\n        eip_list = []\n        for idx, addr in enumerate(addr_list):\n            eip_list.append(_request_eip(interface, vm_))\n        for idx, addr in enumerate(addr_list):\n            _associate_eip_with_interface(eni_id, eip_list[idx], addr, vm_=vm_)\n\n    if 'Name' in interface:\n        tag_params = {'Action': 'CreateTags',\n                      'ResourceId.0': eni_id,\n                      'Tag.0.Key': 'Name',\n                      'Tag.0.Value': interface['Name']}\n        tag_response = aws.query(tag_params,\n                                 return_root=True,\n                                 location=get_location(vm_),\n                                 provider=get_provider(),\n                                 opts=__opts__,\n                                 sigver='4')\n        if 'error' in tag_response:\n            log.error('Failed to set name of interface {0}')\n\n    return {'DeviceIndex': interface['DeviceIndex'],\n            'NetworkInterfaceId': eni_id}", "code_tokens": ["def", "_create_eni_if_necessary", "(", "interface", ",", "vm_", ")", ":", "if", "'NetworkInterfaceId'", "in", "interface", "and", "interface", "[", "'NetworkInterfaceId'", "]", "is", "not", "None", ":", "return", "{", "'DeviceIndex'", ":", "interface", "[", "'DeviceIndex'", "]", ",", "'NetworkInterfaceId'", ":", "interface", "[", "'NetworkInterfaceId'", "]", "}", "params", "=", "{", "'Action'", ":", "'DescribeSubnets'", "}", "subnet_query", "=", "aws", ".", "query", "(", "params", ",", "return_root", "=", "True", ",", "location", "=", "get_location", "(", "vm_", ")", ",", "provider", "=", "get_provider", "(", ")", ",", "opts", "=", "__opts__", ",", "sigver", "=", "'4'", ")", "if", "'SecurityGroupId'", "not", "in", "interface", "and", "'securitygroupname'", "in", "interface", ":", "interface", "[", "'SecurityGroupId'", "]", "=", "_get_securitygroupname_id", "(", "interface", "[", "'securitygroupname'", "]", ")", "if", "'SubnetId'", "not", "in", "interface", "and", "'subnetname'", "in", "interface", ":", "interface", "[", "'SubnetId'", "]", "=", "_get_subnetname_id", "(", "interface", "[", "'subnetname'", "]", ")", "subnet_id", "=", "_get_subnet_id_for_interface", "(", "subnet_query", ",", "interface", ")", "if", "not", "subnet_id", ":", "raise", "SaltCloudConfigError", "(", "'No such subnet <{0}>'", ".", "format", "(", "interface", ".", "get", "(", "'SubnetId'", ")", ")", ")", "params", "=", "{", "'SubnetId'", ":", "subnet_id", "}", "for", "k", "in", "'Description'", ",", "'PrivateIpAddress'", ",", "'SecondaryPrivateIpAddressCount'", ":", "if", "k", "in", "interface", ":", "params", "[", "k", "]", "=", "interface", "[", "k", "]", "for", "k", "in", "'PrivateIpAddresses'", ",", "'SecurityGroupId'", ":", "if", "k", "in", "interface", ":", "params", ".", "update", "(", "_param_from_config", "(", "k", ",", "interface", "[", "k", "]", ")", ")", "if", "'AssociatePublicIpAddress'", "in", "interface", ":", "# Associating a public address in a VPC only works when the interface is not", "# created beforehand, but as a part of the machine creation request.", "for", "k", "in", "(", "'DeviceIndex'", ",", "'AssociatePublicIpAddress'", ",", "'NetworkInterfaceId'", ")", ":", "if", "k", "in", "interface", ":", "params", "[", "k", "]", "=", "interface", "[", "k", "]", "params", "[", "'DeleteOnTermination'", "]", "=", "interface", ".", "get", "(", "'delete_interface_on_terminate'", ",", "True", ")", "return", "params", "params", "[", "'Action'", "]", "=", "'CreateNetworkInterface'", "result", "=", "aws", ".", "query", "(", "params", ",", "return_root", "=", "True", ",", "location", "=", "get_location", "(", "vm_", ")", ",", "provider", "=", "get_provider", "(", ")", ",", "opts", "=", "__opts__", ",", "sigver", "=", "'4'", ")", "eni_desc", "=", "result", "[", "1", "]", "if", "not", "eni_desc", "or", "not", "eni_desc", ".", "get", "(", "'networkInterfaceId'", ")", ":", "raise", "SaltCloudException", "(", "'Failed to create interface: {0}'", ".", "format", "(", "result", ")", ")", "eni_id", "=", "eni_desc", ".", "get", "(", "'networkInterfaceId'", ")", "log", ".", "debug", "(", "'Created network interface %s inst %s'", ",", "eni_id", ",", "interface", "[", "'DeviceIndex'", "]", ")", "associate_public_ip", "=", "interface", ".", "get", "(", "'AssociatePublicIpAddress'", ",", "False", ")", "if", "isinstance", "(", "associate_public_ip", ",", "six", ".", "string_types", ")", ":", "# Assume id of EIP as value", "_associate_eip_with_interface", "(", "eni_id", ",", "associate_public_ip", ",", "vm_", "=", "vm_", ")", "if", "interface", ".", "get", "(", "'associate_eip'", ")", ":", "_associate_eip_with_interface", "(", "eni_id", ",", "interface", ".", "get", "(", "'associate_eip'", ")", ",", "vm_", "=", "vm_", ")", "elif", "interface", ".", "get", "(", "'allocate_new_eip'", ")", ":", "_new_eip", "=", "_request_eip", "(", "interface", ",", "vm_", ")", "_associate_eip_with_interface", "(", "eni_id", ",", "_new_eip", ",", "vm_", "=", "vm_", ")", "elif", "interface", ".", "get", "(", "'allocate_new_eips'", ")", ":", "addr_list", "=", "_list_interface_private_addrs", "(", "eni_desc", ")", "eip_list", "=", "[", "]", "for", "idx", ",", "addr", "in", "enumerate", "(", "addr_list", ")", ":", "eip_list", ".", "append", "(", "_request_eip", "(", "interface", ",", "vm_", ")", ")", "for", "idx", ",", "addr", "in", "enumerate", "(", "addr_list", ")", ":", "_associate_eip_with_interface", "(", "eni_id", ",", "eip_list", "[", "idx", "]", ",", "addr", ",", "vm_", "=", "vm_", ")", "if", "'Name'", "in", "interface", ":", "tag_params", "=", "{", "'Action'", ":", "'CreateTags'", ",", "'ResourceId.0'", ":", "eni_id", ",", "'Tag.0.Key'", ":", "'Name'", ",", "'Tag.0.Value'", ":", "interface", "[", "'Name'", "]", "}", "tag_response", "=", "aws", ".", "query", "(", "tag_params", ",", "return_root", "=", "True", ",", "location", "=", "get_location", "(", "vm_", ")", ",", "provider", "=", "get_provider", "(", ")", ",", "opts", "=", "__opts__", ",", "sigver", "=", "'4'", ")", "if", "'error'", "in", "tag_response", ":", "log", ".", "error", "(", "'Failed to set name of interface {0}'", ")", "return", "{", "'DeviceIndex'", ":", "interface", "[", "'DeviceIndex'", "]", ",", "'NetworkInterfaceId'", ":", "eni_id", "}"], "docstring": "Create an Elastic Interface if necessary and return a Network Interface Specification", "docstring_tokens": ["Create", "an", "Elastic", "Interface", "if", "necessary", "and", "return", "a", "Network", "Interface", "Specification"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/cloud/clouds/ec2.py#L1418-L1515", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/cloud/clouds/ec2.py", "func_name": "_list_interface_private_addrs", "original_string": "def _list_interface_private_addrs(eni_desc):\n    '''\n    Returns a list of all of the private IP addresses attached to a\n    network interface. The 'primary' address will be listed first.\n    '''\n    primary = eni_desc.get('privateIpAddress')\n    if not primary:\n        return None\n\n    addresses = [primary]\n\n    lst = eni_desc.get('privateIpAddressesSet', {}).get('item', [])\n    if not isinstance(lst, list):\n        return addresses\n\n    for entry in lst:\n        if entry.get('primary') == 'true':\n            continue\n        if entry.get('privateIpAddress'):\n            addresses.append(entry.get('privateIpAddress'))\n\n    return addresses", "language": "python", "code": "def _list_interface_private_addrs(eni_desc):\n    '''\n    Returns a list of all of the private IP addresses attached to a\n    network interface. The 'primary' address will be listed first.\n    '''\n    primary = eni_desc.get('privateIpAddress')\n    if not primary:\n        return None\n\n    addresses = [primary]\n\n    lst = eni_desc.get('privateIpAddressesSet', {}).get('item', [])\n    if not isinstance(lst, list):\n        return addresses\n\n    for entry in lst:\n        if entry.get('primary') == 'true':\n            continue\n        if entry.get('privateIpAddress'):\n            addresses.append(entry.get('privateIpAddress'))\n\n    return addresses", "code_tokens": ["def", "_list_interface_private_addrs", "(", "eni_desc", ")", ":", "primary", "=", "eni_desc", ".", "get", "(", "'privateIpAddress'", ")", "if", "not", "primary", ":", "return", "None", "addresses", "=", "[", "primary", "]", "lst", "=", "eni_desc", ".", "get", "(", "'privateIpAddressesSet'", ",", "{", "}", ")", ".", "get", "(", "'item'", ",", "[", "]", ")", "if", "not", "isinstance", "(", "lst", ",", "list", ")", ":", "return", "addresses", "for", "entry", "in", "lst", ":", "if", "entry", ".", "get", "(", "'primary'", ")", "==", "'true'", ":", "continue", "if", "entry", ".", "get", "(", "'privateIpAddress'", ")", ":", "addresses", ".", "append", "(", "entry", ".", "get", "(", "'privateIpAddress'", ")", ")", "return", "addresses"], "docstring": "Returns a list of all of the private IP addresses attached to a\n    network interface. The 'primary' address will be listed first.", "docstring_tokens": ["Returns", "a", "list", "of", "all", "of", "the", "private", "IP", "addresses", "attached", "to", "a", "network", "interface", ".", "The", "primary", "address", "will", "be", "listed", "first", "."], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/cloud/clouds/ec2.py#L1543-L1564", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/cloud/clouds/ec2.py", "func_name": "_modify_eni_properties", "original_string": "def _modify_eni_properties(eni_id, properties=None, vm_=None):\n    '''\n    Change properties of the interface\n    with id eni_id to the values in properties dict\n    '''\n    if not isinstance(properties, dict):\n        raise SaltCloudException(\n            'ENI properties must be a dictionary'\n        )\n\n    params = {'Action': 'ModifyNetworkInterfaceAttribute',\n              'NetworkInterfaceId': eni_id}\n    for k, v in six.iteritems(properties):\n        params[k] = v\n\n    result = aws.query(params,\n                       return_root=True,\n                       location=get_location(vm_),\n                       provider=get_provider(),\n                       opts=__opts__,\n                       sigver='4')\n\n    if isinstance(result, dict) and result.get('error'):\n        raise SaltCloudException(\n            'Could not change interface <{0}> attributes <\\'{1}\\'>'.format(\n                eni_id, properties\n            )\n        )\n    else:\n        return result", "language": "python", "code": "def _modify_eni_properties(eni_id, properties=None, vm_=None):\n    '''\n    Change properties of the interface\n    with id eni_id to the values in properties dict\n    '''\n    if not isinstance(properties, dict):\n        raise SaltCloudException(\n            'ENI properties must be a dictionary'\n        )\n\n    params = {'Action': 'ModifyNetworkInterfaceAttribute',\n              'NetworkInterfaceId': eni_id}\n    for k, v in six.iteritems(properties):\n        params[k] = v\n\n    result = aws.query(params,\n                       return_root=True,\n                       location=get_location(vm_),\n                       provider=get_provider(),\n                       opts=__opts__,\n                       sigver='4')\n\n    if isinstance(result, dict) and result.get('error'):\n        raise SaltCloudException(\n            'Could not change interface <{0}> attributes <\\'{1}\\'>'.format(\n                eni_id, properties\n            )\n        )\n    else:\n        return result", "code_tokens": ["def", "_modify_eni_properties", "(", "eni_id", ",", "properties", "=", "None", ",", "vm_", "=", "None", ")", ":", "if", "not", "isinstance", "(", "properties", ",", "dict", ")", ":", "raise", "SaltCloudException", "(", "'ENI properties must be a dictionary'", ")", "params", "=", "{", "'Action'", ":", "'ModifyNetworkInterfaceAttribute'", ",", "'NetworkInterfaceId'", ":", "eni_id", "}", "for", "k", ",", "v", "in", "six", ".", "iteritems", "(", "properties", ")", ":", "params", "[", "k", "]", "=", "v", "result", "=", "aws", ".", "query", "(", "params", ",", "return_root", "=", "True", ",", "location", "=", "get_location", "(", "vm_", ")", ",", "provider", "=", "get_provider", "(", ")", ",", "opts", "=", "__opts__", ",", "sigver", "=", "'4'", ")", "if", "isinstance", "(", "result", ",", "dict", ")", "and", "result", ".", "get", "(", "'error'", ")", ":", "raise", "SaltCloudException", "(", "'Could not change interface <{0}> attributes <\\'{1}\\'>'", ".", "format", "(", "eni_id", ",", "properties", ")", ")", "else", ":", "return", "result"], "docstring": "Change properties of the interface\n    with id eni_id to the values in properties dict", "docstring_tokens": ["Change", "properties", "of", "the", "interface", "with", "id", "eni_id", "to", "the", "values", "in", "properties", "dict"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/cloud/clouds/ec2.py#L1567-L1596", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/cloud/clouds/ec2.py", "func_name": "_associate_eip_with_interface", "original_string": "def _associate_eip_with_interface(eni_id, eip_id, private_ip=None, vm_=None):\n    '''\n    Accept the id of a network interface, and the id of an elastic ip\n    address, and associate the two of them, such that traffic sent to the\n    elastic ip address will be forwarded (NATted) to this network interface.\n\n    Optionally specify the private (10.x.x.x) IP address that traffic should\n    be NATted to - useful if you have multiple IP addresses assigned to an\n    interface.\n    '''\n    params = {'Action': 'AssociateAddress',\n              'NetworkInterfaceId': eni_id,\n              'AllocationId': eip_id}\n\n    if private_ip:\n        params['PrivateIpAddress'] = private_ip\n\n    result = aws.query(params,\n                       return_root=True,\n                       location=get_location(vm_),\n                       provider=get_provider(),\n                       opts=__opts__,\n                       sigver='4')\n\n    if not result[2].get('associationId'):\n        raise SaltCloudException(\n            'Could not associate elastic ip address '\n            '<{0}> with network interface <{1}>'.format(\n                eip_id, eni_id\n            )\n        )\n\n    log.debug(\n        'Associated ElasticIP address %s with interface %s',\n        eip_id, eni_id\n    )\n\n    return result[2].get('associationId')", "language": "python", "code": "def _associate_eip_with_interface(eni_id, eip_id, private_ip=None, vm_=None):\n    '''\n    Accept the id of a network interface, and the id of an elastic ip\n    address, and associate the two of them, such that traffic sent to the\n    elastic ip address will be forwarded (NATted) to this network interface.\n\n    Optionally specify the private (10.x.x.x) IP address that traffic should\n    be NATted to - useful if you have multiple IP addresses assigned to an\n    interface.\n    '''\n    params = {'Action': 'AssociateAddress',\n              'NetworkInterfaceId': eni_id,\n              'AllocationId': eip_id}\n\n    if private_ip:\n        params['PrivateIpAddress'] = private_ip\n\n    result = aws.query(params,\n                       return_root=True,\n                       location=get_location(vm_),\n                       provider=get_provider(),\n                       opts=__opts__,\n                       sigver='4')\n\n    if not result[2].get('associationId'):\n        raise SaltCloudException(\n            'Could not associate elastic ip address '\n            '<{0}> with network interface <{1}>'.format(\n                eip_id, eni_id\n            )\n        )\n\n    log.debug(\n        'Associated ElasticIP address %s with interface %s',\n        eip_id, eni_id\n    )\n\n    return result[2].get('associationId')", "code_tokens": ["def", "_associate_eip_with_interface", "(", "eni_id", ",", "eip_id", ",", "private_ip", "=", "None", ",", "vm_", "=", "None", ")", ":", "params", "=", "{", "'Action'", ":", "'AssociateAddress'", ",", "'NetworkInterfaceId'", ":", "eni_id", ",", "'AllocationId'", ":", "eip_id", "}", "if", "private_ip", ":", "params", "[", "'PrivateIpAddress'", "]", "=", "private_ip", "result", "=", "aws", ".", "query", "(", "params", ",", "return_root", "=", "True", ",", "location", "=", "get_location", "(", "vm_", ")", ",", "provider", "=", "get_provider", "(", ")", ",", "opts", "=", "__opts__", ",", "sigver", "=", "'4'", ")", "if", "not", "result", "[", "2", "]", ".", "get", "(", "'associationId'", ")", ":", "raise", "SaltCloudException", "(", "'Could not associate elastic ip address '", "'<{0}> with network interface <{1}>'", ".", "format", "(", "eip_id", ",", "eni_id", ")", ")", "log", ".", "debug", "(", "'Associated ElasticIP address %s with interface %s'", ",", "eip_id", ",", "eni_id", ")", "return", "result", "[", "2", "]", ".", "get", "(", "'associationId'", ")"], "docstring": "Accept the id of a network interface, and the id of an elastic ip\n    address, and associate the two of them, such that traffic sent to the\n    elastic ip address will be forwarded (NATted) to this network interface.\n\n    Optionally specify the private (10.x.x.x) IP address that traffic should\n    be NATted to - useful if you have multiple IP addresses assigned to an\n    interface.", "docstring_tokens": ["Accept", "the", "id", "of", "a", "network", "interface", "and", "the", "id", "of", "an", "elastic", "ip", "address", "and", "associate", "the", "two", "of", "them", "such", "that", "traffic", "sent", "to", "the", "elastic", "ip", "address", "will", "be", "forwarded", "(", "NATted", ")", "to", "this", "network", "interface", "."], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/cloud/clouds/ec2.py#L1599-L1636", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/cloud/clouds/ec2.py", "func_name": "_param_from_config", "original_string": "def _param_from_config(key, data):\n    '''\n    Return EC2 API parameters based on the given config data.\n\n    Examples:\n    1. List of dictionaries\n    >>> data = [\n    ...     {'DeviceIndex': 0, 'SubnetId': 'subid0',\n    ...      'AssociatePublicIpAddress': True},\n    ...     {'DeviceIndex': 1,\n    ...      'SubnetId': 'subid1',\n    ...      'PrivateIpAddress': '192.168.1.128'}\n    ... ]\n    >>> _param_from_config('NetworkInterface', data)\n    ... {'NetworkInterface.0.SubnetId': 'subid0',\n    ...  'NetworkInterface.0.DeviceIndex': 0,\n    ...  'NetworkInterface.1.SubnetId': 'subid1',\n    ...  'NetworkInterface.1.PrivateIpAddress': '192.168.1.128',\n    ...  'NetworkInterface.0.AssociatePublicIpAddress': 'true',\n    ...  'NetworkInterface.1.DeviceIndex': 1}\n\n    2. List of nested dictionaries\n    >>> data = [\n    ...     {'DeviceName': '/dev/sdf',\n    ...      'Ebs': {\n    ...      'SnapshotId': 'dummy0',\n    ...      'VolumeSize': 200,\n    ...      'VolumeType': 'standard'}},\n    ...     {'DeviceName': '/dev/sdg',\n    ...      'Ebs': {\n    ...          'SnapshotId': 'dummy1',\n    ...          'VolumeSize': 100,\n    ...          'VolumeType': 'standard'}}\n    ... ]\n    >>> _param_from_config('BlockDeviceMapping', data)\n    ... {'BlockDeviceMapping.0.Ebs.VolumeType': 'standard',\n    ...  'BlockDeviceMapping.1.Ebs.SnapshotId': 'dummy1',\n    ...  'BlockDeviceMapping.0.Ebs.VolumeSize': 200,\n    ...  'BlockDeviceMapping.0.Ebs.SnapshotId': 'dummy0',\n    ...  'BlockDeviceMapping.1.Ebs.VolumeType': 'standard',\n    ...  'BlockDeviceMapping.1.DeviceName': '/dev/sdg',\n    ...  'BlockDeviceMapping.1.Ebs.VolumeSize': 100,\n    ...  'BlockDeviceMapping.0.DeviceName': '/dev/sdf'}\n\n    3. Dictionary of dictionaries\n    >>> data = { 'Arn': 'dummyarn', 'Name': 'Tester' }\n    >>> _param_from_config('IamInstanceProfile', data)\n    {'IamInstanceProfile.Arn': 'dummyarn', 'IamInstanceProfile.Name': 'Tester'}\n\n    '''\n\n    param = {}\n\n    if isinstance(data, dict):\n        for k, v in six.iteritems(data):\n            param.update(_param_from_config('{0}.{1}'.format(key, k), v))\n\n    elif isinstance(data, list) or isinstance(data, tuple):\n        for idx, conf_item in enumerate(data):\n            prefix = '{0}.{1}'.format(key, idx)\n            param.update(_param_from_config(prefix, conf_item))\n\n    else:\n        if isinstance(data, bool):\n            # convert boolean True/False to 'true'/'false'\n            param.update({key: six.text_type(data).lower()})\n        else:\n            param.update({key: data})\n\n    return param", "language": "python", "code": "def _param_from_config(key, data):\n    '''\n    Return EC2 API parameters based on the given config data.\n\n    Examples:\n    1. List of dictionaries\n    >>> data = [\n    ...     {'DeviceIndex': 0, 'SubnetId': 'subid0',\n    ...      'AssociatePublicIpAddress': True},\n    ...     {'DeviceIndex': 1,\n    ...      'SubnetId': 'subid1',\n    ...      'PrivateIpAddress': '192.168.1.128'}\n    ... ]\n    >>> _param_from_config('NetworkInterface', data)\n    ... {'NetworkInterface.0.SubnetId': 'subid0',\n    ...  'NetworkInterface.0.DeviceIndex': 0,\n    ...  'NetworkInterface.1.SubnetId': 'subid1',\n    ...  'NetworkInterface.1.PrivateIpAddress': '192.168.1.128',\n    ...  'NetworkInterface.0.AssociatePublicIpAddress': 'true',\n    ...  'NetworkInterface.1.DeviceIndex': 1}\n\n    2. List of nested dictionaries\n    >>> data = [\n    ...     {'DeviceName': '/dev/sdf',\n    ...      'Ebs': {\n    ...      'SnapshotId': 'dummy0',\n    ...      'VolumeSize': 200,\n    ...      'VolumeType': 'standard'}},\n    ...     {'DeviceName': '/dev/sdg',\n    ...      'Ebs': {\n    ...          'SnapshotId': 'dummy1',\n    ...          'VolumeSize': 100,\n    ...          'VolumeType': 'standard'}}\n    ... ]\n    >>> _param_from_config('BlockDeviceMapping', data)\n    ... {'BlockDeviceMapping.0.Ebs.VolumeType': 'standard',\n    ...  'BlockDeviceMapping.1.Ebs.SnapshotId': 'dummy1',\n    ...  'BlockDeviceMapping.0.Ebs.VolumeSize': 200,\n    ...  'BlockDeviceMapping.0.Ebs.SnapshotId': 'dummy0',\n    ...  'BlockDeviceMapping.1.Ebs.VolumeType': 'standard',\n    ...  'BlockDeviceMapping.1.DeviceName': '/dev/sdg',\n    ...  'BlockDeviceMapping.1.Ebs.VolumeSize': 100,\n    ...  'BlockDeviceMapping.0.DeviceName': '/dev/sdf'}\n\n    3. Dictionary of dictionaries\n    >>> data = { 'Arn': 'dummyarn', 'Name': 'Tester' }\n    >>> _param_from_config('IamInstanceProfile', data)\n    {'IamInstanceProfile.Arn': 'dummyarn', 'IamInstanceProfile.Name': 'Tester'}\n\n    '''\n\n    param = {}\n\n    if isinstance(data, dict):\n        for k, v in six.iteritems(data):\n            param.update(_param_from_config('{0}.{1}'.format(key, k), v))\n\n    elif isinstance(data, list) or isinstance(data, tuple):\n        for idx, conf_item in enumerate(data):\n            prefix = '{0}.{1}'.format(key, idx)\n            param.update(_param_from_config(prefix, conf_item))\n\n    else:\n        if isinstance(data, bool):\n            # convert boolean True/False to 'true'/'false'\n            param.update({key: six.text_type(data).lower()})\n        else:\n            param.update({key: data})\n\n    return param", "code_tokens": ["def", "_param_from_config", "(", "key", ",", "data", ")", ":", "param", "=", "{", "}", "if", "isinstance", "(", "data", ",", "dict", ")", ":", "for", "k", ",", "v", "in", "six", ".", "iteritems", "(", "data", ")", ":", "param", ".", "update", "(", "_param_from_config", "(", "'{0}.{1}'", ".", "format", "(", "key", ",", "k", ")", ",", "v", ")", ")", "elif", "isinstance", "(", "data", ",", "list", ")", "or", "isinstance", "(", "data", ",", "tuple", ")", ":", "for", "idx", ",", "conf_item", "in", "enumerate", "(", "data", ")", ":", "prefix", "=", "'{0}.{1}'", ".", "format", "(", "key", ",", "idx", ")", "param", ".", "update", "(", "_param_from_config", "(", "prefix", ",", "conf_item", ")", ")", "else", ":", "if", "isinstance", "(", "data", ",", "bool", ")", ":", "# convert boolean True/False to 'true'/'false'", "param", ".", "update", "(", "{", "key", ":", "six", ".", "text_type", "(", "data", ")", ".", "lower", "(", ")", "}", ")", "else", ":", "param", ".", "update", "(", "{", "key", ":", "data", "}", ")", "return", "param"], "docstring": "Return EC2 API parameters based on the given config data.\n\n    Examples:\n    1. List of dictionaries\n    >>> data = [\n    ...     {'DeviceIndex': 0, 'SubnetId': 'subid0',\n    ...      'AssociatePublicIpAddress': True},\n    ...     {'DeviceIndex': 1,\n    ...      'SubnetId': 'subid1',\n    ...      'PrivateIpAddress': '192.168.1.128'}\n    ... ]\n    >>> _param_from_config('NetworkInterface', data)\n    ... {'NetworkInterface.0.SubnetId': 'subid0',\n    ...  'NetworkInterface.0.DeviceIndex': 0,\n    ...  'NetworkInterface.1.SubnetId': 'subid1',\n    ...  'NetworkInterface.1.PrivateIpAddress': '192.168.1.128',\n    ...  'NetworkInterface.0.AssociatePublicIpAddress': 'true',\n    ...  'NetworkInterface.1.DeviceIndex': 1}\n\n    2. List of nested dictionaries\n    >>> data = [\n    ...     {'DeviceName': '/dev/sdf',\n    ...      'Ebs': {\n    ...      'SnapshotId': 'dummy0',\n    ...      'VolumeSize': 200,\n    ...      'VolumeType': 'standard'}},\n    ...     {'DeviceName': '/dev/sdg',\n    ...      'Ebs': {\n    ...          'SnapshotId': 'dummy1',\n    ...          'VolumeSize': 100,\n    ...          'VolumeType': 'standard'}}\n    ... ]\n    >>> _param_from_config('BlockDeviceMapping', data)\n    ... {'BlockDeviceMapping.0.Ebs.VolumeType': 'standard',\n    ...  'BlockDeviceMapping.1.Ebs.SnapshotId': 'dummy1',\n    ...  'BlockDeviceMapping.0.Ebs.VolumeSize': 200,\n    ...  'BlockDeviceMapping.0.Ebs.SnapshotId': 'dummy0',\n    ...  'BlockDeviceMapping.1.Ebs.VolumeType': 'standard',\n    ...  'BlockDeviceMapping.1.DeviceName': '/dev/sdg',\n    ...  'BlockDeviceMapping.1.Ebs.VolumeSize': 100,\n    ...  'BlockDeviceMapping.0.DeviceName': '/dev/sdf'}\n\n    3. Dictionary of dictionaries\n    >>> data = { 'Arn': 'dummyarn', 'Name': 'Tester' }\n    >>> _param_from_config('IamInstanceProfile', data)\n    {'IamInstanceProfile.Arn': 'dummyarn', 'IamInstanceProfile.Name': 'Tester'}", "docstring_tokens": ["Return", "EC2", "API", "parameters", "based", "on", "the", "given", "config", "data", "."], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/cloud/clouds/ec2.py#L1675-L1744", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/cloud/clouds/ec2.py", "func_name": "request_instance", "original_string": "def request_instance(vm_=None, call=None):\n    '''\n    Put together all of the information necessary to request an instance on EC2,\n    and then fire off the request the instance.\n\n    Returns data about the instance\n    '''\n    if call == 'function':\n        # Technically this function may be called other ways too, but it\n        # definitely cannot be called with --function.\n        raise SaltCloudSystemExit(\n            'The request_instance action must be called with -a or --action.'\n        )\n\n    location = vm_.get('location', get_location(vm_))\n\n    # do we launch a regular vm or a spot instance?\n    # see http://goo.gl/hYZ13f for more information on EC2 API\n    spot_config = get_spot_config(vm_)\n    if spot_config is not None:\n        if 'spot_price' not in spot_config:\n            raise SaltCloudSystemExit(\n                'Spot instance config for {0} requires a spot_price '\n                'attribute.'.format(vm_['name'])\n            )\n\n        params = {'Action': 'RequestSpotInstances',\n                  'InstanceCount': '1',\n                  'Type': spot_config['type']\n                  if 'type' in spot_config else 'one-time',\n                  'SpotPrice': spot_config['spot_price']}\n\n        # All of the necessary launch parameters for a VM when using\n        # spot instances are the same except for the prefix below\n        # being tacked on.\n        spot_prefix = 'LaunchSpecification.'\n\n    # regular EC2 instance\n    else:\n        # WARNING! EXPERIMENTAL!\n        # This allows more than one instance to be spun up in a single call.\n        # The first instance will be called by the name provided, but all other\n        # instances will be nameless (or more specifically, they will use the\n        # InstanceId as the name). This interface is expected to change, so\n        # use at your own risk.\n        min_instance = config.get_cloud_config_value(\n            'min_instance', vm_, __opts__, search_global=False, default=1\n        )\n        max_instance = config.get_cloud_config_value(\n            'max_instance', vm_, __opts__, search_global=False, default=1\n        )\n        params = {'Action': 'RunInstances',\n                  'MinCount': min_instance,\n                  'MaxCount': max_instance}\n\n        # Normal instances should have no prefix.\n        spot_prefix = ''\n\n    image_id = get_imageid(vm_)\n    params[spot_prefix + 'ImageId'] = image_id\n\n    userdata = None\n    userdata_file = config.get_cloud_config_value(\n        'userdata_file', vm_, __opts__, search_global=False, default=None\n    )\n    if userdata_file is None:\n        userdata = config.get_cloud_config_value(\n            'userdata', vm_, __opts__, search_global=False, default=None\n        )\n    else:\n        log.trace('userdata_file: %s', userdata_file)\n        if os.path.exists(userdata_file):\n            with salt.utils.files.fopen(userdata_file, 'r') as fh_:\n                userdata = salt.utils.stringutils.to_unicode(fh_.read())\n\n    userdata = salt.utils.cloud.userdata_template(__opts__, vm_, userdata)\n\n    if userdata is not None:\n        try:\n            params[spot_prefix + 'UserData'] = base64.b64encode(\n                salt.utils.stringutils.to_bytes(userdata)\n            )\n        except Exception as exc:\n            log.exception('Failed to encode userdata: %s', exc)\n\n    vm_size = config.get_cloud_config_value(\n        'size', vm_, __opts__, search_global=False\n    )\n    params[spot_prefix + 'InstanceType'] = vm_size\n\n    ex_keyname = keyname(vm_)\n    if ex_keyname:\n        params[spot_prefix + 'KeyName'] = ex_keyname\n\n    ex_securitygroup = securitygroup(vm_)\n    if ex_securitygroup:\n        if not isinstance(ex_securitygroup, list):\n            params[spot_prefix + 'SecurityGroup.1'] = ex_securitygroup\n        else:\n            for counter, sg_ in enumerate(ex_securitygroup):\n                params[spot_prefix + 'SecurityGroup.{0}'.format(counter)] = sg_\n\n    ex_iam_profile = iam_profile(vm_)\n    if ex_iam_profile:\n        try:\n            if ex_iam_profile.startswith('arn:aws:iam:'):\n                params[\n                    spot_prefix + 'IamInstanceProfile.Arn'\n                ] = ex_iam_profile\n            else:\n                params[\n                    spot_prefix + 'IamInstanceProfile.Name'\n                ] = ex_iam_profile\n        except AttributeError:\n            raise SaltCloudConfigError(\n                '\\'iam_profile\\' should be a string value.'\n            )\n\n    az_ = get_availability_zone(vm_)\n    if az_ is not None:\n        params[spot_prefix + 'Placement.AvailabilityZone'] = az_\n\n    tenancy_ = get_tenancy(vm_)\n    if tenancy_ is not None:\n        if spot_config is not None:\n            raise SaltCloudConfigError(\n                'Spot instance config for {0} does not support '\n                'specifying tenancy.'.format(vm_['name'])\n            )\n        params['Placement.Tenancy'] = tenancy_\n\n    subnetid_ = get_subnetid(vm_)\n    if subnetid_ is not None:\n        params[spot_prefix + 'SubnetId'] = subnetid_\n\n    ex_securitygroupid = securitygroupid(vm_)\n    if ex_securitygroupid:\n        if not isinstance(ex_securitygroupid, list):\n            params[spot_prefix + 'SecurityGroupId.1'] = ex_securitygroupid\n        else:\n            for counter, sg_ in enumerate(ex_securitygroupid):\n                params[\n                    spot_prefix + 'SecurityGroupId.{0}'.format(counter)\n                ] = sg_\n\n    placementgroup_ = get_placementgroup(vm_)\n    if placementgroup_ is not None:\n        params[spot_prefix + 'Placement.GroupName'] = placementgroup_\n\n    blockdevicemappings_holder = block_device_mappings(vm_)\n    if blockdevicemappings_holder:\n        for _bd in blockdevicemappings_holder:\n            if 'tag' in _bd:\n                _bd.pop('tag')\n\n    ex_blockdevicemappings = blockdevicemappings_holder\n    if ex_blockdevicemappings:\n        params.update(_param_from_config(spot_prefix + 'BlockDeviceMapping',\n                      ex_blockdevicemappings))\n\n    network_interfaces = config.get_cloud_config_value(\n        'network_interfaces',\n        vm_,\n        __opts__,\n        search_global=False\n    )\n\n    if network_interfaces:\n        eni_devices = []\n        for interface in network_interfaces:\n            log.debug('Create network interface: %s', interface)\n            _new_eni = _create_eni_if_necessary(interface, vm_)\n            eni_devices.append(_new_eni)\n        params.update(_param_from_config(spot_prefix + 'NetworkInterface',\n                                         eni_devices))\n\n    set_ebs_optimized = config.get_cloud_config_value(\n        'ebs_optimized', vm_, __opts__, search_global=False\n    )\n\n    if set_ebs_optimized is not None:\n        if not isinstance(set_ebs_optimized, bool):\n            raise SaltCloudConfigError(\n                '\\'ebs_optimized\\' should be a boolean value.'\n            )\n        params[spot_prefix + 'EbsOptimized'] = set_ebs_optimized\n\n    set_del_root_vol_on_destroy = config.get_cloud_config_value(\n        'del_root_vol_on_destroy', vm_, __opts__, search_global=False\n    )\n\n    set_termination_protection = config.get_cloud_config_value(\n        'termination_protection', vm_, __opts__, search_global=False\n    )\n\n    if set_termination_protection is not None:\n        if not isinstance(set_termination_protection, bool):\n            raise SaltCloudConfigError(\n                '\\'termination_protection\\' should be a boolean value.'\n            )\n        params.update(_param_from_config(spot_prefix + 'DisableApiTermination',\n                                         set_termination_protection))\n\n    if set_del_root_vol_on_destroy and not isinstance(set_del_root_vol_on_destroy, bool):\n        raise SaltCloudConfigError(\n            '\\'del_root_vol_on_destroy\\' should be a boolean value.'\n        )\n\n    vm_['set_del_root_vol_on_destroy'] = set_del_root_vol_on_destroy\n\n    if set_del_root_vol_on_destroy:\n        # first make sure to look up the root device name\n        # as Ubuntu and CentOS (and most likely other OSs)\n        # use different device identifiers\n\n        log.info('Attempting to look up root device name for image id %s on '\n                 'VM %s', image_id, vm_['name'])\n\n        rd_params = {\n            'Action': 'DescribeImages',\n            'ImageId.1': image_id\n        }\n        try:\n            rd_data = aws.query(rd_params,\n                                location=get_location(vm_),\n                                provider=get_provider(),\n                                opts=__opts__,\n                                sigver='4')\n            if 'error' in rd_data:\n                return rd_data['error']\n            log.debug('EC2 Response: \\'%s\\'', rd_data)\n        except Exception as exc:\n            log.error(\n                'Error getting root device name for image id %s for '\n                'VM %s: \\n%s', image_id, vm_['name'], exc,\n                # Show the traceback if the debug logging level is enabled\n                exc_info_on_loglevel=logging.DEBUG\n            )\n            raise\n\n        # make sure we have a response\n        if not rd_data:\n            err_msg = 'There was an error querying EC2 for the root device ' \\\n                      'of image id {0}. Empty response.'.format(image_id)\n            raise SaltCloudSystemExit(err_msg)\n\n        # pull the root device name from the result and use it when\n        # launching the new VM\n        rd_name = None\n        rd_type = None\n        if 'blockDeviceMapping' in rd_data[0]:\n            # Some ami instances do not have a root volume. Ignore such cases\n            if rd_data[0]['blockDeviceMapping'] is not None:\n                item = rd_data[0]['blockDeviceMapping']['item']\n                if isinstance(item, list):\n                    item = item[0]\n                rd_name = item['deviceName']\n                # Grab the volume type\n                rd_type = item['ebs'].get('volumeType', None)\n\n            log.info('Found root device name: %s', rd_name)\n\n        if rd_name is not None:\n            if ex_blockdevicemappings:\n                dev_list = [\n                    dev['DeviceName'] for dev in ex_blockdevicemappings\n                ]\n            else:\n                dev_list = []\n\n            if rd_name in dev_list:\n                # Device already listed, just grab the index\n                dev_index = dev_list.index(rd_name)\n            else:\n                dev_index = len(dev_list)\n                # Add the device name in since it wasn't already there\n                params[\n                    '{0}BlockDeviceMapping.{1}.DeviceName'.format(\n                        spot_prefix, dev_index\n                    )\n                ] = rd_name\n\n            # Set the termination value\n            termination_key = '{0}BlockDeviceMapping.{1}.Ebs.DeleteOnTermination'.format(spot_prefix, dev_index)\n            params[termination_key] = six.text_type(set_del_root_vol_on_destroy).lower()\n\n            # Use default volume type if not specified\n            if ex_blockdevicemappings and dev_index < len(ex_blockdevicemappings) and \\\n                   'Ebs.VolumeType' not in ex_blockdevicemappings[dev_index]:\n                type_key = '{0}BlockDeviceMapping.{1}.Ebs.VolumeType'.format(spot_prefix, dev_index)\n                params[type_key] = rd_type\n\n    set_del_all_vols_on_destroy = config.get_cloud_config_value(\n        'del_all_vols_on_destroy', vm_, __opts__, search_global=False, default=False\n    )\n\n    if set_del_all_vols_on_destroy and not isinstance(set_del_all_vols_on_destroy, bool):\n        raise SaltCloudConfigError(\n            '\\'del_all_vols_on_destroy\\' should be a boolean value.'\n        )\n\n    __utils__['cloud.fire_event'](\n        'event',\n        'requesting instance',\n        'salt/cloud/{0}/requesting'.format(vm_['name']),\n        args={\n            'kwargs': __utils__['cloud.filter_event'](\n                'requesting', params, list(params)\n            ),\n            'location': location,\n        },\n        sock_dir=__opts__['sock_dir'],\n        transport=__opts__['transport']\n    )\n\n    provider = get_provider(vm_)\n\n    try:\n        data = aws.query(params,\n                         'instancesSet',\n                         location=location,\n                         provider=provider,\n                         opts=__opts__,\n                         sigver='4')\n        if 'error' in data:\n            return data['error']\n    except Exception as exc:\n        log.error(\n            'Error creating %s on EC2 when trying to run the initial '\n            'deployment: \\n%s', vm_['name'], exc,\n            # Show the traceback if the debug logging level is enabled\n            exc_info_on_loglevel=logging.DEBUG\n        )\n        raise\n\n    # if we're using spot instances, we need to wait for the spot request\n    # to become active before we continue\n    if spot_config:\n        sir_id = data[0]['spotInstanceRequestId']\n\n        vm_['spotRequestId'] = sir_id\n\n        def __query_spot_instance_request(sir_id, location):\n            params = {'Action': 'DescribeSpotInstanceRequests',\n                      'SpotInstanceRequestId.1': sir_id}\n            data = aws.query(params,\n                             location=location,\n                             provider=provider,\n                             opts=__opts__,\n                             sigver='4')\n            if not data:\n                log.error(\n                    'There was an error while querying EC2. Empty response'\n                )\n                # Trigger a failure in the wait for spot instance method\n                return False\n\n            if isinstance(data, dict) and 'error' in data:\n                log.warning('There was an error in the query. %s', data['error'])\n                # Trigger a failure in the wait for spot instance method\n                return False\n\n            log.debug('Returned query data: %s', data)\n\n            state = data[0].get('state')\n\n            if state == 'active':\n                return data\n\n            if state == 'open':\n                # Still waiting for an active state\n                log.info('Spot instance status: %s', data[0]['status']['message'])\n                return None\n\n            if state in ['cancelled', 'failed', 'closed']:\n                # Request will never be active, fail\n                log.error('Spot instance request resulted in state \\'{0}\\'. '\n                          'Nothing else we can do here.')\n                return False\n\n        __utils__['cloud.fire_event'](\n            'event',\n            'waiting for spot instance',\n            'salt/cloud/{0}/waiting_for_spot'.format(vm_['name']),\n            sock_dir=__opts__['sock_dir'],\n            transport=__opts__['transport']\n        )\n\n        try:\n            data = _wait_for_spot_instance(\n                __query_spot_instance_request,\n                update_args=(sir_id, location),\n                timeout=config.get_cloud_config_value(\n                    'wait_for_spot_timeout', vm_, __opts__, default=10 * 60),\n                interval=config.get_cloud_config_value(\n                    'wait_for_spot_interval', vm_, __opts__, default=30),\n                interval_multiplier=config.get_cloud_config_value(\n                    'wait_for_spot_interval_multiplier',\n                    vm_,\n                    __opts__,\n                    default=1),\n                max_failures=config.get_cloud_config_value(\n                    'wait_for_spot_max_failures',\n                    vm_,\n                    __opts__,\n                    default=10),\n            )\n            log.debug('wait_for_spot_instance data %s', data)\n\n        except (SaltCloudExecutionTimeout, SaltCloudExecutionFailure) as exc:\n            try:\n                # Cancel the existing spot instance request\n                params = {'Action': 'CancelSpotInstanceRequests',\n                          'SpotInstanceRequestId.1': sir_id}\n                data = aws.query(params,\n                                 location=location,\n                                 provider=provider,\n                                 opts=__opts__,\n                                 sigver='4')\n\n                log.debug('Canceled spot instance request %s. Data '\n                          'returned: %s', sir_id, data)\n\n            except SaltCloudSystemExit:\n                pass\n            finally:\n                raise SaltCloudSystemExit(six.text_type(exc))\n\n    return data, vm_", "language": "python", "code": "def request_instance(vm_=None, call=None):\n    '''\n    Put together all of the information necessary to request an instance on EC2,\n    and then fire off the request the instance.\n\n    Returns data about the instance\n    '''\n    if call == 'function':\n        # Technically this function may be called other ways too, but it\n        # definitely cannot be called with --function.\n        raise SaltCloudSystemExit(\n            'The request_instance action must be called with -a or --action.'\n        )\n\n    location = vm_.get('location', get_location(vm_))\n\n    # do we launch a regular vm or a spot instance?\n    # see http://goo.gl/hYZ13f for more information on EC2 API\n    spot_config = get_spot_config(vm_)\n    if spot_config is not None:\n        if 'spot_price' not in spot_config:\n            raise SaltCloudSystemExit(\n                'Spot instance config for {0} requires a spot_price '\n                'attribute.'.format(vm_['name'])\n            )\n\n        params = {'Action': 'RequestSpotInstances',\n                  'InstanceCount': '1',\n                  'Type': spot_config['type']\n                  if 'type' in spot_config else 'one-time',\n                  'SpotPrice': spot_config['spot_price']}\n\n        # All of the necessary launch parameters for a VM when using\n        # spot instances are the same except for the prefix below\n        # being tacked on.\n        spot_prefix = 'LaunchSpecification.'\n\n    # regular EC2 instance\n    else:\n        # WARNING! EXPERIMENTAL!\n        # This allows more than one instance to be spun up in a single call.\n        # The first instance will be called by the name provided, but all other\n        # instances will be nameless (or more specifically, they will use the\n        # InstanceId as the name). This interface is expected to change, so\n        # use at your own risk.\n        min_instance = config.get_cloud_config_value(\n            'min_instance', vm_, __opts__, search_global=False, default=1\n        )\n        max_instance = config.get_cloud_config_value(\n            'max_instance', vm_, __opts__, search_global=False, default=1\n        )\n        params = {'Action': 'RunInstances',\n                  'MinCount': min_instance,\n                  'MaxCount': max_instance}\n\n        # Normal instances should have no prefix.\n        spot_prefix = ''\n\n    image_id = get_imageid(vm_)\n    params[spot_prefix + 'ImageId'] = image_id\n\n    userdata = None\n    userdata_file = config.get_cloud_config_value(\n        'userdata_file', vm_, __opts__, search_global=False, default=None\n    )\n    if userdata_file is None:\n        userdata = config.get_cloud_config_value(\n            'userdata', vm_, __opts__, search_global=False, default=None\n        )\n    else:\n        log.trace('userdata_file: %s', userdata_file)\n        if os.path.exists(userdata_file):\n            with salt.utils.files.fopen(userdata_file, 'r') as fh_:\n                userdata = salt.utils.stringutils.to_unicode(fh_.read())\n\n    userdata = salt.utils.cloud.userdata_template(__opts__, vm_, userdata)\n\n    if userdata is not None:\n        try:\n            params[spot_prefix + 'UserData'] = base64.b64encode(\n                salt.utils.stringutils.to_bytes(userdata)\n            )\n        except Exception as exc:\n            log.exception('Failed to encode userdata: %s', exc)\n\n    vm_size = config.get_cloud_config_value(\n        'size', vm_, __opts__, search_global=False\n    )\n    params[spot_prefix + 'InstanceType'] = vm_size\n\n    ex_keyname = keyname(vm_)\n    if ex_keyname:\n        params[spot_prefix + 'KeyName'] = ex_keyname\n\n    ex_securitygroup = securitygroup(vm_)\n    if ex_securitygroup:\n        if not isinstance(ex_securitygroup, list):\n            params[spot_prefix + 'SecurityGroup.1'] = ex_securitygroup\n        else:\n            for counter, sg_ in enumerate(ex_securitygroup):\n                params[spot_prefix + 'SecurityGroup.{0}'.format(counter)] = sg_\n\n    ex_iam_profile = iam_profile(vm_)\n    if ex_iam_profile:\n        try:\n            if ex_iam_profile.startswith('arn:aws:iam:'):\n                params[\n                    spot_prefix + 'IamInstanceProfile.Arn'\n                ] = ex_iam_profile\n            else:\n                params[\n                    spot_prefix + 'IamInstanceProfile.Name'\n                ] = ex_iam_profile\n        except AttributeError:\n            raise SaltCloudConfigError(\n                '\\'iam_profile\\' should be a string value.'\n            )\n\n    az_ = get_availability_zone(vm_)\n    if az_ is not None:\n        params[spot_prefix + 'Placement.AvailabilityZone'] = az_\n\n    tenancy_ = get_tenancy(vm_)\n    if tenancy_ is not None:\n        if spot_config is not None:\n            raise SaltCloudConfigError(\n                'Spot instance config for {0} does not support '\n                'specifying tenancy.'.format(vm_['name'])\n            )\n        params['Placement.Tenancy'] = tenancy_\n\n    subnetid_ = get_subnetid(vm_)\n    if subnetid_ is not None:\n        params[spot_prefix + 'SubnetId'] = subnetid_\n\n    ex_securitygroupid = securitygroupid(vm_)\n    if ex_securitygroupid:\n        if not isinstance(ex_securitygroupid, list):\n            params[spot_prefix + 'SecurityGroupId.1'] = ex_securitygroupid\n        else:\n            for counter, sg_ in enumerate(ex_securitygroupid):\n                params[\n                    spot_prefix + 'SecurityGroupId.{0}'.format(counter)\n                ] = sg_\n\n    placementgroup_ = get_placementgroup(vm_)\n    if placementgroup_ is not None:\n        params[spot_prefix + 'Placement.GroupName'] = placementgroup_\n\n    blockdevicemappings_holder = block_device_mappings(vm_)\n    if blockdevicemappings_holder:\n        for _bd in blockdevicemappings_holder:\n            if 'tag' in _bd:\n                _bd.pop('tag')\n\n    ex_blockdevicemappings = blockdevicemappings_holder\n    if ex_blockdevicemappings:\n        params.update(_param_from_config(spot_prefix + 'BlockDeviceMapping',\n                      ex_blockdevicemappings))\n\n    network_interfaces = config.get_cloud_config_value(\n        'network_interfaces',\n        vm_,\n        __opts__,\n        search_global=False\n    )\n\n    if network_interfaces:\n        eni_devices = []\n        for interface in network_interfaces:\n            log.debug('Create network interface: %s', interface)\n            _new_eni = _create_eni_if_necessary(interface, vm_)\n            eni_devices.append(_new_eni)\n        params.update(_param_from_config(spot_prefix + 'NetworkInterface',\n                                         eni_devices))\n\n    set_ebs_optimized = config.get_cloud_config_value(\n        'ebs_optimized', vm_, __opts__, search_global=False\n    )\n\n    if set_ebs_optimized is not None:\n        if not isinstance(set_ebs_optimized, bool):\n            raise SaltCloudConfigError(\n                '\\'ebs_optimized\\' should be a boolean value.'\n            )\n        params[spot_prefix + 'EbsOptimized'] = set_ebs_optimized\n\n    set_del_root_vol_on_destroy = config.get_cloud_config_value(\n        'del_root_vol_on_destroy', vm_, __opts__, search_global=False\n    )\n\n    set_termination_protection = config.get_cloud_config_value(\n        'termination_protection', vm_, __opts__, search_global=False\n    )\n\n    if set_termination_protection is not None:\n        if not isinstance(set_termination_protection, bool):\n            raise SaltCloudConfigError(\n                '\\'termination_protection\\' should be a boolean value.'\n            )\n        params.update(_param_from_config(spot_prefix + 'DisableApiTermination',\n                                         set_termination_protection))\n\n    if set_del_root_vol_on_destroy and not isinstance(set_del_root_vol_on_destroy, bool):\n        raise SaltCloudConfigError(\n            '\\'del_root_vol_on_destroy\\' should be a boolean value.'\n        )\n\n    vm_['set_del_root_vol_on_destroy'] = set_del_root_vol_on_destroy\n\n    if set_del_root_vol_on_destroy:\n        # first make sure to look up the root device name\n        # as Ubuntu and CentOS (and most likely other OSs)\n        # use different device identifiers\n\n        log.info('Attempting to look up root device name for image id %s on '\n                 'VM %s', image_id, vm_['name'])\n\n        rd_params = {\n            'Action': 'DescribeImages',\n            'ImageId.1': image_id\n        }\n        try:\n            rd_data = aws.query(rd_params,\n                                location=get_location(vm_),\n                                provider=get_provider(),\n                                opts=__opts__,\n                                sigver='4')\n            if 'error' in rd_data:\n                return rd_data['error']\n            log.debug('EC2 Response: \\'%s\\'', rd_data)\n        except Exception as exc:\n            log.error(\n                'Error getting root device name for image id %s for '\n                'VM %s: \\n%s', image_id, vm_['name'], exc,\n                # Show the traceback if the debug logging level is enabled\n                exc_info_on_loglevel=logging.DEBUG\n            )\n            raise\n\n        # make sure we have a response\n        if not rd_data:\n            err_msg = 'There was an error querying EC2 for the root device ' \\\n                      'of image id {0}. Empty response.'.format(image_id)\n            raise SaltCloudSystemExit(err_msg)\n\n        # pull the root device name from the result and use it when\n        # launching the new VM\n        rd_name = None\n        rd_type = None\n        if 'blockDeviceMapping' in rd_data[0]:\n            # Some ami instances do not have a root volume. Ignore such cases\n            if rd_data[0]['blockDeviceMapping'] is not None:\n                item = rd_data[0]['blockDeviceMapping']['item']\n                if isinstance(item, list):\n                    item = item[0]\n                rd_name = item['deviceName']\n                # Grab the volume type\n                rd_type = item['ebs'].get('volumeType', None)\n\n            log.info('Found root device name: %s', rd_name)\n\n        if rd_name is not None:\n            if ex_blockdevicemappings:\n                dev_list = [\n                    dev['DeviceName'] for dev in ex_blockdevicemappings\n                ]\n            else:\n                dev_list = []\n\n            if rd_name in dev_list:\n                # Device already listed, just grab the index\n                dev_index = dev_list.index(rd_name)\n            else:\n                dev_index = len(dev_list)\n                # Add the device name in since it wasn't already there\n                params[\n                    '{0}BlockDeviceMapping.{1}.DeviceName'.format(\n                        spot_prefix, dev_index\n                    )\n                ] = rd_name\n\n            # Set the termination value\n            termination_key = '{0}BlockDeviceMapping.{1}.Ebs.DeleteOnTermination'.format(spot_prefix, dev_index)\n            params[termination_key] = six.text_type(set_del_root_vol_on_destroy).lower()\n\n            # Use default volume type if not specified\n            if ex_blockdevicemappings and dev_index < len(ex_blockdevicemappings) and \\\n                   'Ebs.VolumeType' not in ex_blockdevicemappings[dev_index]:\n                type_key = '{0}BlockDeviceMapping.{1}.Ebs.VolumeType'.format(spot_prefix, dev_index)\n                params[type_key] = rd_type\n\n    set_del_all_vols_on_destroy = config.get_cloud_config_value(\n        'del_all_vols_on_destroy', vm_, __opts__, search_global=False, default=False\n    )\n\n    if set_del_all_vols_on_destroy and not isinstance(set_del_all_vols_on_destroy, bool):\n        raise SaltCloudConfigError(\n            '\\'del_all_vols_on_destroy\\' should be a boolean value.'\n        )\n\n    __utils__['cloud.fire_event'](\n        'event',\n        'requesting instance',\n        'salt/cloud/{0}/requesting'.format(vm_['name']),\n        args={\n            'kwargs': __utils__['cloud.filter_event'](\n                'requesting', params, list(params)\n            ),\n            'location': location,\n        },\n        sock_dir=__opts__['sock_dir'],\n        transport=__opts__['transport']\n    )\n\n    provider = get_provider(vm_)\n\n    try:\n        data = aws.query(params,\n                         'instancesSet',\n                         location=location,\n                         provider=provider,\n                         opts=__opts__,\n                         sigver='4')\n        if 'error' in data:\n            return data['error']\n    except Exception as exc:\n        log.error(\n            'Error creating %s on EC2 when trying to run the initial '\n            'deployment: \\n%s', vm_['name'], exc,\n            # Show the traceback if the debug logging level is enabled\n            exc_info_on_loglevel=logging.DEBUG\n        )\n        raise\n\n    # if we're using spot instances, we need to wait for the spot request\n    # to become active before we continue\n    if spot_config:\n        sir_id = data[0]['spotInstanceRequestId']\n\n        vm_['spotRequestId'] = sir_id\n\n        def __query_spot_instance_request(sir_id, location):\n            params = {'Action': 'DescribeSpotInstanceRequests',\n                      'SpotInstanceRequestId.1': sir_id}\n            data = aws.query(params,\n                             location=location,\n                             provider=provider,\n                             opts=__opts__,\n                             sigver='4')\n            if not data:\n                log.error(\n                    'There was an error while querying EC2. Empty response'\n                )\n                # Trigger a failure in the wait for spot instance method\n                return False\n\n            if isinstance(data, dict) and 'error' in data:\n                log.warning('There was an error in the query. %s', data['error'])\n                # Trigger a failure in the wait for spot instance method\n                return False\n\n            log.debug('Returned query data: %s', data)\n\n            state = data[0].get('state')\n\n            if state == 'active':\n                return data\n\n            if state == 'open':\n                # Still waiting for an active state\n                log.info('Spot instance status: %s', data[0]['status']['message'])\n                return None\n\n            if state in ['cancelled', 'failed', 'closed']:\n                # Request will never be active, fail\n                log.error('Spot instance request resulted in state \\'{0}\\'. '\n                          'Nothing else we can do here.')\n                return False\n\n        __utils__['cloud.fire_event'](\n            'event',\n            'waiting for spot instance',\n            'salt/cloud/{0}/waiting_for_spot'.format(vm_['name']),\n            sock_dir=__opts__['sock_dir'],\n            transport=__opts__['transport']\n        )\n\n        try:\n            data = _wait_for_spot_instance(\n                __query_spot_instance_request,\n                update_args=(sir_id, location),\n                timeout=config.get_cloud_config_value(\n                    'wait_for_spot_timeout', vm_, __opts__, default=10 * 60),\n                interval=config.get_cloud_config_value(\n                    'wait_for_spot_interval', vm_, __opts__, default=30),\n                interval_multiplier=config.get_cloud_config_value(\n                    'wait_for_spot_interval_multiplier',\n                    vm_,\n                    __opts__,\n                    default=1),\n                max_failures=config.get_cloud_config_value(\n                    'wait_for_spot_max_failures',\n                    vm_,\n                    __opts__,\n                    default=10),\n            )\n            log.debug('wait_for_spot_instance data %s', data)\n\n        except (SaltCloudExecutionTimeout, SaltCloudExecutionFailure) as exc:\n            try:\n                # Cancel the existing spot instance request\n                params = {'Action': 'CancelSpotInstanceRequests',\n                          'SpotInstanceRequestId.1': sir_id}\n                data = aws.query(params,\n                                 location=location,\n                                 provider=provider,\n                                 opts=__opts__,\n                                 sigver='4')\n\n                log.debug('Canceled spot instance request %s. Data '\n                          'returned: %s', sir_id, data)\n\n            except SaltCloudSystemExit:\n                pass\n            finally:\n                raise SaltCloudSystemExit(six.text_type(exc))\n\n    return data, vm_", "code_tokens": ["def", "request_instance", "(", "vm_", "=", "None", ",", "call", "=", "None", ")", ":", "if", "call", "==", "'function'", ":", "# Technically this function may be called other ways too, but it", "# definitely cannot be called with --function.", "raise", "SaltCloudSystemExit", "(", "'The request_instance action must be called with -a or --action.'", ")", "location", "=", "vm_", ".", "get", "(", "'location'", ",", "get_location", "(", "vm_", ")", ")", "# do we launch a regular vm or a spot instance?", "# see http://goo.gl/hYZ13f for more information on EC2 API", "spot_config", "=", "get_spot_config", "(", "vm_", ")", "if", "spot_config", "is", "not", "None", ":", "if", "'spot_price'", "not", "in", "spot_config", ":", "raise", "SaltCloudSystemExit", "(", "'Spot instance config for {0} requires a spot_price '", "'attribute.'", ".", "format", "(", "vm_", "[", "'name'", "]", ")", ")", "params", "=", "{", "'Action'", ":", "'RequestSpotInstances'", ",", "'InstanceCount'", ":", "'1'", ",", "'Type'", ":", "spot_config", "[", "'type'", "]", "if", "'type'", "in", "spot_config", "else", "'one-time'", ",", "'SpotPrice'", ":", "spot_config", "[", "'spot_price'", "]", "}", "# All of the necessary launch parameters for a VM when using", "# spot instances are the same except for the prefix below", "# being tacked on.", "spot_prefix", "=", "'LaunchSpecification.'", "# regular EC2 instance", "else", ":", "# WARNING! EXPERIMENTAL!", "# This allows more than one instance to be spun up in a single call.", "# The first instance will be called by the name provided, but all other", "# instances will be nameless (or more specifically, they will use the", "# InstanceId as the name). This interface is expected to change, so", "# use at your own risk.", "min_instance", "=", "config", ".", "get_cloud_config_value", "(", "'min_instance'", ",", "vm_", ",", "__opts__", ",", "search_global", "=", "False", ",", "default", "=", "1", ")", "max_instance", "=", "config", ".", "get_cloud_config_value", "(", "'max_instance'", ",", "vm_", ",", "__opts__", ",", "search_global", "=", "False", ",", "default", "=", "1", ")", "params", "=", "{", "'Action'", ":", "'RunInstances'", ",", "'MinCount'", ":", "min_instance", ",", "'MaxCount'", ":", "max_instance", "}", "# Normal instances should have no prefix.", "spot_prefix", "=", "''", "image_id", "=", "get_imageid", "(", "vm_", ")", "params", "[", "spot_prefix", "+", "'ImageId'", "]", "=", "image_id", "userdata", "=", "None", "userdata_file", "=", "config", ".", "get_cloud_config_value", "(", "'userdata_file'", ",", "vm_", ",", "__opts__", ",", "search_global", "=", "False", ",", "default", "=", "None", ")", "if", "userdata_file", "is", "None", ":", "userdata", "=", "config", ".", "get_cloud_config_value", "(", "'userdata'", ",", "vm_", ",", "__opts__", ",", "search_global", "=", "False", ",", "default", "=", "None", ")", "else", ":", "log", ".", "trace", "(", "'userdata_file: %s'", ",", "userdata_file", ")", "if", "os", ".", "path", ".", "exists", "(", "userdata_file", ")", ":", "with", "salt", ".", "utils", ".", "files", ".", "fopen", "(", "userdata_file", ",", "'r'", ")", "as", "fh_", ":", "userdata", "=", "salt", ".", "utils", ".", "stringutils", ".", "to_unicode", "(", "fh_", ".", "read", "(", ")", ")", "userdata", "=", "salt", ".", "utils", ".", "cloud", ".", "userdata_template", "(", "__opts__", ",", "vm_", ",", "userdata", ")", "if", "userdata", "is", "not", "None", ":", "try", ":", "params", "[", "spot_prefix", "+", "'UserData'", "]", "=", "base64", ".", "b64encode", "(", "salt", ".", "utils", ".", "stringutils", ".", "to_bytes", "(", "userdata", ")", ")", "except", "Exception", "as", "exc", ":", "log", ".", "exception", "(", "'Failed to encode userdata: %s'", ",", "exc", ")", "vm_size", "=", "config", ".", "get_cloud_config_value", "(", "'size'", ",", "vm_", ",", "__opts__", ",", "search_global", "=", "False", ")", "params", "[", "spot_prefix", "+", "'InstanceType'", "]", "=", "vm_size", "ex_keyname", "=", "keyname", "(", "vm_", ")", "if", "ex_keyname", ":", "params", "[", "spot_prefix", "+", "'KeyName'", "]", "=", "ex_keyname", "ex_securitygroup", "=", "securitygroup", "(", "vm_", ")", "if", "ex_securitygroup", ":", "if", "not", "isinstance", "(", "ex_securitygroup", ",", "list", ")", ":", "params", "[", "spot_prefix", "+", "'SecurityGroup.1'", "]", "=", "ex_securitygroup", "else", ":", "for", "counter", ",", "sg_", "in", "enumerate", "(", "ex_securitygroup", ")", ":", "params", "[", "spot_prefix", "+", "'SecurityGroup.{0}'", ".", "format", "(", "counter", ")", "]", "=", "sg_", "ex_iam_profile", "=", "iam_profile", "(", "vm_", ")", "if", "ex_iam_profile", ":", "try", ":", "if", "ex_iam_profile", ".", "startswith", "(", "'arn:aws:iam:'", ")", ":", "params", "[", "spot_prefix", "+", "'IamInstanceProfile.Arn'", "]", "=", "ex_iam_profile", "else", ":", "params", "[", "spot_prefix", "+", "'IamInstanceProfile.Name'", "]", "=", "ex_iam_profile", "except", "AttributeError", ":", "raise", "SaltCloudConfigError", "(", "'\\'iam_profile\\' should be a string value.'", ")", "az_", "=", "get_availability_zone", "(", "vm_", ")", "if", "az_", "is", "not", "None", ":", "params", "[", "spot_prefix", "+", "'Placement.AvailabilityZone'", "]", "=", "az_", "tenancy_", "=", "get_tenancy", "(", "vm_", ")", "if", "tenancy_", "is", "not", "None", ":", "if", "spot_config", "is", "not", "None", ":", "raise", "SaltCloudConfigError", "(", "'Spot instance config for {0} does not support '", "'specifying tenancy.'", ".", "format", "(", "vm_", "[", "'name'", "]", ")", ")", "params", "[", "'Placement.Tenancy'", "]", "=", "tenancy_", "subnetid_", "=", "get_subnetid", "(", "vm_", ")", "if", "subnetid_", "is", "not", "None", ":", "params", "[", "spot_prefix", "+", "'SubnetId'", "]", "=", "subnetid_", "ex_securitygroupid", "=", "securitygroupid", "(", "vm_", ")", "if", "ex_securitygroupid", ":", "if", "not", "isinstance", "(", "ex_securitygroupid", ",", "list", ")", ":", "params", "[", "spot_prefix", "+", "'SecurityGroupId.1'", "]", "=", "ex_securitygroupid", "else", ":", "for", "counter", ",", "sg_", "in", "enumerate", "(", "ex_securitygroupid", ")", ":", "params", "[", "spot_prefix", "+", "'SecurityGroupId.{0}'", ".", "format", "(", "counter", ")", "]", "=", "sg_", "placementgroup_", "=", "get_placementgroup", "(", "vm_", ")", "if", "placementgroup_", "is", "not", "None", ":", "params", "[", "spot_prefix", "+", "'Placement.GroupName'", "]", "=", "placementgroup_", "blockdevicemappings_holder", "=", "block_device_mappings", "(", "vm_", ")", "if", "blockdevicemappings_holder", ":", "for", "_bd", "in", "blockdevicemappings_holder", ":", "if", "'tag'", "in", "_bd", ":", "_bd", ".", "pop", "(", "'tag'", ")", "ex_blockdevicemappings", "=", "blockdevicemappings_holder", "if", "ex_blockdevicemappings", ":", "params", ".", "update", "(", "_param_from_config", "(", "spot_prefix", "+", "'BlockDeviceMapping'", ",", "ex_blockdevicemappings", ")", ")", "network_interfaces", "=", "config", ".", "get_cloud_config_value", "(", "'network_interfaces'", ",", "vm_", ",", "__opts__", ",", "search_global", "=", "False", ")", "if", "network_interfaces", ":", "eni_devices", "=", "[", "]", "for", "interface", "in", "network_interfaces", ":", "log", ".", "debug", "(", "'Create network interface: %s'", ",", "interface", ")", "_new_eni", "=", "_create_eni_if_necessary", "(", "interface", ",", "vm_", ")", "eni_devices", ".", "append", "(", "_new_eni", ")", "params", ".", "update", "(", "_param_from_config", "(", "spot_prefix", "+", "'NetworkInterface'", ",", "eni_devices", ")", ")", "set_ebs_optimized", "=", "config", ".", "get_cloud_config_value", "(", "'ebs_optimized'", ",", "vm_", ",", "__opts__", ",", "search_global", "=", "False", ")", "if", "set_ebs_optimized", "is", "not", "None", ":", "if", "not", "isinstance", "(", "set_ebs_optimized", ",", "bool", ")", ":", "raise", "SaltCloudConfigError", "(", "'\\'ebs_optimized\\' should be a boolean value.'", ")", "params", "[", "spot_prefix", "+", "'EbsOptimized'", "]", "=", "set_ebs_optimized", "set_del_root_vol_on_destroy", "=", "config", ".", "get_cloud_config_value", "(", "'del_root_vol_on_destroy'", ",", "vm_", ",", "__opts__", ",", "search_global", "=", "False", ")", "set_termination_protection", "=", "config", ".", "get_cloud_config_value", "(", "'termination_protection'", ",", "vm_", ",", "__opts__", ",", "search_global", "=", "False", ")", "if", "set_termination_protection", "is", "not", "None", ":", "if", "not", "isinstance", "(", "set_termination_protection", ",", "bool", ")", ":", "raise", "SaltCloudConfigError", "(", "'\\'termination_protection\\' should be a boolean value.'", ")", "params", ".", "update", "(", "_param_from_config", "(", "spot_prefix", "+", "'DisableApiTermination'", ",", "set_termination_protection", ")", ")", "if", "set_del_root_vol_on_destroy", "and", "not", "isinstance", "(", "set_del_root_vol_on_destroy", ",", "bool", ")", ":", "raise", "SaltCloudConfigError", "(", "'\\'del_root_vol_on_destroy\\' should be a boolean value.'", ")", "vm_", "[", "'set_del_root_vol_on_destroy'", "]", "=", "set_del_root_vol_on_destroy", "if", "set_del_root_vol_on_destroy", ":", "# first make sure to look up the root device name", "# as Ubuntu and CentOS (and most likely other OSs)", "# use different device identifiers", "log", ".", "info", "(", "'Attempting to look up root device name for image id %s on '", "'VM %s'", ",", "image_id", ",", "vm_", "[", "'name'", "]", ")", "rd_params", "=", "{", "'Action'", ":", "'DescribeImages'", ",", "'ImageId.1'", ":", "image_id", "}", "try", ":", "rd_data", "=", "aws", ".", "query", "(", "rd_params", ",", "location", "=", "get_location", "(", "vm_", ")", ",", "provider", "=", "get_provider", "(", ")", ",", "opts", "=", "__opts__", ",", "sigver", "=", "'4'", ")", "if", "'error'", "in", "rd_data", ":", "return", "rd_data", "[", "'error'", "]", "log", ".", "debug", "(", "'EC2 Response: \\'%s\\''", ",", "rd_data", ")", "except", "Exception", "as", "exc", ":", "log", ".", "error", "(", "'Error getting root device name for image id %s for '", "'VM %s: \\n%s'", ",", "image_id", ",", "vm_", "[", "'name'", "]", ",", "exc", ",", "# Show the traceback if the debug logging level is enabled", "exc_info_on_loglevel", "=", "logging", ".", "DEBUG", ")", "raise", "# make sure we have a response", "if", "not", "rd_data", ":", "err_msg", "=", "'There was an error querying EC2 for the root device '", "'of image id {0}. Empty response.'", ".", "format", "(", "image_id", ")", "raise", "SaltCloudSystemExit", "(", "err_msg", ")", "# pull the root device name from the result and use it when", "# launching the new VM", "rd_name", "=", "None", "rd_type", "=", "None", "if", "'blockDeviceMapping'", "in", "rd_data", "[", "0", "]", ":", "# Some ami instances do not have a root volume. Ignore such cases", "if", "rd_data", "[", "0", "]", "[", "'blockDeviceMapping'", "]", "is", "not", "None", ":", "item", "=", "rd_data", "[", "0", "]", "[", "'blockDeviceMapping'", "]", "[", "'item'", "]", "if", "isinstance", "(", "item", ",", "list", ")", ":", "item", "=", "item", "[", "0", "]", "rd_name", "=", "item", "[", "'deviceName'", "]", "# Grab the volume type", "rd_type", "=", "item", "[", "'ebs'", "]", ".", "get", "(", "'volumeType'", ",", "None", ")", "log", ".", "info", "(", "'Found root device name: %s'", ",", "rd_name", ")", "if", "rd_name", "is", "not", "None", ":", "if", "ex_blockdevicemappings", ":", "dev_list", "=", "[", "dev", "[", "'DeviceName'", "]", "for", "dev", "in", "ex_blockdevicemappings", "]", "else", ":", "dev_list", "=", "[", "]", "if", "rd_name", "in", "dev_list", ":", "# Device already listed, just grab the index", "dev_index", "=", "dev_list", ".", "index", "(", "rd_name", ")", "else", ":", "dev_index", "=", "len", "(", "dev_list", ")", "# Add the device name in since it wasn't already there", "params", "[", "'{0}BlockDeviceMapping.{1}.DeviceName'", ".", "format", "(", "spot_prefix", ",", "dev_index", ")", "]", "=", "rd_name", "# Set the termination value", "termination_key", "=", "'{0}BlockDeviceMapping.{1}.Ebs.DeleteOnTermination'", ".", "format", "(", "spot_prefix", ",", "dev_index", ")", "params", "[", "termination_key", "]", "=", "six", ".", "text_type", "(", "set_del_root_vol_on_destroy", ")", ".", "lower", "(", ")", "# Use default volume type if not specified", "if", "ex_blockdevicemappings", "and", "dev_index", "<", "len", "(", "ex_blockdevicemappings", ")", "and", "'Ebs.VolumeType'", "not", "in", "ex_blockdevicemappings", "[", "dev_index", "]", ":", "type_key", "=", "'{0}BlockDeviceMapping.{1}.Ebs.VolumeType'", ".", "format", "(", "spot_prefix", ",", "dev_index", ")", "params", "[", "type_key", "]", "=", "rd_type", "set_del_all_vols_on_destroy", "=", "config", ".", "get_cloud_config_value", "(", "'del_all_vols_on_destroy'", ",", "vm_", ",", "__opts__", ",", "search_global", "=", "False", ",", "default", "=", "False", ")", "if", "set_del_all_vols_on_destroy", "and", "not", "isinstance", "(", "set_del_all_vols_on_destroy", ",", "bool", ")", ":", "raise", "SaltCloudConfigError", "(", "'\\'del_all_vols_on_destroy\\' should be a boolean value.'", ")", "__utils__", "[", "'cloud.fire_event'", "]", "(", "'event'", ",", "'requesting instance'", ",", "'salt/cloud/{0}/requesting'", ".", "format", "(", "vm_", "[", "'name'", "]", ")", ",", "args", "=", "{", "'kwargs'", ":", "__utils__", "[", "'cloud.filter_event'", "]", "(", "'requesting'", ",", "params", ",", "list", "(", "params", ")", ")", ",", "'location'", ":", "location", ",", "}", ",", "sock_dir", "=", "__opts__", "[", "'sock_dir'", "]", ",", "transport", "=", "__opts__", "[", "'transport'", "]", ")", "provider", "=", "get_provider", "(", "vm_", ")", "try", ":", "data", "=", "aws", ".", "query", "(", "params", ",", "'instancesSet'", ",", "location", "=", "location", ",", "provider", "=", "provider", ",", "opts", "=", "__opts__", ",", "sigver", "=", "'4'", ")", "if", "'error'", "in", "data", ":", "return", "data", "[", "'error'", "]", "except", "Exception", "as", "exc", ":", "log", ".", "error", "(", "'Error creating %s on EC2 when trying to run the initial '", "'deployment: \\n%s'", ",", "vm_", "[", "'name'", "]", ",", "exc", ",", "# Show the traceback if the debug logging level is enabled", "exc_info_on_loglevel", "=", "logging", ".", "DEBUG", ")", "raise", "# if we're using spot instances, we need to wait for the spot request", "# to become active before we continue", "if", "spot_config", ":", "sir_id", "=", "data", "[", "0", "]", "[", "'spotInstanceRequestId'", "]", "vm_", "[", "'spotRequestId'", "]", "=", "sir_id", "def", "__query_spot_instance_request", "(", "sir_id", ",", "location", ")", ":", "params", "=", "{", "'Action'", ":", "'DescribeSpotInstanceRequests'", ",", "'SpotInstanceRequestId.1'", ":", "sir_id", "}", "data", "=", "aws", ".", "query", "(", "params", ",", "location", "=", "location", ",", "provider", "=", "provider", ",", "opts", "=", "__opts__", ",", "sigver", "=", "'4'", ")", "if", "not", "data", ":", "log", ".", "error", "(", "'There was an error while querying EC2. Empty response'", ")", "# Trigger a failure in the wait for spot instance method", "return", "False", "if", "isinstance", "(", "data", ",", "dict", ")", "and", "'error'", "in", "data", ":", "log", ".", "warning", "(", "'There was an error in the query. %s'", ",", "data", "[", "'error'", "]", ")", "# Trigger a failure in the wait for spot instance method", "return", "False", "log", ".", "debug", "(", "'Returned query data: %s'", ",", "data", ")", "state", "=", "data", "[", "0", "]", ".", "get", "(", "'state'", ")", "if", "state", "==", "'active'", ":", "return", "data", "if", "state", "==", "'open'", ":", "# Still waiting for an active state", "log", ".", "info", "(", "'Spot instance status: %s'", ",", "data", "[", "0", "]", "[", "'status'", "]", "[", "'message'", "]", ")", "return", "None", "if", "state", "in", "[", "'cancelled'", ",", "'failed'", ",", "'closed'", "]", ":", "# Request will never be active, fail", "log", ".", "error", "(", "'Spot instance request resulted in state \\'{0}\\'. '", "'Nothing else we can do here.'", ")", "return", "False", "__utils__", "[", "'cloud.fire_event'", "]", "(", "'event'", ",", "'waiting for spot instance'", ",", "'salt/cloud/{0}/waiting_for_spot'", ".", "format", "(", "vm_", "[", "'name'", "]", ")", ",", "sock_dir", "=", "__opts__", "[", "'sock_dir'", "]", ",", "transport", "=", "__opts__", "[", "'transport'", "]", ")", "try", ":", "data", "=", "_wait_for_spot_instance", "(", "__query_spot_instance_request", ",", "update_args", "=", "(", "sir_id", ",", "location", ")", ",", "timeout", "=", "config", ".", "get_cloud_config_value", "(", "'wait_for_spot_timeout'", ",", "vm_", ",", "__opts__", ",", "default", "=", "10", "*", "60", ")", ",", "interval", "=", "config", ".", "get_cloud_config_value", "(", "'wait_for_spot_interval'", ",", "vm_", ",", "__opts__", ",", "default", "=", "30", ")", ",", "interval_multiplier", "=", "config", ".", "get_cloud_config_value", "(", "'wait_for_spot_interval_multiplier'", ",", "vm_", ",", "__opts__", ",", "default", "=", "1", ")", ",", "max_failures", "=", "config", ".", "get_cloud_config_value", "(", "'wait_for_spot_max_failures'", ",", "vm_", ",", "__opts__", ",", "default", "=", "10", ")", ",", ")", "log", ".", "debug", "(", "'wait_for_spot_instance data %s'", ",", "data", ")", "except", "(", "SaltCloudExecutionTimeout", ",", "SaltCloudExecutionFailure", ")", "as", "exc", ":", "try", ":", "# Cancel the existing spot instance request", "params", "=", "{", "'Action'", ":", "'CancelSpotInstanceRequests'", ",", "'SpotInstanceRequestId.1'", ":", "sir_id", "}", "data", "=", "aws", ".", "query", "(", "params", ",", "location", "=", "location", ",", "provider", "=", "provider", ",", "opts", "=", "__opts__", ",", "sigver", "=", "'4'", ")", "log", ".", "debug", "(", "'Canceled spot instance request %s. Data '", "'returned: %s'", ",", "sir_id", ",", "data", ")", "except", "SaltCloudSystemExit", ":", "pass", "finally", ":", "raise", "SaltCloudSystemExit", "(", "six", ".", "text_type", "(", "exc", ")", ")", "return", "data", ",", "vm_"], "docstring": "Put together all of the information necessary to request an instance on EC2,\n    and then fire off the request the instance.\n\n    Returns data about the instance", "docstring_tokens": ["Put", "together", "all", "of", "the", "information", "necessary", "to", "request", "an", "instance", "on", "EC2", "and", "then", "fire", "off", "the", "request", "the", "instance", "."], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/cloud/clouds/ec2.py#L1747-L2175", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/cloud/clouds/ec2.py", "func_name": "query_instance", "original_string": "def query_instance(vm_=None, call=None):\n    '''\n    Query an instance upon creation from the EC2 API\n    '''\n    if call == 'function':\n        # Technically this function may be called other ways too, but it\n        # definitely cannot be called with --function.\n        raise SaltCloudSystemExit(\n            'The query_instance action must be called with -a or --action.'\n        )\n\n    instance_id = vm_['instance_id']\n    location = vm_.get('location', get_location(vm_))\n    __utils__['cloud.fire_event'](\n        'event',\n        'querying instance',\n        'salt/cloud/{0}/querying'.format(vm_['name']),\n        args={'instance_id': instance_id},\n        sock_dir=__opts__['sock_dir'],\n        transport=__opts__['transport']\n    )\n\n    log.debug('The new VM instance_id is %s', instance_id)\n\n    params = {'Action': 'DescribeInstances',\n              'InstanceId.1': instance_id}\n\n    provider = get_provider(vm_)\n\n    attempts = 0\n    while attempts < aws.AWS_MAX_RETRIES:\n        data, requesturl = aws.query(params,                # pylint: disable=unbalanced-tuple-unpacking\n                                     location=location,\n                                     provider=provider,\n                                     opts=__opts__,\n                                     return_url=True,\n                                     sigver='4')\n        log.debug('The query returned: %s', data)\n\n        if isinstance(data, dict) and 'error' in data:\n            log.warning(\n                'There was an error in the query. %s attempts '\n                'remaining: %s', attempts, data['error']\n            )\n        elif isinstance(data, list) and not data:\n            log.warning(\n                'Query returned an empty list. %s attempts '\n                'remaining.', attempts\n            )\n        else:\n            break\n\n        aws.sleep_exponential_backoff(attempts)\n        attempts += 1\n        continue\n    else:\n        raise SaltCloudSystemExit(\n            'An error occurred while creating VM: {0}'.format(data['error'])\n        )\n\n    def __query_ip_address(params, url):  # pylint: disable=W0613\n        data = aws.query(params,\n                         location=location,\n                         provider=provider,\n                         opts=__opts__,\n                         sigver='4')\n        if not data:\n            log.error(\n                'There was an error while querying EC2. Empty response'\n            )\n            # Trigger a failure in the wait for IP function\n            return False\n\n        if isinstance(data, dict) and 'error' in data:\n            log.warning('There was an error in the query. %s', data['error'])\n            # Trigger a failure in the wait for IP function\n            return False\n\n        log.debug('Returned query data: %s', data)\n\n        if ssh_interface(vm_) == 'public_ips':\n            if 'ipAddress' in data[0]['instancesSet']['item']:\n                return data\n            else:\n                log.error(\n                    'Public IP not detected.'\n                )\n\n        if ssh_interface(vm_) == 'private_ips':\n            if 'privateIpAddress' in data[0]['instancesSet']['item']:\n                return data\n            else:\n                log.error(\n                    'Private IP not detected.'\n                )\n\n    try:\n        data = salt.utils.cloud.wait_for_ip(\n            __query_ip_address,\n            update_args=(params, requesturl),\n            timeout=config.get_cloud_config_value(\n                'wait_for_ip_timeout', vm_, __opts__, default=10 * 60),\n            interval=config.get_cloud_config_value(\n                'wait_for_ip_interval', vm_, __opts__, default=10),\n            interval_multiplier=config.get_cloud_config_value(\n                'wait_for_ip_interval_multiplier', vm_, __opts__, default=1),\n        )\n    except (SaltCloudExecutionTimeout, SaltCloudExecutionFailure) as exc:\n        try:\n            # It might be already up, let's destroy it!\n            destroy(vm_['name'])\n        except SaltCloudSystemExit:\n            pass\n        finally:\n            raise SaltCloudSystemExit(six.text_type(exc))\n\n    if 'reactor' in vm_ and vm_['reactor'] is True:\n        __utils__['cloud.fire_event'](\n            'event',\n            'instance queried',\n            'salt/cloud/{0}/query_reactor'.format(vm_['name']),\n            args={'data': data},\n            sock_dir=__opts__['sock_dir'],\n            transport=__opts__['transport']\n        )\n\n    return data", "language": "python", "code": "def query_instance(vm_=None, call=None):\n    '''\n    Query an instance upon creation from the EC2 API\n    '''\n    if call == 'function':\n        # Technically this function may be called other ways too, but it\n        # definitely cannot be called with --function.\n        raise SaltCloudSystemExit(\n            'The query_instance action must be called with -a or --action.'\n        )\n\n    instance_id = vm_['instance_id']\n    location = vm_.get('location', get_location(vm_))\n    __utils__['cloud.fire_event'](\n        'event',\n        'querying instance',\n        'salt/cloud/{0}/querying'.format(vm_['name']),\n        args={'instance_id': instance_id},\n        sock_dir=__opts__['sock_dir'],\n        transport=__opts__['transport']\n    )\n\n    log.debug('The new VM instance_id is %s', instance_id)\n\n    params = {'Action': 'DescribeInstances',\n              'InstanceId.1': instance_id}\n\n    provider = get_provider(vm_)\n\n    attempts = 0\n    while attempts < aws.AWS_MAX_RETRIES:\n        data, requesturl = aws.query(params,                # pylint: disable=unbalanced-tuple-unpacking\n                                     location=location,\n                                     provider=provider,\n                                     opts=__opts__,\n                                     return_url=True,\n                                     sigver='4')\n        log.debug('The query returned: %s', data)\n\n        if isinstance(data, dict) and 'error' in data:\n            log.warning(\n                'There was an error in the query. %s attempts '\n                'remaining: %s', attempts, data['error']\n            )\n        elif isinstance(data, list) and not data:\n            log.warning(\n                'Query returned an empty list. %s attempts '\n                'remaining.', attempts\n            )\n        else:\n            break\n\n        aws.sleep_exponential_backoff(attempts)\n        attempts += 1\n        continue\n    else:\n        raise SaltCloudSystemExit(\n            'An error occurred while creating VM: {0}'.format(data['error'])\n        )\n\n    def __query_ip_address(params, url):  # pylint: disable=W0613\n        data = aws.query(params,\n                         location=location,\n                         provider=provider,\n                         opts=__opts__,\n                         sigver='4')\n        if not data:\n            log.error(\n                'There was an error while querying EC2. Empty response'\n            )\n            # Trigger a failure in the wait for IP function\n            return False\n\n        if isinstance(data, dict) and 'error' in data:\n            log.warning('There was an error in the query. %s', data['error'])\n            # Trigger a failure in the wait for IP function\n            return False\n\n        log.debug('Returned query data: %s', data)\n\n        if ssh_interface(vm_) == 'public_ips':\n            if 'ipAddress' in data[0]['instancesSet']['item']:\n                return data\n            else:\n                log.error(\n                    'Public IP not detected.'\n                )\n\n        if ssh_interface(vm_) == 'private_ips':\n            if 'privateIpAddress' in data[0]['instancesSet']['item']:\n                return data\n            else:\n                log.error(\n                    'Private IP not detected.'\n                )\n\n    try:\n        data = salt.utils.cloud.wait_for_ip(\n            __query_ip_address,\n            update_args=(params, requesturl),\n            timeout=config.get_cloud_config_value(\n                'wait_for_ip_timeout', vm_, __opts__, default=10 * 60),\n            interval=config.get_cloud_config_value(\n                'wait_for_ip_interval', vm_, __opts__, default=10),\n            interval_multiplier=config.get_cloud_config_value(\n                'wait_for_ip_interval_multiplier', vm_, __opts__, default=1),\n        )\n    except (SaltCloudExecutionTimeout, SaltCloudExecutionFailure) as exc:\n        try:\n            # It might be already up, let's destroy it!\n            destroy(vm_['name'])\n        except SaltCloudSystemExit:\n            pass\n        finally:\n            raise SaltCloudSystemExit(six.text_type(exc))\n\n    if 'reactor' in vm_ and vm_['reactor'] is True:\n        __utils__['cloud.fire_event'](\n            'event',\n            'instance queried',\n            'salt/cloud/{0}/query_reactor'.format(vm_['name']),\n            args={'data': data},\n            sock_dir=__opts__['sock_dir'],\n            transport=__opts__['transport']\n        )\n\n    return data", "code_tokens": ["def", "query_instance", "(", "vm_", "=", "None", ",", "call", "=", "None", ")", ":", "if", "call", "==", "'function'", ":", "# Technically this function may be called other ways too, but it", "# definitely cannot be called with --function.", "raise", "SaltCloudSystemExit", "(", "'The query_instance action must be called with -a or --action.'", ")", "instance_id", "=", "vm_", "[", "'instance_id'", "]", "location", "=", "vm_", ".", "get", "(", "'location'", ",", "get_location", "(", "vm_", ")", ")", "__utils__", "[", "'cloud.fire_event'", "]", "(", "'event'", ",", "'querying instance'", ",", "'salt/cloud/{0}/querying'", ".", "format", "(", "vm_", "[", "'name'", "]", ")", ",", "args", "=", "{", "'instance_id'", ":", "instance_id", "}", ",", "sock_dir", "=", "__opts__", "[", "'sock_dir'", "]", ",", "transport", "=", "__opts__", "[", "'transport'", "]", ")", "log", ".", "debug", "(", "'The new VM instance_id is %s'", ",", "instance_id", ")", "params", "=", "{", "'Action'", ":", "'DescribeInstances'", ",", "'InstanceId.1'", ":", "instance_id", "}", "provider", "=", "get_provider", "(", "vm_", ")", "attempts", "=", "0", "while", "attempts", "<", "aws", ".", "AWS_MAX_RETRIES", ":", "data", ",", "requesturl", "=", "aws", ".", "query", "(", "params", ",", "# pylint: disable=unbalanced-tuple-unpacking", "location", "=", "location", ",", "provider", "=", "provider", ",", "opts", "=", "__opts__", ",", "return_url", "=", "True", ",", "sigver", "=", "'4'", ")", "log", ".", "debug", "(", "'The query returned: %s'", ",", "data", ")", "if", "isinstance", "(", "data", ",", "dict", ")", "and", "'error'", "in", "data", ":", "log", ".", "warning", "(", "'There was an error in the query. %s attempts '", "'remaining: %s'", ",", "attempts", ",", "data", "[", "'error'", "]", ")", "elif", "isinstance", "(", "data", ",", "list", ")", "and", "not", "data", ":", "log", ".", "warning", "(", "'Query returned an empty list. %s attempts '", "'remaining.'", ",", "attempts", ")", "else", ":", "break", "aws", ".", "sleep_exponential_backoff", "(", "attempts", ")", "attempts", "+=", "1", "continue", "else", ":", "raise", "SaltCloudSystemExit", "(", "'An error occurred while creating VM: {0}'", ".", "format", "(", "data", "[", "'error'", "]", ")", ")", "def", "__query_ip_address", "(", "params", ",", "url", ")", ":", "# pylint: disable=W0613", "data", "=", "aws", ".", "query", "(", "params", ",", "location", "=", "location", ",", "provider", "=", "provider", ",", "opts", "=", "__opts__", ",", "sigver", "=", "'4'", ")", "if", "not", "data", ":", "log", ".", "error", "(", "'There was an error while querying EC2. Empty response'", ")", "# Trigger a failure in the wait for IP function", "return", "False", "if", "isinstance", "(", "data", ",", "dict", ")", "and", "'error'", "in", "data", ":", "log", ".", "warning", "(", "'There was an error in the query. %s'", ",", "data", "[", "'error'", "]", ")", "# Trigger a failure in the wait for IP function", "return", "False", "log", ".", "debug", "(", "'Returned query data: %s'", ",", "data", ")", "if", "ssh_interface", "(", "vm_", ")", "==", "'public_ips'", ":", "if", "'ipAddress'", "in", "data", "[", "0", "]", "[", "'instancesSet'", "]", "[", "'item'", "]", ":", "return", "data", "else", ":", "log", ".", "error", "(", "'Public IP not detected.'", ")", "if", "ssh_interface", "(", "vm_", ")", "==", "'private_ips'", ":", "if", "'privateIpAddress'", "in", "data", "[", "0", "]", "[", "'instancesSet'", "]", "[", "'item'", "]", ":", "return", "data", "else", ":", "log", ".", "error", "(", "'Private IP not detected.'", ")", "try", ":", "data", "=", "salt", ".", "utils", ".", "cloud", ".", "wait_for_ip", "(", "__query_ip_address", ",", "update_args", "=", "(", "params", ",", "requesturl", ")", ",", "timeout", "=", "config", ".", "get_cloud_config_value", "(", "'wait_for_ip_timeout'", ",", "vm_", ",", "__opts__", ",", "default", "=", "10", "*", "60", ")", ",", "interval", "=", "config", ".", "get_cloud_config_value", "(", "'wait_for_ip_interval'", ",", "vm_", ",", "__opts__", ",", "default", "=", "10", ")", ",", "interval_multiplier", "=", "config", ".", "get_cloud_config_value", "(", "'wait_for_ip_interval_multiplier'", ",", "vm_", ",", "__opts__", ",", "default", "=", "1", ")", ",", ")", "except", "(", "SaltCloudExecutionTimeout", ",", "SaltCloudExecutionFailure", ")", "as", "exc", ":", "try", ":", "# It might be already up, let's destroy it!", "destroy", "(", "vm_", "[", "'name'", "]", ")", "except", "SaltCloudSystemExit", ":", "pass", "finally", ":", "raise", "SaltCloudSystemExit", "(", "six", ".", "text_type", "(", "exc", ")", ")", "if", "'reactor'", "in", "vm_", "and", "vm_", "[", "'reactor'", "]", "is", "True", ":", "__utils__", "[", "'cloud.fire_event'", "]", "(", "'event'", ",", "'instance queried'", ",", "'salt/cloud/{0}/query_reactor'", ".", "format", "(", "vm_", "[", "'name'", "]", ")", ",", "args", "=", "{", "'data'", ":", "data", "}", ",", "sock_dir", "=", "__opts__", "[", "'sock_dir'", "]", ",", "transport", "=", "__opts__", "[", "'transport'", "]", ")", "return", "data"], "docstring": "Query an instance upon creation from the EC2 API", "docstring_tokens": ["Query", "an", "instance", "upon", "creation", "from", "the", "EC2", "API"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/cloud/clouds/ec2.py#L2178-L2304", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/cloud/clouds/ec2.py", "func_name": "wait_for_instance", "original_string": "def wait_for_instance(\n        vm_=None,\n        data=None,\n        ip_address=None,\n        display_ssh_output=True,\n        call=None,\n    ):\n    '''\n    Wait for an instance upon creation from the EC2 API, to become available\n    '''\n    if call == 'function':\n        # Technically this function may be called other ways too, but it\n        # definitely cannot be called with --function.\n        raise SaltCloudSystemExit(\n            'The wait_for_instance action must be called with -a or --action.'\n        )\n\n    if vm_ is None:\n        vm_ = {}\n\n    if data is None:\n        data = {}\n\n    ssh_gateway_config = vm_.get(\n        'gateway', get_ssh_gateway_config(vm_)\n    )\n\n    __utils__['cloud.fire_event'](\n        'event',\n        'waiting for ssh',\n        'salt/cloud/{0}/waiting_for_ssh'.format(vm_['name']),\n        args={'ip_address': ip_address},\n        sock_dir=__opts__['sock_dir'],\n        transport=__opts__['transport']\n    )\n\n    ssh_connect_timeout = config.get_cloud_config_value(\n        'ssh_connect_timeout', vm_, __opts__, 900   # 15 minutes\n    )\n    ssh_port = config.get_cloud_config_value(\n        'ssh_port', vm_, __opts__, 22\n    )\n\n    if config.get_cloud_config_value('win_installer', vm_, __opts__):\n        username = config.get_cloud_config_value(\n            'win_username', vm_, __opts__, default='Administrator'\n        )\n        win_passwd = config.get_cloud_config_value(\n            'win_password', vm_, __opts__, default=''\n        )\n        win_deploy_auth_retries = config.get_cloud_config_value(\n            'win_deploy_auth_retries', vm_, __opts__, default=10\n        )\n        win_deploy_auth_retry_delay = config.get_cloud_config_value(\n            'win_deploy_auth_retry_delay', vm_, __opts__, default=1\n        )\n        use_winrm = config.get_cloud_config_value(\n            'use_winrm', vm_, __opts__, default=False\n        )\n        winrm_verify_ssl = config.get_cloud_config_value(\n            'winrm_verify_ssl', vm_, __opts__, default=True\n        )\n\n        if win_passwd and win_passwd == 'auto':\n            log.debug('Waiting for auto-generated Windows EC2 password')\n            while True:\n                password_data = get_password_data(\n                    name=vm_['name'],\n                    kwargs={\n                        'key_file': vm_['private_key'],\n                    },\n                    call='action',\n                )\n                win_passwd = password_data.get('password', None)\n                if win_passwd is None:\n                    log.debug(password_data)\n                    # This wait is so high, because the password is unlikely to\n                    # be generated for at least 4 minutes\n                    time.sleep(60)\n                else:\n                    logging_data = password_data\n\n                    logging_data['password'] = 'XXX-REDACTED-XXX'\n                    logging_data['passwordData'] = 'XXX-REDACTED-XXX'\n                    log.debug(logging_data)\n\n                    vm_['win_password'] = win_passwd\n                    break\n\n        # SMB used whether psexec or winrm\n        if not salt.utils.cloud.wait_for_port(ip_address,\n                                              port=445,\n                                              timeout=ssh_connect_timeout):\n            raise SaltCloudSystemExit(\n                'Failed to connect to remote windows host'\n            )\n\n        # If not using winrm keep same psexec behavior\n        if not use_winrm:\n\n            log.debug('Trying to authenticate via SMB using psexec')\n\n            if not salt.utils.cloud.validate_windows_cred(ip_address,\n                                                          username,\n                                                          win_passwd,\n                                                          retries=win_deploy_auth_retries,\n                                                          retry_delay=win_deploy_auth_retry_delay):\n                raise SaltCloudSystemExit(\n                    'Failed to authenticate against remote windows host (smb)'\n                )\n\n        # If using winrm\n        else:\n\n            # Default HTTPS port can be changed in cloud configuration\n            winrm_port = config.get_cloud_config_value(\n                'winrm_port', vm_, __opts__, default=5986\n            )\n\n            # Wait for winrm port to be available\n            if not salt.utils.cloud.wait_for_port(ip_address,\n                                                  port=winrm_port,\n                                                  timeout=ssh_connect_timeout):\n                raise SaltCloudSystemExit(\n                    'Failed to connect to remote windows host (winrm)'\n                )\n\n            log.debug('Trying to authenticate via Winrm using pywinrm')\n\n            if not salt.utils.cloud.wait_for_winrm(ip_address,\n                                                          winrm_port,\n                                                          username,\n                                                          win_passwd,\n                                                          timeout=ssh_connect_timeout,\n                                                          verify=winrm_verify_ssl):\n                raise SaltCloudSystemExit(\n                    'Failed to authenticate against remote windows host'\n                )\n\n    elif salt.utils.cloud.wait_for_port(ip_address,\n                                        port=ssh_port,\n                                        timeout=ssh_connect_timeout,\n                                        gateway=ssh_gateway_config\n                                        ):\n        # If a known_hosts_file is configured, this instance will not be\n        # accessible until it has a host key. Since this is provided on\n        # supported instances by cloud-init, and viewable to us only from the\n        # console output (which may take several minutes to become available,\n        # we have some more waiting to do here.\n        known_hosts_file = config.get_cloud_config_value(\n            'known_hosts_file', vm_, __opts__, default=None\n        )\n        if known_hosts_file:\n            console = {}\n            while 'output_decoded' not in console:\n                console = get_console_output(\n                    instance_id=vm_['instance_id'],\n                    call='action',\n                    location=get_location(vm_)\n                )\n                pprint.pprint(console)\n                time.sleep(5)\n            output = salt.utils.stringutils.to_unicode(console['output_decoded'])\n            comps = output.split('-----BEGIN SSH HOST KEY KEYS-----')\n            if len(comps) < 2:\n                # Fail; there are no host keys\n                return False\n\n            comps = comps[1].split('-----END SSH HOST KEY KEYS-----')\n            keys = ''\n            for line in comps[0].splitlines():\n                if not line:\n                    continue\n                keys += '\\n{0} {1}'.format(ip_address, line)\n\n            with salt.utils.files.fopen(known_hosts_file, 'a') as fp_:\n                fp_.write(salt.utils.stringutils.to_str(keys))\n            fp_.close()\n\n        for user in vm_['usernames']:\n            if salt.utils.cloud.wait_for_passwd(\n                host=ip_address,\n                port=ssh_port,\n                username=user,\n                ssh_timeout=config.get_cloud_config_value(\n                    'wait_for_passwd_timeout', vm_, __opts__, default=1 * 60\n                ),\n                key_filename=vm_['key_filename'],\n                display_ssh_output=display_ssh_output,\n                gateway=ssh_gateway_config,\n                maxtries=config.get_cloud_config_value(\n                    'wait_for_passwd_maxtries', vm_, __opts__, default=15\n                ),\n                known_hosts_file=config.get_cloud_config_value(\n                    'known_hosts_file', vm_, __opts__,\n                    default='/dev/null'\n                ),\n            ):\n                __opts__['ssh_username'] = user\n                vm_['ssh_username'] = user\n                break\n        else:\n            raise SaltCloudSystemExit(\n                'Failed to authenticate against remote ssh'\n            )\n    else:\n        raise SaltCloudSystemExit(\n            'Failed to connect to remote ssh'\n        )\n\n    if 'reactor' in vm_ and vm_['reactor'] is True:\n        __utils__['cloud.fire_event'](\n            'event',\n            'ssh is available',\n            'salt/cloud/{0}/ssh_ready_reactor'.format(vm_['name']),\n            args={'ip_address': ip_address},\n            sock_dir=__opts__['sock_dir'],\n            transport=__opts__['transport']\n        )\n\n    return vm_", "language": "python", "code": "def wait_for_instance(\n        vm_=None,\n        data=None,\n        ip_address=None,\n        display_ssh_output=True,\n        call=None,\n    ):\n    '''\n    Wait for an instance upon creation from the EC2 API, to become available\n    '''\n    if call == 'function':\n        # Technically this function may be called other ways too, but it\n        # definitely cannot be called with --function.\n        raise SaltCloudSystemExit(\n            'The wait_for_instance action must be called with -a or --action.'\n        )\n\n    if vm_ is None:\n        vm_ = {}\n\n    if data is None:\n        data = {}\n\n    ssh_gateway_config = vm_.get(\n        'gateway', get_ssh_gateway_config(vm_)\n    )\n\n    __utils__['cloud.fire_event'](\n        'event',\n        'waiting for ssh',\n        'salt/cloud/{0}/waiting_for_ssh'.format(vm_['name']),\n        args={'ip_address': ip_address},\n        sock_dir=__opts__['sock_dir'],\n        transport=__opts__['transport']\n    )\n\n    ssh_connect_timeout = config.get_cloud_config_value(\n        'ssh_connect_timeout', vm_, __opts__, 900   # 15 minutes\n    )\n    ssh_port = config.get_cloud_config_value(\n        'ssh_port', vm_, __opts__, 22\n    )\n\n    if config.get_cloud_config_value('win_installer', vm_, __opts__):\n        username = config.get_cloud_config_value(\n            'win_username', vm_, __opts__, default='Administrator'\n        )\n        win_passwd = config.get_cloud_config_value(\n            'win_password', vm_, __opts__, default=''\n        )\n        win_deploy_auth_retries = config.get_cloud_config_value(\n            'win_deploy_auth_retries', vm_, __opts__, default=10\n        )\n        win_deploy_auth_retry_delay = config.get_cloud_config_value(\n            'win_deploy_auth_retry_delay', vm_, __opts__, default=1\n        )\n        use_winrm = config.get_cloud_config_value(\n            'use_winrm', vm_, __opts__, default=False\n        )\n        winrm_verify_ssl = config.get_cloud_config_value(\n            'winrm_verify_ssl', vm_, __opts__, default=True\n        )\n\n        if win_passwd and win_passwd == 'auto':\n            log.debug('Waiting for auto-generated Windows EC2 password')\n            while True:\n                password_data = get_password_data(\n                    name=vm_['name'],\n                    kwargs={\n                        'key_file': vm_['private_key'],\n                    },\n                    call='action',\n                )\n                win_passwd = password_data.get('password', None)\n                if win_passwd is None:\n                    log.debug(password_data)\n                    # This wait is so high, because the password is unlikely to\n                    # be generated for at least 4 minutes\n                    time.sleep(60)\n                else:\n                    logging_data = password_data\n\n                    logging_data['password'] = 'XXX-REDACTED-XXX'\n                    logging_data['passwordData'] = 'XXX-REDACTED-XXX'\n                    log.debug(logging_data)\n\n                    vm_['win_password'] = win_passwd\n                    break\n\n        # SMB used whether psexec or winrm\n        if not salt.utils.cloud.wait_for_port(ip_address,\n                                              port=445,\n                                              timeout=ssh_connect_timeout):\n            raise SaltCloudSystemExit(\n                'Failed to connect to remote windows host'\n            )\n\n        # If not using winrm keep same psexec behavior\n        if not use_winrm:\n\n            log.debug('Trying to authenticate via SMB using psexec')\n\n            if not salt.utils.cloud.validate_windows_cred(ip_address,\n                                                          username,\n                                                          win_passwd,\n                                                          retries=win_deploy_auth_retries,\n                                                          retry_delay=win_deploy_auth_retry_delay):\n                raise SaltCloudSystemExit(\n                    'Failed to authenticate against remote windows host (smb)'\n                )\n\n        # If using winrm\n        else:\n\n            # Default HTTPS port can be changed in cloud configuration\n            winrm_port = config.get_cloud_config_value(\n                'winrm_port', vm_, __opts__, default=5986\n            )\n\n            # Wait for winrm port to be available\n            if not salt.utils.cloud.wait_for_port(ip_address,\n                                                  port=winrm_port,\n                                                  timeout=ssh_connect_timeout):\n                raise SaltCloudSystemExit(\n                    'Failed to connect to remote windows host (winrm)'\n                )\n\n            log.debug('Trying to authenticate via Winrm using pywinrm')\n\n            if not salt.utils.cloud.wait_for_winrm(ip_address,\n                                                          winrm_port,\n                                                          username,\n                                                          win_passwd,\n                                                          timeout=ssh_connect_timeout,\n                                                          verify=winrm_verify_ssl):\n                raise SaltCloudSystemExit(\n                    'Failed to authenticate against remote windows host'\n                )\n\n    elif salt.utils.cloud.wait_for_port(ip_address,\n                                        port=ssh_port,\n                                        timeout=ssh_connect_timeout,\n                                        gateway=ssh_gateway_config\n                                        ):\n        # If a known_hosts_file is configured, this instance will not be\n        # accessible until it has a host key. Since this is provided on\n        # supported instances by cloud-init, and viewable to us only from the\n        # console output (which may take several minutes to become available,\n        # we have some more waiting to do here.\n        known_hosts_file = config.get_cloud_config_value(\n            'known_hosts_file', vm_, __opts__, default=None\n        )\n        if known_hosts_file:\n            console = {}\n            while 'output_decoded' not in console:\n                console = get_console_output(\n                    instance_id=vm_['instance_id'],\n                    call='action',\n                    location=get_location(vm_)\n                )\n                pprint.pprint(console)\n                time.sleep(5)\n            output = salt.utils.stringutils.to_unicode(console['output_decoded'])\n            comps = output.split('-----BEGIN SSH HOST KEY KEYS-----')\n            if len(comps) < 2:\n                # Fail; there are no host keys\n                return False\n\n            comps = comps[1].split('-----END SSH HOST KEY KEYS-----')\n            keys = ''\n            for line in comps[0].splitlines():\n                if not line:\n                    continue\n                keys += '\\n{0} {1}'.format(ip_address, line)\n\n            with salt.utils.files.fopen(known_hosts_file, 'a') as fp_:\n                fp_.write(salt.utils.stringutils.to_str(keys))\n            fp_.close()\n\n        for user in vm_['usernames']:\n            if salt.utils.cloud.wait_for_passwd(\n                host=ip_address,\n                port=ssh_port,\n                username=user,\n                ssh_timeout=config.get_cloud_config_value(\n                    'wait_for_passwd_timeout', vm_, __opts__, default=1 * 60\n                ),\n                key_filename=vm_['key_filename'],\n                display_ssh_output=display_ssh_output,\n                gateway=ssh_gateway_config,\n                maxtries=config.get_cloud_config_value(\n                    'wait_for_passwd_maxtries', vm_, __opts__, default=15\n                ),\n                known_hosts_file=config.get_cloud_config_value(\n                    'known_hosts_file', vm_, __opts__,\n                    default='/dev/null'\n                ),\n            ):\n                __opts__['ssh_username'] = user\n                vm_['ssh_username'] = user\n                break\n        else:\n            raise SaltCloudSystemExit(\n                'Failed to authenticate against remote ssh'\n            )\n    else:\n        raise SaltCloudSystemExit(\n            'Failed to connect to remote ssh'\n        )\n\n    if 'reactor' in vm_ and vm_['reactor'] is True:\n        __utils__['cloud.fire_event'](\n            'event',\n            'ssh is available',\n            'salt/cloud/{0}/ssh_ready_reactor'.format(vm_['name']),\n            args={'ip_address': ip_address},\n            sock_dir=__opts__['sock_dir'],\n            transport=__opts__['transport']\n        )\n\n    return vm_", "code_tokens": ["def", "wait_for_instance", "(", "vm_", "=", "None", ",", "data", "=", "None", ",", "ip_address", "=", "None", ",", "display_ssh_output", "=", "True", ",", "call", "=", "None", ",", ")", ":", "if", "call", "==", "'function'", ":", "# Technically this function may be called other ways too, but it", "# definitely cannot be called with --function.", "raise", "SaltCloudSystemExit", "(", "'The wait_for_instance action must be called with -a or --action.'", ")", "if", "vm_", "is", "None", ":", "vm_", "=", "{", "}", "if", "data", "is", "None", ":", "data", "=", "{", "}", "ssh_gateway_config", "=", "vm_", ".", "get", "(", "'gateway'", ",", "get_ssh_gateway_config", "(", "vm_", ")", ")", "__utils__", "[", "'cloud.fire_event'", "]", "(", "'event'", ",", "'waiting for ssh'", ",", "'salt/cloud/{0}/waiting_for_ssh'", ".", "format", "(", "vm_", "[", "'name'", "]", ")", ",", "args", "=", "{", "'ip_address'", ":", "ip_address", "}", ",", "sock_dir", "=", "__opts__", "[", "'sock_dir'", "]", ",", "transport", "=", "__opts__", "[", "'transport'", "]", ")", "ssh_connect_timeout", "=", "config", ".", "get_cloud_config_value", "(", "'ssh_connect_timeout'", ",", "vm_", ",", "__opts__", ",", "900", "# 15 minutes", ")", "ssh_port", "=", "config", ".", "get_cloud_config_value", "(", "'ssh_port'", ",", "vm_", ",", "__opts__", ",", "22", ")", "if", "config", ".", "get_cloud_config_value", "(", "'win_installer'", ",", "vm_", ",", "__opts__", ")", ":", "username", "=", "config", ".", "get_cloud_config_value", "(", "'win_username'", ",", "vm_", ",", "__opts__", ",", "default", "=", "'Administrator'", ")", "win_passwd", "=", "config", ".", "get_cloud_config_value", "(", "'win_password'", ",", "vm_", ",", "__opts__", ",", "default", "=", "''", ")", "win_deploy_auth_retries", "=", "config", ".", "get_cloud_config_value", "(", "'win_deploy_auth_retries'", ",", "vm_", ",", "__opts__", ",", "default", "=", "10", ")", "win_deploy_auth_retry_delay", "=", "config", ".", "get_cloud_config_value", "(", "'win_deploy_auth_retry_delay'", ",", "vm_", ",", "__opts__", ",", "default", "=", "1", ")", "use_winrm", "=", "config", ".", "get_cloud_config_value", "(", "'use_winrm'", ",", "vm_", ",", "__opts__", ",", "default", "=", "False", ")", "winrm_verify_ssl", "=", "config", ".", "get_cloud_config_value", "(", "'winrm_verify_ssl'", ",", "vm_", ",", "__opts__", ",", "default", "=", "True", ")", "if", "win_passwd", "and", "win_passwd", "==", "'auto'", ":", "log", ".", "debug", "(", "'Waiting for auto-generated Windows EC2 password'", ")", "while", "True", ":", "password_data", "=", "get_password_data", "(", "name", "=", "vm_", "[", "'name'", "]", ",", "kwargs", "=", "{", "'key_file'", ":", "vm_", "[", "'private_key'", "]", ",", "}", ",", "call", "=", "'action'", ",", ")", "win_passwd", "=", "password_data", ".", "get", "(", "'password'", ",", "None", ")", "if", "win_passwd", "is", "None", ":", "log", ".", "debug", "(", "password_data", ")", "# This wait is so high, because the password is unlikely to", "# be generated for at least 4 minutes", "time", ".", "sleep", "(", "60", ")", "else", ":", "logging_data", "=", "password_data", "logging_data", "[", "'password'", "]", "=", "'XXX-REDACTED-XXX'", "logging_data", "[", "'passwordData'", "]", "=", "'XXX-REDACTED-XXX'", "log", ".", "debug", "(", "logging_data", ")", "vm_", "[", "'win_password'", "]", "=", "win_passwd", "break", "# SMB used whether psexec or winrm", "if", "not", "salt", ".", "utils", ".", "cloud", ".", "wait_for_port", "(", "ip_address", ",", "port", "=", "445", ",", "timeout", "=", "ssh_connect_timeout", ")", ":", "raise", "SaltCloudSystemExit", "(", "'Failed to connect to remote windows host'", ")", "# If not using winrm keep same psexec behavior", "if", "not", "use_winrm", ":", "log", ".", "debug", "(", "'Trying to authenticate via SMB using psexec'", ")", "if", "not", "salt", ".", "utils", ".", "cloud", ".", "validate_windows_cred", "(", "ip_address", ",", "username", ",", "win_passwd", ",", "retries", "=", "win_deploy_auth_retries", ",", "retry_delay", "=", "win_deploy_auth_retry_delay", ")", ":", "raise", "SaltCloudSystemExit", "(", "'Failed to authenticate against remote windows host (smb)'", ")", "# If using winrm", "else", ":", "# Default HTTPS port can be changed in cloud configuration", "winrm_port", "=", "config", ".", "get_cloud_config_value", "(", "'winrm_port'", ",", "vm_", ",", "__opts__", ",", "default", "=", "5986", ")", "# Wait for winrm port to be available", "if", "not", "salt", ".", "utils", ".", "cloud", ".", "wait_for_port", "(", "ip_address", ",", "port", "=", "winrm_port", ",", "timeout", "=", "ssh_connect_timeout", ")", ":", "raise", "SaltCloudSystemExit", "(", "'Failed to connect to remote windows host (winrm)'", ")", "log", ".", "debug", "(", "'Trying to authenticate via Winrm using pywinrm'", ")", "if", "not", "salt", ".", "utils", ".", "cloud", ".", "wait_for_winrm", "(", "ip_address", ",", "winrm_port", ",", "username", ",", "win_passwd", ",", "timeout", "=", "ssh_connect_timeout", ",", "verify", "=", "winrm_verify_ssl", ")", ":", "raise", "SaltCloudSystemExit", "(", "'Failed to authenticate against remote windows host'", ")", "elif", "salt", ".", "utils", ".", "cloud", ".", "wait_for_port", "(", "ip_address", ",", "port", "=", "ssh_port", ",", "timeout", "=", "ssh_connect_timeout", ",", "gateway", "=", "ssh_gateway_config", ")", ":", "# If a known_hosts_file is configured, this instance will not be", "# accessible until it has a host key. Since this is provided on", "# supported instances by cloud-init, and viewable to us only from the", "# console output (which may take several minutes to become available,", "# we have some more waiting to do here.", "known_hosts_file", "=", "config", ".", "get_cloud_config_value", "(", "'known_hosts_file'", ",", "vm_", ",", "__opts__", ",", "default", "=", "None", ")", "if", "known_hosts_file", ":", "console", "=", "{", "}", "while", "'output_decoded'", "not", "in", "console", ":", "console", "=", "get_console_output", "(", "instance_id", "=", "vm_", "[", "'instance_id'", "]", ",", "call", "=", "'action'", ",", "location", "=", "get_location", "(", "vm_", ")", ")", "pprint", ".", "pprint", "(", "console", ")", "time", ".", "sleep", "(", "5", ")", "output", "=", "salt", ".", "utils", ".", "stringutils", ".", "to_unicode", "(", "console", "[", "'output_decoded'", "]", ")", "comps", "=", "output", ".", "split", "(", "'-----BEGIN SSH HOST KEY KEYS-----'", ")", "if", "len", "(", "comps", ")", "<", "2", ":", "# Fail; there are no host keys", "return", "False", "comps", "=", "comps", "[", "1", "]", ".", "split", "(", "'-----END SSH HOST KEY KEYS-----'", ")", "keys", "=", "''", "for", "line", "in", "comps", "[", "0", "]", ".", "splitlines", "(", ")", ":", "if", "not", "line", ":", "continue", "keys", "+=", "'\\n{0} {1}'", ".", "format", "(", "ip_address", ",", "line", ")", "with", "salt", ".", "utils", ".", "files", ".", "fopen", "(", "known_hosts_file", ",", "'a'", ")", "as", "fp_", ":", "fp_", ".", "write", "(", "salt", ".", "utils", ".", "stringutils", ".", "to_str", "(", "keys", ")", ")", "fp_", ".", "close", "(", ")", "for", "user", "in", "vm_", "[", "'usernames'", "]", ":", "if", "salt", ".", "utils", ".", "cloud", ".", "wait_for_passwd", "(", "host", "=", "ip_address", ",", "port", "=", "ssh_port", ",", "username", "=", "user", ",", "ssh_timeout", "=", "config", ".", "get_cloud_config_value", "(", "'wait_for_passwd_timeout'", ",", "vm_", ",", "__opts__", ",", "default", "=", "1", "*", "60", ")", ",", "key_filename", "=", "vm_", "[", "'key_filename'", "]", ",", "display_ssh_output", "=", "display_ssh_output", ",", "gateway", "=", "ssh_gateway_config", ",", "maxtries", "=", "config", ".", "get_cloud_config_value", "(", "'wait_for_passwd_maxtries'", ",", "vm_", ",", "__opts__", ",", "default", "=", "15", ")", ",", "known_hosts_file", "=", "config", ".", "get_cloud_config_value", "(", "'known_hosts_file'", ",", "vm_", ",", "__opts__", ",", "default", "=", "'/dev/null'", ")", ",", ")", ":", "__opts__", "[", "'ssh_username'", "]", "=", "user", "vm_", "[", "'ssh_username'", "]", "=", "user", "break", "else", ":", "raise", "SaltCloudSystemExit", "(", "'Failed to authenticate against remote ssh'", ")", "else", ":", "raise", "SaltCloudSystemExit", "(", "'Failed to connect to remote ssh'", ")", "if", "'reactor'", "in", "vm_", "and", "vm_", "[", "'reactor'", "]", "is", "True", ":", "__utils__", "[", "'cloud.fire_event'", "]", "(", "'event'", ",", "'ssh is available'", ",", "'salt/cloud/{0}/ssh_ready_reactor'", ".", "format", "(", "vm_", "[", "'name'", "]", ")", ",", "args", "=", "{", "'ip_address'", ":", "ip_address", "}", ",", "sock_dir", "=", "__opts__", "[", "'sock_dir'", "]", ",", "transport", "=", "__opts__", "[", "'transport'", "]", ")", "return", "vm_"], "docstring": "Wait for an instance upon creation from the EC2 API, to become available", "docstring_tokens": ["Wait", "for", "an", "instance", "upon", "creation", "from", "the", "EC2", "API", "to", "become", "available"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/cloud/clouds/ec2.py#L2307-L2527", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/cloud/clouds/ec2.py", "func_name": "create", "original_string": "def create(vm_=None, call=None):\n    '''\n    Create a single VM from a data dict\n    '''\n    if call:\n        raise SaltCloudSystemExit(\n            'You cannot create an instance with -a or -f.'\n        )\n\n    try:\n        # Check for required profile parameters before sending any API calls.\n        if vm_['profile'] and config.is_profile_configured(__opts__,\n                                                           __active_provider_name__ or 'ec2',\n                                                           vm_['profile'],\n                                                           vm_=vm_) is False:\n            return False\n    except AttributeError:\n        pass\n\n    # Check for private_key and keyfile name for bootstrapping new instances\n    deploy = config.get_cloud_config_value(\n        'deploy', vm_, __opts__, default=True\n    )\n    win_password = config.get_cloud_config_value(\n        'win_password', vm_, __opts__, default=''\n    )\n    key_filename = config.get_cloud_config_value(\n        'private_key', vm_, __opts__, search_global=False, default=None\n    )\n    if deploy:\n        # The private_key and keyname settings are only needed for bootstrapping\n        # new instances when deploy is True\n        _validate_key_path_and_mode(key_filename)\n\n    __utils__['cloud.fire_event'](\n        'event',\n        'starting create',\n        'salt/cloud/{0}/creating'.format(vm_['name']),\n        args=__utils__['cloud.filter_event']('creating', vm_, ['name', 'profile', 'provider', 'driver']),\n        sock_dir=__opts__['sock_dir'],\n        transport=__opts__['transport']\n    )\n    __utils__['cloud.cachedir_index_add'](\n        vm_['name'], vm_['profile'], 'ec2', vm_['driver']\n    )\n\n    vm_['key_filename'] = key_filename\n    # wait_for_instance requires private_key\n    vm_['private_key'] = key_filename\n\n    # Get SSH Gateway config early to verify the private_key,\n    # if used, exists or not. We don't want to deploy an instance\n    # and not be able to access it via the gateway.\n    vm_['gateway'] = get_ssh_gateway_config(vm_)\n\n    location = get_location(vm_)\n    vm_['location'] = location\n\n    log.info('Creating Cloud VM %s in %s', vm_['name'], location)\n    vm_['usernames'] = salt.utils.cloud.ssh_usernames(\n        vm_,\n        __opts__,\n        default_users=(\n            'ec2-user',  # Amazon Linux, Fedora, RHEL; FreeBSD\n            'centos',    # CentOS AMIs from AWS Marketplace\n            'ubuntu',    # Ubuntu\n            'admin',     # Debian GNU/Linux\n            'bitnami',   # BitNami AMIs\n            'root'       # Last resort, default user on RHEL 5, SUSE\n        )\n    )\n\n    if 'instance_id' in vm_:\n        # This was probably created via another process, and doesn't have\n        # things like salt keys created yet, so let's create them now.\n        if 'pub_key' not in vm_ and 'priv_key' not in vm_:\n            log.debug('Generating minion keys for \\'%s\\'', vm_['name'])\n            vm_['priv_key'], vm_['pub_key'] = salt.utils.cloud.gen_keys(\n                salt.config.get_cloud_config_value(\n                    'keysize',\n                    vm_,\n                    __opts__\n                )\n            )\n    else:\n        # Put together all of the information required to request the instance,\n        # and then fire off the request for it\n        if keyname(vm_) is None:\n            raise SaltCloudSystemExit(\n                'The required \\'keyname\\' configuration setting is missing from the '\n                '\\'ec2\\' driver.'\n            )\n\n        data, vm_ = request_instance(vm_, location)\n\n        # If data is a str, it's an error\n        if isinstance(data, six.string_types):\n            log.error('Error requesting instance: %s', data)\n            return {}\n\n        # Pull the instance ID, valid for both spot and normal instances\n\n        # Multiple instances may have been spun up, get all their IDs\n        vm_['instance_id_list'] = []\n        for instance in data:\n            vm_['instance_id_list'].append(instance['instanceId'])\n\n        vm_['instance_id'] = vm_['instance_id_list'].pop()\n        if vm_['instance_id_list']:\n            # Multiple instances were spun up, get one now, and queue the rest\n            queue_instances(vm_['instance_id_list'])\n\n    # Wait for vital information, such as IP addresses, to be available\n    # for the new instance\n    data = query_instance(vm_)\n\n    # Now that the instance is available, tag it appropriately. Should\n    # mitigate race conditions with tags\n    tags = config.get_cloud_config_value('tag',\n                                         vm_,\n                                         __opts__,\n                                         {},\n                                         search_global=False)\n    if not isinstance(tags, dict):\n        raise SaltCloudConfigError(\n            '\\'tag\\' should be a dict.'\n        )\n\n    for value in six.itervalues(tags):\n        if not isinstance(value, six.string_types):\n            raise SaltCloudConfigError(\n                '\\'tag\\' values must be strings. Try quoting the values. '\n                'e.g. \"2013-09-19T20:09:46Z\".'\n            )\n\n    tags['Name'] = vm_['name']\n\n    __utils__['cloud.fire_event'](\n        'event',\n        'setting tags',\n        'salt/cloud/{0}/tagging'.format(vm_['name']),\n        args={'tags': tags},\n        sock_dir=__opts__['sock_dir'],\n        transport=__opts__['transport']\n    )\n\n    salt.utils.cloud.wait_for_fun(\n        set_tags,\n        timeout=30,\n        name=vm_['name'],\n        tags=tags,\n        instance_id=vm_['instance_id'],\n        call='action',\n        location=location\n    )\n\n    # Once instance tags are set, tag the spot request if configured\n    if 'spot_config' in vm_ and 'tag' in vm_['spot_config']:\n\n        if not isinstance(vm_['spot_config']['tag'], dict):\n            raise SaltCloudConfigError(\n                '\\'tag\\' should be a dict.'\n            )\n\n        for value in six.itervalues(vm_['spot_config']['tag']):\n            if not isinstance(value, str):\n                raise SaltCloudConfigError(\n                    '\\'tag\\' values must be strings. Try quoting the values. '\n                    'e.g. \"2013-09-19T20:09:46Z\".'\n                )\n\n        spot_request_tags = {}\n\n        if 'spotRequestId' not in vm_:\n            raise SaltCloudConfigError('Failed to find spotRequestId')\n\n        sir_id = vm_['spotRequestId']\n\n        spot_request_tags['Name'] = vm_['name']\n\n        for k, v in six.iteritems(vm_['spot_config']['tag']):\n            spot_request_tags[k] = v\n\n        __utils__['cloud.fire_event'](\n            'event',\n            'setting tags',\n            'salt/cloud/spot_request_{0}/tagging'.format(sir_id),\n            args={'tags': spot_request_tags},\n            sock_dir=__opts__['sock_dir'],\n            transport=__opts__['transport']\n        )\n        salt.utils.cloud.wait_for_fun(\n            set_tags,\n            timeout=30,\n            name=vm_['name'],\n            tags=spot_request_tags,\n            instance_id=sir_id,\n            call='action',\n            location=location\n        )\n\n    network_interfaces = config.get_cloud_config_value(\n        'network_interfaces',\n        vm_,\n        __opts__,\n        search_global=False\n    )\n\n    if network_interfaces:\n        _update_enis(network_interfaces, data, vm_)\n\n    # At this point, the node is created and tagged, and now needs to be\n    # bootstrapped, once the necessary port is available.\n    log.info('Created node %s', vm_['name'])\n\n    instance = data[0]['instancesSet']['item']\n\n    # Wait for the necessary port to become available to bootstrap\n    if ssh_interface(vm_) == 'private_ips':\n        ip_address = instance['privateIpAddress']\n        log.info('Salt node data. Private_ip: %s', ip_address)\n    else:\n        ip_address = instance['ipAddress']\n        log.info('Salt node data. Public_ip: %s', ip_address)\n    vm_['ssh_host'] = ip_address\n\n    if salt.utils.cloud.get_salt_interface(vm_, __opts__) == 'private_ips':\n        salt_ip_address = instance['privateIpAddress']\n        log.info('Salt interface set to: %s', salt_ip_address)\n    else:\n        salt_ip_address = instance['ipAddress']\n        log.debug('Salt interface set to: %s', salt_ip_address)\n    vm_['salt_host'] = salt_ip_address\n\n    if deploy:\n        display_ssh_output = config.get_cloud_config_value(\n            'display_ssh_output', vm_, __opts__, default=True\n        )\n\n        vm_ = wait_for_instance(\n            vm_, data, ip_address, display_ssh_output\n        )\n\n    # The instance is booted and accessible, let's Salt it!\n    ret = instance.copy()\n\n    # Get ANY defined volumes settings, merging data, in the following order\n    # 1. VM config\n    # 2. Profile config\n    # 3. Global configuration\n    volumes = config.get_cloud_config_value(\n        'volumes', vm_, __opts__, search_global=True\n    )\n    if volumes:\n        __utils__['cloud.fire_event'](\n            'event',\n            'attaching volumes',\n            'salt/cloud/{0}/attaching_volumes'.format(vm_['name']),\n            args={'volumes': volumes},\n            sock_dir=__opts__['sock_dir'],\n            transport=__opts__['transport']\n        )\n\n        log.info('Create and attach volumes to node %s', vm_['name'])\n        created = create_attach_volumes(\n            vm_['name'],\n            {\n                'volumes': volumes,\n                'zone': ret['placement']['availabilityZone'],\n                'instance_id': ret['instanceId'],\n                'del_all_vols_on_destroy': vm_.get('del_all_vols_on_destroy', False)\n            },\n            call='action'\n        )\n        ret['Attached Volumes'] = created\n\n    # Associate instance with a ssm document, if present\n    ssm_document = config.get_cloud_config_value(\n        'ssm_document', vm_, __opts__, None, search_global=False\n    )\n    if ssm_document:\n        log.debug('Associating with ssm document: %s', ssm_document)\n        assoc = ssm_create_association(\n            vm_['name'],\n            {'ssm_document': ssm_document},\n            instance_id=vm_['instance_id'],\n            call='action'\n        )\n        if isinstance(assoc, dict) and assoc.get('error', None):\n            log.error(\n                'Failed to associate instance %s with ssm document %s',\n                vm_['instance_id'], ssm_document\n            )\n            return {}\n\n    for key, value in six.iteritems(__utils__['cloud.bootstrap'](vm_, __opts__)):\n        ret.setdefault(key, value)\n\n    log.info('Created Cloud VM \\'%s\\'', vm_['name'])\n    log.debug(\n        '\\'%s\\' VM creation details:\\n%s',\n        vm_['name'], pprint.pformat(instance)\n    )\n\n    event_data = {\n        'name': vm_['name'],\n        'profile': vm_['profile'],\n        'provider': vm_['driver'],\n        'instance_id': vm_['instance_id'],\n    }\n    if volumes:\n        event_data['volumes'] = volumes\n    if ssm_document:\n        event_data['ssm_document'] = ssm_document\n\n    __utils__['cloud.fire_event'](\n        'event',\n        'created instance',\n        'salt/cloud/{0}/created'.format(vm_['name']),\n        args=__utils__['cloud.filter_event']('created', event_data, list(event_data)),\n        sock_dir=__opts__['sock_dir'],\n        transport=__opts__['transport']\n    )\n\n    # Ensure that the latest node data is returned\n    node = _get_node(instance_id=vm_['instance_id'])\n    __utils__['cloud.cache_node'](node, __active_provider_name__, __opts__)\n    ret.update(node)\n\n    # Add any block device tags specified\n    ex_blockdevicetags = {}\n    blockdevicemappings_holder = block_device_mappings(vm_)\n    if blockdevicemappings_holder:\n        for _bd in blockdevicemappings_holder:\n            if 'tag' in _bd:\n                ex_blockdevicetags[_bd['DeviceName']] = _bd['tag']\n\n    block_device_volume_id_map = {}\n\n    if ex_blockdevicetags:\n        for _device, _map in six.iteritems(ret['blockDeviceMapping']):\n            bd_items = []\n            if isinstance(_map, dict):\n                bd_items.append(_map)\n            else:\n                for mapitem in _map:\n                    bd_items.append(mapitem)\n\n            for blockitem in bd_items:\n                if blockitem['deviceName'] in ex_blockdevicetags and 'Name' not in ex_blockdevicetags[blockitem['deviceName']]:\n                    ex_blockdevicetags[blockitem['deviceName']]['Name'] = vm_['name']\n                if blockitem['deviceName'] in ex_blockdevicetags:\n                    block_device_volume_id_map[blockitem[ret['rootDeviceType']]['volumeId']] = ex_blockdevicetags[blockitem['deviceName']]\n\n    if block_device_volume_id_map:\n\n        for volid, tags in six.iteritems(block_device_volume_id_map):\n            __utils__['cloud.fire_event'](\n                'event',\n                'setting tags',\n                'salt/cloud/block_volume_{0}/tagging'.format(str(volid)),\n                args={'tags': tags},\n                sock_dir=__opts__['sock_dir'],\n                transport=__opts__['transport']\n            )\n\n            __utils__['cloud.wait_for_fun'](\n                set_tags,\n                timeout=30,\n                name=vm_['name'],\n                tags=tags,\n                resource_id=volid,\n                call='action',\n                location=location\n            )\n\n    return ret", "language": "python", "code": "def create(vm_=None, call=None):\n    '''\n    Create a single VM from a data dict\n    '''\n    if call:\n        raise SaltCloudSystemExit(\n            'You cannot create an instance with -a or -f.'\n        )\n\n    try:\n        # Check for required profile parameters before sending any API calls.\n        if vm_['profile'] and config.is_profile_configured(__opts__,\n                                                           __active_provider_name__ or 'ec2',\n                                                           vm_['profile'],\n                                                           vm_=vm_) is False:\n            return False\n    except AttributeError:\n        pass\n\n    # Check for private_key and keyfile name for bootstrapping new instances\n    deploy = config.get_cloud_config_value(\n        'deploy', vm_, __opts__, default=True\n    )\n    win_password = config.get_cloud_config_value(\n        'win_password', vm_, __opts__, default=''\n    )\n    key_filename = config.get_cloud_config_value(\n        'private_key', vm_, __opts__, search_global=False, default=None\n    )\n    if deploy:\n        # The private_key and keyname settings are only needed for bootstrapping\n        # new instances when deploy is True\n        _validate_key_path_and_mode(key_filename)\n\n    __utils__['cloud.fire_event'](\n        'event',\n        'starting create',\n        'salt/cloud/{0}/creating'.format(vm_['name']),\n        args=__utils__['cloud.filter_event']('creating', vm_, ['name', 'profile', 'provider', 'driver']),\n        sock_dir=__opts__['sock_dir'],\n        transport=__opts__['transport']\n    )\n    __utils__['cloud.cachedir_index_add'](\n        vm_['name'], vm_['profile'], 'ec2', vm_['driver']\n    )\n\n    vm_['key_filename'] = key_filename\n    # wait_for_instance requires private_key\n    vm_['private_key'] = key_filename\n\n    # Get SSH Gateway config early to verify the private_key,\n    # if used, exists or not. We don't want to deploy an instance\n    # and not be able to access it via the gateway.\n    vm_['gateway'] = get_ssh_gateway_config(vm_)\n\n    location = get_location(vm_)\n    vm_['location'] = location\n\n    log.info('Creating Cloud VM %s in %s', vm_['name'], location)\n    vm_['usernames'] = salt.utils.cloud.ssh_usernames(\n        vm_,\n        __opts__,\n        default_users=(\n            'ec2-user',  # Amazon Linux, Fedora, RHEL; FreeBSD\n            'centos',    # CentOS AMIs from AWS Marketplace\n            'ubuntu',    # Ubuntu\n            'admin',     # Debian GNU/Linux\n            'bitnami',   # BitNami AMIs\n            'root'       # Last resort, default user on RHEL 5, SUSE\n        )\n    )\n\n    if 'instance_id' in vm_:\n        # This was probably created via another process, and doesn't have\n        # things like salt keys created yet, so let's create them now.\n        if 'pub_key' not in vm_ and 'priv_key' not in vm_:\n            log.debug('Generating minion keys for \\'%s\\'', vm_['name'])\n            vm_['priv_key'], vm_['pub_key'] = salt.utils.cloud.gen_keys(\n                salt.config.get_cloud_config_value(\n                    'keysize',\n                    vm_,\n                    __opts__\n                )\n            )\n    else:\n        # Put together all of the information required to request the instance,\n        # and then fire off the request for it\n        if keyname(vm_) is None:\n            raise SaltCloudSystemExit(\n                'The required \\'keyname\\' configuration setting is missing from the '\n                '\\'ec2\\' driver.'\n            )\n\n        data, vm_ = request_instance(vm_, location)\n\n        # If data is a str, it's an error\n        if isinstance(data, six.string_types):\n            log.error('Error requesting instance: %s', data)\n            return {}\n\n        # Pull the instance ID, valid for both spot and normal instances\n\n        # Multiple instances may have been spun up, get all their IDs\n        vm_['instance_id_list'] = []\n        for instance in data:\n            vm_['instance_id_list'].append(instance['instanceId'])\n\n        vm_['instance_id'] = vm_['instance_id_list'].pop()\n        if vm_['instance_id_list']:\n            # Multiple instances were spun up, get one now, and queue the rest\n            queue_instances(vm_['instance_id_list'])\n\n    # Wait for vital information, such as IP addresses, to be available\n    # for the new instance\n    data = query_instance(vm_)\n\n    # Now that the instance is available, tag it appropriately. Should\n    # mitigate race conditions with tags\n    tags = config.get_cloud_config_value('tag',\n                                         vm_,\n                                         __opts__,\n                                         {},\n                                         search_global=False)\n    if not isinstance(tags, dict):\n        raise SaltCloudConfigError(\n            '\\'tag\\' should be a dict.'\n        )\n\n    for value in six.itervalues(tags):\n        if not isinstance(value, six.string_types):\n            raise SaltCloudConfigError(\n                '\\'tag\\' values must be strings. Try quoting the values. '\n                'e.g. \"2013-09-19T20:09:46Z\".'\n            )\n\n    tags['Name'] = vm_['name']\n\n    __utils__['cloud.fire_event'](\n        'event',\n        'setting tags',\n        'salt/cloud/{0}/tagging'.format(vm_['name']),\n        args={'tags': tags},\n        sock_dir=__opts__['sock_dir'],\n        transport=__opts__['transport']\n    )\n\n    salt.utils.cloud.wait_for_fun(\n        set_tags,\n        timeout=30,\n        name=vm_['name'],\n        tags=tags,\n        instance_id=vm_['instance_id'],\n        call='action',\n        location=location\n    )\n\n    # Once instance tags are set, tag the spot request if configured\n    if 'spot_config' in vm_ and 'tag' in vm_['spot_config']:\n\n        if not isinstance(vm_['spot_config']['tag'], dict):\n            raise SaltCloudConfigError(\n                '\\'tag\\' should be a dict.'\n            )\n\n        for value in six.itervalues(vm_['spot_config']['tag']):\n            if not isinstance(value, str):\n                raise SaltCloudConfigError(\n                    '\\'tag\\' values must be strings. Try quoting the values. '\n                    'e.g. \"2013-09-19T20:09:46Z\".'\n                )\n\n        spot_request_tags = {}\n\n        if 'spotRequestId' not in vm_:\n            raise SaltCloudConfigError('Failed to find spotRequestId')\n\n        sir_id = vm_['spotRequestId']\n\n        spot_request_tags['Name'] = vm_['name']\n\n        for k, v in six.iteritems(vm_['spot_config']['tag']):\n            spot_request_tags[k] = v\n\n        __utils__['cloud.fire_event'](\n            'event',\n            'setting tags',\n            'salt/cloud/spot_request_{0}/tagging'.format(sir_id),\n            args={'tags': spot_request_tags},\n            sock_dir=__opts__['sock_dir'],\n            transport=__opts__['transport']\n        )\n        salt.utils.cloud.wait_for_fun(\n            set_tags,\n            timeout=30,\n            name=vm_['name'],\n            tags=spot_request_tags,\n            instance_id=sir_id,\n            call='action',\n            location=location\n        )\n\n    network_interfaces = config.get_cloud_config_value(\n        'network_interfaces',\n        vm_,\n        __opts__,\n        search_global=False\n    )\n\n    if network_interfaces:\n        _update_enis(network_interfaces, data, vm_)\n\n    # At this point, the node is created and tagged, and now needs to be\n    # bootstrapped, once the necessary port is available.\n    log.info('Created node %s', vm_['name'])\n\n    instance = data[0]['instancesSet']['item']\n\n    # Wait for the necessary port to become available to bootstrap\n    if ssh_interface(vm_) == 'private_ips':\n        ip_address = instance['privateIpAddress']\n        log.info('Salt node data. Private_ip: %s', ip_address)\n    else:\n        ip_address = instance['ipAddress']\n        log.info('Salt node data. Public_ip: %s', ip_address)\n    vm_['ssh_host'] = ip_address\n\n    if salt.utils.cloud.get_salt_interface(vm_, __opts__) == 'private_ips':\n        salt_ip_address = instance['privateIpAddress']\n        log.info('Salt interface set to: %s', salt_ip_address)\n    else:\n        salt_ip_address = instance['ipAddress']\n        log.debug('Salt interface set to: %s', salt_ip_address)\n    vm_['salt_host'] = salt_ip_address\n\n    if deploy:\n        display_ssh_output = config.get_cloud_config_value(\n            'display_ssh_output', vm_, __opts__, default=True\n        )\n\n        vm_ = wait_for_instance(\n            vm_, data, ip_address, display_ssh_output\n        )\n\n    # The instance is booted and accessible, let's Salt it!\n    ret = instance.copy()\n\n    # Get ANY defined volumes settings, merging data, in the following order\n    # 1. VM config\n    # 2. Profile config\n    # 3. Global configuration\n    volumes = config.get_cloud_config_value(\n        'volumes', vm_, __opts__, search_global=True\n    )\n    if volumes:\n        __utils__['cloud.fire_event'](\n            'event',\n            'attaching volumes',\n            'salt/cloud/{0}/attaching_volumes'.format(vm_['name']),\n            args={'volumes': volumes},\n            sock_dir=__opts__['sock_dir'],\n            transport=__opts__['transport']\n        )\n\n        log.info('Create and attach volumes to node %s', vm_['name'])\n        created = create_attach_volumes(\n            vm_['name'],\n            {\n                'volumes': volumes,\n                'zone': ret['placement']['availabilityZone'],\n                'instance_id': ret['instanceId'],\n                'del_all_vols_on_destroy': vm_.get('del_all_vols_on_destroy', False)\n            },\n            call='action'\n        )\n        ret['Attached Volumes'] = created\n\n    # Associate instance with a ssm document, if present\n    ssm_document = config.get_cloud_config_value(\n        'ssm_document', vm_, __opts__, None, search_global=False\n    )\n    if ssm_document:\n        log.debug('Associating with ssm document: %s', ssm_document)\n        assoc = ssm_create_association(\n            vm_['name'],\n            {'ssm_document': ssm_document},\n            instance_id=vm_['instance_id'],\n            call='action'\n        )\n        if isinstance(assoc, dict) and assoc.get('error', None):\n            log.error(\n                'Failed to associate instance %s with ssm document %s',\n                vm_['instance_id'], ssm_document\n            )\n            return {}\n\n    for key, value in six.iteritems(__utils__['cloud.bootstrap'](vm_, __opts__)):\n        ret.setdefault(key, value)\n\n    log.info('Created Cloud VM \\'%s\\'', vm_['name'])\n    log.debug(\n        '\\'%s\\' VM creation details:\\n%s',\n        vm_['name'], pprint.pformat(instance)\n    )\n\n    event_data = {\n        'name': vm_['name'],\n        'profile': vm_['profile'],\n        'provider': vm_['driver'],\n        'instance_id': vm_['instance_id'],\n    }\n    if volumes:\n        event_data['volumes'] = volumes\n    if ssm_document:\n        event_data['ssm_document'] = ssm_document\n\n    __utils__['cloud.fire_event'](\n        'event',\n        'created instance',\n        'salt/cloud/{0}/created'.format(vm_['name']),\n        args=__utils__['cloud.filter_event']('created', event_data, list(event_data)),\n        sock_dir=__opts__['sock_dir'],\n        transport=__opts__['transport']\n    )\n\n    # Ensure that the latest node data is returned\n    node = _get_node(instance_id=vm_['instance_id'])\n    __utils__['cloud.cache_node'](node, __active_provider_name__, __opts__)\n    ret.update(node)\n\n    # Add any block device tags specified\n    ex_blockdevicetags = {}\n    blockdevicemappings_holder = block_device_mappings(vm_)\n    if blockdevicemappings_holder:\n        for _bd in blockdevicemappings_holder:\n            if 'tag' in _bd:\n                ex_blockdevicetags[_bd['DeviceName']] = _bd['tag']\n\n    block_device_volume_id_map = {}\n\n    if ex_blockdevicetags:\n        for _device, _map in six.iteritems(ret['blockDeviceMapping']):\n            bd_items = []\n            if isinstance(_map, dict):\n                bd_items.append(_map)\n            else:\n                for mapitem in _map:\n                    bd_items.append(mapitem)\n\n            for blockitem in bd_items:\n                if blockitem['deviceName'] in ex_blockdevicetags and 'Name' not in ex_blockdevicetags[blockitem['deviceName']]:\n                    ex_blockdevicetags[blockitem['deviceName']]['Name'] = vm_['name']\n                if blockitem['deviceName'] in ex_blockdevicetags:\n                    block_device_volume_id_map[blockitem[ret['rootDeviceType']]['volumeId']] = ex_blockdevicetags[blockitem['deviceName']]\n\n    if block_device_volume_id_map:\n\n        for volid, tags in six.iteritems(block_device_volume_id_map):\n            __utils__['cloud.fire_event'](\n                'event',\n                'setting tags',\n                'salt/cloud/block_volume_{0}/tagging'.format(str(volid)),\n                args={'tags': tags},\n                sock_dir=__opts__['sock_dir'],\n                transport=__opts__['transport']\n            )\n\n            __utils__['cloud.wait_for_fun'](\n                set_tags,\n                timeout=30,\n                name=vm_['name'],\n                tags=tags,\n                resource_id=volid,\n                call='action',\n                location=location\n            )\n\n    return ret", "code_tokens": ["def", "create", "(", "vm_", "=", "None", ",", "call", "=", "None", ")", ":", "if", "call", ":", "raise", "SaltCloudSystemExit", "(", "'You cannot create an instance with -a or -f.'", ")", "try", ":", "# Check for required profile parameters before sending any API calls.", "if", "vm_", "[", "'profile'", "]", "and", "config", ".", "is_profile_configured", "(", "__opts__", ",", "__active_provider_name__", "or", "'ec2'", ",", "vm_", "[", "'profile'", "]", ",", "vm_", "=", "vm_", ")", "is", "False", ":", "return", "False", "except", "AttributeError", ":", "pass", "# Check for private_key and keyfile name for bootstrapping new instances", "deploy", "=", "config", ".", "get_cloud_config_value", "(", "'deploy'", ",", "vm_", ",", "__opts__", ",", "default", "=", "True", ")", "win_password", "=", "config", ".", "get_cloud_config_value", "(", "'win_password'", ",", "vm_", ",", "__opts__", ",", "default", "=", "''", ")", "key_filename", "=", "config", ".", "get_cloud_config_value", "(", "'private_key'", ",", "vm_", ",", "__opts__", ",", "search_global", "=", "False", ",", "default", "=", "None", ")", "if", "deploy", ":", "# The private_key and keyname settings are only needed for bootstrapping", "# new instances when deploy is True", "_validate_key_path_and_mode", "(", "key_filename", ")", "__utils__", "[", "'cloud.fire_event'", "]", "(", "'event'", ",", "'starting create'", ",", "'salt/cloud/{0}/creating'", ".", "format", "(", "vm_", "[", "'name'", "]", ")", ",", "args", "=", "__utils__", "[", "'cloud.filter_event'", "]", "(", "'creating'", ",", "vm_", ",", "[", "'name'", ",", "'profile'", ",", "'provider'", ",", "'driver'", "]", ")", ",", "sock_dir", "=", "__opts__", "[", "'sock_dir'", "]", ",", "transport", "=", "__opts__", "[", "'transport'", "]", ")", "__utils__", "[", "'cloud.cachedir_index_add'", "]", "(", "vm_", "[", "'name'", "]", ",", "vm_", "[", "'profile'", "]", ",", "'ec2'", ",", "vm_", "[", "'driver'", "]", ")", "vm_", "[", "'key_filename'", "]", "=", "key_filename", "# wait_for_instance requires private_key", "vm_", "[", "'private_key'", "]", "=", "key_filename", "# Get SSH Gateway config early to verify the private_key,", "# if used, exists or not. We don't want to deploy an instance", "# and not be able to access it via the gateway.", "vm_", "[", "'gateway'", "]", "=", "get_ssh_gateway_config", "(", "vm_", ")", "location", "=", "get_location", "(", "vm_", ")", "vm_", "[", "'location'", "]", "=", "location", "log", ".", "info", "(", "'Creating Cloud VM %s in %s'", ",", "vm_", "[", "'name'", "]", ",", "location", ")", "vm_", "[", "'usernames'", "]", "=", "salt", ".", "utils", ".", "cloud", ".", "ssh_usernames", "(", "vm_", ",", "__opts__", ",", "default_users", "=", "(", "'ec2-user'", ",", "# Amazon Linux, Fedora, RHEL; FreeBSD", "'centos'", ",", "# CentOS AMIs from AWS Marketplace", "'ubuntu'", ",", "# Ubuntu", "'admin'", ",", "# Debian GNU/Linux", "'bitnami'", ",", "# BitNami AMIs", "'root'", "# Last resort, default user on RHEL 5, SUSE", ")", ")", "if", "'instance_id'", "in", "vm_", ":", "# This was probably created via another process, and doesn't have", "# things like salt keys created yet, so let's create them now.", "if", "'pub_key'", "not", "in", "vm_", "and", "'priv_key'", "not", "in", "vm_", ":", "log", ".", "debug", "(", "'Generating minion keys for \\'%s\\''", ",", "vm_", "[", "'name'", "]", ")", "vm_", "[", "'priv_key'", "]", ",", "vm_", "[", "'pub_key'", "]", "=", "salt", ".", "utils", ".", "cloud", ".", "gen_keys", "(", "salt", ".", "config", ".", "get_cloud_config_value", "(", "'keysize'", ",", "vm_", ",", "__opts__", ")", ")", "else", ":", "# Put together all of the information required to request the instance,", "# and then fire off the request for it", "if", "keyname", "(", "vm_", ")", "is", "None", ":", "raise", "SaltCloudSystemExit", "(", "'The required \\'keyname\\' configuration setting is missing from the '", "'\\'ec2\\' driver.'", ")", "data", ",", "vm_", "=", "request_instance", "(", "vm_", ",", "location", ")", "# If data is a str, it's an error", "if", "isinstance", "(", "data", ",", "six", ".", "string_types", ")", ":", "log", ".", "error", "(", "'Error requesting instance: %s'", ",", "data", ")", "return", "{", "}", "# Pull the instance ID, valid for both spot and normal instances", "# Multiple instances may have been spun up, get all their IDs", "vm_", "[", "'instance_id_list'", "]", "=", "[", "]", "for", "instance", "in", "data", ":", "vm_", "[", "'instance_id_list'", "]", ".", "append", "(", "instance", "[", "'instanceId'", "]", ")", "vm_", "[", "'instance_id'", "]", "=", "vm_", "[", "'instance_id_list'", "]", ".", "pop", "(", ")", "if", "vm_", "[", "'instance_id_list'", "]", ":", "# Multiple instances were spun up, get one now, and queue the rest", "queue_instances", "(", "vm_", "[", "'instance_id_list'", "]", ")", "# Wait for vital information, such as IP addresses, to be available", "# for the new instance", "data", "=", "query_instance", "(", "vm_", ")", "# Now that the instance is available, tag it appropriately. Should", "# mitigate race conditions with tags", "tags", "=", "config", ".", "get_cloud_config_value", "(", "'tag'", ",", "vm_", ",", "__opts__", ",", "{", "}", ",", "search_global", "=", "False", ")", "if", "not", "isinstance", "(", "tags", ",", "dict", ")", ":", "raise", "SaltCloudConfigError", "(", "'\\'tag\\' should be a dict.'", ")", "for", "value", "in", "six", ".", "itervalues", "(", "tags", ")", ":", "if", "not", "isinstance", "(", "value", ",", "six", ".", "string_types", ")", ":", "raise", "SaltCloudConfigError", "(", "'\\'tag\\' values must be strings. Try quoting the values. '", "'e.g. \"2013-09-19T20:09:46Z\".'", ")", "tags", "[", "'Name'", "]", "=", "vm_", "[", "'name'", "]", "__utils__", "[", "'cloud.fire_event'", "]", "(", "'event'", ",", "'setting tags'", ",", "'salt/cloud/{0}/tagging'", ".", "format", "(", "vm_", "[", "'name'", "]", ")", ",", "args", "=", "{", "'tags'", ":", "tags", "}", ",", "sock_dir", "=", "__opts__", "[", "'sock_dir'", "]", ",", "transport", "=", "__opts__", "[", "'transport'", "]", ")", "salt", ".", "utils", ".", "cloud", ".", "wait_for_fun", "(", "set_tags", ",", "timeout", "=", "30", ",", "name", "=", "vm_", "[", "'name'", "]", ",", "tags", "=", "tags", ",", "instance_id", "=", "vm_", "[", "'instance_id'", "]", ",", "call", "=", "'action'", ",", "location", "=", "location", ")", "# Once instance tags are set, tag the spot request if configured", "if", "'spot_config'", "in", "vm_", "and", "'tag'", "in", "vm_", "[", "'spot_config'", "]", ":", "if", "not", "isinstance", "(", "vm_", "[", "'spot_config'", "]", "[", "'tag'", "]", ",", "dict", ")", ":", "raise", "SaltCloudConfigError", "(", "'\\'tag\\' should be a dict.'", ")", "for", "value", "in", "six", ".", "itervalues", "(", "vm_", "[", "'spot_config'", "]", "[", "'tag'", "]", ")", ":", "if", "not", "isinstance", "(", "value", ",", "str", ")", ":", "raise", "SaltCloudConfigError", "(", "'\\'tag\\' values must be strings. Try quoting the values. '", "'e.g. \"2013-09-19T20:09:46Z\".'", ")", "spot_request_tags", "=", "{", "}", "if", "'spotRequestId'", "not", "in", "vm_", ":", "raise", "SaltCloudConfigError", "(", "'Failed to find spotRequestId'", ")", "sir_id", "=", "vm_", "[", "'spotRequestId'", "]", "spot_request_tags", "[", "'Name'", "]", "=", "vm_", "[", "'name'", "]", "for", "k", ",", "v", "in", "six", ".", "iteritems", "(", "vm_", "[", "'spot_config'", "]", "[", "'tag'", "]", ")", ":", "spot_request_tags", "[", "k", "]", "=", "v", "__utils__", "[", "'cloud.fire_event'", "]", "(", "'event'", ",", "'setting tags'", ",", "'salt/cloud/spot_request_{0}/tagging'", ".", "format", "(", "sir_id", ")", ",", "args", "=", "{", "'tags'", ":", "spot_request_tags", "}", ",", "sock_dir", "=", "__opts__", "[", "'sock_dir'", "]", ",", "transport", "=", "__opts__", "[", "'transport'", "]", ")", "salt", ".", "utils", ".", "cloud", ".", "wait_for_fun", "(", "set_tags", ",", "timeout", "=", "30", ",", "name", "=", "vm_", "[", "'name'", "]", ",", "tags", "=", "spot_request_tags", ",", "instance_id", "=", "sir_id", ",", "call", "=", "'action'", ",", "location", "=", "location", ")", "network_interfaces", "=", "config", ".", "get_cloud_config_value", "(", "'network_interfaces'", ",", "vm_", ",", "__opts__", ",", "search_global", "=", "False", ")", "if", "network_interfaces", ":", "_update_enis", "(", "network_interfaces", ",", "data", ",", "vm_", ")", "# At this point, the node is created and tagged, and now needs to be", "# bootstrapped, once the necessary port is available.", "log", ".", "info", "(", "'Created node %s'", ",", "vm_", "[", "'name'", "]", ")", "instance", "=", "data", "[", "0", "]", "[", "'instancesSet'", "]", "[", "'item'", "]", "# Wait for the necessary port to become available to bootstrap", "if", "ssh_interface", "(", "vm_", ")", "==", "'private_ips'", ":", "ip_address", "=", "instance", "[", "'privateIpAddress'", "]", "log", ".", "info", "(", "'Salt node data. Private_ip: %s'", ",", "ip_address", ")", "else", ":", "ip_address", "=", "instance", "[", "'ipAddress'", "]", "log", ".", "info", "(", "'Salt node data. Public_ip: %s'", ",", "ip_address", ")", "vm_", "[", "'ssh_host'", "]", "=", "ip_address", "if", "salt", ".", "utils", ".", "cloud", ".", "get_salt_interface", "(", "vm_", ",", "__opts__", ")", "==", "'private_ips'", ":", "salt_ip_address", "=", "instance", "[", "'privateIpAddress'", "]", "log", ".", "info", "(", "'Salt interface set to: %s'", ",", "salt_ip_address", ")", "else", ":", "salt_ip_address", "=", "instance", "[", "'ipAddress'", "]", "log", ".", "debug", "(", "'Salt interface set to: %s'", ",", "salt_ip_address", ")", "vm_", "[", "'salt_host'", "]", "=", "salt_ip_address", "if", "deploy", ":", "display_ssh_output", "=", "config", ".", "get_cloud_config_value", "(", "'display_ssh_output'", ",", "vm_", ",", "__opts__", ",", "default", "=", "True", ")", "vm_", "=", "wait_for_instance", "(", "vm_", ",", "data", ",", "ip_address", ",", "display_ssh_output", ")", "# The instance is booted and accessible, let's Salt it!", "ret", "=", "instance", ".", "copy", "(", ")", "# Get ANY defined volumes settings, merging data, in the following order", "# 1. VM config", "# 2. Profile config", "# 3. Global configuration", "volumes", "=", "config", ".", "get_cloud_config_value", "(", "'volumes'", ",", "vm_", ",", "__opts__", ",", "search_global", "=", "True", ")", "if", "volumes", ":", "__utils__", "[", "'cloud.fire_event'", "]", "(", "'event'", ",", "'attaching volumes'", ",", "'salt/cloud/{0}/attaching_volumes'", ".", "format", "(", "vm_", "[", "'name'", "]", ")", ",", "args", "=", "{", "'volumes'", ":", "volumes", "}", ",", "sock_dir", "=", "__opts__", "[", "'sock_dir'", "]", ",", "transport", "=", "__opts__", "[", "'transport'", "]", ")", "log", ".", "info", "(", "'Create and attach volumes to node %s'", ",", "vm_", "[", "'name'", "]", ")", "created", "=", "create_attach_volumes", "(", "vm_", "[", "'name'", "]", ",", "{", "'volumes'", ":", "volumes", ",", "'zone'", ":", "ret", "[", "'placement'", "]", "[", "'availabilityZone'", "]", ",", "'instance_id'", ":", "ret", "[", "'instanceId'", "]", ",", "'del_all_vols_on_destroy'", ":", "vm_", ".", "get", "(", "'del_all_vols_on_destroy'", ",", "False", ")", "}", ",", "call", "=", "'action'", ")", "ret", "[", "'Attached Volumes'", "]", "=", "created", "# Associate instance with a ssm document, if present", "ssm_document", "=", "config", ".", "get_cloud_config_value", "(", "'ssm_document'", ",", "vm_", ",", "__opts__", ",", "None", ",", "search_global", "=", "False", ")", "if", "ssm_document", ":", "log", ".", "debug", "(", "'Associating with ssm document: %s'", ",", "ssm_document", ")", "assoc", "=", "ssm_create_association", "(", "vm_", "[", "'name'", "]", ",", "{", "'ssm_document'", ":", "ssm_document", "}", ",", "instance_id", "=", "vm_", "[", "'instance_id'", "]", ",", "call", "=", "'action'", ")", "if", "isinstance", "(", "assoc", ",", "dict", ")", "and", "assoc", ".", "get", "(", "'error'", ",", "None", ")", ":", "log", ".", "error", "(", "'Failed to associate instance %s with ssm document %s'", ",", "vm_", "[", "'instance_id'", "]", ",", "ssm_document", ")", "return", "{", "}", "for", "key", ",", "value", "in", "six", ".", "iteritems", "(", "__utils__", "[", "'cloud.bootstrap'", "]", "(", "vm_", ",", "__opts__", ")", ")", ":", "ret", ".", "setdefault", "(", "key", ",", "value", ")", "log", ".", "info", "(", "'Created Cloud VM \\'%s\\''", ",", "vm_", "[", "'name'", "]", ")", "log", ".", "debug", "(", "'\\'%s\\' VM creation details:\\n%s'", ",", "vm_", "[", "'name'", "]", ",", "pprint", ".", "pformat", "(", "instance", ")", ")", "event_data", "=", "{", "'name'", ":", "vm_", "[", "'name'", "]", ",", "'profile'", ":", "vm_", "[", "'profile'", "]", ",", "'provider'", ":", "vm_", "[", "'driver'", "]", ",", "'instance_id'", ":", "vm_", "[", "'instance_id'", "]", ",", "}", "if", "volumes", ":", "event_data", "[", "'volumes'", "]", "=", "volumes", "if", "ssm_document", ":", "event_data", "[", "'ssm_document'", "]", "=", "ssm_document", "__utils__", "[", "'cloud.fire_event'", "]", "(", "'event'", ",", "'created instance'", ",", "'salt/cloud/{0}/created'", ".", "format", "(", "vm_", "[", "'name'", "]", ")", ",", "args", "=", "__utils__", "[", "'cloud.filter_event'", "]", "(", "'created'", ",", "event_data", ",", "list", "(", "event_data", ")", ")", ",", "sock_dir", "=", "__opts__", "[", "'sock_dir'", "]", ",", "transport", "=", "__opts__", "[", "'transport'", "]", ")", "# Ensure that the latest node data is returned", "node", "=", "_get_node", "(", "instance_id", "=", "vm_", "[", "'instance_id'", "]", ")", "__utils__", "[", "'cloud.cache_node'", "]", "(", "node", ",", "__active_provider_name__", ",", "__opts__", ")", "ret", ".", "update", "(", "node", ")", "# Add any block device tags specified", "ex_blockdevicetags", "=", "{", "}", "blockdevicemappings_holder", "=", "block_device_mappings", "(", "vm_", ")", "if", "blockdevicemappings_holder", ":", "for", "_bd", "in", "blockdevicemappings_holder", ":", "if", "'tag'", "in", "_bd", ":", "ex_blockdevicetags", "[", "_bd", "[", "'DeviceName'", "]", "]", "=", "_bd", "[", "'tag'", "]", "block_device_volume_id_map", "=", "{", "}", "if", "ex_blockdevicetags", ":", "for", "_device", ",", "_map", "in", "six", ".", "iteritems", "(", "ret", "[", "'blockDeviceMapping'", "]", ")", ":", "bd_items", "=", "[", "]", "if", "isinstance", "(", "_map", ",", "dict", ")", ":", "bd_items", ".", "append", "(", "_map", ")", "else", ":", "for", "mapitem", "in", "_map", ":", "bd_items", ".", "append", "(", "mapitem", ")", "for", "blockitem", "in", "bd_items", ":", "if", "blockitem", "[", "'deviceName'", "]", "in", "ex_blockdevicetags", "and", "'Name'", "not", "in", "ex_blockdevicetags", "[", "blockitem", "[", "'deviceName'", "]", "]", ":", "ex_blockdevicetags", "[", "blockitem", "[", "'deviceName'", "]", "]", "[", "'Name'", "]", "=", "vm_", "[", "'name'", "]", "if", "blockitem", "[", "'deviceName'", "]", "in", "ex_blockdevicetags", ":", "block_device_volume_id_map", "[", "blockitem", "[", "ret", "[", "'rootDeviceType'", "]", "]", "[", "'volumeId'", "]", "]", "=", "ex_blockdevicetags", "[", "blockitem", "[", "'deviceName'", "]", "]", "if", "block_device_volume_id_map", ":", "for", "volid", ",", "tags", "in", "six", ".", "iteritems", "(", "block_device_volume_id_map", ")", ":", "__utils__", "[", "'cloud.fire_event'", "]", "(", "'event'", ",", "'setting tags'", ",", "'salt/cloud/block_volume_{0}/tagging'", ".", "format", "(", "str", "(", "volid", ")", ")", ",", "args", "=", "{", "'tags'", ":", "tags", "}", ",", "sock_dir", "=", "__opts__", "[", "'sock_dir'", "]", ",", "transport", "=", "__opts__", "[", "'transport'", "]", ")", "__utils__", "[", "'cloud.wait_for_fun'", "]", "(", "set_tags", ",", "timeout", "=", "30", ",", "name", "=", "vm_", "[", "'name'", "]", ",", "tags", "=", "tags", ",", "resource_id", "=", "volid", ",", "call", "=", "'action'", ",", "location", "=", "location", ")", "return", "ret"], "docstring": "Create a single VM from a data dict", "docstring_tokens": ["Create", "a", "single", "VM", "from", "a", "data", "dict"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/cloud/clouds/ec2.py#L2555-L2931", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/cloud/clouds/ec2.py", "func_name": "queue_instances", "original_string": "def queue_instances(instances):\n    '''\n    Queue a set of instances to be provisioned later. Expects a list.\n\n    Currently this only queries node data, and then places it in the cloud\n    cache (if configured). If the salt-cloud-reactor is being used, these\n    instances will be automatically provisioned using that.\n\n    For more information about the salt-cloud-reactor, see:\n\n    https://github.com/saltstack-formulas/salt-cloud-reactor\n    '''\n    for instance_id in instances:\n        node = _get_node(instance_id=instance_id)\n        __utils__['cloud.cache_node'](node, __active_provider_name__, __opts__)", "language": "python", "code": "def queue_instances(instances):\n    '''\n    Queue a set of instances to be provisioned later. Expects a list.\n\n    Currently this only queries node data, and then places it in the cloud\n    cache (if configured). If the salt-cloud-reactor is being used, these\n    instances will be automatically provisioned using that.\n\n    For more information about the salt-cloud-reactor, see:\n\n    https://github.com/saltstack-formulas/salt-cloud-reactor\n    '''\n    for instance_id in instances:\n        node = _get_node(instance_id=instance_id)\n        __utils__['cloud.cache_node'](node, __active_provider_name__, __opts__)", "code_tokens": ["def", "queue_instances", "(", "instances", ")", ":", "for", "instance_id", "in", "instances", ":", "node", "=", "_get_node", "(", "instance_id", "=", "instance_id", ")", "__utils__", "[", "'cloud.cache_node'", "]", "(", "node", ",", "__active_provider_name__", ",", "__opts__", ")"], "docstring": "Queue a set of instances to be provisioned later. Expects a list.\n\n    Currently this only queries node data, and then places it in the cloud\n    cache (if configured). If the salt-cloud-reactor is being used, these\n    instances will be automatically provisioned using that.\n\n    For more information about the salt-cloud-reactor, see:\n\n    https://github.com/saltstack-formulas/salt-cloud-reactor", "docstring_tokens": ["Queue", "a", "set", "of", "instances", "to", "be", "provisioned", "later", ".", "Expects", "a", "list", "."], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/cloud/clouds/ec2.py#L2934-L2948", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/cloud/clouds/ec2.py", "func_name": "create_attach_volumes", "original_string": "def create_attach_volumes(name, kwargs, call=None, wait_to_finish=True):\n    '''\n    Create and attach volumes to created node\n    '''\n    if call != 'action':\n        raise SaltCloudSystemExit(\n            'The create_attach_volumes action must be called with '\n            '-a or --action.'\n        )\n\n    if 'instance_id' not in kwargs:\n        kwargs['instance_id'] = _get_node(name)['instanceId']\n\n    if isinstance(kwargs['volumes'], six.string_types):\n        volumes = salt.utils.yaml.safe_load(kwargs['volumes'])\n    else:\n        volumes = kwargs['volumes']\n\n    ret = []\n    for volume in volumes:\n        created = False\n        volume_name = '{0} on {1}'.format(volume['device'], name)\n\n        volume_dict = {\n            'volume_name': volume_name,\n            'zone': kwargs['zone']\n        }\n        if 'volume_id' in volume:\n            volume_dict['volume_id'] = volume['volume_id']\n        elif 'snapshot' in volume:\n            volume_dict['snapshot'] = volume['snapshot']\n        elif 'size' in volume:\n            volume_dict['size'] = volume['size']\n        else:\n            raise SaltCloudConfigError(\n                'Cannot create volume.  Please define one of \\'volume_id\\', '\n                '\\'snapshot\\', or \\'size\\''\n            )\n\n        if 'tags' in volume:\n            volume_dict['tags'] = volume['tags']\n        if 'type' in volume:\n            volume_dict['type'] = volume['type']\n        if 'iops' in volume:\n            volume_dict['iops'] = volume['iops']\n        if 'encrypted' in volume:\n            volume_dict['encrypted'] = volume['encrypted']\n        if 'kmskeyid' in volume:\n            volume_dict['kmskeyid'] = volume['kmskeyid']\n\n        if 'volume_id' not in volume_dict:\n            created_volume = create_volume(volume_dict, call='function', wait_to_finish=wait_to_finish)\n            created = True\n            if 'volumeId' in created_volume:\n                volume_dict['volume_id'] = created_volume['volumeId']\n\n        attach = attach_volume(\n            name,\n            {'volume_id': volume_dict['volume_id'],\n             'device': volume['device']},\n            instance_id=kwargs['instance_id'],\n            call='action'\n        )\n\n        # Update the delvol parameter for this volume\n        delvols_on_destroy = kwargs.get('del_all_vols_on_destroy', None)\n\n        if attach and created and delvols_on_destroy is not None:\n            _toggle_delvol(instance_id=kwargs['instance_id'],\n                           device=volume['device'],\n                           value=delvols_on_destroy)\n\n        if attach:\n            msg = (\n                '{0} attached to {1} (aka {2}) as device {3}'.format(\n                    volume_dict['volume_id'],\n                    kwargs['instance_id'],\n                    name,\n                    volume['device']\n                )\n            )\n            log.info(msg)\n            ret.append(msg)\n    return ret", "language": "python", "code": "def create_attach_volumes(name, kwargs, call=None, wait_to_finish=True):\n    '''\n    Create and attach volumes to created node\n    '''\n    if call != 'action':\n        raise SaltCloudSystemExit(\n            'The create_attach_volumes action must be called with '\n            '-a or --action.'\n        )\n\n    if 'instance_id' not in kwargs:\n        kwargs['instance_id'] = _get_node(name)['instanceId']\n\n    if isinstance(kwargs['volumes'], six.string_types):\n        volumes = salt.utils.yaml.safe_load(kwargs['volumes'])\n    else:\n        volumes = kwargs['volumes']\n\n    ret = []\n    for volume in volumes:\n        created = False\n        volume_name = '{0} on {1}'.format(volume['device'], name)\n\n        volume_dict = {\n            'volume_name': volume_name,\n            'zone': kwargs['zone']\n        }\n        if 'volume_id' in volume:\n            volume_dict['volume_id'] = volume['volume_id']\n        elif 'snapshot' in volume:\n            volume_dict['snapshot'] = volume['snapshot']\n        elif 'size' in volume:\n            volume_dict['size'] = volume['size']\n        else:\n            raise SaltCloudConfigError(\n                'Cannot create volume.  Please define one of \\'volume_id\\', '\n                '\\'snapshot\\', or \\'size\\''\n            )\n\n        if 'tags' in volume:\n            volume_dict['tags'] = volume['tags']\n        if 'type' in volume:\n            volume_dict['type'] = volume['type']\n        if 'iops' in volume:\n            volume_dict['iops'] = volume['iops']\n        if 'encrypted' in volume:\n            volume_dict['encrypted'] = volume['encrypted']\n        if 'kmskeyid' in volume:\n            volume_dict['kmskeyid'] = volume['kmskeyid']\n\n        if 'volume_id' not in volume_dict:\n            created_volume = create_volume(volume_dict, call='function', wait_to_finish=wait_to_finish)\n            created = True\n            if 'volumeId' in created_volume:\n                volume_dict['volume_id'] = created_volume['volumeId']\n\n        attach = attach_volume(\n            name,\n            {'volume_id': volume_dict['volume_id'],\n             'device': volume['device']},\n            instance_id=kwargs['instance_id'],\n            call='action'\n        )\n\n        # Update the delvol parameter for this volume\n        delvols_on_destroy = kwargs.get('del_all_vols_on_destroy', None)\n\n        if attach and created and delvols_on_destroy is not None:\n            _toggle_delvol(instance_id=kwargs['instance_id'],\n                           device=volume['device'],\n                           value=delvols_on_destroy)\n\n        if attach:\n            msg = (\n                '{0} attached to {1} (aka {2}) as device {3}'.format(\n                    volume_dict['volume_id'],\n                    kwargs['instance_id'],\n                    name,\n                    volume['device']\n                )\n            )\n            log.info(msg)\n            ret.append(msg)\n    return ret", "code_tokens": ["def", "create_attach_volumes", "(", "name", ",", "kwargs", ",", "call", "=", "None", ",", "wait_to_finish", "=", "True", ")", ":", "if", "call", "!=", "'action'", ":", "raise", "SaltCloudSystemExit", "(", "'The create_attach_volumes action must be called with '", "'-a or --action.'", ")", "if", "'instance_id'", "not", "in", "kwargs", ":", "kwargs", "[", "'instance_id'", "]", "=", "_get_node", "(", "name", ")", "[", "'instanceId'", "]", "if", "isinstance", "(", "kwargs", "[", "'volumes'", "]", ",", "six", ".", "string_types", ")", ":", "volumes", "=", "salt", ".", "utils", ".", "yaml", ".", "safe_load", "(", "kwargs", "[", "'volumes'", "]", ")", "else", ":", "volumes", "=", "kwargs", "[", "'volumes'", "]", "ret", "=", "[", "]", "for", "volume", "in", "volumes", ":", "created", "=", "False", "volume_name", "=", "'{0} on {1}'", ".", "format", "(", "volume", "[", "'device'", "]", ",", "name", ")", "volume_dict", "=", "{", "'volume_name'", ":", "volume_name", ",", "'zone'", ":", "kwargs", "[", "'zone'", "]", "}", "if", "'volume_id'", "in", "volume", ":", "volume_dict", "[", "'volume_id'", "]", "=", "volume", "[", "'volume_id'", "]", "elif", "'snapshot'", "in", "volume", ":", "volume_dict", "[", "'snapshot'", "]", "=", "volume", "[", "'snapshot'", "]", "elif", "'size'", "in", "volume", ":", "volume_dict", "[", "'size'", "]", "=", "volume", "[", "'size'", "]", "else", ":", "raise", "SaltCloudConfigError", "(", "'Cannot create volume.  Please define one of \\'volume_id\\', '", "'\\'snapshot\\', or \\'size\\''", ")", "if", "'tags'", "in", "volume", ":", "volume_dict", "[", "'tags'", "]", "=", "volume", "[", "'tags'", "]", "if", "'type'", "in", "volume", ":", "volume_dict", "[", "'type'", "]", "=", "volume", "[", "'type'", "]", "if", "'iops'", "in", "volume", ":", "volume_dict", "[", "'iops'", "]", "=", "volume", "[", "'iops'", "]", "if", "'encrypted'", "in", "volume", ":", "volume_dict", "[", "'encrypted'", "]", "=", "volume", "[", "'encrypted'", "]", "if", "'kmskeyid'", "in", "volume", ":", "volume_dict", "[", "'kmskeyid'", "]", "=", "volume", "[", "'kmskeyid'", "]", "if", "'volume_id'", "not", "in", "volume_dict", ":", "created_volume", "=", "create_volume", "(", "volume_dict", ",", "call", "=", "'function'", ",", "wait_to_finish", "=", "wait_to_finish", ")", "created", "=", "True", "if", "'volumeId'", "in", "created_volume", ":", "volume_dict", "[", "'volume_id'", "]", "=", "created_volume", "[", "'volumeId'", "]", "attach", "=", "attach_volume", "(", "name", ",", "{", "'volume_id'", ":", "volume_dict", "[", "'volume_id'", "]", ",", "'device'", ":", "volume", "[", "'device'", "]", "}", ",", "instance_id", "=", "kwargs", "[", "'instance_id'", "]", ",", "call", "=", "'action'", ")", "# Update the delvol parameter for this volume", "delvols_on_destroy", "=", "kwargs", ".", "get", "(", "'del_all_vols_on_destroy'", ",", "None", ")", "if", "attach", "and", "created", "and", "delvols_on_destroy", "is", "not", "None", ":", "_toggle_delvol", "(", "instance_id", "=", "kwargs", "[", "'instance_id'", "]", ",", "device", "=", "volume", "[", "'device'", "]", ",", "value", "=", "delvols_on_destroy", ")", "if", "attach", ":", "msg", "=", "(", "'{0} attached to {1} (aka {2}) as device {3}'", ".", "format", "(", "volume_dict", "[", "'volume_id'", "]", ",", "kwargs", "[", "'instance_id'", "]", ",", "name", ",", "volume", "[", "'device'", "]", ")", ")", "log", ".", "info", "(", "msg", ")", "ret", ".", "append", "(", "msg", ")", "return", "ret"], "docstring": "Create and attach volumes to created node", "docstring_tokens": ["Create", "and", "attach", "volumes", "to", "created", "node"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/cloud/clouds/ec2.py#L2951-L3034", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/cloud/clouds/ec2.py", "func_name": "stop", "original_string": "def stop(name, call=None):\n    '''\n    Stop a node\n    '''\n    if call != 'action':\n        raise SaltCloudSystemExit(\n            'The stop action must be called with -a or --action.'\n        )\n\n    log.info('Stopping node %s', name)\n\n    instance_id = _get_node(name)['instanceId']\n\n    __utils__['cloud.fire_event'](\n        'event',\n        'stopping instance',\n        'salt/cloud/{0}/stopping'.format(name),\n        args={'name': name, 'instance_id': instance_id},\n        sock_dir=__opts__['sock_dir'],\n        transport=__opts__['transport']\n    )\n\n    params = {'Action': 'StopInstances',\n              'InstanceId.1': instance_id}\n    result = aws.query(params,\n                       location=get_location(),\n                       provider=get_provider(),\n                       opts=__opts__,\n                       sigver='4')\n\n    return result", "language": "python", "code": "def stop(name, call=None):\n    '''\n    Stop a node\n    '''\n    if call != 'action':\n        raise SaltCloudSystemExit(\n            'The stop action must be called with -a or --action.'\n        )\n\n    log.info('Stopping node %s', name)\n\n    instance_id = _get_node(name)['instanceId']\n\n    __utils__['cloud.fire_event'](\n        'event',\n        'stopping instance',\n        'salt/cloud/{0}/stopping'.format(name),\n        args={'name': name, 'instance_id': instance_id},\n        sock_dir=__opts__['sock_dir'],\n        transport=__opts__['transport']\n    )\n\n    params = {'Action': 'StopInstances',\n              'InstanceId.1': instance_id}\n    result = aws.query(params,\n                       location=get_location(),\n                       provider=get_provider(),\n                       opts=__opts__,\n                       sigver='4')\n\n    return result", "code_tokens": ["def", "stop", "(", "name", ",", "call", "=", "None", ")", ":", "if", "call", "!=", "'action'", ":", "raise", "SaltCloudSystemExit", "(", "'The stop action must be called with -a or --action.'", ")", "log", ".", "info", "(", "'Stopping node %s'", ",", "name", ")", "instance_id", "=", "_get_node", "(", "name", ")", "[", "'instanceId'", "]", "__utils__", "[", "'cloud.fire_event'", "]", "(", "'event'", ",", "'stopping instance'", ",", "'salt/cloud/{0}/stopping'", ".", "format", "(", "name", ")", ",", "args", "=", "{", "'name'", ":", "name", ",", "'instance_id'", ":", "instance_id", "}", ",", "sock_dir", "=", "__opts__", "[", "'sock_dir'", "]", ",", "transport", "=", "__opts__", "[", "'transport'", "]", ")", "params", "=", "{", "'Action'", ":", "'StopInstances'", ",", "'InstanceId.1'", ":", "instance_id", "}", "result", "=", "aws", ".", "query", "(", "params", ",", "location", "=", "get_location", "(", ")", ",", "provider", "=", "get_provider", "(", ")", ",", "opts", "=", "__opts__", ",", "sigver", "=", "'4'", ")", "return", "result"], "docstring": "Stop a node", "docstring_tokens": ["Stop", "a", "node"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/cloud/clouds/ec2.py#L3037-L3067", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/cloud/clouds/ec2.py", "func_name": "set_tags", "original_string": "def set_tags(name=None,\n             tags=None,\n             call=None,\n             location=None,\n             instance_id=None,\n             resource_id=None,\n             kwargs=None):  # pylint: disable=W0613\n    '''\n    Set tags for a resource. Normally a VM name or instance_id is passed in,\n    but a resource_id may be passed instead. If both are passed in, the\n    instance_id will be used.\n\n    CLI Examples:\n\n    .. code-block:: bash\n\n        salt-cloud -a set_tags mymachine tag1=somestuff tag2='Other stuff'\n        salt-cloud -a set_tags resource_id=vol-3267ab32 tag=somestuff\n    '''\n    if kwargs is None:\n        kwargs = {}\n\n    if location is None:\n        location = get_location()\n\n    if instance_id is None:\n        if 'resource_id' in kwargs:\n            resource_id = kwargs['resource_id']\n            del kwargs['resource_id']\n\n        if 'instance_id' in kwargs:\n            instance_id = kwargs['instance_id']\n            del kwargs['instance_id']\n\n        if resource_id is None:\n            if instance_id is None:\n                instance_id = _get_node(name=name, instance_id=None, location=location)['instanceId']\n        else:\n            instance_id = resource_id\n\n    # This second check is a safety, in case the above still failed to produce\n    # a usable ID\n    if instance_id is None:\n        return {\n            'Error': 'A valid instance_id or resource_id was not specified.'\n        }\n\n    params = {'Action': 'CreateTags',\n              'ResourceId.1': instance_id}\n\n    log.debug('Tags to set for %s: %s', name, tags)\n\n    if kwargs and not tags:\n        tags = kwargs\n\n    for idx, (tag_k, tag_v) in enumerate(six.iteritems(tags)):\n        params['Tag.{0}.Key'.format(idx)] = tag_k\n        params['Tag.{0}.Value'.format(idx)] = tag_v\n\n    attempts = 0\n    while attempts < aws.AWS_MAX_RETRIES:\n        aws.query(params,\n                           setname='tagSet',\n                           location=location,\n                           provider=get_provider(),\n                           opts=__opts__,\n                           sigver='4')\n\n        settags = get_tags(\n            instance_id=instance_id, call='action', location=location\n        )\n\n        log.debug('Setting the tags returned: %s', settags)\n\n        failed_to_set_tags = False\n        for tag in settags:\n            if tag['key'] not in tags:\n                # We were not setting this tag\n                continue\n\n            if tag.get('value') is None and tags.get(tag['key']) == '':\n                # This is a correctly set tag with no value\n                continue\n\n            if six.text_type(tags.get(tag['key'])) != six.text_type(tag['value']):\n                # Not set to the proper value!?\n                log.debug(\n                    'Setting the tag %s returned %s instead of %s',\n                    tag['key'], tags.get(tag['key']), tag['value']\n                )\n                failed_to_set_tags = True\n                break\n\n        if failed_to_set_tags:\n            log.warning('Failed to set tags. Remaining attempts %s', attempts)\n            attempts += 1\n            aws.sleep_exponential_backoff(attempts)\n            continue\n\n        return settags\n\n    raise SaltCloudSystemExit(\n        'Failed to set tags on {0}!'.format(name)\n    )", "language": "python", "code": "def set_tags(name=None,\n             tags=None,\n             call=None,\n             location=None,\n             instance_id=None,\n             resource_id=None,\n             kwargs=None):  # pylint: disable=W0613\n    '''\n    Set tags for a resource. Normally a VM name or instance_id is passed in,\n    but a resource_id may be passed instead. If both are passed in, the\n    instance_id will be used.\n\n    CLI Examples:\n\n    .. code-block:: bash\n\n        salt-cloud -a set_tags mymachine tag1=somestuff tag2='Other stuff'\n        salt-cloud -a set_tags resource_id=vol-3267ab32 tag=somestuff\n    '''\n    if kwargs is None:\n        kwargs = {}\n\n    if location is None:\n        location = get_location()\n\n    if instance_id is None:\n        if 'resource_id' in kwargs:\n            resource_id = kwargs['resource_id']\n            del kwargs['resource_id']\n\n        if 'instance_id' in kwargs:\n            instance_id = kwargs['instance_id']\n            del kwargs['instance_id']\n\n        if resource_id is None:\n            if instance_id is None:\n                instance_id = _get_node(name=name, instance_id=None, location=location)['instanceId']\n        else:\n            instance_id = resource_id\n\n    # This second check is a safety, in case the above still failed to produce\n    # a usable ID\n    if instance_id is None:\n        return {\n            'Error': 'A valid instance_id or resource_id was not specified.'\n        }\n\n    params = {'Action': 'CreateTags',\n              'ResourceId.1': instance_id}\n\n    log.debug('Tags to set for %s: %s', name, tags)\n\n    if kwargs and not tags:\n        tags = kwargs\n\n    for idx, (tag_k, tag_v) in enumerate(six.iteritems(tags)):\n        params['Tag.{0}.Key'.format(idx)] = tag_k\n        params['Tag.{0}.Value'.format(idx)] = tag_v\n\n    attempts = 0\n    while attempts < aws.AWS_MAX_RETRIES:\n        aws.query(params,\n                           setname='tagSet',\n                           location=location,\n                           provider=get_provider(),\n                           opts=__opts__,\n                           sigver='4')\n\n        settags = get_tags(\n            instance_id=instance_id, call='action', location=location\n        )\n\n        log.debug('Setting the tags returned: %s', settags)\n\n        failed_to_set_tags = False\n        for tag in settags:\n            if tag['key'] not in tags:\n                # We were not setting this tag\n                continue\n\n            if tag.get('value') is None and tags.get(tag['key']) == '':\n                # This is a correctly set tag with no value\n                continue\n\n            if six.text_type(tags.get(tag['key'])) != six.text_type(tag['value']):\n                # Not set to the proper value!?\n                log.debug(\n                    'Setting the tag %s returned %s instead of %s',\n                    tag['key'], tags.get(tag['key']), tag['value']\n                )\n                failed_to_set_tags = True\n                break\n\n        if failed_to_set_tags:\n            log.warning('Failed to set tags. Remaining attempts %s', attempts)\n            attempts += 1\n            aws.sleep_exponential_backoff(attempts)\n            continue\n\n        return settags\n\n    raise SaltCloudSystemExit(\n        'Failed to set tags on {0}!'.format(name)\n    )", "code_tokens": ["def", "set_tags", "(", "name", "=", "None", ",", "tags", "=", "None", ",", "call", "=", "None", ",", "location", "=", "None", ",", "instance_id", "=", "None", ",", "resource_id", "=", "None", ",", "kwargs", "=", "None", ")", ":", "# pylint: disable=W0613", "if", "kwargs", "is", "None", ":", "kwargs", "=", "{", "}", "if", "location", "is", "None", ":", "location", "=", "get_location", "(", ")", "if", "instance_id", "is", "None", ":", "if", "'resource_id'", "in", "kwargs", ":", "resource_id", "=", "kwargs", "[", "'resource_id'", "]", "del", "kwargs", "[", "'resource_id'", "]", "if", "'instance_id'", "in", "kwargs", ":", "instance_id", "=", "kwargs", "[", "'instance_id'", "]", "del", "kwargs", "[", "'instance_id'", "]", "if", "resource_id", "is", "None", ":", "if", "instance_id", "is", "None", ":", "instance_id", "=", "_get_node", "(", "name", "=", "name", ",", "instance_id", "=", "None", ",", "location", "=", "location", ")", "[", "'instanceId'", "]", "else", ":", "instance_id", "=", "resource_id", "# This second check is a safety, in case the above still failed to produce", "# a usable ID", "if", "instance_id", "is", "None", ":", "return", "{", "'Error'", ":", "'A valid instance_id or resource_id was not specified.'", "}", "params", "=", "{", "'Action'", ":", "'CreateTags'", ",", "'ResourceId.1'", ":", "instance_id", "}", "log", ".", "debug", "(", "'Tags to set for %s: %s'", ",", "name", ",", "tags", ")", "if", "kwargs", "and", "not", "tags", ":", "tags", "=", "kwargs", "for", "idx", ",", "(", "tag_k", ",", "tag_v", ")", "in", "enumerate", "(", "six", ".", "iteritems", "(", "tags", ")", ")", ":", "params", "[", "'Tag.{0}.Key'", ".", "format", "(", "idx", ")", "]", "=", "tag_k", "params", "[", "'Tag.{0}.Value'", ".", "format", "(", "idx", ")", "]", "=", "tag_v", "attempts", "=", "0", "while", "attempts", "<", "aws", ".", "AWS_MAX_RETRIES", ":", "aws", ".", "query", "(", "params", ",", "setname", "=", "'tagSet'", ",", "location", "=", "location", ",", "provider", "=", "get_provider", "(", ")", ",", "opts", "=", "__opts__", ",", "sigver", "=", "'4'", ")", "settags", "=", "get_tags", "(", "instance_id", "=", "instance_id", ",", "call", "=", "'action'", ",", "location", "=", "location", ")", "log", ".", "debug", "(", "'Setting the tags returned: %s'", ",", "settags", ")", "failed_to_set_tags", "=", "False", "for", "tag", "in", "settags", ":", "if", "tag", "[", "'key'", "]", "not", "in", "tags", ":", "# We were not setting this tag", "continue", "if", "tag", ".", "get", "(", "'value'", ")", "is", "None", "and", "tags", ".", "get", "(", "tag", "[", "'key'", "]", ")", "==", "''", ":", "# This is a correctly set tag with no value", "continue", "if", "six", ".", "text_type", "(", "tags", ".", "get", "(", "tag", "[", "'key'", "]", ")", ")", "!=", "six", ".", "text_type", "(", "tag", "[", "'value'", "]", ")", ":", "# Not set to the proper value!?", "log", ".", "debug", "(", "'Setting the tag %s returned %s instead of %s'", ",", "tag", "[", "'key'", "]", ",", "tags", ".", "get", "(", "tag", "[", "'key'", "]", ")", ",", "tag", "[", "'value'", "]", ")", "failed_to_set_tags", "=", "True", "break", "if", "failed_to_set_tags", ":", "log", ".", "warning", "(", "'Failed to set tags. Remaining attempts %s'", ",", "attempts", ")", "attempts", "+=", "1", "aws", ".", "sleep_exponential_backoff", "(", "attempts", ")", "continue", "return", "settags", "raise", "SaltCloudSystemExit", "(", "'Failed to set tags on {0}!'", ".", "format", "(", "name", ")", ")"], "docstring": "Set tags for a resource. Normally a VM name or instance_id is passed in,\n    but a resource_id may be passed instead. If both are passed in, the\n    instance_id will be used.\n\n    CLI Examples:\n\n    .. code-block:: bash\n\n        salt-cloud -a set_tags mymachine tag1=somestuff tag2='Other stuff'\n        salt-cloud -a set_tags resource_id=vol-3267ab32 tag=somestuff", "docstring_tokens": ["Set", "tags", "for", "a", "resource", ".", "Normally", "a", "VM", "name", "or", "instance_id", "is", "passed", "in", "but", "a", "resource_id", "may", "be", "passed", "instead", ".", "If", "both", "are", "passed", "in", "the", "instance_id", "will", "be", "used", "."], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/cloud/clouds/ec2.py#L3103-L3206", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/cloud/clouds/ec2.py", "func_name": "get_tags", "original_string": "def get_tags(name=None,\n             instance_id=None,\n             call=None,\n             location=None,\n             kwargs=None,\n             resource_id=None):  # pylint: disable=W0613\n    '''\n    Retrieve tags for a resource. Normally a VM name or instance_id is passed\n    in, but a resource_id may be passed instead. If both are passed in, the\n    instance_id will be used.\n\n    CLI Examples:\n\n    .. code-block:: bash\n\n        salt-cloud -a get_tags mymachine\n        salt-cloud -a get_tags resource_id=vol-3267ab32\n    '''\n    if location is None:\n        location = get_location()\n\n    if instance_id is None:\n        if resource_id is None:\n            if name:\n                instance_id = _get_node(name)['instanceId']\n            elif 'instance_id' in kwargs:\n                instance_id = kwargs['instance_id']\n            elif 'resource_id' in kwargs:\n                instance_id = kwargs['resource_id']\n        else:\n            instance_id = resource_id\n\n    params = {'Action': 'DescribeTags',\n              'Filter.1.Name': 'resource-id',\n              'Filter.1.Value': instance_id}\n\n    return aws.query(params,\n                     setname='tagSet',\n                     location=location,\n                     provider=get_provider(),\n                     opts=__opts__,\n                     sigver='4')", "language": "python", "code": "def get_tags(name=None,\n             instance_id=None,\n             call=None,\n             location=None,\n             kwargs=None,\n             resource_id=None):  # pylint: disable=W0613\n    '''\n    Retrieve tags for a resource. Normally a VM name or instance_id is passed\n    in, but a resource_id may be passed instead. If both are passed in, the\n    instance_id will be used.\n\n    CLI Examples:\n\n    .. code-block:: bash\n\n        salt-cloud -a get_tags mymachine\n        salt-cloud -a get_tags resource_id=vol-3267ab32\n    '''\n    if location is None:\n        location = get_location()\n\n    if instance_id is None:\n        if resource_id is None:\n            if name:\n                instance_id = _get_node(name)['instanceId']\n            elif 'instance_id' in kwargs:\n                instance_id = kwargs['instance_id']\n            elif 'resource_id' in kwargs:\n                instance_id = kwargs['resource_id']\n        else:\n            instance_id = resource_id\n\n    params = {'Action': 'DescribeTags',\n              'Filter.1.Name': 'resource-id',\n              'Filter.1.Value': instance_id}\n\n    return aws.query(params,\n                     setname='tagSet',\n                     location=location,\n                     provider=get_provider(),\n                     opts=__opts__,\n                     sigver='4')", "code_tokens": ["def", "get_tags", "(", "name", "=", "None", ",", "instance_id", "=", "None", ",", "call", "=", "None", ",", "location", "=", "None", ",", "kwargs", "=", "None", ",", "resource_id", "=", "None", ")", ":", "# pylint: disable=W0613", "if", "location", "is", "None", ":", "location", "=", "get_location", "(", ")", "if", "instance_id", "is", "None", ":", "if", "resource_id", "is", "None", ":", "if", "name", ":", "instance_id", "=", "_get_node", "(", "name", ")", "[", "'instanceId'", "]", "elif", "'instance_id'", "in", "kwargs", ":", "instance_id", "=", "kwargs", "[", "'instance_id'", "]", "elif", "'resource_id'", "in", "kwargs", ":", "instance_id", "=", "kwargs", "[", "'resource_id'", "]", "else", ":", "instance_id", "=", "resource_id", "params", "=", "{", "'Action'", ":", "'DescribeTags'", ",", "'Filter.1.Name'", ":", "'resource-id'", ",", "'Filter.1.Value'", ":", "instance_id", "}", "return", "aws", ".", "query", "(", "params", ",", "setname", "=", "'tagSet'", ",", "location", "=", "location", ",", "provider", "=", "get_provider", "(", ")", ",", "opts", "=", "__opts__", ",", "sigver", "=", "'4'", ")"], "docstring": "Retrieve tags for a resource. Normally a VM name or instance_id is passed\n    in, but a resource_id may be passed instead. If both are passed in, the\n    instance_id will be used.\n\n    CLI Examples:\n\n    .. code-block:: bash\n\n        salt-cloud -a get_tags mymachine\n        salt-cloud -a get_tags resource_id=vol-3267ab32", "docstring_tokens": ["Retrieve", "tags", "for", "a", "resource", ".", "Normally", "a", "VM", "name", "or", "instance_id", "is", "passed", "in", "but", "a", "resource_id", "may", "be", "passed", "instead", ".", "If", "both", "are", "passed", "in", "the", "instance_id", "will", "be", "used", "."], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/cloud/clouds/ec2.py#L3209-L3250", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/cloud/clouds/ec2.py", "func_name": "del_tags", "original_string": "def del_tags(name=None,\n             kwargs=None,\n             call=None,\n             instance_id=None,\n             resource_id=None):  # pylint: disable=W0613\n    '''\n    Delete tags for a resource. Normally a VM name or instance_id is passed in,\n    but a resource_id may be passed instead. If both are passed in, the\n    instance_id will be used.\n\n    CLI Examples:\n\n    .. code-block:: bash\n\n        salt-cloud -a del_tags mymachine tags=mytag,\n        salt-cloud -a del_tags mymachine tags=tag1,tag2,tag3\n        salt-cloud -a del_tags resource_id=vol-3267ab32 tags=tag1,tag2,tag3\n    '''\n    if kwargs is None:\n        kwargs = {}\n\n    if 'tags' not in kwargs:\n        raise SaltCloudSystemExit(\n            'A tag or tags must be specified using tags=list,of,tags'\n        )\n\n    if not name and 'resource_id' in kwargs:\n        instance_id = kwargs['resource_id']\n        del kwargs['resource_id']\n\n    if not instance_id:\n        instance_id = _get_node(name)['instanceId']\n\n    params = {'Action': 'DeleteTags',\n              'ResourceId.1': instance_id}\n\n    for idx, tag in enumerate(kwargs['tags'].split(',')):\n        params['Tag.{0}.Key'.format(idx)] = tag\n\n    aws.query(params,\n              setname='tagSet',\n              location=get_location(),\n              provider=get_provider(),\n              opts=__opts__,\n              sigver='4')\n\n    if resource_id:\n        return get_tags(resource_id=resource_id)\n    else:\n        return get_tags(instance_id=instance_id)", "language": "python", "code": "def del_tags(name=None,\n             kwargs=None,\n             call=None,\n             instance_id=None,\n             resource_id=None):  # pylint: disable=W0613\n    '''\n    Delete tags for a resource. Normally a VM name or instance_id is passed in,\n    but a resource_id may be passed instead. If both are passed in, the\n    instance_id will be used.\n\n    CLI Examples:\n\n    .. code-block:: bash\n\n        salt-cloud -a del_tags mymachine tags=mytag,\n        salt-cloud -a del_tags mymachine tags=tag1,tag2,tag3\n        salt-cloud -a del_tags resource_id=vol-3267ab32 tags=tag1,tag2,tag3\n    '''\n    if kwargs is None:\n        kwargs = {}\n\n    if 'tags' not in kwargs:\n        raise SaltCloudSystemExit(\n            'A tag or tags must be specified using tags=list,of,tags'\n        )\n\n    if not name and 'resource_id' in kwargs:\n        instance_id = kwargs['resource_id']\n        del kwargs['resource_id']\n\n    if not instance_id:\n        instance_id = _get_node(name)['instanceId']\n\n    params = {'Action': 'DeleteTags',\n              'ResourceId.1': instance_id}\n\n    for idx, tag in enumerate(kwargs['tags'].split(',')):\n        params['Tag.{0}.Key'.format(idx)] = tag\n\n    aws.query(params,\n              setname='tagSet',\n              location=get_location(),\n              provider=get_provider(),\n              opts=__opts__,\n              sigver='4')\n\n    if resource_id:\n        return get_tags(resource_id=resource_id)\n    else:\n        return get_tags(instance_id=instance_id)", "code_tokens": ["def", "del_tags", "(", "name", "=", "None", ",", "kwargs", "=", "None", ",", "call", "=", "None", ",", "instance_id", "=", "None", ",", "resource_id", "=", "None", ")", ":", "# pylint: disable=W0613", "if", "kwargs", "is", "None", ":", "kwargs", "=", "{", "}", "if", "'tags'", "not", "in", "kwargs", ":", "raise", "SaltCloudSystemExit", "(", "'A tag or tags must be specified using tags=list,of,tags'", ")", "if", "not", "name", "and", "'resource_id'", "in", "kwargs", ":", "instance_id", "=", "kwargs", "[", "'resource_id'", "]", "del", "kwargs", "[", "'resource_id'", "]", "if", "not", "instance_id", ":", "instance_id", "=", "_get_node", "(", "name", ")", "[", "'instanceId'", "]", "params", "=", "{", "'Action'", ":", "'DeleteTags'", ",", "'ResourceId.1'", ":", "instance_id", "}", "for", "idx", ",", "tag", "in", "enumerate", "(", "kwargs", "[", "'tags'", "]", ".", "split", "(", "','", ")", ")", ":", "params", "[", "'Tag.{0}.Key'", ".", "format", "(", "idx", ")", "]", "=", "tag", "aws", ".", "query", "(", "params", ",", "setname", "=", "'tagSet'", ",", "location", "=", "get_location", "(", ")", ",", "provider", "=", "get_provider", "(", ")", ",", "opts", "=", "__opts__", ",", "sigver", "=", "'4'", ")", "if", "resource_id", ":", "return", "get_tags", "(", "resource_id", "=", "resource_id", ")", "else", ":", "return", "get_tags", "(", "instance_id", "=", "instance_id", ")"], "docstring": "Delete tags for a resource. Normally a VM name or instance_id is passed in,\n    but a resource_id may be passed instead. If both are passed in, the\n    instance_id will be used.\n\n    CLI Examples:\n\n    .. code-block:: bash\n\n        salt-cloud -a del_tags mymachine tags=mytag,\n        salt-cloud -a del_tags mymachine tags=tag1,tag2,tag3\n        salt-cloud -a del_tags resource_id=vol-3267ab32 tags=tag1,tag2,tag3", "docstring_tokens": ["Delete", "tags", "for", "a", "resource", ".", "Normally", "a", "VM", "name", "or", "instance_id", "is", "passed", "in", "but", "a", "resource_id", "may", "be", "passed", "instead", ".", "If", "both", "are", "passed", "in", "the", "instance_id", "will", "be", "used", "."], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/cloud/clouds/ec2.py#L3253-L3302", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/cloud/clouds/ec2.py", "func_name": "rename", "original_string": "def rename(name, kwargs, call=None):\n    '''\n    Properly rename a node. Pass in the new name as \"new name\".\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt-cloud -a rename mymachine newname=yourmachine\n    '''\n    if call != 'action':\n        raise SaltCloudSystemExit(\n            'The rename action must be called with -a or --action.'\n        )\n\n    log.info('Renaming %s to %s', name, kwargs['newname'])\n\n    set_tags(name, {'Name': kwargs['newname']}, call='action')\n\n    salt.utils.cloud.rename_key(\n        __opts__['pki_dir'], name, kwargs['newname']\n    )", "language": "python", "code": "def rename(name, kwargs, call=None):\n    '''\n    Properly rename a node. Pass in the new name as \"new name\".\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt-cloud -a rename mymachine newname=yourmachine\n    '''\n    if call != 'action':\n        raise SaltCloudSystemExit(\n            'The rename action must be called with -a or --action.'\n        )\n\n    log.info('Renaming %s to %s', name, kwargs['newname'])\n\n    set_tags(name, {'Name': kwargs['newname']}, call='action')\n\n    salt.utils.cloud.rename_key(\n        __opts__['pki_dir'], name, kwargs['newname']\n    )", "code_tokens": ["def", "rename", "(", "name", ",", "kwargs", ",", "call", "=", "None", ")", ":", "if", "call", "!=", "'action'", ":", "raise", "SaltCloudSystemExit", "(", "'The rename action must be called with -a or --action.'", ")", "log", ".", "info", "(", "'Renaming %s to %s'", ",", "name", ",", "kwargs", "[", "'newname'", "]", ")", "set_tags", "(", "name", ",", "{", "'Name'", ":", "kwargs", "[", "'newname'", "]", "}", ",", "call", "=", "'action'", ")", "salt", ".", "utils", ".", "cloud", ".", "rename_key", "(", "__opts__", "[", "'pki_dir'", "]", ",", "name", ",", "kwargs", "[", "'newname'", "]", ")"], "docstring": "Properly rename a node. Pass in the new name as \"new name\".\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt-cloud -a rename mymachine newname=yourmachine", "docstring_tokens": ["Properly", "rename", "a", "node", ".", "Pass", "in", "the", "new", "name", "as", "new", "name", "."], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/cloud/clouds/ec2.py#L3305-L3326", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/cloud/clouds/ec2.py", "func_name": "destroy", "original_string": "def destroy(name, call=None):\n    '''\n    Destroy a node. Will check termination protection and warn if enabled.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt-cloud --destroy mymachine\n    '''\n    if call == 'function':\n        raise SaltCloudSystemExit(\n            'The destroy action must be called with -d, --destroy, '\n            '-a or --action.'\n        )\n\n    node_metadata = _get_node(name)\n    instance_id = node_metadata['instanceId']\n    sir_id = node_metadata.get('spotInstanceRequestId')\n    protected = show_term_protect(\n        name=name,\n        instance_id=instance_id,\n        call='action',\n        quiet=True\n    )\n\n    __utils__['cloud.fire_event'](\n        'event',\n        'destroying instance',\n        'salt/cloud/{0}/destroying'.format(name),\n        args={'name': name, 'instance_id': instance_id},\n        sock_dir=__opts__['sock_dir'],\n        transport=__opts__['transport']\n    )\n\n    if protected == 'true':\n        raise SaltCloudSystemExit(\n            'This instance has been protected from being destroyed. '\n            'Use the following command to disable protection:\\n\\n'\n            'salt-cloud -a disable_term_protect {0}'.format(\n                name\n            )\n        )\n\n    ret = {}\n\n    # Default behavior is to rename EC2 VMs when destroyed\n    # via salt-cloud, unless explicitly set to False.\n    rename_on_destroy = config.get_cloud_config_value('rename_on_destroy',\n                                                      get_configured_provider(),\n                                                      __opts__,\n                                                      search_global=False)\n    if rename_on_destroy is not False:\n        newname = '{0}-DEL{1}'.format(name, uuid.uuid4().hex)\n        rename(name, kwargs={'newname': newname}, call='action')\n        log.info(\n            'Machine will be identified as %s until it has been '\n            'cleaned up.', newname\n        )\n        ret['newname'] = newname\n\n    params = {'Action': 'TerminateInstances',\n              'InstanceId.1': instance_id}\n\n    location = get_location()\n    provider = get_provider()\n    result = aws.query(params,\n                       location=location,\n                       provider=provider,\n                       opts=__opts__,\n                       sigver='4')\n\n    log.info(result)\n    ret.update(result[0])\n\n    # If this instance is part of a spot instance request, we\n    # need to cancel it as well\n    if sir_id is not None:\n        params = {'Action': 'CancelSpotInstanceRequests',\n                  'SpotInstanceRequestId.1': sir_id}\n        result = aws.query(params,\n                           location=location,\n                           provider=provider,\n                           opts=__opts__,\n                           sigver='4')\n        ret['spotInstance'] = result[0]\n\n    __utils__['cloud.fire_event'](\n        'event',\n        'destroyed instance',\n        'salt/cloud/{0}/destroyed'.format(name),\n        args={'name': name, 'instance_id': instance_id},\n        sock_dir=__opts__['sock_dir'],\n        transport=__opts__['transport']\n    )\n\n    __utils__['cloud.cachedir_index_del'](name)\n\n    if __opts__.get('update_cachedir', False) is True:\n        __utils__['cloud.delete_minion_cachedir'](name, __active_provider_name__.split(':')[0], __opts__)\n\n    return ret", "language": "python", "code": "def destroy(name, call=None):\n    '''\n    Destroy a node. Will check termination protection and warn if enabled.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt-cloud --destroy mymachine\n    '''\n    if call == 'function':\n        raise SaltCloudSystemExit(\n            'The destroy action must be called with -d, --destroy, '\n            '-a or --action.'\n        )\n\n    node_metadata = _get_node(name)\n    instance_id = node_metadata['instanceId']\n    sir_id = node_metadata.get('spotInstanceRequestId')\n    protected = show_term_protect(\n        name=name,\n        instance_id=instance_id,\n        call='action',\n        quiet=True\n    )\n\n    __utils__['cloud.fire_event'](\n        'event',\n        'destroying instance',\n        'salt/cloud/{0}/destroying'.format(name),\n        args={'name': name, 'instance_id': instance_id},\n        sock_dir=__opts__['sock_dir'],\n        transport=__opts__['transport']\n    )\n\n    if protected == 'true':\n        raise SaltCloudSystemExit(\n            'This instance has been protected from being destroyed. '\n            'Use the following command to disable protection:\\n\\n'\n            'salt-cloud -a disable_term_protect {0}'.format(\n                name\n            )\n        )\n\n    ret = {}\n\n    # Default behavior is to rename EC2 VMs when destroyed\n    # via salt-cloud, unless explicitly set to False.\n    rename_on_destroy = config.get_cloud_config_value('rename_on_destroy',\n                                                      get_configured_provider(),\n                                                      __opts__,\n                                                      search_global=False)\n    if rename_on_destroy is not False:\n        newname = '{0}-DEL{1}'.format(name, uuid.uuid4().hex)\n        rename(name, kwargs={'newname': newname}, call='action')\n        log.info(\n            'Machine will be identified as %s until it has been '\n            'cleaned up.', newname\n        )\n        ret['newname'] = newname\n\n    params = {'Action': 'TerminateInstances',\n              'InstanceId.1': instance_id}\n\n    location = get_location()\n    provider = get_provider()\n    result = aws.query(params,\n                       location=location,\n                       provider=provider,\n                       opts=__opts__,\n                       sigver='4')\n\n    log.info(result)\n    ret.update(result[0])\n\n    # If this instance is part of a spot instance request, we\n    # need to cancel it as well\n    if sir_id is not None:\n        params = {'Action': 'CancelSpotInstanceRequests',\n                  'SpotInstanceRequestId.1': sir_id}\n        result = aws.query(params,\n                           location=location,\n                           provider=provider,\n                           opts=__opts__,\n                           sigver='4')\n        ret['spotInstance'] = result[0]\n\n    __utils__['cloud.fire_event'](\n        'event',\n        'destroyed instance',\n        'salt/cloud/{0}/destroyed'.format(name),\n        args={'name': name, 'instance_id': instance_id},\n        sock_dir=__opts__['sock_dir'],\n        transport=__opts__['transport']\n    )\n\n    __utils__['cloud.cachedir_index_del'](name)\n\n    if __opts__.get('update_cachedir', False) is True:\n        __utils__['cloud.delete_minion_cachedir'](name, __active_provider_name__.split(':')[0], __opts__)\n\n    return ret", "code_tokens": ["def", "destroy", "(", "name", ",", "call", "=", "None", ")", ":", "if", "call", "==", "'function'", ":", "raise", "SaltCloudSystemExit", "(", "'The destroy action must be called with -d, --destroy, '", "'-a or --action.'", ")", "node_metadata", "=", "_get_node", "(", "name", ")", "instance_id", "=", "node_metadata", "[", "'instanceId'", "]", "sir_id", "=", "node_metadata", ".", "get", "(", "'spotInstanceRequestId'", ")", "protected", "=", "show_term_protect", "(", "name", "=", "name", ",", "instance_id", "=", "instance_id", ",", "call", "=", "'action'", ",", "quiet", "=", "True", ")", "__utils__", "[", "'cloud.fire_event'", "]", "(", "'event'", ",", "'destroying instance'", ",", "'salt/cloud/{0}/destroying'", ".", "format", "(", "name", ")", ",", "args", "=", "{", "'name'", ":", "name", ",", "'instance_id'", ":", "instance_id", "}", ",", "sock_dir", "=", "__opts__", "[", "'sock_dir'", "]", ",", "transport", "=", "__opts__", "[", "'transport'", "]", ")", "if", "protected", "==", "'true'", ":", "raise", "SaltCloudSystemExit", "(", "'This instance has been protected from being destroyed. '", "'Use the following command to disable protection:\\n\\n'", "'salt-cloud -a disable_term_protect {0}'", ".", "format", "(", "name", ")", ")", "ret", "=", "{", "}", "# Default behavior is to rename EC2 VMs when destroyed", "# via salt-cloud, unless explicitly set to False.", "rename_on_destroy", "=", "config", ".", "get_cloud_config_value", "(", "'rename_on_destroy'", ",", "get_configured_provider", "(", ")", ",", "__opts__", ",", "search_global", "=", "False", ")", "if", "rename_on_destroy", "is", "not", "False", ":", "newname", "=", "'{0}-DEL{1}'", ".", "format", "(", "name", ",", "uuid", ".", "uuid4", "(", ")", ".", "hex", ")", "rename", "(", "name", ",", "kwargs", "=", "{", "'newname'", ":", "newname", "}", ",", "call", "=", "'action'", ")", "log", ".", "info", "(", "'Machine will be identified as %s until it has been '", "'cleaned up.'", ",", "newname", ")", "ret", "[", "'newname'", "]", "=", "newname", "params", "=", "{", "'Action'", ":", "'TerminateInstances'", ",", "'InstanceId.1'", ":", "instance_id", "}", "location", "=", "get_location", "(", ")", "provider", "=", "get_provider", "(", ")", "result", "=", "aws", ".", "query", "(", "params", ",", "location", "=", "location", ",", "provider", "=", "provider", ",", "opts", "=", "__opts__", ",", "sigver", "=", "'4'", ")", "log", ".", "info", "(", "result", ")", "ret", ".", "update", "(", "result", "[", "0", "]", ")", "# If this instance is part of a spot instance request, we", "# need to cancel it as well", "if", "sir_id", "is", "not", "None", ":", "params", "=", "{", "'Action'", ":", "'CancelSpotInstanceRequests'", ",", "'SpotInstanceRequestId.1'", ":", "sir_id", "}", "result", "=", "aws", ".", "query", "(", "params", ",", "location", "=", "location", ",", "provider", "=", "provider", ",", "opts", "=", "__opts__", ",", "sigver", "=", "'4'", ")", "ret", "[", "'spotInstance'", "]", "=", "result", "[", "0", "]", "__utils__", "[", "'cloud.fire_event'", "]", "(", "'event'", ",", "'destroyed instance'", ",", "'salt/cloud/{0}/destroyed'", ".", "format", "(", "name", ")", ",", "args", "=", "{", "'name'", ":", "name", ",", "'instance_id'", ":", "instance_id", "}", ",", "sock_dir", "=", "__opts__", "[", "'sock_dir'", "]", ",", "transport", "=", "__opts__", "[", "'transport'", "]", ")", "__utils__", "[", "'cloud.cachedir_index_del'", "]", "(", "name", ")", "if", "__opts__", ".", "get", "(", "'update_cachedir'", ",", "False", ")", "is", "True", ":", "__utils__", "[", "'cloud.delete_minion_cachedir'", "]", "(", "name", ",", "__active_provider_name__", ".", "split", "(", "':'", ")", "[", "0", "]", ",", "__opts__", ")", "return", "ret"], "docstring": "Destroy a node. Will check termination protection and warn if enabled.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt-cloud --destroy mymachine", "docstring_tokens": ["Destroy", "a", "node", ".", "Will", "check", "termination", "protection", "and", "warn", "if", "enabled", "."], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/cloud/clouds/ec2.py#L3329-L3430", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/cloud/clouds/ec2.py", "func_name": "reboot", "original_string": "def reboot(name, call=None):\n    '''\n    Reboot a node.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt-cloud -a reboot mymachine\n    '''\n    instance_id = _get_node(name)['instanceId']\n    params = {'Action': 'RebootInstances',\n              'InstanceId.1': instance_id}\n\n    result = aws.query(params,\n                       setname='tagSet',\n                       location=get_location(),\n                       provider=get_provider(),\n                       opts=__opts__,\n                       sigver='4')\n\n    if result == []:\n        log.info('Complete')\n\n    return {'Reboot': 'Complete'}", "language": "python", "code": "def reboot(name, call=None):\n    '''\n    Reboot a node.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt-cloud -a reboot mymachine\n    '''\n    instance_id = _get_node(name)['instanceId']\n    params = {'Action': 'RebootInstances',\n              'InstanceId.1': instance_id}\n\n    result = aws.query(params,\n                       setname='tagSet',\n                       location=get_location(),\n                       provider=get_provider(),\n                       opts=__opts__,\n                       sigver='4')\n\n    if result == []:\n        log.info('Complete')\n\n    return {'Reboot': 'Complete'}", "code_tokens": ["def", "reboot", "(", "name", ",", "call", "=", "None", ")", ":", "instance_id", "=", "_get_node", "(", "name", ")", "[", "'instanceId'", "]", "params", "=", "{", "'Action'", ":", "'RebootInstances'", ",", "'InstanceId.1'", ":", "instance_id", "}", "result", "=", "aws", ".", "query", "(", "params", ",", "setname", "=", "'tagSet'", ",", "location", "=", "get_location", "(", ")", ",", "provider", "=", "get_provider", "(", ")", ",", "opts", "=", "__opts__", ",", "sigver", "=", "'4'", ")", "if", "result", "==", "[", "]", ":", "log", ".", "info", "(", "'Complete'", ")", "return", "{", "'Reboot'", ":", "'Complete'", "}"], "docstring": "Reboot a node.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt-cloud -a reboot mymachine", "docstring_tokens": ["Reboot", "a", "node", "."], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/cloud/clouds/ec2.py#L3433-L3457", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/cloud/clouds/ec2.py", "func_name": "show_image", "original_string": "def show_image(kwargs, call=None):\n    '''\n    Show the details from EC2 concerning an AMI\n    '''\n    if call != 'function':\n        raise SaltCloudSystemExit(\n            'The show_image action must be called with -f or --function.'\n        )\n\n    params = {'ImageId.1': kwargs['image'],\n              'Action': 'DescribeImages'}\n    result = aws.query(params,\n                       setname='tagSet',\n                       location=get_location(),\n                       provider=get_provider(),\n                       opts=__opts__,\n                       sigver='4')\n    log.info(result)\n\n    return result", "language": "python", "code": "def show_image(kwargs, call=None):\n    '''\n    Show the details from EC2 concerning an AMI\n    '''\n    if call != 'function':\n        raise SaltCloudSystemExit(\n            'The show_image action must be called with -f or --function.'\n        )\n\n    params = {'ImageId.1': kwargs['image'],\n              'Action': 'DescribeImages'}\n    result = aws.query(params,\n                       setname='tagSet',\n                       location=get_location(),\n                       provider=get_provider(),\n                       opts=__opts__,\n                       sigver='4')\n    log.info(result)\n\n    return result", "code_tokens": ["def", "show_image", "(", "kwargs", ",", "call", "=", "None", ")", ":", "if", "call", "!=", "'function'", ":", "raise", "SaltCloudSystemExit", "(", "'The show_image action must be called with -f or --function.'", ")", "params", "=", "{", "'ImageId.1'", ":", "kwargs", "[", "'image'", "]", ",", "'Action'", ":", "'DescribeImages'", "}", "result", "=", "aws", ".", "query", "(", "params", ",", "setname", "=", "'tagSet'", ",", "location", "=", "get_location", "(", ")", ",", "provider", "=", "get_provider", "(", ")", ",", "opts", "=", "__opts__", ",", "sigver", "=", "'4'", ")", "log", ".", "info", "(", "result", ")", "return", "result"], "docstring": "Show the details from EC2 concerning an AMI", "docstring_tokens": ["Show", "the", "details", "from", "EC2", "concerning", "an", "AMI"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/cloud/clouds/ec2.py#L3460-L3479", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/cloud/clouds/ec2.py", "func_name": "show_instance", "original_string": "def show_instance(name=None, instance_id=None, call=None, kwargs=None):\n    '''\n    Show the details from EC2 concerning an AMI.\n\n    Can be called as an action (which requires a name):\n\n    .. code-block:: bash\n\n        salt-cloud -a show_instance myinstance\n\n    ...or as a function (which requires either a name or instance_id):\n\n    .. code-block:: bash\n\n        salt-cloud -f show_instance my-ec2 name=myinstance\n        salt-cloud -f show_instance my-ec2 instance_id=i-d34db33f\n    '''\n    if not name and call == 'action':\n        raise SaltCloudSystemExit(\n            'The show_instance action requires a name.'\n        )\n\n    if call == 'function':\n        name = kwargs.get('name', None)\n        instance_id = kwargs.get('instance_id', None)\n\n    if not name and not instance_id:\n        raise SaltCloudSystemExit(\n            'The show_instance function requires '\n            'either a name or an instance_id'\n        )\n\n    node = _get_node(name=name, instance_id=instance_id)\n    __utils__['cloud.cache_node'](node, __active_provider_name__, __opts__)\n    return node", "language": "python", "code": "def show_instance(name=None, instance_id=None, call=None, kwargs=None):\n    '''\n    Show the details from EC2 concerning an AMI.\n\n    Can be called as an action (which requires a name):\n\n    .. code-block:: bash\n\n        salt-cloud -a show_instance myinstance\n\n    ...or as a function (which requires either a name or instance_id):\n\n    .. code-block:: bash\n\n        salt-cloud -f show_instance my-ec2 name=myinstance\n        salt-cloud -f show_instance my-ec2 instance_id=i-d34db33f\n    '''\n    if not name and call == 'action':\n        raise SaltCloudSystemExit(\n            'The show_instance action requires a name.'\n        )\n\n    if call == 'function':\n        name = kwargs.get('name', None)\n        instance_id = kwargs.get('instance_id', None)\n\n    if not name and not instance_id:\n        raise SaltCloudSystemExit(\n            'The show_instance function requires '\n            'either a name or an instance_id'\n        )\n\n    node = _get_node(name=name, instance_id=instance_id)\n    __utils__['cloud.cache_node'](node, __active_provider_name__, __opts__)\n    return node", "code_tokens": ["def", "show_instance", "(", "name", "=", "None", ",", "instance_id", "=", "None", ",", "call", "=", "None", ",", "kwargs", "=", "None", ")", ":", "if", "not", "name", "and", "call", "==", "'action'", ":", "raise", "SaltCloudSystemExit", "(", "'The show_instance action requires a name.'", ")", "if", "call", "==", "'function'", ":", "name", "=", "kwargs", ".", "get", "(", "'name'", ",", "None", ")", "instance_id", "=", "kwargs", ".", "get", "(", "'instance_id'", ",", "None", ")", "if", "not", "name", "and", "not", "instance_id", ":", "raise", "SaltCloudSystemExit", "(", "'The show_instance function requires '", "'either a name or an instance_id'", ")", "node", "=", "_get_node", "(", "name", "=", "name", ",", "instance_id", "=", "instance_id", ")", "__utils__", "[", "'cloud.cache_node'", "]", "(", "node", ",", "__active_provider_name__", ",", "__opts__", ")", "return", "node"], "docstring": "Show the details from EC2 concerning an AMI.\n\n    Can be called as an action (which requires a name):\n\n    .. code-block:: bash\n\n        salt-cloud -a show_instance myinstance\n\n    ...or as a function (which requires either a name or instance_id):\n\n    .. code-block:: bash\n\n        salt-cloud -f show_instance my-ec2 name=myinstance\n        salt-cloud -f show_instance my-ec2 instance_id=i-d34db33f", "docstring_tokens": ["Show", "the", "details", "from", "EC2", "concerning", "an", "AMI", "."], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/cloud/clouds/ec2.py#L3482-L3516", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/cloud/clouds/ec2.py", "func_name": "_extract_instance_info", "original_string": "def _extract_instance_info(instances):\n    '''\n    Given an instance query, return a dict of all instance data\n    '''\n    ret = {}\n    for instance in instances:\n        # items could be type dict or list (for stopped EC2 instances)\n        if isinstance(instance['instancesSet']['item'], list):\n            for item in instance['instancesSet']['item']:\n                name = _extract_name_tag(item)\n                ret[name] = item\n                ret[name]['name'] = name\n                ret[name].update(\n                    dict(\n                        id=item['instanceId'],\n                        image=item['imageId'],\n                        size=item['instanceType'],\n                        state=item['instanceState']['name'],\n                        private_ips=item.get('privateIpAddress', []),\n                        public_ips=item.get('ipAddress', [])\n                    )\n                )\n        else:\n            item = instance['instancesSet']['item']\n            name = _extract_name_tag(item)\n            ret[name] = item\n            ret[name]['name'] = name\n            ret[name].update(\n                dict(\n                    id=item['instanceId'],\n                    image=item['imageId'],\n                    size=item['instanceType'],\n                    state=item['instanceState']['name'],\n                    private_ips=item.get('privateIpAddress', []),\n                    public_ips=item.get('ipAddress', [])\n                )\n            )\n\n    return ret", "language": "python", "code": "def _extract_instance_info(instances):\n    '''\n    Given an instance query, return a dict of all instance data\n    '''\n    ret = {}\n    for instance in instances:\n        # items could be type dict or list (for stopped EC2 instances)\n        if isinstance(instance['instancesSet']['item'], list):\n            for item in instance['instancesSet']['item']:\n                name = _extract_name_tag(item)\n                ret[name] = item\n                ret[name]['name'] = name\n                ret[name].update(\n                    dict(\n                        id=item['instanceId'],\n                        image=item['imageId'],\n                        size=item['instanceType'],\n                        state=item['instanceState']['name'],\n                        private_ips=item.get('privateIpAddress', []),\n                        public_ips=item.get('ipAddress', [])\n                    )\n                )\n        else:\n            item = instance['instancesSet']['item']\n            name = _extract_name_tag(item)\n            ret[name] = item\n            ret[name]['name'] = name\n            ret[name].update(\n                dict(\n                    id=item['instanceId'],\n                    image=item['imageId'],\n                    size=item['instanceType'],\n                    state=item['instanceState']['name'],\n                    private_ips=item.get('privateIpAddress', []),\n                    public_ips=item.get('ipAddress', [])\n                )\n            )\n\n    return ret", "code_tokens": ["def", "_extract_instance_info", "(", "instances", ")", ":", "ret", "=", "{", "}", "for", "instance", "in", "instances", ":", "# items could be type dict or list (for stopped EC2 instances)", "if", "isinstance", "(", "instance", "[", "'instancesSet'", "]", "[", "'item'", "]", ",", "list", ")", ":", "for", "item", "in", "instance", "[", "'instancesSet'", "]", "[", "'item'", "]", ":", "name", "=", "_extract_name_tag", "(", "item", ")", "ret", "[", "name", "]", "=", "item", "ret", "[", "name", "]", "[", "'name'", "]", "=", "name", "ret", "[", "name", "]", ".", "update", "(", "dict", "(", "id", "=", "item", "[", "'instanceId'", "]", ",", "image", "=", "item", "[", "'imageId'", "]", ",", "size", "=", "item", "[", "'instanceType'", "]", ",", "state", "=", "item", "[", "'instanceState'", "]", "[", "'name'", "]", ",", "private_ips", "=", "item", ".", "get", "(", "'privateIpAddress'", ",", "[", "]", ")", ",", "public_ips", "=", "item", ".", "get", "(", "'ipAddress'", ",", "[", "]", ")", ")", ")", "else", ":", "item", "=", "instance", "[", "'instancesSet'", "]", "[", "'item'", "]", "name", "=", "_extract_name_tag", "(", "item", ")", "ret", "[", "name", "]", "=", "item", "ret", "[", "name", "]", "[", "'name'", "]", "=", "name", "ret", "[", "name", "]", ".", "update", "(", "dict", "(", "id", "=", "item", "[", "'instanceId'", "]", ",", "image", "=", "item", "[", "'imageId'", "]", ",", "size", "=", "item", "[", "'instanceType'", "]", ",", "state", "=", "item", "[", "'instanceState'", "]", "[", "'name'", "]", ",", "private_ips", "=", "item", ".", "get", "(", "'privateIpAddress'", ",", "[", "]", ")", ",", "public_ips", "=", "item", ".", "get", "(", "'ipAddress'", ",", "[", "]", ")", ")", ")", "return", "ret"], "docstring": "Given an instance query, return a dict of all instance data", "docstring_tokens": ["Given", "an", "instance", "query", "return", "a", "dict", "of", "all", "instance", "data"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/cloud/clouds/ec2.py#L3583-L3621", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/cloud/clouds/ec2.py", "func_name": "_list_nodes_full", "original_string": "def _list_nodes_full(location=None):\n    '''\n    Return a list of the VMs that in this location\n    '''\n    provider = __active_provider_name__ or 'ec2'\n    if ':' in provider:\n        comps = provider.split(':')\n        provider = comps[0]\n\n    params = {'Action': 'DescribeInstances'}\n    instances = aws.query(params,\n                          location=location,\n                          provider=provider,\n                          opts=__opts__,\n                          sigver='4')\n    if 'error' in instances:\n        raise SaltCloudSystemExit(\n            'An error occurred while listing nodes: {0}'.format(\n                instances['error']['Errors']['Error']['Message']\n            )\n        )\n\n    ret = _extract_instance_info(instances)\n\n    __utils__['cloud.cache_node_list'](ret, provider, __opts__)\n    return ret", "language": "python", "code": "def _list_nodes_full(location=None):\n    '''\n    Return a list of the VMs that in this location\n    '''\n    provider = __active_provider_name__ or 'ec2'\n    if ':' in provider:\n        comps = provider.split(':')\n        provider = comps[0]\n\n    params = {'Action': 'DescribeInstances'}\n    instances = aws.query(params,\n                          location=location,\n                          provider=provider,\n                          opts=__opts__,\n                          sigver='4')\n    if 'error' in instances:\n        raise SaltCloudSystemExit(\n            'An error occurred while listing nodes: {0}'.format(\n                instances['error']['Errors']['Error']['Message']\n            )\n        )\n\n    ret = _extract_instance_info(instances)\n\n    __utils__['cloud.cache_node_list'](ret, provider, __opts__)\n    return ret", "code_tokens": ["def", "_list_nodes_full", "(", "location", "=", "None", ")", ":", "provider", "=", "__active_provider_name__", "or", "'ec2'", "if", "':'", "in", "provider", ":", "comps", "=", "provider", ".", "split", "(", "':'", ")", "provider", "=", "comps", "[", "0", "]", "params", "=", "{", "'Action'", ":", "'DescribeInstances'", "}", "instances", "=", "aws", ".", "query", "(", "params", ",", "location", "=", "location", ",", "provider", "=", "provider", ",", "opts", "=", "__opts__", ",", "sigver", "=", "'4'", ")", "if", "'error'", "in", "instances", ":", "raise", "SaltCloudSystemExit", "(", "'An error occurred while listing nodes: {0}'", ".", "format", "(", "instances", "[", "'error'", "]", "[", "'Errors'", "]", "[", "'Error'", "]", "[", "'Message'", "]", ")", ")", "ret", "=", "_extract_instance_info", "(", "instances", ")", "__utils__", "[", "'cloud.cache_node_list'", "]", "(", "ret", ",", "provider", ",", "__opts__", ")", "return", "ret"], "docstring": "Return a list of the VMs that in this location", "docstring_tokens": ["Return", "a", "list", "of", "the", "VMs", "that", "in", "this", "location"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/cloud/clouds/ec2.py#L3624-L3649", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/cloud/clouds/ec2.py", "func_name": "list_nodes_min", "original_string": "def list_nodes_min(location=None, call=None):\n    '''\n    Return a list of the VMs that are on the provider. Only a list of VM names,\n    and their state, is returned. This is the minimum amount of information\n    needed to check for existing VMs.\n    '''\n    if call == 'action':\n        raise SaltCloudSystemExit(\n            'The list_nodes_min function must be called with -f or --function.'\n        )\n\n    ret = {}\n    params = {'Action': 'DescribeInstances'}\n    instances = aws.query(params,\n                          location=get_location(),\n                          provider=get_provider(),\n                          opts=__opts__,\n                          sigver='4')\n    if 'error' in instances:\n        raise SaltCloudSystemExit(\n            'An error occurred while listing nodes: {0}'.format(\n                instances['error']['Errors']['Error']['Message']\n            )\n        )\n\n    for instance in instances:\n        if isinstance(instance['instancesSet']['item'], list):\n            items = instance['instancesSet']['item']\n        else:\n            items = [instance['instancesSet']['item']]\n\n        for item in items:\n            state = item['instanceState']['name']\n            name = _extract_name_tag(item)\n            id = item['instanceId']\n            ret[name] = {'state': state, 'id': id}\n    return ret", "language": "python", "code": "def list_nodes_min(location=None, call=None):\n    '''\n    Return a list of the VMs that are on the provider. Only a list of VM names,\n    and their state, is returned. This is the minimum amount of information\n    needed to check for existing VMs.\n    '''\n    if call == 'action':\n        raise SaltCloudSystemExit(\n            'The list_nodes_min function must be called with -f or --function.'\n        )\n\n    ret = {}\n    params = {'Action': 'DescribeInstances'}\n    instances = aws.query(params,\n                          location=get_location(),\n                          provider=get_provider(),\n                          opts=__opts__,\n                          sigver='4')\n    if 'error' in instances:\n        raise SaltCloudSystemExit(\n            'An error occurred while listing nodes: {0}'.format(\n                instances['error']['Errors']['Error']['Message']\n            )\n        )\n\n    for instance in instances:\n        if isinstance(instance['instancesSet']['item'], list):\n            items = instance['instancesSet']['item']\n        else:\n            items = [instance['instancesSet']['item']]\n\n        for item in items:\n            state = item['instanceState']['name']\n            name = _extract_name_tag(item)\n            id = item['instanceId']\n            ret[name] = {'state': state, 'id': id}\n    return ret", "code_tokens": ["def", "list_nodes_min", "(", "location", "=", "None", ",", "call", "=", "None", ")", ":", "if", "call", "==", "'action'", ":", "raise", "SaltCloudSystemExit", "(", "'The list_nodes_min function must be called with -f or --function.'", ")", "ret", "=", "{", "}", "params", "=", "{", "'Action'", ":", "'DescribeInstances'", "}", "instances", "=", "aws", ".", "query", "(", "params", ",", "location", "=", "get_location", "(", ")", ",", "provider", "=", "get_provider", "(", ")", ",", "opts", "=", "__opts__", ",", "sigver", "=", "'4'", ")", "if", "'error'", "in", "instances", ":", "raise", "SaltCloudSystemExit", "(", "'An error occurred while listing nodes: {0}'", ".", "format", "(", "instances", "[", "'error'", "]", "[", "'Errors'", "]", "[", "'Error'", "]", "[", "'Message'", "]", ")", ")", "for", "instance", "in", "instances", ":", "if", "isinstance", "(", "instance", "[", "'instancesSet'", "]", "[", "'item'", "]", ",", "list", ")", ":", "items", "=", "instance", "[", "'instancesSet'", "]", "[", "'item'", "]", "else", ":", "items", "=", "[", "instance", "[", "'instancesSet'", "]", "[", "'item'", "]", "]", "for", "item", "in", "items", ":", "state", "=", "item", "[", "'instanceState'", "]", "[", "'name'", "]", "name", "=", "_extract_name_tag", "(", "item", ")", "id", "=", "item", "[", "'instanceId'", "]", "ret", "[", "name", "]", "=", "{", "'state'", ":", "state", ",", "'id'", ":", "id", "}", "return", "ret"], "docstring": "Return a list of the VMs that are on the provider. Only a list of VM names,\n    and their state, is returned. This is the minimum amount of information\n    needed to check for existing VMs.", "docstring_tokens": ["Return", "a", "list", "of", "the", "VMs", "that", "are", "on", "the", "provider", ".", "Only", "a", "list", "of", "VM", "names", "and", "their", "state", "is", "returned", ".", "This", "is", "the", "minimum", "amount", "of", "information", "needed", "to", "check", "for", "existing", "VMs", "."], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/cloud/clouds/ec2.py#L3652-L3688", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/cloud/clouds/ec2.py", "func_name": "list_nodes_select", "original_string": "def list_nodes_select(call=None):\n    '''\n    Return a list of the VMs that are on the provider, with select fields\n    '''\n    return salt.utils.cloud.list_nodes_select(\n        list_nodes_full(get_location()), __opts__['query.selection'], call,\n    )", "language": "python", "code": "def list_nodes_select(call=None):\n    '''\n    Return a list of the VMs that are on the provider, with select fields\n    '''\n    return salt.utils.cloud.list_nodes_select(\n        list_nodes_full(get_location()), __opts__['query.selection'], call,\n    )", "code_tokens": ["def", "list_nodes_select", "(", "call", "=", "None", ")", ":", "return", "salt", ".", "utils", ".", "cloud", ".", "list_nodes_select", "(", "list_nodes_full", "(", "get_location", "(", ")", ")", ",", "__opts__", "[", "'query.selection'", "]", ",", "call", ",", ")"], "docstring": "Return a list of the VMs that are on the provider, with select fields", "docstring_tokens": ["Return", "a", "list", "of", "the", "VMs", "that", "are", "on", "the", "provider", "with", "select", "fields"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/cloud/clouds/ec2.py#L3721-L3727", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/cloud/clouds/ec2.py", "func_name": "show_term_protect", "original_string": "def show_term_protect(name=None, instance_id=None, call=None, quiet=False):\n    '''\n    Show the details from EC2 concerning an instance's termination protection state\n\n    '''\n    if call != 'action':\n        raise SaltCloudSystemExit(\n            'The show_term_protect action must be called with -a or --action.'\n        )\n\n    if not instance_id:\n        instance_id = _get_node(name)['instanceId']\n    params = {'Action': 'DescribeInstanceAttribute',\n              'InstanceId': instance_id,\n              'Attribute': 'disableApiTermination'}\n    result = aws.query(params,\n                       location=get_location(),\n                       provider=get_provider(),\n                       return_root=True,\n                       opts=__opts__,\n                       sigver='4')\n\n    disable_protect = False\n    for item in result:\n        if 'value' in item:\n            disable_protect = item['value']\n            break\n\n    log.log(\n        logging.DEBUG if quiet is True else logging.INFO,\n        'Termination Protection is %s for %s',\n        disable_protect == 'true' and 'enabled' or 'disabled', name\n    )\n\n    return disable_protect", "language": "python", "code": "def show_term_protect(name=None, instance_id=None, call=None, quiet=False):\n    '''\n    Show the details from EC2 concerning an instance's termination protection state\n\n    '''\n    if call != 'action':\n        raise SaltCloudSystemExit(\n            'The show_term_protect action must be called with -a or --action.'\n        )\n\n    if not instance_id:\n        instance_id = _get_node(name)['instanceId']\n    params = {'Action': 'DescribeInstanceAttribute',\n              'InstanceId': instance_id,\n              'Attribute': 'disableApiTermination'}\n    result = aws.query(params,\n                       location=get_location(),\n                       provider=get_provider(),\n                       return_root=True,\n                       opts=__opts__,\n                       sigver='4')\n\n    disable_protect = False\n    for item in result:\n        if 'value' in item:\n            disable_protect = item['value']\n            break\n\n    log.log(\n        logging.DEBUG if quiet is True else logging.INFO,\n        'Termination Protection is %s for %s',\n        disable_protect == 'true' and 'enabled' or 'disabled', name\n    )\n\n    return disable_protect", "code_tokens": ["def", "show_term_protect", "(", "name", "=", "None", ",", "instance_id", "=", "None", ",", "call", "=", "None", ",", "quiet", "=", "False", ")", ":", "if", "call", "!=", "'action'", ":", "raise", "SaltCloudSystemExit", "(", "'The show_term_protect action must be called with -a or --action.'", ")", "if", "not", "instance_id", ":", "instance_id", "=", "_get_node", "(", "name", ")", "[", "'instanceId'", "]", "params", "=", "{", "'Action'", ":", "'DescribeInstanceAttribute'", ",", "'InstanceId'", ":", "instance_id", ",", "'Attribute'", ":", "'disableApiTermination'", "}", "result", "=", "aws", ".", "query", "(", "params", ",", "location", "=", "get_location", "(", ")", ",", "provider", "=", "get_provider", "(", ")", ",", "return_root", "=", "True", ",", "opts", "=", "__opts__", ",", "sigver", "=", "'4'", ")", "disable_protect", "=", "False", "for", "item", "in", "result", ":", "if", "'value'", "in", "item", ":", "disable_protect", "=", "item", "[", "'value'", "]", "break", "log", ".", "log", "(", "logging", ".", "DEBUG", "if", "quiet", "is", "True", "else", "logging", ".", "INFO", ",", "'Termination Protection is %s for %s'", ",", "disable_protect", "==", "'true'", "and", "'enabled'", "or", "'disabled'", ",", "name", ")", "return", "disable_protect"], "docstring": "Show the details from EC2 concerning an instance's termination protection state", "docstring_tokens": ["Show", "the", "details", "from", "EC2", "concerning", "an", "instance", "s", "termination", "protection", "state"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/cloud/clouds/ec2.py#L3730-L3764", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/cloud/clouds/ec2.py", "func_name": "show_detailed_monitoring", "original_string": "def show_detailed_monitoring(name=None, instance_id=None, call=None, quiet=False):\n    '''\n    Show the details from EC2 regarding cloudwatch detailed monitoring.\n    '''\n    if call != 'action':\n        raise SaltCloudSystemExit(\n            'The show_detailed_monitoring action must be called with -a or --action.'\n        )\n    location = get_location()\n    if six.text_type(name).startswith('i-') and (len(name) == 10 or len(name) == 19):\n        instance_id = name\n\n    if not name and not instance_id:\n        raise SaltCloudSystemExit(\n            'The show_detailed_monitoring action must be provided with a name or instance\\\n ID'\n        )\n    matched = _get_node(name=name, instance_id=instance_id, location=location)\n    log.log(\n        logging.DEBUG if quiet is True else logging.INFO,\n        'Detailed Monitoring is %s for %s', matched['monitoring'], name\n    )\n    return matched['monitoring']", "language": "python", "code": "def show_detailed_monitoring(name=None, instance_id=None, call=None, quiet=False):\n    '''\n    Show the details from EC2 regarding cloudwatch detailed monitoring.\n    '''\n    if call != 'action':\n        raise SaltCloudSystemExit(\n            'The show_detailed_monitoring action must be called with -a or --action.'\n        )\n    location = get_location()\n    if six.text_type(name).startswith('i-') and (len(name) == 10 or len(name) == 19):\n        instance_id = name\n\n    if not name and not instance_id:\n        raise SaltCloudSystemExit(\n            'The show_detailed_monitoring action must be provided with a name or instance\\\n ID'\n        )\n    matched = _get_node(name=name, instance_id=instance_id, location=location)\n    log.log(\n        logging.DEBUG if quiet is True else logging.INFO,\n        'Detailed Monitoring is %s for %s', matched['monitoring'], name\n    )\n    return matched['monitoring']", "code_tokens": ["def", "show_detailed_monitoring", "(", "name", "=", "None", ",", "instance_id", "=", "None", ",", "call", "=", "None", ",", "quiet", "=", "False", ")", ":", "if", "call", "!=", "'action'", ":", "raise", "SaltCloudSystemExit", "(", "'The show_detailed_monitoring action must be called with -a or --action.'", ")", "location", "=", "get_location", "(", ")", "if", "six", ".", "text_type", "(", "name", ")", ".", "startswith", "(", "'i-'", ")", "and", "(", "len", "(", "name", ")", "==", "10", "or", "len", "(", "name", ")", "==", "19", ")", ":", "instance_id", "=", "name", "if", "not", "name", "and", "not", "instance_id", ":", "raise", "SaltCloudSystemExit", "(", "'The show_detailed_monitoring action must be provided with a name or instance\\\n ID'", ")", "matched", "=", "_get_node", "(", "name", "=", "name", ",", "instance_id", "=", "instance_id", ",", "location", "=", "location", ")", "log", ".", "log", "(", "logging", ".", "DEBUG", "if", "quiet", "is", "True", "else", "logging", ".", "INFO", ",", "'Detailed Monitoring is %s for %s'", ",", "matched", "[", "'monitoring'", "]", ",", "name", ")", "return", "matched", "[", "'monitoring'", "]"], "docstring": "Show the details from EC2 regarding cloudwatch detailed monitoring.", "docstring_tokens": ["Show", "the", "details", "from", "EC2", "regarding", "cloudwatch", "detailed", "monitoring", "."], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/cloud/clouds/ec2.py#L3767-L3789", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/cloud/clouds/ec2.py", "func_name": "_toggle_term_protect", "original_string": "def _toggle_term_protect(name, value):\n    '''\n    Enable or Disable termination protection on a node\n\n    '''\n    instance_id = _get_node(name)['instanceId']\n    params = {'Action': 'ModifyInstanceAttribute',\n              'InstanceId': instance_id,\n              'DisableApiTermination.Value': value}\n\n    result = aws.query(params,\n                       location=get_location(),\n                       provider=get_provider(),\n                       return_root=True,\n                       opts=__opts__,\n                       sigver='4')\n\n    return show_term_protect(name=name, instance_id=instance_id, call='action')", "language": "python", "code": "def _toggle_term_protect(name, value):\n    '''\n    Enable or Disable termination protection on a node\n\n    '''\n    instance_id = _get_node(name)['instanceId']\n    params = {'Action': 'ModifyInstanceAttribute',\n              'InstanceId': instance_id,\n              'DisableApiTermination.Value': value}\n\n    result = aws.query(params,\n                       location=get_location(),\n                       provider=get_provider(),\n                       return_root=True,\n                       opts=__opts__,\n                       sigver='4')\n\n    return show_term_protect(name=name, instance_id=instance_id, call='action')", "code_tokens": ["def", "_toggle_term_protect", "(", "name", ",", "value", ")", ":", "instance_id", "=", "_get_node", "(", "name", ")", "[", "'instanceId'", "]", "params", "=", "{", "'Action'", ":", "'ModifyInstanceAttribute'", ",", "'InstanceId'", ":", "instance_id", ",", "'DisableApiTermination.Value'", ":", "value", "}", "result", "=", "aws", ".", "query", "(", "params", ",", "location", "=", "get_location", "(", ")", ",", "provider", "=", "get_provider", "(", ")", ",", "return_root", "=", "True", ",", "opts", "=", "__opts__", ",", "sigver", "=", "'4'", ")", "return", "show_term_protect", "(", "name", "=", "name", ",", "instance_id", "=", "instance_id", ",", "call", "=", "'action'", ")"], "docstring": "Enable or Disable termination protection on a node", "docstring_tokens": ["Enable", "or", "Disable", "termination", "protection", "on", "a", "node"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/cloud/clouds/ec2.py#L3792-L3809", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/cloud/clouds/ec2.py", "func_name": "disable_detailed_monitoring", "original_string": "def disable_detailed_monitoring(name, call=None):\n    '''\n    Enable/disable detailed monitoring on a node\n\n    CLI Example:\n    '''\n    if call != 'action':\n        raise SaltCloudSystemExit(\n            'The enable_term_protect action must be called with '\n            '-a or --action.'\n        )\n\n    instance_id = _get_node(name)['instanceId']\n    params = {'Action': 'UnmonitorInstances',\n              'InstanceId.1': instance_id}\n\n    result = aws.query(params,\n                       location=get_location(),\n                       provider=get_provider(),\n                       return_root=True,\n                       opts=__opts__,\n                       sigver='4')\n\n    return show_detailed_monitoring(name=name, instance_id=instance_id, call='action')", "language": "python", "code": "def disable_detailed_monitoring(name, call=None):\n    '''\n    Enable/disable detailed monitoring on a node\n\n    CLI Example:\n    '''\n    if call != 'action':\n        raise SaltCloudSystemExit(\n            'The enable_term_protect action must be called with '\n            '-a or --action.'\n        )\n\n    instance_id = _get_node(name)['instanceId']\n    params = {'Action': 'UnmonitorInstances',\n              'InstanceId.1': instance_id}\n\n    result = aws.query(params,\n                       location=get_location(),\n                       provider=get_provider(),\n                       return_root=True,\n                       opts=__opts__,\n                       sigver='4')\n\n    return show_detailed_monitoring(name=name, instance_id=instance_id, call='action')", "code_tokens": ["def", "disable_detailed_monitoring", "(", "name", ",", "call", "=", "None", ")", ":", "if", "call", "!=", "'action'", ":", "raise", "SaltCloudSystemExit", "(", "'The enable_term_protect action must be called with '", "'-a or --action.'", ")", "instance_id", "=", "_get_node", "(", "name", ")", "[", "'instanceId'", "]", "params", "=", "{", "'Action'", ":", "'UnmonitorInstances'", ",", "'InstanceId.1'", ":", "instance_id", "}", "result", "=", "aws", ".", "query", "(", "params", ",", "location", "=", "get_location", "(", ")", ",", "provider", "=", "get_provider", "(", ")", ",", "return_root", "=", "True", ",", "opts", "=", "__opts__", ",", "sigver", "=", "'4'", ")", "return", "show_detailed_monitoring", "(", "name", "=", "name", ",", "instance_id", "=", "instance_id", ",", "call", "=", "'action'", ")"], "docstring": "Enable/disable detailed monitoring on a node\n\n    CLI Example:", "docstring_tokens": ["Enable", "/", "disable", "detailed", "monitoring", "on", "a", "node"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/cloud/clouds/ec2.py#L3850-L3873", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/cloud/clouds/ec2.py", "func_name": "show_delvol_on_destroy", "original_string": "def show_delvol_on_destroy(name, kwargs=None, call=None):\n    '''\n    Do not delete all/specified EBS volumes upon instance termination\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt-cloud -a show_delvol_on_destroy mymachine\n    '''\n\n    if call != 'action':\n        raise SaltCloudSystemExit(\n            'The show_delvol_on_destroy action must be called '\n            'with -a or --action.'\n        )\n\n    if not kwargs:\n        kwargs = {}\n\n    instance_id = kwargs.get('instance_id', None)\n    device = kwargs.get('device', None)\n    volume_id = kwargs.get('volume_id', None)\n\n    if instance_id is None:\n        instance_id = _get_node(name)['instanceId']\n\n    params = {'Action': 'DescribeInstances',\n              'InstanceId.1': instance_id}\n\n    data = aws.query(params,\n                     location=get_location(),\n                     provider=get_provider(),\n                     opts=__opts__,\n                     sigver='4')\n\n    blockmap = data[0]['instancesSet']['item']['blockDeviceMapping']\n\n    if not isinstance(blockmap['item'], list):\n        blockmap['item'] = [blockmap['item']]\n\n    items = []\n\n    for idx, item in enumerate(blockmap['item']):\n        device_name = item['deviceName']\n\n        if device is not None and device != device_name:\n            continue\n\n        if volume_id is not None and volume_id != item['ebs']['volumeId']:\n            continue\n\n        info = {\n            'device_name': device_name,\n            'volume_id': item['ebs']['volumeId'],\n            'deleteOnTermination': item['ebs']['deleteOnTermination']\n        }\n\n        items.append(info)\n\n    return items", "language": "python", "code": "def show_delvol_on_destroy(name, kwargs=None, call=None):\n    '''\n    Do not delete all/specified EBS volumes upon instance termination\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt-cloud -a show_delvol_on_destroy mymachine\n    '''\n\n    if call != 'action':\n        raise SaltCloudSystemExit(\n            'The show_delvol_on_destroy action must be called '\n            'with -a or --action.'\n        )\n\n    if not kwargs:\n        kwargs = {}\n\n    instance_id = kwargs.get('instance_id', None)\n    device = kwargs.get('device', None)\n    volume_id = kwargs.get('volume_id', None)\n\n    if instance_id is None:\n        instance_id = _get_node(name)['instanceId']\n\n    params = {'Action': 'DescribeInstances',\n              'InstanceId.1': instance_id}\n\n    data = aws.query(params,\n                     location=get_location(),\n                     provider=get_provider(),\n                     opts=__opts__,\n                     sigver='4')\n\n    blockmap = data[0]['instancesSet']['item']['blockDeviceMapping']\n\n    if not isinstance(blockmap['item'], list):\n        blockmap['item'] = [blockmap['item']]\n\n    items = []\n\n    for idx, item in enumerate(blockmap['item']):\n        device_name = item['deviceName']\n\n        if device is not None and device != device_name:\n            continue\n\n        if volume_id is not None and volume_id != item['ebs']['volumeId']:\n            continue\n\n        info = {\n            'device_name': device_name,\n            'volume_id': item['ebs']['volumeId'],\n            'deleteOnTermination': item['ebs']['deleteOnTermination']\n        }\n\n        items.append(info)\n\n    return items", "code_tokens": ["def", "show_delvol_on_destroy", "(", "name", ",", "kwargs", "=", "None", ",", "call", "=", "None", ")", ":", "if", "call", "!=", "'action'", ":", "raise", "SaltCloudSystemExit", "(", "'The show_delvol_on_destroy action must be called '", "'with -a or --action.'", ")", "if", "not", "kwargs", ":", "kwargs", "=", "{", "}", "instance_id", "=", "kwargs", ".", "get", "(", "'instance_id'", ",", "None", ")", "device", "=", "kwargs", ".", "get", "(", "'device'", ",", "None", ")", "volume_id", "=", "kwargs", ".", "get", "(", "'volume_id'", ",", "None", ")", "if", "instance_id", "is", "None", ":", "instance_id", "=", "_get_node", "(", "name", ")", "[", "'instanceId'", "]", "params", "=", "{", "'Action'", ":", "'DescribeInstances'", ",", "'InstanceId.1'", ":", "instance_id", "}", "data", "=", "aws", ".", "query", "(", "params", ",", "location", "=", "get_location", "(", ")", ",", "provider", "=", "get_provider", "(", ")", ",", "opts", "=", "__opts__", ",", "sigver", "=", "'4'", ")", "blockmap", "=", "data", "[", "0", "]", "[", "'instancesSet'", "]", "[", "'item'", "]", "[", "'blockDeviceMapping'", "]", "if", "not", "isinstance", "(", "blockmap", "[", "'item'", "]", ",", "list", ")", ":", "blockmap", "[", "'item'", "]", "=", "[", "blockmap", "[", "'item'", "]", "]", "items", "=", "[", "]", "for", "idx", ",", "item", "in", "enumerate", "(", "blockmap", "[", "'item'", "]", ")", ":", "device_name", "=", "item", "[", "'deviceName'", "]", "if", "device", "is", "not", "None", "and", "device", "!=", "device_name", ":", "continue", "if", "volume_id", "is", "not", "None", "and", "volume_id", "!=", "item", "[", "'ebs'", "]", "[", "'volumeId'", "]", ":", "continue", "info", "=", "{", "'device_name'", ":", "device_name", ",", "'volume_id'", ":", "item", "[", "'ebs'", "]", "[", "'volumeId'", "]", ",", "'deleteOnTermination'", ":", "item", "[", "'ebs'", "]", "[", "'deleteOnTermination'", "]", "}", "items", ".", "append", "(", "info", ")", "return", "items"], "docstring": "Do not delete all/specified EBS volumes upon instance termination\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt-cloud -a show_delvol_on_destroy mymachine", "docstring_tokens": ["Do", "not", "delete", "all", "/", "specified", "EBS", "volumes", "upon", "instance", "termination"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/cloud/clouds/ec2.py#L3903-L3963", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/cloud/clouds/ec2.py", "func_name": "keepvol_on_destroy", "original_string": "def keepvol_on_destroy(name, kwargs=None, call=None):\n    '''\n    Do not delete all/specified EBS volumes upon instance termination\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt-cloud -a keepvol_on_destroy mymachine\n    '''\n    if call != 'action':\n        raise SaltCloudSystemExit(\n            'The keepvol_on_destroy action must be called with -a or --action.'\n        )\n\n    if not kwargs:\n        kwargs = {}\n\n    device = kwargs.get('device', None)\n    volume_id = kwargs.get('volume_id', None)\n\n    return _toggle_delvol(name=name, device=device,\n                          volume_id=volume_id, value='false')", "language": "python", "code": "def keepvol_on_destroy(name, kwargs=None, call=None):\n    '''\n    Do not delete all/specified EBS volumes upon instance termination\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt-cloud -a keepvol_on_destroy mymachine\n    '''\n    if call != 'action':\n        raise SaltCloudSystemExit(\n            'The keepvol_on_destroy action must be called with -a or --action.'\n        )\n\n    if not kwargs:\n        kwargs = {}\n\n    device = kwargs.get('device', None)\n    volume_id = kwargs.get('volume_id', None)\n\n    return _toggle_delvol(name=name, device=device,\n                          volume_id=volume_id, value='false')", "code_tokens": ["def", "keepvol_on_destroy", "(", "name", ",", "kwargs", "=", "None", ",", "call", "=", "None", ")", ":", "if", "call", "!=", "'action'", ":", "raise", "SaltCloudSystemExit", "(", "'The keepvol_on_destroy action must be called with -a or --action.'", ")", "if", "not", "kwargs", ":", "kwargs", "=", "{", "}", "device", "=", "kwargs", ".", "get", "(", "'device'", ",", "None", ")", "volume_id", "=", "kwargs", ".", "get", "(", "'volume_id'", ",", "None", ")", "return", "_toggle_delvol", "(", "name", "=", "name", ",", "device", "=", "device", ",", "volume_id", "=", "volume_id", ",", "value", "=", "'false'", ")"], "docstring": "Do not delete all/specified EBS volumes upon instance termination\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt-cloud -a keepvol_on_destroy mymachine", "docstring_tokens": ["Do", "not", "delete", "all", "/", "specified", "EBS", "volumes", "upon", "instance", "termination"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/cloud/clouds/ec2.py#L3966-L3988", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/cloud/clouds/ec2.py", "func_name": "register_image", "original_string": "def register_image(kwargs=None, call=None):\n    '''\n    Create an ami from a snapshot\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt-cloud -f register_image my-ec2-config ami_name=my_ami description=\"my description\"\n                root_device_name=/dev/xvda snapshot_id=snap-xxxxxxxx\n    '''\n\n    if call != 'function':\n        log.error(\n            'The create_volume function must be called with -f or --function.'\n        )\n        return False\n\n    if 'ami_name' not in kwargs:\n        log.error('ami_name must be specified to register an image.')\n        return False\n\n    block_device_mapping = kwargs.get('block_device_mapping', None)\n    if not block_device_mapping:\n        if 'snapshot_id' not in kwargs:\n            log.error('snapshot_id or block_device_mapping must be specified to register an image.')\n            return False\n        if 'root_device_name' not in kwargs:\n            log.error('root_device_name or block_device_mapping must be specified to register an image.')\n            return False\n        block_device_mapping = [{\n            'DeviceName': kwargs['root_device_name'],\n            'Ebs': {\n                'VolumeType': kwargs.get('volume_type', 'gp2'),\n                'SnapshotId': kwargs['snapshot_id'],\n             }\n        }]\n\n    if not isinstance(block_device_mapping, list):\n        block_device_mapping = [block_device_mapping]\n\n    params = {'Action': 'RegisterImage',\n              'Name': kwargs['ami_name']}\n\n    params.update(_param_from_config('BlockDeviceMapping', block_device_mapping))\n\n    if 'root_device_name' in kwargs:\n        params['RootDeviceName'] = kwargs['root_device_name']\n\n    if 'description' in kwargs:\n        params['Description'] = kwargs['description']\n\n    if 'virtualization_type' in kwargs:\n        params['VirtualizationType'] = kwargs['virtualization_type']\n\n    if 'architecture' in kwargs:\n        params['Architecture'] = kwargs['architecture']\n\n    log.debug(params)\n\n    data = aws.query(params,\n                     return_url=True,\n                     return_root=True,\n                     location=get_location(),\n                     provider=get_provider(),\n                     opts=__opts__,\n                     sigver='4')\n\n    r_data = {}\n    for d in data[0]:\n        for k, v in d.items():\n            r_data[k] = v\n\n    return r_data", "language": "python", "code": "def register_image(kwargs=None, call=None):\n    '''\n    Create an ami from a snapshot\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt-cloud -f register_image my-ec2-config ami_name=my_ami description=\"my description\"\n                root_device_name=/dev/xvda snapshot_id=snap-xxxxxxxx\n    '''\n\n    if call != 'function':\n        log.error(\n            'The create_volume function must be called with -f or --function.'\n        )\n        return False\n\n    if 'ami_name' not in kwargs:\n        log.error('ami_name must be specified to register an image.')\n        return False\n\n    block_device_mapping = kwargs.get('block_device_mapping', None)\n    if not block_device_mapping:\n        if 'snapshot_id' not in kwargs:\n            log.error('snapshot_id or block_device_mapping must be specified to register an image.')\n            return False\n        if 'root_device_name' not in kwargs:\n            log.error('root_device_name or block_device_mapping must be specified to register an image.')\n            return False\n        block_device_mapping = [{\n            'DeviceName': kwargs['root_device_name'],\n            'Ebs': {\n                'VolumeType': kwargs.get('volume_type', 'gp2'),\n                'SnapshotId': kwargs['snapshot_id'],\n             }\n        }]\n\n    if not isinstance(block_device_mapping, list):\n        block_device_mapping = [block_device_mapping]\n\n    params = {'Action': 'RegisterImage',\n              'Name': kwargs['ami_name']}\n\n    params.update(_param_from_config('BlockDeviceMapping', block_device_mapping))\n\n    if 'root_device_name' in kwargs:\n        params['RootDeviceName'] = kwargs['root_device_name']\n\n    if 'description' in kwargs:\n        params['Description'] = kwargs['description']\n\n    if 'virtualization_type' in kwargs:\n        params['VirtualizationType'] = kwargs['virtualization_type']\n\n    if 'architecture' in kwargs:\n        params['Architecture'] = kwargs['architecture']\n\n    log.debug(params)\n\n    data = aws.query(params,\n                     return_url=True,\n                     return_root=True,\n                     location=get_location(),\n                     provider=get_provider(),\n                     opts=__opts__,\n                     sigver='4')\n\n    r_data = {}\n    for d in data[0]:\n        for k, v in d.items():\n            r_data[k] = v\n\n    return r_data", "code_tokens": ["def", "register_image", "(", "kwargs", "=", "None", ",", "call", "=", "None", ")", ":", "if", "call", "!=", "'function'", ":", "log", ".", "error", "(", "'The create_volume function must be called with -f or --function.'", ")", "return", "False", "if", "'ami_name'", "not", "in", "kwargs", ":", "log", ".", "error", "(", "'ami_name must be specified to register an image.'", ")", "return", "False", "block_device_mapping", "=", "kwargs", ".", "get", "(", "'block_device_mapping'", ",", "None", ")", "if", "not", "block_device_mapping", ":", "if", "'snapshot_id'", "not", "in", "kwargs", ":", "log", ".", "error", "(", "'snapshot_id or block_device_mapping must be specified to register an image.'", ")", "return", "False", "if", "'root_device_name'", "not", "in", "kwargs", ":", "log", ".", "error", "(", "'root_device_name or block_device_mapping must be specified to register an image.'", ")", "return", "False", "block_device_mapping", "=", "[", "{", "'DeviceName'", ":", "kwargs", "[", "'root_device_name'", "]", ",", "'Ebs'", ":", "{", "'VolumeType'", ":", "kwargs", ".", "get", "(", "'volume_type'", ",", "'gp2'", ")", ",", "'SnapshotId'", ":", "kwargs", "[", "'snapshot_id'", "]", ",", "}", "}", "]", "if", "not", "isinstance", "(", "block_device_mapping", ",", "list", ")", ":", "block_device_mapping", "=", "[", "block_device_mapping", "]", "params", "=", "{", "'Action'", ":", "'RegisterImage'", ",", "'Name'", ":", "kwargs", "[", "'ami_name'", "]", "}", "params", ".", "update", "(", "_param_from_config", "(", "'BlockDeviceMapping'", ",", "block_device_mapping", ")", ")", "if", "'root_device_name'", "in", "kwargs", ":", "params", "[", "'RootDeviceName'", "]", "=", "kwargs", "[", "'root_device_name'", "]", "if", "'description'", "in", "kwargs", ":", "params", "[", "'Description'", "]", "=", "kwargs", "[", "'description'", "]", "if", "'virtualization_type'", "in", "kwargs", ":", "params", "[", "'VirtualizationType'", "]", "=", "kwargs", "[", "'virtualization_type'", "]", "if", "'architecture'", "in", "kwargs", ":", "params", "[", "'Architecture'", "]", "=", "kwargs", "[", "'architecture'", "]", "log", ".", "debug", "(", "params", ")", "data", "=", "aws", ".", "query", "(", "params", ",", "return_url", "=", "True", ",", "return_root", "=", "True", ",", "location", "=", "get_location", "(", ")", ",", "provider", "=", "get_provider", "(", ")", ",", "opts", "=", "__opts__", ",", "sigver", "=", "'4'", ")", "r_data", "=", "{", "}", "for", "d", "in", "data", "[", "0", "]", ":", "for", "k", ",", "v", "in", "d", ".", "items", "(", ")", ":", "r_data", "[", "k", "]", "=", "v", "return", "r_data"], "docstring": "Create an ami from a snapshot\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt-cloud -f register_image my-ec2-config ami_name=my_ami description=\"my description\"\n                root_device_name=/dev/xvda snapshot_id=snap-xxxxxxxx", "docstring_tokens": ["Create", "an", "ami", "from", "a", "snapshot"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/cloud/clouds/ec2.py#L4070-L4143", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/cloud/clouds/ec2.py", "func_name": "create_volume", "original_string": "def create_volume(kwargs=None, call=None, wait_to_finish=False):\n    '''\n    Create a volume.\n\n    zone\n        The availability zone used to create the volume. Required. String.\n\n    size\n        The size of the volume, in GiBs. Defaults to ``10``. Integer.\n\n    snapshot\n        The snapshot-id from which to create the volume. Integer.\n\n    type\n        The volume type. This can be gp2 for General Purpose SSD, io1 for Provisioned\n        IOPS SSD, st1 for Throughput Optimized HDD, sc1 for Cold HDD, or standard for\n        Magnetic volumes. String.\n\n    iops\n        The number of I/O operations per second (IOPS) to provision for the volume,\n        with a maximum ratio of 50 IOPS/GiB. Only valid for Provisioned IOPS SSD\n        volumes. Integer.\n\n        This option will only be set if ``type`` is also specified as ``io1``.\n\n    encrypted\n        Specifies whether the volume will be encrypted. Boolean.\n\n        If ``snapshot`` is also given in the list of kwargs, then this value is ignored\n        since volumes that are created from encrypted snapshots are also automatically\n        encrypted.\n\n    tags\n        The tags to apply to the volume during creation. Dictionary.\n\n    call\n        The ``create_volume`` function must be called with ``-f`` or ``--function``.\n        String.\n\n    wait_to_finish\n        Whether or not to wait for the volume to be available. Boolean. Defaults to\n        ``False``.\n\n    CLI Examples:\n\n    .. code-block:: bash\n\n        salt-cloud -f create_volume my-ec2-config zone=us-east-1b\n        salt-cloud -f create_volume my-ec2-config zone=us-east-1b tags='{\"tag1\": \"val1\", \"tag2\", \"val2\"}'\n    '''\n    if call != 'function':\n        log.error(\n            'The create_volume function must be called with -f or --function.'\n        )\n        return False\n\n    if 'zone' not in kwargs:\n        log.error('An availability zone must be specified to create a volume.')\n        return False\n\n    if 'size' not in kwargs and 'snapshot' not in kwargs:\n        # This number represents GiB\n        kwargs['size'] = '10'\n\n    params = {'Action': 'CreateVolume',\n              'AvailabilityZone': kwargs['zone']}\n\n    if 'size' in kwargs:\n        params['Size'] = kwargs['size']\n\n    if 'snapshot' in kwargs:\n        params['SnapshotId'] = kwargs['snapshot']\n\n    if 'type' in kwargs:\n        params['VolumeType'] = kwargs['type']\n\n    if 'iops' in kwargs and kwargs.get('type', 'standard') == 'io1':\n        params['Iops'] = kwargs['iops']\n\n    # You can't set `encrypted` if you pass a snapshot\n    if 'encrypted' in kwargs and 'snapshot' not in kwargs:\n        params['Encrypted'] = kwargs['encrypted']\n        if 'kmskeyid' in kwargs:\n            params['KmsKeyId'] = kwargs['kmskeyid']\n    if 'kmskeyid' in kwargs and 'encrypted' not in kwargs:\n        log.error(\n            'If a KMS Key ID is specified, encryption must be enabled'\n        )\n        return False\n\n    log.debug(params)\n\n    data = aws.query(params,\n                     return_url=True,\n                     return_root=True,\n                     location=get_location(),\n                     provider=get_provider(),\n                     opts=__opts__,\n                     sigver='4')\n\n    r_data = {}\n    for d in data[0]:\n        for k, v in six.iteritems(d):\n            r_data[k] = v\n    volume_id = r_data['volumeId']\n\n    # Allow tags to be set upon creation\n    if 'tags' in kwargs:\n        if isinstance(kwargs['tags'], six.string_types):\n            tags = salt.utils.yaml.safe_load(kwargs['tags'])\n        else:\n            tags = kwargs['tags']\n\n        if isinstance(tags, dict):\n            new_tags = set_tags(tags=tags,\n                                resource_id=volume_id,\n                                call='action',\n                                location=get_location())\n            r_data['tags'] = new_tags\n\n    # Waits till volume is available\n    if wait_to_finish:\n        salt.utils.cloud.run_func_until_ret_arg(fun=describe_volumes,\n                                                kwargs={'volume_id': volume_id},\n                                                fun_call=call,\n                                                argument_being_watched='status',\n                                                required_argument_response='available')\n\n    return r_data", "language": "python", "code": "def create_volume(kwargs=None, call=None, wait_to_finish=False):\n    '''\n    Create a volume.\n\n    zone\n        The availability zone used to create the volume. Required. String.\n\n    size\n        The size of the volume, in GiBs. Defaults to ``10``. Integer.\n\n    snapshot\n        The snapshot-id from which to create the volume. Integer.\n\n    type\n        The volume type. This can be gp2 for General Purpose SSD, io1 for Provisioned\n        IOPS SSD, st1 for Throughput Optimized HDD, sc1 for Cold HDD, or standard for\n        Magnetic volumes. String.\n\n    iops\n        The number of I/O operations per second (IOPS) to provision for the volume,\n        with a maximum ratio of 50 IOPS/GiB. Only valid for Provisioned IOPS SSD\n        volumes. Integer.\n\n        This option will only be set if ``type`` is also specified as ``io1``.\n\n    encrypted\n        Specifies whether the volume will be encrypted. Boolean.\n\n        If ``snapshot`` is also given in the list of kwargs, then this value is ignored\n        since volumes that are created from encrypted snapshots are also automatically\n        encrypted.\n\n    tags\n        The tags to apply to the volume during creation. Dictionary.\n\n    call\n        The ``create_volume`` function must be called with ``-f`` or ``--function``.\n        String.\n\n    wait_to_finish\n        Whether or not to wait for the volume to be available. Boolean. Defaults to\n        ``False``.\n\n    CLI Examples:\n\n    .. code-block:: bash\n\n        salt-cloud -f create_volume my-ec2-config zone=us-east-1b\n        salt-cloud -f create_volume my-ec2-config zone=us-east-1b tags='{\"tag1\": \"val1\", \"tag2\", \"val2\"}'\n    '''\n    if call != 'function':\n        log.error(\n            'The create_volume function must be called with -f or --function.'\n        )\n        return False\n\n    if 'zone' not in kwargs:\n        log.error('An availability zone must be specified to create a volume.')\n        return False\n\n    if 'size' not in kwargs and 'snapshot' not in kwargs:\n        # This number represents GiB\n        kwargs['size'] = '10'\n\n    params = {'Action': 'CreateVolume',\n              'AvailabilityZone': kwargs['zone']}\n\n    if 'size' in kwargs:\n        params['Size'] = kwargs['size']\n\n    if 'snapshot' in kwargs:\n        params['SnapshotId'] = kwargs['snapshot']\n\n    if 'type' in kwargs:\n        params['VolumeType'] = kwargs['type']\n\n    if 'iops' in kwargs and kwargs.get('type', 'standard') == 'io1':\n        params['Iops'] = kwargs['iops']\n\n    # You can't set `encrypted` if you pass a snapshot\n    if 'encrypted' in kwargs and 'snapshot' not in kwargs:\n        params['Encrypted'] = kwargs['encrypted']\n        if 'kmskeyid' in kwargs:\n            params['KmsKeyId'] = kwargs['kmskeyid']\n    if 'kmskeyid' in kwargs and 'encrypted' not in kwargs:\n        log.error(\n            'If a KMS Key ID is specified, encryption must be enabled'\n        )\n        return False\n\n    log.debug(params)\n\n    data = aws.query(params,\n                     return_url=True,\n                     return_root=True,\n                     location=get_location(),\n                     provider=get_provider(),\n                     opts=__opts__,\n                     sigver='4')\n\n    r_data = {}\n    for d in data[0]:\n        for k, v in six.iteritems(d):\n            r_data[k] = v\n    volume_id = r_data['volumeId']\n\n    # Allow tags to be set upon creation\n    if 'tags' in kwargs:\n        if isinstance(kwargs['tags'], six.string_types):\n            tags = salt.utils.yaml.safe_load(kwargs['tags'])\n        else:\n            tags = kwargs['tags']\n\n        if isinstance(tags, dict):\n            new_tags = set_tags(tags=tags,\n                                resource_id=volume_id,\n                                call='action',\n                                location=get_location())\n            r_data['tags'] = new_tags\n\n    # Waits till volume is available\n    if wait_to_finish:\n        salt.utils.cloud.run_func_until_ret_arg(fun=describe_volumes,\n                                                kwargs={'volume_id': volume_id},\n                                                fun_call=call,\n                                                argument_being_watched='status',\n                                                required_argument_response='available')\n\n    return r_data", "code_tokens": ["def", "create_volume", "(", "kwargs", "=", "None", ",", "call", "=", "None", ",", "wait_to_finish", "=", "False", ")", ":", "if", "call", "!=", "'function'", ":", "log", ".", "error", "(", "'The create_volume function must be called with -f or --function.'", ")", "return", "False", "if", "'zone'", "not", "in", "kwargs", ":", "log", ".", "error", "(", "'An availability zone must be specified to create a volume.'", ")", "return", "False", "if", "'size'", "not", "in", "kwargs", "and", "'snapshot'", "not", "in", "kwargs", ":", "# This number represents GiB", "kwargs", "[", "'size'", "]", "=", "'10'", "params", "=", "{", "'Action'", ":", "'CreateVolume'", ",", "'AvailabilityZone'", ":", "kwargs", "[", "'zone'", "]", "}", "if", "'size'", "in", "kwargs", ":", "params", "[", "'Size'", "]", "=", "kwargs", "[", "'size'", "]", "if", "'snapshot'", "in", "kwargs", ":", "params", "[", "'SnapshotId'", "]", "=", "kwargs", "[", "'snapshot'", "]", "if", "'type'", "in", "kwargs", ":", "params", "[", "'VolumeType'", "]", "=", "kwargs", "[", "'type'", "]", "if", "'iops'", "in", "kwargs", "and", "kwargs", ".", "get", "(", "'type'", ",", "'standard'", ")", "==", "'io1'", ":", "params", "[", "'Iops'", "]", "=", "kwargs", "[", "'iops'", "]", "# You can't set `encrypted` if you pass a snapshot", "if", "'encrypted'", "in", "kwargs", "and", "'snapshot'", "not", "in", "kwargs", ":", "params", "[", "'Encrypted'", "]", "=", "kwargs", "[", "'encrypted'", "]", "if", "'kmskeyid'", "in", "kwargs", ":", "params", "[", "'KmsKeyId'", "]", "=", "kwargs", "[", "'kmskeyid'", "]", "if", "'kmskeyid'", "in", "kwargs", "and", "'encrypted'", "not", "in", "kwargs", ":", "log", ".", "error", "(", "'If a KMS Key ID is specified, encryption must be enabled'", ")", "return", "False", "log", ".", "debug", "(", "params", ")", "data", "=", "aws", ".", "query", "(", "params", ",", "return_url", "=", "True", ",", "return_root", "=", "True", ",", "location", "=", "get_location", "(", ")", ",", "provider", "=", "get_provider", "(", ")", ",", "opts", "=", "__opts__", ",", "sigver", "=", "'4'", ")", "r_data", "=", "{", "}", "for", "d", "in", "data", "[", "0", "]", ":", "for", "k", ",", "v", "in", "six", ".", "iteritems", "(", "d", ")", ":", "r_data", "[", "k", "]", "=", "v", "volume_id", "=", "r_data", "[", "'volumeId'", "]", "# Allow tags to be set upon creation", "if", "'tags'", "in", "kwargs", ":", "if", "isinstance", "(", "kwargs", "[", "'tags'", "]", ",", "six", ".", "string_types", ")", ":", "tags", "=", "salt", ".", "utils", ".", "yaml", ".", "safe_load", "(", "kwargs", "[", "'tags'", "]", ")", "else", ":", "tags", "=", "kwargs", "[", "'tags'", "]", "if", "isinstance", "(", "tags", ",", "dict", ")", ":", "new_tags", "=", "set_tags", "(", "tags", "=", "tags", ",", "resource_id", "=", "volume_id", ",", "call", "=", "'action'", ",", "location", "=", "get_location", "(", ")", ")", "r_data", "[", "'tags'", "]", "=", "new_tags", "# Waits till volume is available", "if", "wait_to_finish", ":", "salt", ".", "utils", ".", "cloud", ".", "run_func_until_ret_arg", "(", "fun", "=", "describe_volumes", ",", "kwargs", "=", "{", "'volume_id'", ":", "volume_id", "}", ",", "fun_call", "=", "call", ",", "argument_being_watched", "=", "'status'", ",", "required_argument_response", "=", "'available'", ")", "return", "r_data"], "docstring": "Create a volume.\n\n    zone\n        The availability zone used to create the volume. Required. String.\n\n    size\n        The size of the volume, in GiBs. Defaults to ``10``. Integer.\n\n    snapshot\n        The snapshot-id from which to create the volume. Integer.\n\n    type\n        The volume type. This can be gp2 for General Purpose SSD, io1 for Provisioned\n        IOPS SSD, st1 for Throughput Optimized HDD, sc1 for Cold HDD, or standard for\n        Magnetic volumes. String.\n\n    iops\n        The number of I/O operations per second (IOPS) to provision for the volume,\n        with a maximum ratio of 50 IOPS/GiB. Only valid for Provisioned IOPS SSD\n        volumes. Integer.\n\n        This option will only be set if ``type`` is also specified as ``io1``.\n\n    encrypted\n        Specifies whether the volume will be encrypted. Boolean.\n\n        If ``snapshot`` is also given in the list of kwargs, then this value is ignored\n        since volumes that are created from encrypted snapshots are also automatically\n        encrypted.\n\n    tags\n        The tags to apply to the volume during creation. Dictionary.\n\n    call\n        The ``create_volume`` function must be called with ``-f`` or ``--function``.\n        String.\n\n    wait_to_finish\n        Whether or not to wait for the volume to be available. Boolean. Defaults to\n        ``False``.\n\n    CLI Examples:\n\n    .. code-block:: bash\n\n        salt-cloud -f create_volume my-ec2-config zone=us-east-1b\n        salt-cloud -f create_volume my-ec2-config zone=us-east-1b tags='{\"tag1\": \"val1\", \"tag2\", \"val2\"}'", "docstring_tokens": ["Create", "a", "volume", "."], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/cloud/clouds/ec2.py#L4154-L4282", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/cloud/clouds/ec2.py", "func_name": "attach_volume", "original_string": "def attach_volume(name=None, kwargs=None, instance_id=None, call=None):\n    '''\n    Attach a volume to an instance\n    '''\n    if call != 'action':\n        raise SaltCloudSystemExit(\n            'The attach_volume action must be called with -a or --action.'\n        )\n\n    if not kwargs:\n        kwargs = {}\n\n    if 'instance_id' in kwargs:\n        instance_id = kwargs['instance_id']\n\n    if name and not instance_id:\n        instance_id = _get_node(name)['instanceId']\n\n    if not name and not instance_id:\n        log.error('Either a name or an instance_id is required.')\n        return False\n\n    if 'volume_id' not in kwargs:\n        log.error('A volume_id is required.')\n        return False\n\n    if 'device' not in kwargs:\n        log.error('A device is required (ex. /dev/sdb1).')\n        return False\n\n    params = {'Action': 'AttachVolume',\n              'VolumeId': kwargs['volume_id'],\n              'InstanceId': instance_id,\n              'Device': kwargs['device']}\n\n    log.debug(params)\n\n    vm_ = get_configured_provider()\n\n    data = salt.utils.cloud.wait_for_ip(\n        __attach_vol_to_instance,\n        update_args=(params, kwargs, instance_id),\n        timeout=config.get_cloud_config_value(\n            'wait_for_ip_timeout', vm_, __opts__, default=10 * 60),\n        interval=config.get_cloud_config_value(\n            'wait_for_ip_interval', vm_, __opts__, default=10),\n        interval_multiplier=config.get_cloud_config_value(\n            'wait_for_ip_interval_multiplier', vm_, __opts__, default=1),\n    )\n\n    return data", "language": "python", "code": "def attach_volume(name=None, kwargs=None, instance_id=None, call=None):\n    '''\n    Attach a volume to an instance\n    '''\n    if call != 'action':\n        raise SaltCloudSystemExit(\n            'The attach_volume action must be called with -a or --action.'\n        )\n\n    if not kwargs:\n        kwargs = {}\n\n    if 'instance_id' in kwargs:\n        instance_id = kwargs['instance_id']\n\n    if name and not instance_id:\n        instance_id = _get_node(name)['instanceId']\n\n    if not name and not instance_id:\n        log.error('Either a name or an instance_id is required.')\n        return False\n\n    if 'volume_id' not in kwargs:\n        log.error('A volume_id is required.')\n        return False\n\n    if 'device' not in kwargs:\n        log.error('A device is required (ex. /dev/sdb1).')\n        return False\n\n    params = {'Action': 'AttachVolume',\n              'VolumeId': kwargs['volume_id'],\n              'InstanceId': instance_id,\n              'Device': kwargs['device']}\n\n    log.debug(params)\n\n    vm_ = get_configured_provider()\n\n    data = salt.utils.cloud.wait_for_ip(\n        __attach_vol_to_instance,\n        update_args=(params, kwargs, instance_id),\n        timeout=config.get_cloud_config_value(\n            'wait_for_ip_timeout', vm_, __opts__, default=10 * 60),\n        interval=config.get_cloud_config_value(\n            'wait_for_ip_interval', vm_, __opts__, default=10),\n        interval_multiplier=config.get_cloud_config_value(\n            'wait_for_ip_interval_multiplier', vm_, __opts__, default=1),\n    )\n\n    return data", "code_tokens": ["def", "attach_volume", "(", "name", "=", "None", ",", "kwargs", "=", "None", ",", "instance_id", "=", "None", ",", "call", "=", "None", ")", ":", "if", "call", "!=", "'action'", ":", "raise", "SaltCloudSystemExit", "(", "'The attach_volume action must be called with -a or --action.'", ")", "if", "not", "kwargs", ":", "kwargs", "=", "{", "}", "if", "'instance_id'", "in", "kwargs", ":", "instance_id", "=", "kwargs", "[", "'instance_id'", "]", "if", "name", "and", "not", "instance_id", ":", "instance_id", "=", "_get_node", "(", "name", ")", "[", "'instanceId'", "]", "if", "not", "name", "and", "not", "instance_id", ":", "log", ".", "error", "(", "'Either a name or an instance_id is required.'", ")", "return", "False", "if", "'volume_id'", "not", "in", "kwargs", ":", "log", ".", "error", "(", "'A volume_id is required.'", ")", "return", "False", "if", "'device'", "not", "in", "kwargs", ":", "log", ".", "error", "(", "'A device is required (ex. /dev/sdb1).'", ")", "return", "False", "params", "=", "{", "'Action'", ":", "'AttachVolume'", ",", "'VolumeId'", ":", "kwargs", "[", "'volume_id'", "]", ",", "'InstanceId'", ":", "instance_id", ",", "'Device'", ":", "kwargs", "[", "'device'", "]", "}", "log", ".", "debug", "(", "params", ")", "vm_", "=", "get_configured_provider", "(", ")", "data", "=", "salt", ".", "utils", ".", "cloud", ".", "wait_for_ip", "(", "__attach_vol_to_instance", ",", "update_args", "=", "(", "params", ",", "kwargs", ",", "instance_id", ")", ",", "timeout", "=", "config", ".", "get_cloud_config_value", "(", "'wait_for_ip_timeout'", ",", "vm_", ",", "__opts__", ",", "default", "=", "10", "*", "60", ")", ",", "interval", "=", "config", ".", "get_cloud_config_value", "(", "'wait_for_ip_interval'", ",", "vm_", ",", "__opts__", ",", "default", "=", "10", ")", ",", "interval_multiplier", "=", "config", ".", "get_cloud_config_value", "(", "'wait_for_ip_interval_multiplier'", ",", "vm_", ",", "__opts__", ",", "default", "=", "1", ")", ",", ")", "return", "data"], "docstring": "Attach a volume to an instance", "docstring_tokens": ["Attach", "a", "volume", "to", "an", "instance"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/cloud/clouds/ec2.py#L4302-L4352", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/cloud/clouds/ec2.py", "func_name": "describe_volumes", "original_string": "def describe_volumes(kwargs=None, call=None):\n    '''\n    Describe a volume (or volumes)\n\n    volume_id\n        One or more volume IDs. Multiple IDs must be separated by \",\".\n\n    TODO: Add all of the filters.\n    '''\n    if call != 'function':\n        log.error(\n            'The describe_volumes function must be called with -f '\n            'or --function.'\n        )\n        return False\n\n    if not kwargs:\n        kwargs = {}\n\n    params = {'Action': 'DescribeVolumes'}\n\n    if 'volume_id' in kwargs:\n        volume_id = kwargs['volume_id'].split(',')\n        for volume_index, volume_id in enumerate(volume_id):\n            params['VolumeId.{0}'.format(volume_index)] = volume_id\n\n    log.debug(params)\n\n    data = aws.query(params,\n                     return_url=True,\n                     location=get_location(),\n                     provider=get_provider(),\n                     opts=__opts__,\n                     sigver='4')\n    return data", "language": "python", "code": "def describe_volumes(kwargs=None, call=None):\n    '''\n    Describe a volume (or volumes)\n\n    volume_id\n        One or more volume IDs. Multiple IDs must be separated by \",\".\n\n    TODO: Add all of the filters.\n    '''\n    if call != 'function':\n        log.error(\n            'The describe_volumes function must be called with -f '\n            'or --function.'\n        )\n        return False\n\n    if not kwargs:\n        kwargs = {}\n\n    params = {'Action': 'DescribeVolumes'}\n\n    if 'volume_id' in kwargs:\n        volume_id = kwargs['volume_id'].split(',')\n        for volume_index, volume_id in enumerate(volume_id):\n            params['VolumeId.{0}'.format(volume_index)] = volume_id\n\n    log.debug(params)\n\n    data = aws.query(params,\n                     return_url=True,\n                     location=get_location(),\n                     provider=get_provider(),\n                     opts=__opts__,\n                     sigver='4')\n    return data", "code_tokens": ["def", "describe_volumes", "(", "kwargs", "=", "None", ",", "call", "=", "None", ")", ":", "if", "call", "!=", "'function'", ":", "log", ".", "error", "(", "'The describe_volumes function must be called with -f '", "'or --function.'", ")", "return", "False", "if", "not", "kwargs", ":", "kwargs", "=", "{", "}", "params", "=", "{", "'Action'", ":", "'DescribeVolumes'", "}", "if", "'volume_id'", "in", "kwargs", ":", "volume_id", "=", "kwargs", "[", "'volume_id'", "]", ".", "split", "(", "','", ")", "for", "volume_index", ",", "volume_id", "in", "enumerate", "(", "volume_id", ")", ":", "params", "[", "'VolumeId.{0}'", ".", "format", "(", "volume_index", ")", "]", "=", "volume_id", "log", ".", "debug", "(", "params", ")", "data", "=", "aws", ".", "query", "(", "params", ",", "return_url", "=", "True", ",", "location", "=", "get_location", "(", ")", ",", "provider", "=", "get_provider", "(", ")", ",", "opts", "=", "__opts__", ",", "sigver", "=", "'4'", ")", "return", "data"], "docstring": "Describe a volume (or volumes)\n\n    volume_id\n        One or more volume IDs. Multiple IDs must be separated by \",\".\n\n    TODO: Add all of the filters.", "docstring_tokens": ["Describe", "a", "volume", "(", "or", "volumes", ")"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/cloud/clouds/ec2.py#L4426-L4460", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/cloud/clouds/ec2.py", "func_name": "create_keypair", "original_string": "def create_keypair(kwargs=None, call=None):\n    '''\n    Create an SSH keypair\n    '''\n    if call != 'function':\n        log.error(\n            'The create_keypair function must be called with -f or --function.'\n        )\n        return False\n\n    if not kwargs:\n        kwargs = {}\n\n    if 'keyname' not in kwargs:\n        log.error('A keyname is required.')\n        return False\n\n    params = {'Action': 'CreateKeyPair',\n              'KeyName': kwargs['keyname']}\n\n    data = aws.query(params,\n                     return_url=True,\n                     return_root=True,\n                     location=get_location(),\n                     provider=get_provider(),\n                     opts=__opts__,\n                     sigver='4')\n    keys = [x for x in data[0] if 'requestId' not in x]\n\n    return (keys, data[1])", "language": "python", "code": "def create_keypair(kwargs=None, call=None):\n    '''\n    Create an SSH keypair\n    '''\n    if call != 'function':\n        log.error(\n            'The create_keypair function must be called with -f or --function.'\n        )\n        return False\n\n    if not kwargs:\n        kwargs = {}\n\n    if 'keyname' not in kwargs:\n        log.error('A keyname is required.')\n        return False\n\n    params = {'Action': 'CreateKeyPair',\n              'KeyName': kwargs['keyname']}\n\n    data = aws.query(params,\n                     return_url=True,\n                     return_root=True,\n                     location=get_location(),\n                     provider=get_provider(),\n                     opts=__opts__,\n                     sigver='4')\n    keys = [x for x in data[0] if 'requestId' not in x]\n\n    return (keys, data[1])", "code_tokens": ["def", "create_keypair", "(", "kwargs", "=", "None", ",", "call", "=", "None", ")", ":", "if", "call", "!=", "'function'", ":", "log", ".", "error", "(", "'The create_keypair function must be called with -f or --function.'", ")", "return", "False", "if", "not", "kwargs", ":", "kwargs", "=", "{", "}", "if", "'keyname'", "not", "in", "kwargs", ":", "log", ".", "error", "(", "'A keyname is required.'", ")", "return", "False", "params", "=", "{", "'Action'", ":", "'CreateKeyPair'", ",", "'KeyName'", ":", "kwargs", "[", "'keyname'", "]", "}", "data", "=", "aws", ".", "query", "(", "params", ",", "return_url", "=", "True", ",", "return_root", "=", "True", ",", "location", "=", "get_location", "(", ")", ",", "provider", "=", "get_provider", "(", ")", ",", "opts", "=", "__opts__", ",", "sigver", "=", "'4'", ")", "keys", "=", "[", "x", "for", "x", "in", "data", "[", "0", "]", "if", "'requestId'", "not", "in", "x", "]", "return", "(", "keys", ",", "data", "[", "1", "]", ")"], "docstring": "Create an SSH keypair", "docstring_tokens": ["Create", "an", "SSH", "keypair"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/cloud/clouds/ec2.py#L4463-L4492", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/cloud/clouds/ec2.py", "func_name": "import_keypair", "original_string": "def import_keypair(kwargs=None, call=None):\n    '''\n    Import an SSH public key.\n\n    .. versionadded:: 2015.8.3\n    '''\n    if call != 'function':\n        log.error(\n            'The import_keypair function must be called with -f or --function.'\n        )\n        return False\n\n    if not kwargs:\n        kwargs = {}\n\n    if 'keyname' not in kwargs:\n        log.error('A keyname is required.')\n        return False\n\n    if 'file' not in kwargs:\n        log.error('A public key file is required.')\n        return False\n\n    params = {'Action': 'ImportKeyPair',\n              'KeyName': kwargs['keyname']}\n\n    public_key_file = kwargs['file']\n\n    if os.path.exists(public_key_file):\n        with salt.utils.files.fopen(public_key_file, 'r') as fh_:\n            public_key = salt.utils.stringutils.to_unicode(fh_.read())\n\n    if public_key is not None:\n        params['PublicKeyMaterial'] = base64.b64encode(public_key)\n\n    data = aws.query(params,\n                     return_url=True,\n                     location=get_location(),\n                     provider=get_provider(),\n                     opts=__opts__,\n                     sigver='4')\n    return data", "language": "python", "code": "def import_keypair(kwargs=None, call=None):\n    '''\n    Import an SSH public key.\n\n    .. versionadded:: 2015.8.3\n    '''\n    if call != 'function':\n        log.error(\n            'The import_keypair function must be called with -f or --function.'\n        )\n        return False\n\n    if not kwargs:\n        kwargs = {}\n\n    if 'keyname' not in kwargs:\n        log.error('A keyname is required.')\n        return False\n\n    if 'file' not in kwargs:\n        log.error('A public key file is required.')\n        return False\n\n    params = {'Action': 'ImportKeyPair',\n              'KeyName': kwargs['keyname']}\n\n    public_key_file = kwargs['file']\n\n    if os.path.exists(public_key_file):\n        with salt.utils.files.fopen(public_key_file, 'r') as fh_:\n            public_key = salt.utils.stringutils.to_unicode(fh_.read())\n\n    if public_key is not None:\n        params['PublicKeyMaterial'] = base64.b64encode(public_key)\n\n    data = aws.query(params,\n                     return_url=True,\n                     location=get_location(),\n                     provider=get_provider(),\n                     opts=__opts__,\n                     sigver='4')\n    return data", "code_tokens": ["def", "import_keypair", "(", "kwargs", "=", "None", ",", "call", "=", "None", ")", ":", "if", "call", "!=", "'function'", ":", "log", ".", "error", "(", "'The import_keypair function must be called with -f or --function.'", ")", "return", "False", "if", "not", "kwargs", ":", "kwargs", "=", "{", "}", "if", "'keyname'", "not", "in", "kwargs", ":", "log", ".", "error", "(", "'A keyname is required.'", ")", "return", "False", "if", "'file'", "not", "in", "kwargs", ":", "log", ".", "error", "(", "'A public key file is required.'", ")", "return", "False", "params", "=", "{", "'Action'", ":", "'ImportKeyPair'", ",", "'KeyName'", ":", "kwargs", "[", "'keyname'", "]", "}", "public_key_file", "=", "kwargs", "[", "'file'", "]", "if", "os", ".", "path", ".", "exists", "(", "public_key_file", ")", ":", "with", "salt", ".", "utils", ".", "files", ".", "fopen", "(", "public_key_file", ",", "'r'", ")", "as", "fh_", ":", "public_key", "=", "salt", ".", "utils", ".", "stringutils", ".", "to_unicode", "(", "fh_", ".", "read", "(", ")", ")", "if", "public_key", "is", "not", "None", ":", "params", "[", "'PublicKeyMaterial'", "]", "=", "base64", ".", "b64encode", "(", "public_key", ")", "data", "=", "aws", ".", "query", "(", "params", ",", "return_url", "=", "True", ",", "location", "=", "get_location", "(", ")", ",", "provider", "=", "get_provider", "(", ")", ",", "opts", "=", "__opts__", ",", "sigver", "=", "'4'", ")", "return", "data"], "docstring": "Import an SSH public key.\n\n    .. versionadded:: 2015.8.3", "docstring_tokens": ["Import", "an", "SSH", "public", "key", "."], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/cloud/clouds/ec2.py#L4495-L4536", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/cloud/clouds/ec2.py", "func_name": "delete_keypair", "original_string": "def delete_keypair(kwargs=None, call=None):\n    '''\n    Delete an SSH keypair\n    '''\n    if call != 'function':\n        log.error(\n            'The delete_keypair function must be called with -f or --function.'\n        )\n        return False\n\n    if not kwargs:\n        kwargs = {}\n\n    if 'keyname' not in kwargs:\n        log.error('A keyname is required.')\n        return False\n\n    params = {'Action': 'DeleteKeyPair',\n              'KeyName': kwargs['keyname']}\n\n    data = aws.query(params,\n                     return_url=True,\n                     location=get_location(),\n                     provider=get_provider(),\n                     opts=__opts__,\n                     sigver='4')\n    return data", "language": "python", "code": "def delete_keypair(kwargs=None, call=None):\n    '''\n    Delete an SSH keypair\n    '''\n    if call != 'function':\n        log.error(\n            'The delete_keypair function must be called with -f or --function.'\n        )\n        return False\n\n    if not kwargs:\n        kwargs = {}\n\n    if 'keyname' not in kwargs:\n        log.error('A keyname is required.')\n        return False\n\n    params = {'Action': 'DeleteKeyPair',\n              'KeyName': kwargs['keyname']}\n\n    data = aws.query(params,\n                     return_url=True,\n                     location=get_location(),\n                     provider=get_provider(),\n                     opts=__opts__,\n                     sigver='4')\n    return data", "code_tokens": ["def", "delete_keypair", "(", "kwargs", "=", "None", ",", "call", "=", "None", ")", ":", "if", "call", "!=", "'function'", ":", "log", ".", "error", "(", "'The delete_keypair function must be called with -f or --function.'", ")", "return", "False", "if", "not", "kwargs", ":", "kwargs", "=", "{", "}", "if", "'keyname'", "not", "in", "kwargs", ":", "log", ".", "error", "(", "'A keyname is required.'", ")", "return", "False", "params", "=", "{", "'Action'", ":", "'DeleteKeyPair'", ",", "'KeyName'", ":", "kwargs", "[", "'keyname'", "]", "}", "data", "=", "aws", ".", "query", "(", "params", ",", "return_url", "=", "True", ",", "location", "=", "get_location", "(", ")", ",", "provider", "=", "get_provider", "(", ")", ",", "opts", "=", "__opts__", ",", "sigver", "=", "'4'", ")", "return", "data"], "docstring": "Delete an SSH keypair", "docstring_tokens": ["Delete", "an", "SSH", "keypair"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/cloud/clouds/ec2.py#L4568-L4594", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/cloud/clouds/ec2.py", "func_name": "create_snapshot", "original_string": "def create_snapshot(kwargs=None, call=None, wait_to_finish=False):\n    '''\n    Create a snapshot.\n\n    volume_id\n        The ID of the Volume from which to create a snapshot.\n\n    description\n        The optional description of the snapshot.\n\n    CLI Exampe:\n\n    .. code-block:: bash\n\n        salt-cloud -f create_snapshot my-ec2-config volume_id=vol-351d8826\n        salt-cloud -f create_snapshot my-ec2-config volume_id=vol-351d8826 \\\\\n            description=\"My Snapshot Description\"\n    '''\n    if call != 'function':\n        raise SaltCloudSystemExit(\n            'The create_snapshot function must be called with -f '\n            'or --function.'\n        )\n\n    if kwargs is None:\n        kwargs = {}\n\n    volume_id = kwargs.get('volume_id', None)\n    description = kwargs.get('description', '')\n\n    if volume_id is None:\n        raise SaltCloudSystemExit(\n            'A volume_id must be specified to create a snapshot.'\n        )\n\n    params = {'Action': 'CreateSnapshot',\n              'VolumeId': volume_id,\n              'Description': description}\n\n    log.debug(params)\n\n    data = aws.query(params,\n                     return_url=True,\n                     return_root=True,\n                     location=get_location(),\n                     provider=get_provider(),\n                     opts=__opts__,\n                     sigver='4')[0]\n\n    r_data = {}\n    for d in data:\n        for k, v in six.iteritems(d):\n            r_data[k] = v\n\n    if 'snapshotId' in r_data:\n        snapshot_id = r_data['snapshotId']\n\n        # Waits till volume is available\n        if wait_to_finish:\n            salt.utils.cloud.run_func_until_ret_arg(fun=describe_snapshots,\n                                                    kwargs={'snapshot_id': snapshot_id},\n                                                    fun_call=call,\n                                                    argument_being_watched='status',\n                                                    required_argument_response='completed')\n\n    return r_data", "language": "python", "code": "def create_snapshot(kwargs=None, call=None, wait_to_finish=False):\n    '''\n    Create a snapshot.\n\n    volume_id\n        The ID of the Volume from which to create a snapshot.\n\n    description\n        The optional description of the snapshot.\n\n    CLI Exampe:\n\n    .. code-block:: bash\n\n        salt-cloud -f create_snapshot my-ec2-config volume_id=vol-351d8826\n        salt-cloud -f create_snapshot my-ec2-config volume_id=vol-351d8826 \\\\\n            description=\"My Snapshot Description\"\n    '''\n    if call != 'function':\n        raise SaltCloudSystemExit(\n            'The create_snapshot function must be called with -f '\n            'or --function.'\n        )\n\n    if kwargs is None:\n        kwargs = {}\n\n    volume_id = kwargs.get('volume_id', None)\n    description = kwargs.get('description', '')\n\n    if volume_id is None:\n        raise SaltCloudSystemExit(\n            'A volume_id must be specified to create a snapshot.'\n        )\n\n    params = {'Action': 'CreateSnapshot',\n              'VolumeId': volume_id,\n              'Description': description}\n\n    log.debug(params)\n\n    data = aws.query(params,\n                     return_url=True,\n                     return_root=True,\n                     location=get_location(),\n                     provider=get_provider(),\n                     opts=__opts__,\n                     sigver='4')[0]\n\n    r_data = {}\n    for d in data:\n        for k, v in six.iteritems(d):\n            r_data[k] = v\n\n    if 'snapshotId' in r_data:\n        snapshot_id = r_data['snapshotId']\n\n        # Waits till volume is available\n        if wait_to_finish:\n            salt.utils.cloud.run_func_until_ret_arg(fun=describe_snapshots,\n                                                    kwargs={'snapshot_id': snapshot_id},\n                                                    fun_call=call,\n                                                    argument_being_watched='status',\n                                                    required_argument_response='completed')\n\n    return r_data", "code_tokens": ["def", "create_snapshot", "(", "kwargs", "=", "None", ",", "call", "=", "None", ",", "wait_to_finish", "=", "False", ")", ":", "if", "call", "!=", "'function'", ":", "raise", "SaltCloudSystemExit", "(", "'The create_snapshot function must be called with -f '", "'or --function.'", ")", "if", "kwargs", "is", "None", ":", "kwargs", "=", "{", "}", "volume_id", "=", "kwargs", ".", "get", "(", "'volume_id'", ",", "None", ")", "description", "=", "kwargs", ".", "get", "(", "'description'", ",", "''", ")", "if", "volume_id", "is", "None", ":", "raise", "SaltCloudSystemExit", "(", "'A volume_id must be specified to create a snapshot.'", ")", "params", "=", "{", "'Action'", ":", "'CreateSnapshot'", ",", "'VolumeId'", ":", "volume_id", ",", "'Description'", ":", "description", "}", "log", ".", "debug", "(", "params", ")", "data", "=", "aws", ".", "query", "(", "params", ",", "return_url", "=", "True", ",", "return_root", "=", "True", ",", "location", "=", "get_location", "(", ")", ",", "provider", "=", "get_provider", "(", ")", ",", "opts", "=", "__opts__", ",", "sigver", "=", "'4'", ")", "[", "0", "]", "r_data", "=", "{", "}", "for", "d", "in", "data", ":", "for", "k", ",", "v", "in", "six", ".", "iteritems", "(", "d", ")", ":", "r_data", "[", "k", "]", "=", "v", "if", "'snapshotId'", "in", "r_data", ":", "snapshot_id", "=", "r_data", "[", "'snapshotId'", "]", "# Waits till volume is available", "if", "wait_to_finish", ":", "salt", ".", "utils", ".", "cloud", ".", "run_func_until_ret_arg", "(", "fun", "=", "describe_snapshots", ",", "kwargs", "=", "{", "'snapshot_id'", ":", "snapshot_id", "}", ",", "fun_call", "=", "call", ",", "argument_being_watched", "=", "'status'", ",", "required_argument_response", "=", "'completed'", ")", "return", "r_data"], "docstring": "Create a snapshot.\n\n    volume_id\n        The ID of the Volume from which to create a snapshot.\n\n    description\n        The optional description of the snapshot.\n\n    CLI Exampe:\n\n    .. code-block:: bash\n\n        salt-cloud -f create_snapshot my-ec2-config volume_id=vol-351d8826\n        salt-cloud -f create_snapshot my-ec2-config volume_id=vol-351d8826 \\\\\n            description=\"My Snapshot Description\"", "docstring_tokens": ["Create", "a", "snapshot", "."], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/cloud/clouds/ec2.py#L4597-L4662", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/cloud/clouds/ec2.py", "func_name": "copy_snapshot", "original_string": "def copy_snapshot(kwargs=None, call=None):\n    '''\n    Copy a snapshot\n    '''\n    if call != 'function':\n        log.error(\n            'The copy_snapshot function must be called with -f or --function.'\n        )\n        return False\n\n    if 'source_region' not in kwargs:\n        log.error('A source_region must be specified to copy a snapshot.')\n        return False\n\n    if 'source_snapshot_id' not in kwargs:\n        log.error('A source_snapshot_id must be specified to copy a snapshot.')\n        return False\n\n    if 'description' not in kwargs:\n        kwargs['description'] = ''\n\n    params = {'Action': 'CopySnapshot'}\n\n    if 'source_region' in kwargs:\n        params['SourceRegion'] = kwargs['source_region']\n\n    if 'source_snapshot_id' in kwargs:\n        params['SourceSnapshotId'] = kwargs['source_snapshot_id']\n\n    if 'description' in kwargs:\n        params['Description'] = kwargs['description']\n\n    log.debug(params)\n\n    data = aws.query(params,\n                     return_url=True,\n                     location=get_location(),\n                     provider=get_provider(),\n                     opts=__opts__,\n                     sigver='4')\n    return data", "language": "python", "code": "def copy_snapshot(kwargs=None, call=None):\n    '''\n    Copy a snapshot\n    '''\n    if call != 'function':\n        log.error(\n            'The copy_snapshot function must be called with -f or --function.'\n        )\n        return False\n\n    if 'source_region' not in kwargs:\n        log.error('A source_region must be specified to copy a snapshot.')\n        return False\n\n    if 'source_snapshot_id' not in kwargs:\n        log.error('A source_snapshot_id must be specified to copy a snapshot.')\n        return False\n\n    if 'description' not in kwargs:\n        kwargs['description'] = ''\n\n    params = {'Action': 'CopySnapshot'}\n\n    if 'source_region' in kwargs:\n        params['SourceRegion'] = kwargs['source_region']\n\n    if 'source_snapshot_id' in kwargs:\n        params['SourceSnapshotId'] = kwargs['source_snapshot_id']\n\n    if 'description' in kwargs:\n        params['Description'] = kwargs['description']\n\n    log.debug(params)\n\n    data = aws.query(params,\n                     return_url=True,\n                     location=get_location(),\n                     provider=get_provider(),\n                     opts=__opts__,\n                     sigver='4')\n    return data", "code_tokens": ["def", "copy_snapshot", "(", "kwargs", "=", "None", ",", "call", "=", "None", ")", ":", "if", "call", "!=", "'function'", ":", "log", ".", "error", "(", "'The copy_snapshot function must be called with -f or --function.'", ")", "return", "False", "if", "'source_region'", "not", "in", "kwargs", ":", "log", ".", "error", "(", "'A source_region must be specified to copy a snapshot.'", ")", "return", "False", "if", "'source_snapshot_id'", "not", "in", "kwargs", ":", "log", ".", "error", "(", "'A source_snapshot_id must be specified to copy a snapshot.'", ")", "return", "False", "if", "'description'", "not", "in", "kwargs", ":", "kwargs", "[", "'description'", "]", "=", "''", "params", "=", "{", "'Action'", ":", "'CopySnapshot'", "}", "if", "'source_region'", "in", "kwargs", ":", "params", "[", "'SourceRegion'", "]", "=", "kwargs", "[", "'source_region'", "]", "if", "'source_snapshot_id'", "in", "kwargs", ":", "params", "[", "'SourceSnapshotId'", "]", "=", "kwargs", "[", "'source_snapshot_id'", "]", "if", "'description'", "in", "kwargs", ":", "params", "[", "'Description'", "]", "=", "kwargs", "[", "'description'", "]", "log", ".", "debug", "(", "params", ")", "data", "=", "aws", ".", "query", "(", "params", ",", "return_url", "=", "True", ",", "location", "=", "get_location", "(", ")", ",", "provider", "=", "get_provider", "(", ")", ",", "opts", "=", "__opts__", ",", "sigver", "=", "'4'", ")", "return", "data"], "docstring": "Copy a snapshot", "docstring_tokens": ["Copy", "a", "snapshot"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/cloud/clouds/ec2.py#L4696-L4736", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/cloud/clouds/ec2.py", "func_name": "describe_snapshots", "original_string": "def describe_snapshots(kwargs=None, call=None):\n    '''\n    Describe a snapshot (or snapshots)\n\n    snapshot_id\n        One or more snapshot IDs. Multiple IDs must be separated by \",\".\n\n    owner\n        Return the snapshots owned by the specified owner. Valid values\n        include: self, amazon, <AWS Account ID>. Multiple values must be\n        separated by \",\".\n\n    restorable_by\n        One or more AWS accounts IDs that can create volumes from the snapshot.\n        Multiple aws account IDs must be separated by \",\".\n\n    TODO: Add all of the filters.\n    '''\n    if call != 'function':\n        log.error(\n            'The describe_snapshot function must be called with -f '\n            'or --function.'\n        )\n        return False\n\n    params = {'Action': 'DescribeSnapshots'}\n\n    # The AWS correct way is to use non-plurals like snapshot_id INSTEAD of snapshot_ids.\n    if 'snapshot_ids' in kwargs:\n        kwargs['snapshot_id'] = kwargs['snapshot_ids']\n\n    if 'snapshot_id' in kwargs:\n        snapshot_ids = kwargs['snapshot_id'].split(',')\n        for snapshot_index, snapshot_id in enumerate(snapshot_ids):\n            params['SnapshotId.{0}'.format(snapshot_index)] = snapshot_id\n\n    if 'owner' in kwargs:\n        owners = kwargs['owner'].split(',')\n        for owner_index, owner in enumerate(owners):\n            params['Owner.{0}'.format(owner_index)] = owner\n\n    if 'restorable_by' in kwargs:\n        restorable_bys = kwargs['restorable_by'].split(',')\n        for restorable_by_index, restorable_by in enumerate(restorable_bys):\n            params[\n                'RestorableBy.{0}'.format(restorable_by_index)\n            ] = restorable_by\n\n    log.debug(params)\n\n    data = aws.query(params,\n                     return_url=True,\n                     location=get_location(),\n                     provider=get_provider(),\n                     opts=__opts__,\n                     sigver='4')\n    return data", "language": "python", "code": "def describe_snapshots(kwargs=None, call=None):\n    '''\n    Describe a snapshot (or snapshots)\n\n    snapshot_id\n        One or more snapshot IDs. Multiple IDs must be separated by \",\".\n\n    owner\n        Return the snapshots owned by the specified owner. Valid values\n        include: self, amazon, <AWS Account ID>. Multiple values must be\n        separated by \",\".\n\n    restorable_by\n        One or more AWS accounts IDs that can create volumes from the snapshot.\n        Multiple aws account IDs must be separated by \",\".\n\n    TODO: Add all of the filters.\n    '''\n    if call != 'function':\n        log.error(\n            'The describe_snapshot function must be called with -f '\n            'or --function.'\n        )\n        return False\n\n    params = {'Action': 'DescribeSnapshots'}\n\n    # The AWS correct way is to use non-plurals like snapshot_id INSTEAD of snapshot_ids.\n    if 'snapshot_ids' in kwargs:\n        kwargs['snapshot_id'] = kwargs['snapshot_ids']\n\n    if 'snapshot_id' in kwargs:\n        snapshot_ids = kwargs['snapshot_id'].split(',')\n        for snapshot_index, snapshot_id in enumerate(snapshot_ids):\n            params['SnapshotId.{0}'.format(snapshot_index)] = snapshot_id\n\n    if 'owner' in kwargs:\n        owners = kwargs['owner'].split(',')\n        for owner_index, owner in enumerate(owners):\n            params['Owner.{0}'.format(owner_index)] = owner\n\n    if 'restorable_by' in kwargs:\n        restorable_bys = kwargs['restorable_by'].split(',')\n        for restorable_by_index, restorable_by in enumerate(restorable_bys):\n            params[\n                'RestorableBy.{0}'.format(restorable_by_index)\n            ] = restorable_by\n\n    log.debug(params)\n\n    data = aws.query(params,\n                     return_url=True,\n                     location=get_location(),\n                     provider=get_provider(),\n                     opts=__opts__,\n                     sigver='4')\n    return data", "code_tokens": ["def", "describe_snapshots", "(", "kwargs", "=", "None", ",", "call", "=", "None", ")", ":", "if", "call", "!=", "'function'", ":", "log", ".", "error", "(", "'The describe_snapshot function must be called with -f '", "'or --function.'", ")", "return", "False", "params", "=", "{", "'Action'", ":", "'DescribeSnapshots'", "}", "# The AWS correct way is to use non-plurals like snapshot_id INSTEAD of snapshot_ids.", "if", "'snapshot_ids'", "in", "kwargs", ":", "kwargs", "[", "'snapshot_id'", "]", "=", "kwargs", "[", "'snapshot_ids'", "]", "if", "'snapshot_id'", "in", "kwargs", ":", "snapshot_ids", "=", "kwargs", "[", "'snapshot_id'", "]", ".", "split", "(", "','", ")", "for", "snapshot_index", ",", "snapshot_id", "in", "enumerate", "(", "snapshot_ids", ")", ":", "params", "[", "'SnapshotId.{0}'", ".", "format", "(", "snapshot_index", ")", "]", "=", "snapshot_id", "if", "'owner'", "in", "kwargs", ":", "owners", "=", "kwargs", "[", "'owner'", "]", ".", "split", "(", "','", ")", "for", "owner_index", ",", "owner", "in", "enumerate", "(", "owners", ")", ":", "params", "[", "'Owner.{0}'", ".", "format", "(", "owner_index", ")", "]", "=", "owner", "if", "'restorable_by'", "in", "kwargs", ":", "restorable_bys", "=", "kwargs", "[", "'restorable_by'", "]", ".", "split", "(", "','", ")", "for", "restorable_by_index", ",", "restorable_by", "in", "enumerate", "(", "restorable_bys", ")", ":", "params", "[", "'RestorableBy.{0}'", ".", "format", "(", "restorable_by_index", ")", "]", "=", "restorable_by", "log", ".", "debug", "(", "params", ")", "data", "=", "aws", ".", "query", "(", "params", ",", "return_url", "=", "True", ",", "location", "=", "get_location", "(", ")", ",", "provider", "=", "get_provider", "(", ")", ",", "opts", "=", "__opts__", ",", "sigver", "=", "'4'", ")", "return", "data"], "docstring": "Describe a snapshot (or snapshots)\n\n    snapshot_id\n        One or more snapshot IDs. Multiple IDs must be separated by \",\".\n\n    owner\n        Return the snapshots owned by the specified owner. Valid values\n        include: self, amazon, <AWS Account ID>. Multiple values must be\n        separated by \",\".\n\n    restorable_by\n        One or more AWS accounts IDs that can create volumes from the snapshot.\n        Multiple aws account IDs must be separated by \",\".\n\n    TODO: Add all of the filters.", "docstring_tokens": ["Describe", "a", "snapshot", "(", "or", "snapshots", ")"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/cloud/clouds/ec2.py#L4739-L4795", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/cloud/clouds/ec2.py", "func_name": "get_console_output", "original_string": "def get_console_output(\n        name=None,\n        location=None,\n        instance_id=None,\n        call=None,\n        kwargs=None,\n    ):\n    '''\n    Show the console output from the instance.\n\n    By default, returns decoded data, not the Base64-encoded data that is\n    actually returned from the EC2 API.\n    '''\n    if call != 'action':\n        raise SaltCloudSystemExit(\n            'The get_console_output action must be called with '\n            '-a or --action.'\n        )\n\n    if location is None:\n        location = get_location()\n\n    if not instance_id:\n        instance_id = _get_node(name)['instanceId']\n\n    if kwargs is None:\n        kwargs = {}\n\n    if instance_id is None:\n        if 'instance_id' in kwargs:\n            instance_id = kwargs['instance_id']\n            del kwargs['instance_id']\n\n    params = {'Action': 'GetConsoleOutput',\n              'InstanceId': instance_id}\n\n    ret = {}\n    data = aws.query(params,\n                     return_root=True,\n                     location=location,\n                     provider=get_provider(),\n                     opts=__opts__,\n                     sigver='4')\n\n    for item in data:\n        if next(six.iterkeys(item)) == 'output':\n            ret['output_decoded'] = binascii.a2b_base64(next(six.itervalues(item)))\n        else:\n            ret[next(six.iterkeys(item))] = next(six.itervalues(item))\n\n    return ret", "language": "python", "code": "def get_console_output(\n        name=None,\n        location=None,\n        instance_id=None,\n        call=None,\n        kwargs=None,\n    ):\n    '''\n    Show the console output from the instance.\n\n    By default, returns decoded data, not the Base64-encoded data that is\n    actually returned from the EC2 API.\n    '''\n    if call != 'action':\n        raise SaltCloudSystemExit(\n            'The get_console_output action must be called with '\n            '-a or --action.'\n        )\n\n    if location is None:\n        location = get_location()\n\n    if not instance_id:\n        instance_id = _get_node(name)['instanceId']\n\n    if kwargs is None:\n        kwargs = {}\n\n    if instance_id is None:\n        if 'instance_id' in kwargs:\n            instance_id = kwargs['instance_id']\n            del kwargs['instance_id']\n\n    params = {'Action': 'GetConsoleOutput',\n              'InstanceId': instance_id}\n\n    ret = {}\n    data = aws.query(params,\n                     return_root=True,\n                     location=location,\n                     provider=get_provider(),\n                     opts=__opts__,\n                     sigver='4')\n\n    for item in data:\n        if next(six.iterkeys(item)) == 'output':\n            ret['output_decoded'] = binascii.a2b_base64(next(six.itervalues(item)))\n        else:\n            ret[next(six.iterkeys(item))] = next(six.itervalues(item))\n\n    return ret", "code_tokens": ["def", "get_console_output", "(", "name", "=", "None", ",", "location", "=", "None", ",", "instance_id", "=", "None", ",", "call", "=", "None", ",", "kwargs", "=", "None", ",", ")", ":", "if", "call", "!=", "'action'", ":", "raise", "SaltCloudSystemExit", "(", "'The get_console_output action must be called with '", "'-a or --action.'", ")", "if", "location", "is", "None", ":", "location", "=", "get_location", "(", ")", "if", "not", "instance_id", ":", "instance_id", "=", "_get_node", "(", "name", ")", "[", "'instanceId'", "]", "if", "kwargs", "is", "None", ":", "kwargs", "=", "{", "}", "if", "instance_id", "is", "None", ":", "if", "'instance_id'", "in", "kwargs", ":", "instance_id", "=", "kwargs", "[", "'instance_id'", "]", "del", "kwargs", "[", "'instance_id'", "]", "params", "=", "{", "'Action'", ":", "'GetConsoleOutput'", ",", "'InstanceId'", ":", "instance_id", "}", "ret", "=", "{", "}", "data", "=", "aws", ".", "query", "(", "params", ",", "return_root", "=", "True", ",", "location", "=", "location", ",", "provider", "=", "get_provider", "(", ")", ",", "opts", "=", "__opts__", ",", "sigver", "=", "'4'", ")", "for", "item", "in", "data", ":", "if", "next", "(", "six", ".", "iterkeys", "(", "item", ")", ")", "==", "'output'", ":", "ret", "[", "'output_decoded'", "]", "=", "binascii", ".", "a2b_base64", "(", "next", "(", "six", ".", "itervalues", "(", "item", ")", ")", ")", "else", ":", "ret", "[", "next", "(", "six", ".", "iterkeys", "(", "item", ")", ")", "]", "=", "next", "(", "six", ".", "itervalues", "(", "item", ")", ")", "return", "ret"], "docstring": "Show the console output from the instance.\n\n    By default, returns decoded data, not the Base64-encoded data that is\n    actually returned from the EC2 API.", "docstring_tokens": ["Show", "the", "console", "output", "from", "the", "instance", "."], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/cloud/clouds/ec2.py#L4798-L4848", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/cloud/clouds/ec2.py", "func_name": "get_password_data", "original_string": "def get_password_data(\n        name=None,\n        kwargs=None,\n        instance_id=None,\n        call=None,\n    ):\n    '''\n    Return password data for a Windows instance.\n\n    By default only the encrypted password data will be returned. However, if a\n    key_file is passed in, then a decrypted password will also be returned.\n\n    Note that the key_file references the private key that was used to generate\n    the keypair associated with this instance. This private key will _not_ be\n    transmitted to Amazon; it is only used internally inside of Salt Cloud to\n    decrypt data _after_ it has been received from Amazon.\n\n    CLI Examples:\n\n    .. code-block:: bash\n\n        salt-cloud -a get_password_data mymachine\n        salt-cloud -a get_password_data mymachine key_file=/root/ec2key.pem\n\n    Note: PKCS1_v1_5 was added in PyCrypto 2.5\n    '''\n    if call != 'action':\n        raise SaltCloudSystemExit(\n            'The get_password_data action must be called with '\n            '-a or --action.'\n        )\n\n    if not instance_id:\n        instance_id = _get_node(name)['instanceId']\n\n    if kwargs is None:\n        kwargs = {}\n\n    if instance_id is None:\n        if 'instance_id' in kwargs:\n            instance_id = kwargs['instance_id']\n            del kwargs['instance_id']\n\n    params = {'Action': 'GetPasswordData',\n              'InstanceId': instance_id}\n\n    ret = {}\n    data = aws.query(params,\n                     return_root=True,\n                     location=get_location(),\n                     provider=get_provider(),\n                     opts=__opts__,\n                     sigver='4')\n\n    for item in data:\n        ret[next(six.iterkeys(item))] = next(six.itervalues(item))\n\n    if not HAS_M2 and not HAS_PYCRYPTO:\n        return ret\n\n    if 'key' not in kwargs:\n        if 'key_file' in kwargs:\n            with salt.utils.files.fopen(kwargs['key_file'], 'r') as kf_:\n                kwargs['key'] = salt.utils.stringutils.to_unicode(kf_.read())\n\n    if 'key' in kwargs:\n        pwdata = ret.get('passwordData', None)\n        if pwdata is not None:\n            rsa_key = kwargs['key']\n            pwdata = base64.b64decode(pwdata)\n            if HAS_M2:\n                key = RSA.load_key_string(rsa_key.encode('ascii'))\n                password = key.private_decrypt(pwdata, RSA.pkcs1_padding)\n            else:\n                dsize = Crypto.Hash.SHA.digest_size\n                sentinel = Crypto.Random.new().read(15 + dsize)\n                key_obj = Crypto.PublicKey.RSA.importKey(rsa_key)\n                key_obj = PKCS1_v1_5.new(key_obj)\n                password = key_obj.decrypt(pwdata, sentinel)\n            ret['password'] = salt.utils.stringutils.to_unicode(password)\n\n    return ret", "language": "python", "code": "def get_password_data(\n        name=None,\n        kwargs=None,\n        instance_id=None,\n        call=None,\n    ):\n    '''\n    Return password data for a Windows instance.\n\n    By default only the encrypted password data will be returned. However, if a\n    key_file is passed in, then a decrypted password will also be returned.\n\n    Note that the key_file references the private key that was used to generate\n    the keypair associated with this instance. This private key will _not_ be\n    transmitted to Amazon; it is only used internally inside of Salt Cloud to\n    decrypt data _after_ it has been received from Amazon.\n\n    CLI Examples:\n\n    .. code-block:: bash\n\n        salt-cloud -a get_password_data mymachine\n        salt-cloud -a get_password_data mymachine key_file=/root/ec2key.pem\n\n    Note: PKCS1_v1_5 was added in PyCrypto 2.5\n    '''\n    if call != 'action':\n        raise SaltCloudSystemExit(\n            'The get_password_data action must be called with '\n            '-a or --action.'\n        )\n\n    if not instance_id:\n        instance_id = _get_node(name)['instanceId']\n\n    if kwargs is None:\n        kwargs = {}\n\n    if instance_id is None:\n        if 'instance_id' in kwargs:\n            instance_id = kwargs['instance_id']\n            del kwargs['instance_id']\n\n    params = {'Action': 'GetPasswordData',\n              'InstanceId': instance_id}\n\n    ret = {}\n    data = aws.query(params,\n                     return_root=True,\n                     location=get_location(),\n                     provider=get_provider(),\n                     opts=__opts__,\n                     sigver='4')\n\n    for item in data:\n        ret[next(six.iterkeys(item))] = next(six.itervalues(item))\n\n    if not HAS_M2 and not HAS_PYCRYPTO:\n        return ret\n\n    if 'key' not in kwargs:\n        if 'key_file' in kwargs:\n            with salt.utils.files.fopen(kwargs['key_file'], 'r') as kf_:\n                kwargs['key'] = salt.utils.stringutils.to_unicode(kf_.read())\n\n    if 'key' in kwargs:\n        pwdata = ret.get('passwordData', None)\n        if pwdata is not None:\n            rsa_key = kwargs['key']\n            pwdata = base64.b64decode(pwdata)\n            if HAS_M2:\n                key = RSA.load_key_string(rsa_key.encode('ascii'))\n                password = key.private_decrypt(pwdata, RSA.pkcs1_padding)\n            else:\n                dsize = Crypto.Hash.SHA.digest_size\n                sentinel = Crypto.Random.new().read(15 + dsize)\n                key_obj = Crypto.PublicKey.RSA.importKey(rsa_key)\n                key_obj = PKCS1_v1_5.new(key_obj)\n                password = key_obj.decrypt(pwdata, sentinel)\n            ret['password'] = salt.utils.stringutils.to_unicode(password)\n\n    return ret", "code_tokens": ["def", "get_password_data", "(", "name", "=", "None", ",", "kwargs", "=", "None", ",", "instance_id", "=", "None", ",", "call", "=", "None", ",", ")", ":", "if", "call", "!=", "'action'", ":", "raise", "SaltCloudSystemExit", "(", "'The get_password_data action must be called with '", "'-a or --action.'", ")", "if", "not", "instance_id", ":", "instance_id", "=", "_get_node", "(", "name", ")", "[", "'instanceId'", "]", "if", "kwargs", "is", "None", ":", "kwargs", "=", "{", "}", "if", "instance_id", "is", "None", ":", "if", "'instance_id'", "in", "kwargs", ":", "instance_id", "=", "kwargs", "[", "'instance_id'", "]", "del", "kwargs", "[", "'instance_id'", "]", "params", "=", "{", "'Action'", ":", "'GetPasswordData'", ",", "'InstanceId'", ":", "instance_id", "}", "ret", "=", "{", "}", "data", "=", "aws", ".", "query", "(", "params", ",", "return_root", "=", "True", ",", "location", "=", "get_location", "(", ")", ",", "provider", "=", "get_provider", "(", ")", ",", "opts", "=", "__opts__", ",", "sigver", "=", "'4'", ")", "for", "item", "in", "data", ":", "ret", "[", "next", "(", "six", ".", "iterkeys", "(", "item", ")", ")", "]", "=", "next", "(", "six", ".", "itervalues", "(", "item", ")", ")", "if", "not", "HAS_M2", "and", "not", "HAS_PYCRYPTO", ":", "return", "ret", "if", "'key'", "not", "in", "kwargs", ":", "if", "'key_file'", "in", "kwargs", ":", "with", "salt", ".", "utils", ".", "files", ".", "fopen", "(", "kwargs", "[", "'key_file'", "]", ",", "'r'", ")", "as", "kf_", ":", "kwargs", "[", "'key'", "]", "=", "salt", ".", "utils", ".", "stringutils", ".", "to_unicode", "(", "kf_", ".", "read", "(", ")", ")", "if", "'key'", "in", "kwargs", ":", "pwdata", "=", "ret", ".", "get", "(", "'passwordData'", ",", "None", ")", "if", "pwdata", "is", "not", "None", ":", "rsa_key", "=", "kwargs", "[", "'key'", "]", "pwdata", "=", "base64", ".", "b64decode", "(", "pwdata", ")", "if", "HAS_M2", ":", "key", "=", "RSA", ".", "load_key_string", "(", "rsa_key", ".", "encode", "(", "'ascii'", ")", ")", "password", "=", "key", ".", "private_decrypt", "(", "pwdata", ",", "RSA", ".", "pkcs1_padding", ")", "else", ":", "dsize", "=", "Crypto", ".", "Hash", ".", "SHA", ".", "digest_size", "sentinel", "=", "Crypto", ".", "Random", ".", "new", "(", ")", ".", "read", "(", "15", "+", "dsize", ")", "key_obj", "=", "Crypto", ".", "PublicKey", ".", "RSA", ".", "importKey", "(", "rsa_key", ")", "key_obj", "=", "PKCS1_v1_5", ".", "new", "(", "key_obj", ")", "password", "=", "key_obj", ".", "decrypt", "(", "pwdata", ",", "sentinel", ")", "ret", "[", "'password'", "]", "=", "salt", ".", "utils", ".", "stringutils", ".", "to_unicode", "(", "password", ")", "return", "ret"], "docstring": "Return password data for a Windows instance.\n\n    By default only the encrypted password data will be returned. However, if a\n    key_file is passed in, then a decrypted password will also be returned.\n\n    Note that the key_file references the private key that was used to generate\n    the keypair associated with this instance. This private key will _not_ be\n    transmitted to Amazon; it is only used internally inside of Salt Cloud to\n    decrypt data _after_ it has been received from Amazon.\n\n    CLI Examples:\n\n    .. code-block:: bash\n\n        salt-cloud -a get_password_data mymachine\n        salt-cloud -a get_password_data mymachine key_file=/root/ec2key.pem\n\n    Note: PKCS1_v1_5 was added in PyCrypto 2.5", "docstring_tokens": ["Return", "password", "data", "for", "a", "Windows", "instance", "."], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/cloud/clouds/ec2.py#L4851-L4932", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/cloud/clouds/ec2.py", "func_name": "update_pricing", "original_string": "def update_pricing(kwargs=None, call=None):\n    '''\n    Download most recent pricing information from AWS and convert to a local\n    JSON file.\n\n    CLI Examples:\n\n    .. code-block:: bash\n\n        salt-cloud -f update_pricing my-ec2-config\n        salt-cloud -f update_pricing my-ec2-config type=linux\n\n    .. versionadded:: 2015.8.0\n    '''\n    sources = {\n        'linux': 'https://a0.awsstatic.com/pricing/1/ec2/linux-od.min.js',\n        'rhel': 'https://a0.awsstatic.com/pricing/1/ec2/rhel-od.min.js',\n        'sles': 'https://a0.awsstatic.com/pricing/1/ec2/sles-od.min.js',\n        'mswin': 'https://a0.awsstatic.com/pricing/1/ec2/mswin-od.min.js',\n        'mswinsql': 'https://a0.awsstatic.com/pricing/1/ec2/mswinSQL-od.min.js',\n        'mswinsqlweb': 'https://a0.awsstatic.com/pricing/1/ec2/mswinSQLWeb-od.min.js',\n    }\n\n    if kwargs is None:\n        kwargs = {}\n\n    if 'type' not in kwargs:\n        for source in sources:\n            _parse_pricing(sources[source], source)\n    else:\n        _parse_pricing(sources[kwargs['type']], kwargs['type'])", "language": "python", "code": "def update_pricing(kwargs=None, call=None):\n    '''\n    Download most recent pricing information from AWS and convert to a local\n    JSON file.\n\n    CLI Examples:\n\n    .. code-block:: bash\n\n        salt-cloud -f update_pricing my-ec2-config\n        salt-cloud -f update_pricing my-ec2-config type=linux\n\n    .. versionadded:: 2015.8.0\n    '''\n    sources = {\n        'linux': 'https://a0.awsstatic.com/pricing/1/ec2/linux-od.min.js',\n        'rhel': 'https://a0.awsstatic.com/pricing/1/ec2/rhel-od.min.js',\n        'sles': 'https://a0.awsstatic.com/pricing/1/ec2/sles-od.min.js',\n        'mswin': 'https://a0.awsstatic.com/pricing/1/ec2/mswin-od.min.js',\n        'mswinsql': 'https://a0.awsstatic.com/pricing/1/ec2/mswinSQL-od.min.js',\n        'mswinsqlweb': 'https://a0.awsstatic.com/pricing/1/ec2/mswinSQLWeb-od.min.js',\n    }\n\n    if kwargs is None:\n        kwargs = {}\n\n    if 'type' not in kwargs:\n        for source in sources:\n            _parse_pricing(sources[source], source)\n    else:\n        _parse_pricing(sources[kwargs['type']], kwargs['type'])", "code_tokens": ["def", "update_pricing", "(", "kwargs", "=", "None", ",", "call", "=", "None", ")", ":", "sources", "=", "{", "'linux'", ":", "'https://a0.awsstatic.com/pricing/1/ec2/linux-od.min.js'", ",", "'rhel'", ":", "'https://a0.awsstatic.com/pricing/1/ec2/rhel-od.min.js'", ",", "'sles'", ":", "'https://a0.awsstatic.com/pricing/1/ec2/sles-od.min.js'", ",", "'mswin'", ":", "'https://a0.awsstatic.com/pricing/1/ec2/mswin-od.min.js'", ",", "'mswinsql'", ":", "'https://a0.awsstatic.com/pricing/1/ec2/mswinSQL-od.min.js'", ",", "'mswinsqlweb'", ":", "'https://a0.awsstatic.com/pricing/1/ec2/mswinSQLWeb-od.min.js'", ",", "}", "if", "kwargs", "is", "None", ":", "kwargs", "=", "{", "}", "if", "'type'", "not", "in", "kwargs", ":", "for", "source", "in", "sources", ":", "_parse_pricing", "(", "sources", "[", "source", "]", ",", "source", ")", "else", ":", "_parse_pricing", "(", "sources", "[", "kwargs", "[", "'type'", "]", "]", ",", "kwargs", "[", "'type'", "]", ")"], "docstring": "Download most recent pricing information from AWS and convert to a local\n    JSON file.\n\n    CLI Examples:\n\n    .. code-block:: bash\n\n        salt-cloud -f update_pricing my-ec2-config\n        salt-cloud -f update_pricing my-ec2-config type=linux\n\n    .. versionadded:: 2015.8.0", "docstring_tokens": ["Download", "most", "recent", "pricing", "information", "from", "AWS", "and", "convert", "to", "a", "local", "JSON", "file", "."], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/cloud/clouds/ec2.py#L4935-L4965", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/cloud/clouds/ec2.py", "func_name": "_parse_pricing", "original_string": "def _parse_pricing(url, name):\n    '''\n    Download and parse an individual pricing file from AWS\n\n    .. versionadded:: 2015.8.0\n    '''\n    price_js = http.query(url, text=True)\n\n    items = []\n    current_item = ''\n\n    price_js = re.sub(JS_COMMENT_RE, '', price_js['text'])\n    price_js = price_js.strip().rstrip(');').lstrip('callback(')\n    for keyword in (\n        'vers',\n        'config',\n        'rate',\n        'valueColumns',\n        'currencies',\n        'instanceTypes',\n        'type',\n        'ECU',\n        'storageGB',\n        'name',\n        'vCPU',\n        'memoryGiB',\n        'storageGiB',\n        'USD',\n    ):\n        price_js = price_js.replace(keyword, '\"{0}\"'.format(keyword))\n\n    for keyword in ('region', 'price', 'size'):\n        price_js = price_js.replace(keyword, '\"{0}\"'.format(keyword))\n        price_js = price_js.replace('\"{0}\"s'.format(keyword), '\"{0}s\"'.format(keyword))\n\n    price_js = price_js.replace('\"\"', '\"')\n\n    # Turn the data into something that's easier/faster to process\n    regions = {}\n    price_json = salt.utils.json.loads(price_js)\n    for region in price_json['config']['regions']:\n        sizes = {}\n        for itype in region['instanceTypes']:\n            for size in itype['sizes']:\n                sizes[size['size']] = size\n        regions[region['region']] = sizes\n\n    outfile = os.path.join(\n        __opts__['cachedir'], 'ec2-pricing-{0}.p'.format(name)\n    )\n    with salt.utils.files.fopen(outfile, 'w') as fho:\n        salt.utils.msgpack.dump(regions, fho)\n\n    return True", "language": "python", "code": "def _parse_pricing(url, name):\n    '''\n    Download and parse an individual pricing file from AWS\n\n    .. versionadded:: 2015.8.0\n    '''\n    price_js = http.query(url, text=True)\n\n    items = []\n    current_item = ''\n\n    price_js = re.sub(JS_COMMENT_RE, '', price_js['text'])\n    price_js = price_js.strip().rstrip(');').lstrip('callback(')\n    for keyword in (\n        'vers',\n        'config',\n        'rate',\n        'valueColumns',\n        'currencies',\n        'instanceTypes',\n        'type',\n        'ECU',\n        'storageGB',\n        'name',\n        'vCPU',\n        'memoryGiB',\n        'storageGiB',\n        'USD',\n    ):\n        price_js = price_js.replace(keyword, '\"{0}\"'.format(keyword))\n\n    for keyword in ('region', 'price', 'size'):\n        price_js = price_js.replace(keyword, '\"{0}\"'.format(keyword))\n        price_js = price_js.replace('\"{0}\"s'.format(keyword), '\"{0}s\"'.format(keyword))\n\n    price_js = price_js.replace('\"\"', '\"')\n\n    # Turn the data into something that's easier/faster to process\n    regions = {}\n    price_json = salt.utils.json.loads(price_js)\n    for region in price_json['config']['regions']:\n        sizes = {}\n        for itype in region['instanceTypes']:\n            for size in itype['sizes']:\n                sizes[size['size']] = size\n        regions[region['region']] = sizes\n\n    outfile = os.path.join(\n        __opts__['cachedir'], 'ec2-pricing-{0}.p'.format(name)\n    )\n    with salt.utils.files.fopen(outfile, 'w') as fho:\n        salt.utils.msgpack.dump(regions, fho)\n\n    return True", "code_tokens": ["def", "_parse_pricing", "(", "url", ",", "name", ")", ":", "price_js", "=", "http", ".", "query", "(", "url", ",", "text", "=", "True", ")", "items", "=", "[", "]", "current_item", "=", "''", "price_js", "=", "re", ".", "sub", "(", "JS_COMMENT_RE", ",", "''", ",", "price_js", "[", "'text'", "]", ")", "price_js", "=", "price_js", ".", "strip", "(", ")", ".", "rstrip", "(", "');'", ")", ".", "lstrip", "(", "'callback('", ")", "for", "keyword", "in", "(", "'vers'", ",", "'config'", ",", "'rate'", ",", "'valueColumns'", ",", "'currencies'", ",", "'instanceTypes'", ",", "'type'", ",", "'ECU'", ",", "'storageGB'", ",", "'name'", ",", "'vCPU'", ",", "'memoryGiB'", ",", "'storageGiB'", ",", "'USD'", ",", ")", ":", "price_js", "=", "price_js", ".", "replace", "(", "keyword", ",", "'\"{0}\"'", ".", "format", "(", "keyword", ")", ")", "for", "keyword", "in", "(", "'region'", ",", "'price'", ",", "'size'", ")", ":", "price_js", "=", "price_js", ".", "replace", "(", "keyword", ",", "'\"{0}\"'", ".", "format", "(", "keyword", ")", ")", "price_js", "=", "price_js", ".", "replace", "(", "'\"{0}\"s'", ".", "format", "(", "keyword", ")", ",", "'\"{0}s\"'", ".", "format", "(", "keyword", ")", ")", "price_js", "=", "price_js", ".", "replace", "(", "'\"\"'", ",", "'\"'", ")", "# Turn the data into something that's easier/faster to process", "regions", "=", "{", "}", "price_json", "=", "salt", ".", "utils", ".", "json", ".", "loads", "(", "price_js", ")", "for", "region", "in", "price_json", "[", "'config'", "]", "[", "'regions'", "]", ":", "sizes", "=", "{", "}", "for", "itype", "in", "region", "[", "'instanceTypes'", "]", ":", "for", "size", "in", "itype", "[", "'sizes'", "]", ":", "sizes", "[", "size", "[", "'size'", "]", "]", "=", "size", "regions", "[", "region", "[", "'region'", "]", "]", "=", "sizes", "outfile", "=", "os", ".", "path", ".", "join", "(", "__opts__", "[", "'cachedir'", "]", ",", "'ec2-pricing-{0}.p'", ".", "format", "(", "name", ")", ")", "with", "salt", ".", "utils", ".", "files", ".", "fopen", "(", "outfile", ",", "'w'", ")", "as", "fho", ":", "salt", ".", "utils", ".", "msgpack", ".", "dump", "(", "regions", ",", "fho", ")", "return", "True"], "docstring": "Download and parse an individual pricing file from AWS\n\n    .. versionadded:: 2015.8.0", "docstring_tokens": ["Download", "and", "parse", "an", "individual", "pricing", "file", "from", "AWS"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/cloud/clouds/ec2.py#L4968-L5021", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/cloud/clouds/ec2.py", "func_name": "show_pricing", "original_string": "def show_pricing(kwargs=None, call=None):\n    '''\n    Show pricing for a particular profile. This is only an estimate, based on\n    unofficial pricing sources.\n\n    CLI Examples:\n\n    .. code-block:: bash\n\n        salt-cloud -f show_pricing my-ec2-config profile=my-profile\n\n    If pricing sources have not been cached, they will be downloaded. Once they\n    have been cached, they will not be updated automatically. To manually update\n    all prices, use the following command:\n\n    .. code-block:: bash\n\n        salt-cloud -f update_pricing <provider>\n\n    .. versionadded:: 2015.8.0\n    '''\n    profile = __opts__['profiles'].get(kwargs['profile'], {})\n    if not profile:\n        return {'Error': 'The requested profile was not found'}\n\n    # Make sure the profile belongs to ec2\n    provider = profile.get('provider', '0:0')\n    comps = provider.split(':')\n    if len(comps) < 2 or comps[1] != 'ec2':\n        return {'Error': 'The requested profile does not belong to EC2'}\n\n    image_id = profile.get('image', None)\n    image_dict = show_image({'image': image_id}, 'function')\n    image_info = image_dict[0]\n\n    # Find out what platform it is\n    if image_info.get('imageOwnerAlias', '') == 'amazon':\n        if image_info.get('platform', '') == 'windows':\n            image_description = image_info.get('description', '')\n            if 'sql' in image_description.lower():\n                if 'web' in image_description.lower():\n                    name = 'mswinsqlweb'\n                else:\n                    name = 'mswinsql'\n            else:\n                name = 'mswin'\n        elif image_info.get('imageLocation', '').strip().startswith('amazon/suse'):\n            name = 'sles'\n        else:\n            name = 'linux'\n    elif image_info.get('imageOwnerId', '') == '309956199498':\n        name = 'rhel'\n    else:\n        name = 'linux'\n\n    pricefile = os.path.join(\n        __opts__['cachedir'], 'ec2-pricing-{0}.p'.format(name)\n    )\n\n    if not os.path.isfile(pricefile):\n        update_pricing({'type': name}, 'function')\n\n    with salt.utils.files.fopen(pricefile, 'r') as fhi:\n        ec2_price = salt.utils.stringutils.to_unicode(\n            salt.utils.msgpack.load(fhi))\n\n    region = get_location(profile)\n    size = profile.get('size', None)\n    if size is None:\n        return {'Error': 'The requested profile does not contain a size'}\n\n    try:\n        raw = ec2_price[region][size]\n    except KeyError:\n        return {'Error': 'The size ({0}) in the requested profile does not have '\n                'a price associated with it for the {1} region'.format(size, region)}\n\n    ret = {}\n    if kwargs.get('raw', False):\n        ret['_raw'] = raw\n\n    ret['per_hour'] = 0\n    for col in raw.get('valueColumns', []):\n        ret['per_hour'] += decimal.Decimal(col['prices'].get('USD', 0))\n\n    ret['per_hour'] = decimal.Decimal(ret['per_hour'])\n    ret['per_day'] = ret['per_hour'] * 24\n    ret['per_week'] = ret['per_day'] * 7\n    ret['per_month'] = ret['per_day'] * 30\n    ret['per_year'] = ret['per_week'] * 52\n\n    return {profile['profile']: ret}", "language": "python", "code": "def show_pricing(kwargs=None, call=None):\n    '''\n    Show pricing for a particular profile. This is only an estimate, based on\n    unofficial pricing sources.\n\n    CLI Examples:\n\n    .. code-block:: bash\n\n        salt-cloud -f show_pricing my-ec2-config profile=my-profile\n\n    If pricing sources have not been cached, they will be downloaded. Once they\n    have been cached, they will not be updated automatically. To manually update\n    all prices, use the following command:\n\n    .. code-block:: bash\n\n        salt-cloud -f update_pricing <provider>\n\n    .. versionadded:: 2015.8.0\n    '''\n    profile = __opts__['profiles'].get(kwargs['profile'], {})\n    if not profile:\n        return {'Error': 'The requested profile was not found'}\n\n    # Make sure the profile belongs to ec2\n    provider = profile.get('provider', '0:0')\n    comps = provider.split(':')\n    if len(comps) < 2 or comps[1] != 'ec2':\n        return {'Error': 'The requested profile does not belong to EC2'}\n\n    image_id = profile.get('image', None)\n    image_dict = show_image({'image': image_id}, 'function')\n    image_info = image_dict[0]\n\n    # Find out what platform it is\n    if image_info.get('imageOwnerAlias', '') == 'amazon':\n        if image_info.get('platform', '') == 'windows':\n            image_description = image_info.get('description', '')\n            if 'sql' in image_description.lower():\n                if 'web' in image_description.lower():\n                    name = 'mswinsqlweb'\n                else:\n                    name = 'mswinsql'\n            else:\n                name = 'mswin'\n        elif image_info.get('imageLocation', '').strip().startswith('amazon/suse'):\n            name = 'sles'\n        else:\n            name = 'linux'\n    elif image_info.get('imageOwnerId', '') == '309956199498':\n        name = 'rhel'\n    else:\n        name = 'linux'\n\n    pricefile = os.path.join(\n        __opts__['cachedir'], 'ec2-pricing-{0}.p'.format(name)\n    )\n\n    if not os.path.isfile(pricefile):\n        update_pricing({'type': name}, 'function')\n\n    with salt.utils.files.fopen(pricefile, 'r') as fhi:\n        ec2_price = salt.utils.stringutils.to_unicode(\n            salt.utils.msgpack.load(fhi))\n\n    region = get_location(profile)\n    size = profile.get('size', None)\n    if size is None:\n        return {'Error': 'The requested profile does not contain a size'}\n\n    try:\n        raw = ec2_price[region][size]\n    except KeyError:\n        return {'Error': 'The size ({0}) in the requested profile does not have '\n                'a price associated with it for the {1} region'.format(size, region)}\n\n    ret = {}\n    if kwargs.get('raw', False):\n        ret['_raw'] = raw\n\n    ret['per_hour'] = 0\n    for col in raw.get('valueColumns', []):\n        ret['per_hour'] += decimal.Decimal(col['prices'].get('USD', 0))\n\n    ret['per_hour'] = decimal.Decimal(ret['per_hour'])\n    ret['per_day'] = ret['per_hour'] * 24\n    ret['per_week'] = ret['per_day'] * 7\n    ret['per_month'] = ret['per_day'] * 30\n    ret['per_year'] = ret['per_week'] * 52\n\n    return {profile['profile']: ret}", "code_tokens": ["def", "show_pricing", "(", "kwargs", "=", "None", ",", "call", "=", "None", ")", ":", "profile", "=", "__opts__", "[", "'profiles'", "]", ".", "get", "(", "kwargs", "[", "'profile'", "]", ",", "{", "}", ")", "if", "not", "profile", ":", "return", "{", "'Error'", ":", "'The requested profile was not found'", "}", "# Make sure the profile belongs to ec2", "provider", "=", "profile", ".", "get", "(", "'provider'", ",", "'0:0'", ")", "comps", "=", "provider", ".", "split", "(", "':'", ")", "if", "len", "(", "comps", ")", "<", "2", "or", "comps", "[", "1", "]", "!=", "'ec2'", ":", "return", "{", "'Error'", ":", "'The requested profile does not belong to EC2'", "}", "image_id", "=", "profile", ".", "get", "(", "'image'", ",", "None", ")", "image_dict", "=", "show_image", "(", "{", "'image'", ":", "image_id", "}", ",", "'function'", ")", "image_info", "=", "image_dict", "[", "0", "]", "# Find out what platform it is", "if", "image_info", ".", "get", "(", "'imageOwnerAlias'", ",", "''", ")", "==", "'amazon'", ":", "if", "image_info", ".", "get", "(", "'platform'", ",", "''", ")", "==", "'windows'", ":", "image_description", "=", "image_info", ".", "get", "(", "'description'", ",", "''", ")", "if", "'sql'", "in", "image_description", ".", "lower", "(", ")", ":", "if", "'web'", "in", "image_description", ".", "lower", "(", ")", ":", "name", "=", "'mswinsqlweb'", "else", ":", "name", "=", "'mswinsql'", "else", ":", "name", "=", "'mswin'", "elif", "image_info", ".", "get", "(", "'imageLocation'", ",", "''", ")", ".", "strip", "(", ")", ".", "startswith", "(", "'amazon/suse'", ")", ":", "name", "=", "'sles'", "else", ":", "name", "=", "'linux'", "elif", "image_info", ".", "get", "(", "'imageOwnerId'", ",", "''", ")", "==", "'309956199498'", ":", "name", "=", "'rhel'", "else", ":", "name", "=", "'linux'", "pricefile", "=", "os", ".", "path", ".", "join", "(", "__opts__", "[", "'cachedir'", "]", ",", "'ec2-pricing-{0}.p'", ".", "format", "(", "name", ")", ")", "if", "not", "os", ".", "path", ".", "isfile", "(", "pricefile", ")", ":", "update_pricing", "(", "{", "'type'", ":", "name", "}", ",", "'function'", ")", "with", "salt", ".", "utils", ".", "files", ".", "fopen", "(", "pricefile", ",", "'r'", ")", "as", "fhi", ":", "ec2_price", "=", "salt", ".", "utils", ".", "stringutils", ".", "to_unicode", "(", "salt", ".", "utils", ".", "msgpack", ".", "load", "(", "fhi", ")", ")", "region", "=", "get_location", "(", "profile", ")", "size", "=", "profile", ".", "get", "(", "'size'", ",", "None", ")", "if", "size", "is", "None", ":", "return", "{", "'Error'", ":", "'The requested profile does not contain a size'", "}", "try", ":", "raw", "=", "ec2_price", "[", "region", "]", "[", "size", "]", "except", "KeyError", ":", "return", "{", "'Error'", ":", "'The size ({0}) in the requested profile does not have '", "'a price associated with it for the {1} region'", ".", "format", "(", "size", ",", "region", ")", "}", "ret", "=", "{", "}", "if", "kwargs", ".", "get", "(", "'raw'", ",", "False", ")", ":", "ret", "[", "'_raw'", "]", "=", "raw", "ret", "[", "'per_hour'", "]", "=", "0", "for", "col", "in", "raw", ".", "get", "(", "'valueColumns'", ",", "[", "]", ")", ":", "ret", "[", "'per_hour'", "]", "+=", "decimal", ".", "Decimal", "(", "col", "[", "'prices'", "]", ".", "get", "(", "'USD'", ",", "0", ")", ")", "ret", "[", "'per_hour'", "]", "=", "decimal", ".", "Decimal", "(", "ret", "[", "'per_hour'", "]", ")", "ret", "[", "'per_day'", "]", "=", "ret", "[", "'per_hour'", "]", "*", "24", "ret", "[", "'per_week'", "]", "=", "ret", "[", "'per_day'", "]", "*", "7", "ret", "[", "'per_month'", "]", "=", "ret", "[", "'per_day'", "]", "*", "30", "ret", "[", "'per_year'", "]", "=", "ret", "[", "'per_week'", "]", "*", "52", "return", "{", "profile", "[", "'profile'", "]", ":", "ret", "}"], "docstring": "Show pricing for a particular profile. This is only an estimate, based on\n    unofficial pricing sources.\n\n    CLI Examples:\n\n    .. code-block:: bash\n\n        salt-cloud -f show_pricing my-ec2-config profile=my-profile\n\n    If pricing sources have not been cached, they will be downloaded. Once they\n    have been cached, they will not be updated automatically. To manually update\n    all prices, use the following command:\n\n    .. code-block:: bash\n\n        salt-cloud -f update_pricing <provider>\n\n    .. versionadded:: 2015.8.0", "docstring_tokens": ["Show", "pricing", "for", "a", "particular", "profile", ".", "This", "is", "only", "an", "estimate", "based", "on", "unofficial", "pricing", "sources", "."], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/cloud/clouds/ec2.py#L5024-L5115", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/cloud/clouds/ec2.py", "func_name": "ssm_create_association", "original_string": "def ssm_create_association(name=None, kwargs=None, instance_id=None, call=None):\n    '''\n    Associates the specified SSM document with the specified instance\n\n    http://docs.aws.amazon.com/ssm/latest/APIReference/API_CreateAssociation.html\n\n    CLI Examples:\n\n    .. code-block:: bash\n\n        salt-cloud -a ssm_create_association ec2-instance-name ssm_document=ssm-document-name\n    '''\n\n    if call != 'action':\n        raise SaltCloudSystemExit(\n            'The ssm_create_association action must be called with '\n            '-a or --action.'\n        )\n\n    if not kwargs:\n        kwargs = {}\n\n    if 'instance_id' in kwargs:\n        instance_id = kwargs['instance_id']\n\n    if name and not instance_id:\n        instance_id = _get_node(name)['instanceId']\n\n    if not name and not instance_id:\n        log.error('Either a name or an instance_id is required.')\n        return False\n\n    if 'ssm_document' not in kwargs:\n        log.error('A ssm_document is required.')\n        return False\n\n    params = {'Action': 'CreateAssociation',\n              'InstanceId': instance_id,\n              'Name': kwargs['ssm_document']}\n\n    result = aws.query(params,\n                       return_root=True,\n                       location=get_location(),\n                       provider=get_provider(),\n                       product='ssm',\n                       opts=__opts__,\n                       sigver='4')\n    log.info(result)\n    return result", "language": "python", "code": "def ssm_create_association(name=None, kwargs=None, instance_id=None, call=None):\n    '''\n    Associates the specified SSM document with the specified instance\n\n    http://docs.aws.amazon.com/ssm/latest/APIReference/API_CreateAssociation.html\n\n    CLI Examples:\n\n    .. code-block:: bash\n\n        salt-cloud -a ssm_create_association ec2-instance-name ssm_document=ssm-document-name\n    '''\n\n    if call != 'action':\n        raise SaltCloudSystemExit(\n            'The ssm_create_association action must be called with '\n            '-a or --action.'\n        )\n\n    if not kwargs:\n        kwargs = {}\n\n    if 'instance_id' in kwargs:\n        instance_id = kwargs['instance_id']\n\n    if name and not instance_id:\n        instance_id = _get_node(name)['instanceId']\n\n    if not name and not instance_id:\n        log.error('Either a name or an instance_id is required.')\n        return False\n\n    if 'ssm_document' not in kwargs:\n        log.error('A ssm_document is required.')\n        return False\n\n    params = {'Action': 'CreateAssociation',\n              'InstanceId': instance_id,\n              'Name': kwargs['ssm_document']}\n\n    result = aws.query(params,\n                       return_root=True,\n                       location=get_location(),\n                       provider=get_provider(),\n                       product='ssm',\n                       opts=__opts__,\n                       sigver='4')\n    log.info(result)\n    return result", "code_tokens": ["def", "ssm_create_association", "(", "name", "=", "None", ",", "kwargs", "=", "None", ",", "instance_id", "=", "None", ",", "call", "=", "None", ")", ":", "if", "call", "!=", "'action'", ":", "raise", "SaltCloudSystemExit", "(", "'The ssm_create_association action must be called with '", "'-a or --action.'", ")", "if", "not", "kwargs", ":", "kwargs", "=", "{", "}", "if", "'instance_id'", "in", "kwargs", ":", "instance_id", "=", "kwargs", "[", "'instance_id'", "]", "if", "name", "and", "not", "instance_id", ":", "instance_id", "=", "_get_node", "(", "name", ")", "[", "'instanceId'", "]", "if", "not", "name", "and", "not", "instance_id", ":", "log", ".", "error", "(", "'Either a name or an instance_id is required.'", ")", "return", "False", "if", "'ssm_document'", "not", "in", "kwargs", ":", "log", ".", "error", "(", "'A ssm_document is required.'", ")", "return", "False", "params", "=", "{", "'Action'", ":", "'CreateAssociation'", ",", "'InstanceId'", ":", "instance_id", ",", "'Name'", ":", "kwargs", "[", "'ssm_document'", "]", "}", "result", "=", "aws", ".", "query", "(", "params", ",", "return_root", "=", "True", ",", "location", "=", "get_location", "(", ")", ",", "provider", "=", "get_provider", "(", ")", ",", "product", "=", "'ssm'", ",", "opts", "=", "__opts__", ",", "sigver", "=", "'4'", ")", "log", ".", "info", "(", "result", ")", "return", "result"], "docstring": "Associates the specified SSM document with the specified instance\n\n    http://docs.aws.amazon.com/ssm/latest/APIReference/API_CreateAssociation.html\n\n    CLI Examples:\n\n    .. code-block:: bash\n\n        salt-cloud -a ssm_create_association ec2-instance-name ssm_document=ssm-document-name", "docstring_tokens": ["Associates", "the", "specified", "SSM", "document", "with", "the", "specified", "instance"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/cloud/clouds/ec2.py#L5118-L5166", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/modules/vagrant.py", "func_name": "_build_machine_uri", "original_string": "def _build_machine_uri(machine, cwd):\n    '''\n    returns string used to fetch id names from the sdb store.\n\n    the cwd and machine name are concatenated with '?' which should\n    never collide with a Salt node id -- which is important since we\n    will be storing both in the same table.\n    '''\n    key = '{}?{}'.format(machine, os.path.abspath(cwd))\n    return _build_sdb_uri(key)", "language": "python", "code": "def _build_machine_uri(machine, cwd):\n    '''\n    returns string used to fetch id names from the sdb store.\n\n    the cwd and machine name are concatenated with '?' which should\n    never collide with a Salt node id -- which is important since we\n    will be storing both in the same table.\n    '''\n    key = '{}?{}'.format(machine, os.path.abspath(cwd))\n    return _build_sdb_uri(key)", "code_tokens": ["def", "_build_machine_uri", "(", "machine", ",", "cwd", ")", ":", "key", "=", "'{}?{}'", ".", "format", "(", "machine", ",", "os", ".", "path", ".", "abspath", "(", "cwd", ")", ")", "return", "_build_sdb_uri", "(", "key", ")"], "docstring": "returns string used to fetch id names from the sdb store.\n\n    the cwd and machine name are concatenated with '?' which should\n    never collide with a Salt node id -- which is important since we\n    will be storing both in the same table.", "docstring_tokens": ["returns", "string", "used", "to", "fetch", "id", "names", "from", "the", "sdb", "store", "."], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/modules/vagrant.py#L70-L79", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/modules/vagrant.py", "func_name": "_update_vm_info", "original_string": "def _update_vm_info(name, vm_):\n    ''' store the vm_ information keyed by name '''\n    __utils__['sdb.sdb_set'](_build_sdb_uri(name), vm_, __opts__)\n\n    # store machine-to-name mapping, too\n    if vm_['machine']:\n        __utils__['sdb.sdb_set'](\n            _build_machine_uri(vm_['machine'], vm_.get('cwd', '.')),\n            name,\n            __opts__)", "language": "python", "code": "def _update_vm_info(name, vm_):\n    ''' store the vm_ information keyed by name '''\n    __utils__['sdb.sdb_set'](_build_sdb_uri(name), vm_, __opts__)\n\n    # store machine-to-name mapping, too\n    if vm_['machine']:\n        __utils__['sdb.sdb_set'](\n            _build_machine_uri(vm_['machine'], vm_.get('cwd', '.')),\n            name,\n            __opts__)", "code_tokens": ["def", "_update_vm_info", "(", "name", ",", "vm_", ")", ":", "__utils__", "[", "'sdb.sdb_set'", "]", "(", "_build_sdb_uri", "(", "name", ")", ",", "vm_", ",", "__opts__", ")", "# store machine-to-name mapping, too", "if", "vm_", "[", "'machine'", "]", ":", "__utils__", "[", "'sdb.sdb_set'", "]", "(", "_build_machine_uri", "(", "vm_", "[", "'machine'", "]", ",", "vm_", ".", "get", "(", "'cwd'", ",", "'.'", ")", ")", ",", "name", ",", "__opts__", ")"], "docstring": "store the vm_ information keyed by name", "docstring_tokens": ["store", "the", "vm_", "information", "keyed", "by", "name"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/modules/vagrant.py#L82-L91", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/modules/vagrant.py", "func_name": "get_vm_info", "original_string": "def get_vm_info(name):\n    '''\n    get the information for a VM.\n\n    :param name: salt_id name\n    :return: dictionary of {'machine': x, 'cwd': y, ...}.\n    '''\n    try:\n        vm_ = __utils__['sdb.sdb_get'](_build_sdb_uri(name), __opts__)\n    except KeyError:\n        raise SaltInvocationError(\n            'Probable sdb driver not found. Check your configuration.')\n    if vm_ is None or 'machine' not in vm_:\n        raise SaltInvocationError(\n            'No Vagrant machine defined for Salt_id {}'.format(name))\n    return vm_", "language": "python", "code": "def get_vm_info(name):\n    '''\n    get the information for a VM.\n\n    :param name: salt_id name\n    :return: dictionary of {'machine': x, 'cwd': y, ...}.\n    '''\n    try:\n        vm_ = __utils__['sdb.sdb_get'](_build_sdb_uri(name), __opts__)\n    except KeyError:\n        raise SaltInvocationError(\n            'Probable sdb driver not found. Check your configuration.')\n    if vm_ is None or 'machine' not in vm_:\n        raise SaltInvocationError(\n            'No Vagrant machine defined for Salt_id {}'.format(name))\n    return vm_", "code_tokens": ["def", "get_vm_info", "(", "name", ")", ":", "try", ":", "vm_", "=", "__utils__", "[", "'sdb.sdb_get'", "]", "(", "_build_sdb_uri", "(", "name", ")", ",", "__opts__", ")", "except", "KeyError", ":", "raise", "SaltInvocationError", "(", "'Probable sdb driver not found. Check your configuration.'", ")", "if", "vm_", "is", "None", "or", "'machine'", "not", "in", "vm_", ":", "raise", "SaltInvocationError", "(", "'No Vagrant machine defined for Salt_id {}'", ".", "format", "(", "name", ")", ")", "return", "vm_"], "docstring": "get the information for a VM.\n\n    :param name: salt_id name\n    :return: dictionary of {'machine': x, 'cwd': y, ...}.", "docstring_tokens": ["get", "the", "information", "for", "a", "VM", "."], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/modules/vagrant.py#L94-L109", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/modules/vagrant.py", "func_name": "get_machine_id", "original_string": "def get_machine_id(machine, cwd):\n    '''\n    returns the salt_id name of the Vagrant VM\n\n    :param machine: the Vagrant machine name\n    :param cwd: the path to Vagrantfile\n    :return: salt_id name\n    '''\n    name = __utils__['sdb.sdb_get'](_build_machine_uri(machine, cwd), __opts__)\n    return name", "language": "python", "code": "def get_machine_id(machine, cwd):\n    '''\n    returns the salt_id name of the Vagrant VM\n\n    :param machine: the Vagrant machine name\n    :param cwd: the path to Vagrantfile\n    :return: salt_id name\n    '''\n    name = __utils__['sdb.sdb_get'](_build_machine_uri(machine, cwd), __opts__)\n    return name", "code_tokens": ["def", "get_machine_id", "(", "machine", ",", "cwd", ")", ":", "name", "=", "__utils__", "[", "'sdb.sdb_get'", "]", "(", "_build_machine_uri", "(", "machine", ",", "cwd", ")", ",", "__opts__", ")", "return", "name"], "docstring": "returns the salt_id name of the Vagrant VM\n\n    :param machine: the Vagrant machine name\n    :param cwd: the path to Vagrantfile\n    :return: salt_id name", "docstring_tokens": ["returns", "the", "salt_id", "name", "of", "the", "Vagrant", "VM"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/modules/vagrant.py#L112-L121", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/modules/vagrant.py", "func_name": "_erase_vm_info", "original_string": "def _erase_vm_info(name):\n    '''\n    erase the information for a VM the we are destroying.\n\n    some sdb drivers (such as the SQLite driver we expect to use)\n    do not have a `delete` method, so if the delete fails, we have\n    to replace the with a blank entry.\n    '''\n    try:\n        # delete the machine record\n        vm_ = get_vm_info(name)\n        if vm_['machine']:\n            key = _build_machine_uri(vm_['machine'], vm_.get('cwd', '.'))\n            try:\n                __utils__['sdb.sdb_delete'](key, __opts__)\n            except KeyError:\n                # no delete method found -- load a blank value\n                __utils__['sdb.sdb_set'](key, None, __opts__)\n    except Exception:\n        pass\n\n    uri = _build_sdb_uri(name)\n    try:\n        # delete the name record\n        __utils__['sdb.sdb_delete'](uri, __opts__)\n    except KeyError:\n        # no delete method found -- load an empty dictionary\n        __utils__['sdb.sdb_set'](uri, {}, __opts__)\n    except Exception:\n        pass", "language": "python", "code": "def _erase_vm_info(name):\n    '''\n    erase the information for a VM the we are destroying.\n\n    some sdb drivers (such as the SQLite driver we expect to use)\n    do not have a `delete` method, so if the delete fails, we have\n    to replace the with a blank entry.\n    '''\n    try:\n        # delete the machine record\n        vm_ = get_vm_info(name)\n        if vm_['machine']:\n            key = _build_machine_uri(vm_['machine'], vm_.get('cwd', '.'))\n            try:\n                __utils__['sdb.sdb_delete'](key, __opts__)\n            except KeyError:\n                # no delete method found -- load a blank value\n                __utils__['sdb.sdb_set'](key, None, __opts__)\n    except Exception:\n        pass\n\n    uri = _build_sdb_uri(name)\n    try:\n        # delete the name record\n        __utils__['sdb.sdb_delete'](uri, __opts__)\n    except KeyError:\n        # no delete method found -- load an empty dictionary\n        __utils__['sdb.sdb_set'](uri, {}, __opts__)\n    except Exception:\n        pass", "code_tokens": ["def", "_erase_vm_info", "(", "name", ")", ":", "try", ":", "# delete the machine record", "vm_", "=", "get_vm_info", "(", "name", ")", "if", "vm_", "[", "'machine'", "]", ":", "key", "=", "_build_machine_uri", "(", "vm_", "[", "'machine'", "]", ",", "vm_", ".", "get", "(", "'cwd'", ",", "'.'", ")", ")", "try", ":", "__utils__", "[", "'sdb.sdb_delete'", "]", "(", "key", ",", "__opts__", ")", "except", "KeyError", ":", "# no delete method found -- load a blank value", "__utils__", "[", "'sdb.sdb_set'", "]", "(", "key", ",", "None", ",", "__opts__", ")", "except", "Exception", ":", "pass", "uri", "=", "_build_sdb_uri", "(", "name", ")", "try", ":", "# delete the name record", "__utils__", "[", "'sdb.sdb_delete'", "]", "(", "uri", ",", "__opts__", ")", "except", "KeyError", ":", "# no delete method found -- load an empty dictionary", "__utils__", "[", "'sdb.sdb_set'", "]", "(", "uri", ",", "{", "}", ",", "__opts__", ")", "except", "Exception", ":", "pass"], "docstring": "erase the information for a VM the we are destroying.\n\n    some sdb drivers (such as the SQLite driver we expect to use)\n    do not have a `delete` method, so if the delete fails, we have\n    to replace the with a blank entry.", "docstring_tokens": ["erase", "the", "information", "for", "a", "VM", "the", "we", "are", "destroying", "."], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/modules/vagrant.py#L124-L153", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/modules/vagrant.py", "func_name": "_vagrant_ssh_config", "original_string": "def _vagrant_ssh_config(vm_):\n    '''\n    get the information for ssh communication from the new VM\n\n    :param vm_: the VM's info as we have it now\n    :return: dictionary of ssh stuff\n    '''\n    machine = vm_['machine']\n    log.info('requesting vagrant ssh-config for VM %s', machine or '(default)')\n    cmd = 'vagrant ssh-config {}'.format(machine)\n    reply = __salt__['cmd.shell'](cmd,\n                                  runas=vm_.get('runas'),\n                                  cwd=vm_.get('cwd'),\n                                  ignore_retcode=True)\n    ssh_config = {}\n    for line in reply.split('\\n'):  # build a dictionary of the text reply\n        tokens = line.strip().split()\n        if len(tokens) == 2:  # each two-token line becomes a key:value pair\n            ssh_config[tokens[0]] = tokens[1]\n    log.debug('ssh_config=%s', repr(ssh_config))\n    return ssh_config", "language": "python", "code": "def _vagrant_ssh_config(vm_):\n    '''\n    get the information for ssh communication from the new VM\n\n    :param vm_: the VM's info as we have it now\n    :return: dictionary of ssh stuff\n    '''\n    machine = vm_['machine']\n    log.info('requesting vagrant ssh-config for VM %s', machine or '(default)')\n    cmd = 'vagrant ssh-config {}'.format(machine)\n    reply = __salt__['cmd.shell'](cmd,\n                                  runas=vm_.get('runas'),\n                                  cwd=vm_.get('cwd'),\n                                  ignore_retcode=True)\n    ssh_config = {}\n    for line in reply.split('\\n'):  # build a dictionary of the text reply\n        tokens = line.strip().split()\n        if len(tokens) == 2:  # each two-token line becomes a key:value pair\n            ssh_config[tokens[0]] = tokens[1]\n    log.debug('ssh_config=%s', repr(ssh_config))\n    return ssh_config", "code_tokens": ["def", "_vagrant_ssh_config", "(", "vm_", ")", ":", "machine", "=", "vm_", "[", "'machine'", "]", "log", ".", "info", "(", "'requesting vagrant ssh-config for VM %s'", ",", "machine", "or", "'(default)'", ")", "cmd", "=", "'vagrant ssh-config {}'", ".", "format", "(", "machine", ")", "reply", "=", "__salt__", "[", "'cmd.shell'", "]", "(", "cmd", ",", "runas", "=", "vm_", ".", "get", "(", "'runas'", ")", ",", "cwd", "=", "vm_", ".", "get", "(", "'cwd'", ")", ",", "ignore_retcode", "=", "True", ")", "ssh_config", "=", "{", "}", "for", "line", "in", "reply", ".", "split", "(", "'\\n'", ")", ":", "# build a dictionary of the text reply", "tokens", "=", "line", ".", "strip", "(", ")", ".", "split", "(", ")", "if", "len", "(", "tokens", ")", "==", "2", ":", "# each two-token line becomes a key:value pair", "ssh_config", "[", "tokens", "[", "0", "]", "]", "=", "tokens", "[", "1", "]", "log", ".", "debug", "(", "'ssh_config=%s'", ",", "repr", "(", "ssh_config", ")", ")", "return", "ssh_config"], "docstring": "get the information for ssh communication from the new VM\n\n    :param vm_: the VM's info as we have it now\n    :return: dictionary of ssh stuff", "docstring_tokens": ["get", "the", "information", "for", "ssh", "communication", "from", "the", "new", "VM"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/modules/vagrant.py#L156-L176", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/modules/vagrant.py", "func_name": "list_domains", "original_string": "def list_domains():\n    '''\n    Return a list of the salt_id names of all available Vagrant VMs on\n    this host without regard to the path where they are defined.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' vagrant.list_domains --log-level=info\n\n    The log shows information about all known Vagrant environments\n    on this machine. This data is cached and may not be completely\n    up-to-date.\n    '''\n    vms = []\n    cmd = 'vagrant global-status'\n    reply = __salt__['cmd.shell'](cmd)\n    log.info('--->\\n%s', reply)\n    for line in reply.split('\\n'):  # build a list of the text reply\n        tokens = line.strip().split()\n        try:\n            _ = int(tokens[0], 16)  # valid id numbers are hexadecimal\n        except (ValueError, IndexError):\n            continue  # skip lines without valid id numbers\n        machine = tokens[1]\n        cwd = tokens[-1]\n        name = get_machine_id(machine, cwd)\n        if name:\n            vms.append(name)\n    return vms", "language": "python", "code": "def list_domains():\n    '''\n    Return a list of the salt_id names of all available Vagrant VMs on\n    this host without regard to the path where they are defined.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' vagrant.list_domains --log-level=info\n\n    The log shows information about all known Vagrant environments\n    on this machine. This data is cached and may not be completely\n    up-to-date.\n    '''\n    vms = []\n    cmd = 'vagrant global-status'\n    reply = __salt__['cmd.shell'](cmd)\n    log.info('--->\\n%s', reply)\n    for line in reply.split('\\n'):  # build a list of the text reply\n        tokens = line.strip().split()\n        try:\n            _ = int(tokens[0], 16)  # valid id numbers are hexadecimal\n        except (ValueError, IndexError):\n            continue  # skip lines without valid id numbers\n        machine = tokens[1]\n        cwd = tokens[-1]\n        name = get_machine_id(machine, cwd)\n        if name:\n            vms.append(name)\n    return vms", "code_tokens": ["def", "list_domains", "(", ")", ":", "vms", "=", "[", "]", "cmd", "=", "'vagrant global-status'", "reply", "=", "__salt__", "[", "'cmd.shell'", "]", "(", "cmd", ")", "log", ".", "info", "(", "'--->\\n%s'", ",", "reply", ")", "for", "line", "in", "reply", ".", "split", "(", "'\\n'", ")", ":", "# build a list of the text reply", "tokens", "=", "line", ".", "strip", "(", ")", ".", "split", "(", ")", "try", ":", "_", "=", "int", "(", "tokens", "[", "0", "]", ",", "16", ")", "# valid id numbers are hexadecimal", "except", "(", "ValueError", ",", "IndexError", ")", ":", "continue", "# skip lines without valid id numbers", "machine", "=", "tokens", "[", "1", "]", "cwd", "=", "tokens", "[", "-", "1", "]", "name", "=", "get_machine_id", "(", "machine", ",", "cwd", ")", "if", "name", ":", "vms", ".", "append", "(", "name", ")", "return", "vms"], "docstring": "Return a list of the salt_id names of all available Vagrant VMs on\n    this host without regard to the path where they are defined.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' vagrant.list_domains --log-level=info\n\n    The log shows information about all known Vagrant environments\n    on this machine. This data is cached and may not be completely\n    up-to-date.", "docstring_tokens": ["Return", "a", "list", "of", "the", "salt_id", "names", "of", "all", "available", "Vagrant", "VMs", "on", "this", "host", "without", "regard", "to", "the", "path", "where", "they", "are", "defined", "."], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/modules/vagrant.py#L193-L223", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/modules/vagrant.py", "func_name": "list_active_vms", "original_string": "def list_active_vms(cwd=None):\n    '''\n    Return a list of machine names for active virtual machine on the host,\n    which are defined in the Vagrantfile at the indicated path.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' vagrant.list_active_vms  cwd=/projects/project_1\n    '''\n    vms = []\n    cmd = 'vagrant status'\n    reply = __salt__['cmd.shell'](cmd, cwd=cwd)\n    log.info('--->\\n%s', reply)\n    for line in reply.split('\\n'):  # build a list of the text reply\n        tokens = line.strip().split()\n        if len(tokens) > 1:\n            if tokens[1] == 'running':\n                vms.append(tokens[0])\n    return vms", "language": "python", "code": "def list_active_vms(cwd=None):\n    '''\n    Return a list of machine names for active virtual machine on the host,\n    which are defined in the Vagrantfile at the indicated path.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' vagrant.list_active_vms  cwd=/projects/project_1\n    '''\n    vms = []\n    cmd = 'vagrant status'\n    reply = __salt__['cmd.shell'](cmd, cwd=cwd)\n    log.info('--->\\n%s', reply)\n    for line in reply.split('\\n'):  # build a list of the text reply\n        tokens = line.strip().split()\n        if len(tokens) > 1:\n            if tokens[1] == 'running':\n                vms.append(tokens[0])\n    return vms", "code_tokens": ["def", "list_active_vms", "(", "cwd", "=", "None", ")", ":", "vms", "=", "[", "]", "cmd", "=", "'vagrant status'", "reply", "=", "__salt__", "[", "'cmd.shell'", "]", "(", "cmd", ",", "cwd", "=", "cwd", ")", "log", ".", "info", "(", "'--->\\n%s'", ",", "reply", ")", "for", "line", "in", "reply", ".", "split", "(", "'\\n'", ")", ":", "# build a list of the text reply", "tokens", "=", "line", ".", "strip", "(", ")", ".", "split", "(", ")", "if", "len", "(", "tokens", ")", ">", "1", ":", "if", "tokens", "[", "1", "]", "==", "'running'", ":", "vms", ".", "append", "(", "tokens", "[", "0", "]", ")", "return", "vms"], "docstring": "Return a list of machine names for active virtual machine on the host,\n    which are defined in the Vagrantfile at the indicated path.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' vagrant.list_active_vms  cwd=/projects/project_1", "docstring_tokens": ["Return", "a", "list", "of", "machine", "names", "for", "active", "virtual", "machine", "on", "the", "host", "which", "are", "defined", "in", "the", "Vagrantfile", "at", "the", "indicated", "path", "."], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/modules/vagrant.py#L226-L246", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/modules/vagrant.py", "func_name": "vm_state", "original_string": "def vm_state(name='', cwd=None):\n    '''\n    Return list of information for all the vms indicating their state.\n\n    If you pass a VM name in as an argument then it will return info\n    for just the named VM, otherwise it will return all VMs defined by\n    the Vagrantfile in the `cwd` directory.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' vagrant.vm_state <name>  cwd=/projects/project_1\n\n    returns a list of dictionaries with machine name, state, provider,\n    and salt_id name.\n\n    .. code-block:: python\n\n        datum = {'machine': _, # Vagrant machine name,\n                 'state': _, # string indicating machine state, like 'running'\n                 'provider': _, # the Vagrant VM provider\n                 'name': _} # salt_id name\n\n    Known bug: if there are multiple machines in your Vagrantfile, and you request\n    the status of the ``primary`` machine, which you defined by leaving the ``machine``\n    parameter blank, then you may receive the status of all of them.\n    Please specify the actual machine name for each VM if there are more than one.\n\n    '''\n\n    if name:\n        vm_ = get_vm_info(name)\n        machine = vm_['machine']\n        cwd = vm_['cwd'] or cwd  # usually ignore passed-in cwd\n    else:\n        if not cwd:\n            raise SaltInvocationError(\n                'Path to Vagranfile must be defined, but cwd={}'.format(cwd))\n        machine = ''\n\n    info = []\n    cmd = 'vagrant status {}'.format(machine)\n    reply = __salt__['cmd.shell'](cmd, cwd)\n    log.info('--->\\n%s', reply)\n    for line in reply.split('\\n'):  # build a list of the text reply\n        tokens = line.strip().split()\n        if len(tokens) > 1 and tokens[-1].endswith(')'):\n            try:\n                datum = {'machine': tokens[0],\n                         'state': ' '.join(tokens[1:-1]),\n                         'provider': tokens[-1].lstrip('(').rstrip(')'),\n                         'name': get_machine_id(tokens[0], cwd)\n                         }\n                info.append(datum)\n            except IndexError:\n                pass\n    return info", "language": "python", "code": "def vm_state(name='', cwd=None):\n    '''\n    Return list of information for all the vms indicating their state.\n\n    If you pass a VM name in as an argument then it will return info\n    for just the named VM, otherwise it will return all VMs defined by\n    the Vagrantfile in the `cwd` directory.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' vagrant.vm_state <name>  cwd=/projects/project_1\n\n    returns a list of dictionaries with machine name, state, provider,\n    and salt_id name.\n\n    .. code-block:: python\n\n        datum = {'machine': _, # Vagrant machine name,\n                 'state': _, # string indicating machine state, like 'running'\n                 'provider': _, # the Vagrant VM provider\n                 'name': _} # salt_id name\n\n    Known bug: if there are multiple machines in your Vagrantfile, and you request\n    the status of the ``primary`` machine, which you defined by leaving the ``machine``\n    parameter blank, then you may receive the status of all of them.\n    Please specify the actual machine name for each VM if there are more than one.\n\n    '''\n\n    if name:\n        vm_ = get_vm_info(name)\n        machine = vm_['machine']\n        cwd = vm_['cwd'] or cwd  # usually ignore passed-in cwd\n    else:\n        if not cwd:\n            raise SaltInvocationError(\n                'Path to Vagranfile must be defined, but cwd={}'.format(cwd))\n        machine = ''\n\n    info = []\n    cmd = 'vagrant status {}'.format(machine)\n    reply = __salt__['cmd.shell'](cmd, cwd)\n    log.info('--->\\n%s', reply)\n    for line in reply.split('\\n'):  # build a list of the text reply\n        tokens = line.strip().split()\n        if len(tokens) > 1 and tokens[-1].endswith(')'):\n            try:\n                datum = {'machine': tokens[0],\n                         'state': ' '.join(tokens[1:-1]),\n                         'provider': tokens[-1].lstrip('(').rstrip(')'),\n                         'name': get_machine_id(tokens[0], cwd)\n                         }\n                info.append(datum)\n            except IndexError:\n                pass\n    return info", "code_tokens": ["def", "vm_state", "(", "name", "=", "''", ",", "cwd", "=", "None", ")", ":", "if", "name", ":", "vm_", "=", "get_vm_info", "(", "name", ")", "machine", "=", "vm_", "[", "'machine'", "]", "cwd", "=", "vm_", "[", "'cwd'", "]", "or", "cwd", "# usually ignore passed-in cwd", "else", ":", "if", "not", "cwd", ":", "raise", "SaltInvocationError", "(", "'Path to Vagranfile must be defined, but cwd={}'", ".", "format", "(", "cwd", ")", ")", "machine", "=", "''", "info", "=", "[", "]", "cmd", "=", "'vagrant status {}'", ".", "format", "(", "machine", ")", "reply", "=", "__salt__", "[", "'cmd.shell'", "]", "(", "cmd", ",", "cwd", ")", "log", ".", "info", "(", "'--->\\n%s'", ",", "reply", ")", "for", "line", "in", "reply", ".", "split", "(", "'\\n'", ")", ":", "# build a list of the text reply", "tokens", "=", "line", ".", "strip", "(", ")", ".", "split", "(", ")", "if", "len", "(", "tokens", ")", ">", "1", "and", "tokens", "[", "-", "1", "]", ".", "endswith", "(", "')'", ")", ":", "try", ":", "datum", "=", "{", "'machine'", ":", "tokens", "[", "0", "]", ",", "'state'", ":", "' '", ".", "join", "(", "tokens", "[", "1", ":", "-", "1", "]", ")", ",", "'provider'", ":", "tokens", "[", "-", "1", "]", ".", "lstrip", "(", "'('", ")", ".", "rstrip", "(", "')'", ")", ",", "'name'", ":", "get_machine_id", "(", "tokens", "[", "0", "]", ",", "cwd", ")", "}", "info", ".", "append", "(", "datum", ")", "except", "IndexError", ":", "pass", "return", "info"], "docstring": "Return list of information for all the vms indicating their state.\n\n    If you pass a VM name in as an argument then it will return info\n    for just the named VM, otherwise it will return all VMs defined by\n    the Vagrantfile in the `cwd` directory.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' vagrant.vm_state <name>  cwd=/projects/project_1\n\n    returns a list of dictionaries with machine name, state, provider,\n    and salt_id name.\n\n    .. code-block:: python\n\n        datum = {'machine': _, # Vagrant machine name,\n                 'state': _, # string indicating machine state, like 'running'\n                 'provider': _, # the Vagrant VM provider\n                 'name': _} # salt_id name\n\n    Known bug: if there are multiple machines in your Vagrantfile, and you request\n    the status of the ``primary`` machine, which you defined by leaving the ``machine``\n    parameter blank, then you may receive the status of all of them.\n    Please specify the actual machine name for each VM if there are more than one.", "docstring_tokens": ["Return", "list", "of", "information", "for", "all", "the", "vms", "indicating", "their", "state", "."], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/modules/vagrant.py#L273-L330", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/modules/vagrant.py", "func_name": "init", "original_string": "def init(name,  # Salt_id for created VM\n         cwd=None,  # path to find Vagrantfile\n         machine='',  # name of machine in Vagrantfile\n         runas=None,  # username who owns Vagrant box\n         start=False,  # start the machine when initialized\n         vagrant_provider='',  # vagrant provider (default=virtualbox)\n         vm=None,  # a dictionary of VM configuration settings\n         ):\n    '''\n    Initialize a new Vagrant VM.\n\n    This inputs all the information needed to start a Vagrant VM.  These settings are stored in\n    a Salt sdb database on the Vagrant host minion and used to start, control, and query the\n    guest VMs. The salt_id assigned here is the key field for that database and must be unique.\n\n    :param name: The salt_id name you will use to control this VM\n    :param cwd: The path to the directory where the Vagrantfile is located\n    :param machine: The machine name in the Vagrantfile. If blank, the primary machine will be used.\n    :param runas: The username on the host who owns the Vagrant work files.\n    :param start: (default: False) Start the virtual machine now.\n    :param vagrant_provider: The name of a Vagrant VM provider (if not the default).\n    :param vm: Optionally, all the above information may be supplied in this dictionary.\n    :return: A string indicating success, or False.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt <host> vagrant.init <salt_id> /path/to/Vagrantfile\n        salt my_laptop vagrant.init x1 /projects/bevy_master machine=quail1\n    '''\n    vm_ = {} if vm is None else vm.copy()  # passed configuration data\n    vm_['name'] = name\n    # passed-in keyword arguments overwrite vm dictionary values\n    vm_['cwd'] = cwd or vm_.get('cwd')\n    if not vm_['cwd']:\n        raise SaltInvocationError('Path to Vagrantfile must be defined by \"cwd\" argument')\n    vm_['machine'] = machine or vm_.get('machine', machine)\n    vm_['runas'] = runas or vm_.get('runas', runas)\n    vm_['vagrant_provider'] = vagrant_provider or vm_.get('vagrant_provider', '')\n    _update_vm_info(name, vm_)\n\n    if start:\n        log.debug('Starting VM %s', name)\n        ret = _start(name, vm_)\n    else:\n        ret = 'Name {} defined using VM {}'.format(name, vm_['machine'] or '(default)')\n    return ret", "language": "python", "code": "def init(name,  # Salt_id for created VM\n         cwd=None,  # path to find Vagrantfile\n         machine='',  # name of machine in Vagrantfile\n         runas=None,  # username who owns Vagrant box\n         start=False,  # start the machine when initialized\n         vagrant_provider='',  # vagrant provider (default=virtualbox)\n         vm=None,  # a dictionary of VM configuration settings\n         ):\n    '''\n    Initialize a new Vagrant VM.\n\n    This inputs all the information needed to start a Vagrant VM.  These settings are stored in\n    a Salt sdb database on the Vagrant host minion and used to start, control, and query the\n    guest VMs. The salt_id assigned here is the key field for that database and must be unique.\n\n    :param name: The salt_id name you will use to control this VM\n    :param cwd: The path to the directory where the Vagrantfile is located\n    :param machine: The machine name in the Vagrantfile. If blank, the primary machine will be used.\n    :param runas: The username on the host who owns the Vagrant work files.\n    :param start: (default: False) Start the virtual machine now.\n    :param vagrant_provider: The name of a Vagrant VM provider (if not the default).\n    :param vm: Optionally, all the above information may be supplied in this dictionary.\n    :return: A string indicating success, or False.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt <host> vagrant.init <salt_id> /path/to/Vagrantfile\n        salt my_laptop vagrant.init x1 /projects/bevy_master machine=quail1\n    '''\n    vm_ = {} if vm is None else vm.copy()  # passed configuration data\n    vm_['name'] = name\n    # passed-in keyword arguments overwrite vm dictionary values\n    vm_['cwd'] = cwd or vm_.get('cwd')\n    if not vm_['cwd']:\n        raise SaltInvocationError('Path to Vagrantfile must be defined by \"cwd\" argument')\n    vm_['machine'] = machine or vm_.get('machine', machine)\n    vm_['runas'] = runas or vm_.get('runas', runas)\n    vm_['vagrant_provider'] = vagrant_provider or vm_.get('vagrant_provider', '')\n    _update_vm_info(name, vm_)\n\n    if start:\n        log.debug('Starting VM %s', name)\n        ret = _start(name, vm_)\n    else:\n        ret = 'Name {} defined using VM {}'.format(name, vm_['machine'] or '(default)')\n    return ret", "code_tokens": ["def", "init", "(", "name", ",", "# Salt_id for created VM", "cwd", "=", "None", ",", "# path to find Vagrantfile", "machine", "=", "''", ",", "# name of machine in Vagrantfile", "runas", "=", "None", ",", "# username who owns Vagrant box", "start", "=", "False", ",", "# start the machine when initialized", "vagrant_provider", "=", "''", ",", "# vagrant provider (default=virtualbox)", "vm", "=", "None", ",", "# a dictionary of VM configuration settings", ")", ":", "vm_", "=", "{", "}", "if", "vm", "is", "None", "else", "vm", ".", "copy", "(", ")", "# passed configuration data", "vm_", "[", "'name'", "]", "=", "name", "# passed-in keyword arguments overwrite vm dictionary values", "vm_", "[", "'cwd'", "]", "=", "cwd", "or", "vm_", ".", "get", "(", "'cwd'", ")", "if", "not", "vm_", "[", "'cwd'", "]", ":", "raise", "SaltInvocationError", "(", "'Path to Vagrantfile must be defined by \"cwd\" argument'", ")", "vm_", "[", "'machine'", "]", "=", "machine", "or", "vm_", ".", "get", "(", "'machine'", ",", "machine", ")", "vm_", "[", "'runas'", "]", "=", "runas", "or", "vm_", ".", "get", "(", "'runas'", ",", "runas", ")", "vm_", "[", "'vagrant_provider'", "]", "=", "vagrant_provider", "or", "vm_", ".", "get", "(", "'vagrant_provider'", ",", "''", ")", "_update_vm_info", "(", "name", ",", "vm_", ")", "if", "start", ":", "log", ".", "debug", "(", "'Starting VM %s'", ",", "name", ")", "ret", "=", "_start", "(", "name", ",", "vm_", ")", "else", ":", "ret", "=", "'Name {} defined using VM {}'", ".", "format", "(", "name", ",", "vm_", "[", "'machine'", "]", "or", "'(default)'", ")", "return", "ret"], "docstring": "Initialize a new Vagrant VM.\n\n    This inputs all the information needed to start a Vagrant VM.  These settings are stored in\n    a Salt sdb database on the Vagrant host minion and used to start, control, and query the\n    guest VMs. The salt_id assigned here is the key field for that database and must be unique.\n\n    :param name: The salt_id name you will use to control this VM\n    :param cwd: The path to the directory where the Vagrantfile is located\n    :param machine: The machine name in the Vagrantfile. If blank, the primary machine will be used.\n    :param runas: The username on the host who owns the Vagrant work files.\n    :param start: (default: False) Start the virtual machine now.\n    :param vagrant_provider: The name of a Vagrant VM provider (if not the default).\n    :param vm: Optionally, all the above information may be supplied in this dictionary.\n    :return: A string indicating success, or False.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt <host> vagrant.init <salt_id> /path/to/Vagrantfile\n        salt my_laptop vagrant.init x1 /projects/bevy_master machine=quail1", "docstring_tokens": ["Initialize", "a", "new", "Vagrant", "VM", "."], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/modules/vagrant.py#L333-L380", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/modules/vagrant.py", "func_name": "stop", "original_string": "def stop(name):\n    '''\n    Hard shutdown the virtual machine. (vagrant halt)\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt <host> vagrant.stop <salt_id>\n    '''\n    vm_ = get_vm_info(name)\n    machine = vm_['machine']\n\n    cmd = 'vagrant halt {}'.format(machine)\n    ret = __salt__['cmd.retcode'](cmd,\n                                  runas=vm_.get('runas'),\n                                  cwd=vm_.get('cwd'))\n    return ret == 0", "language": "python", "code": "def stop(name):\n    '''\n    Hard shutdown the virtual machine. (vagrant halt)\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt <host> vagrant.stop <salt_id>\n    '''\n    vm_ = get_vm_info(name)\n    machine = vm_['machine']\n\n    cmd = 'vagrant halt {}'.format(machine)\n    ret = __salt__['cmd.retcode'](cmd,\n                                  runas=vm_.get('runas'),\n                                  cwd=vm_.get('cwd'))\n    return ret == 0", "code_tokens": ["def", "stop", "(", "name", ")", ":", "vm_", "=", "get_vm_info", "(", "name", ")", "machine", "=", "vm_", "[", "'machine'", "]", "cmd", "=", "'vagrant halt {}'", ".", "format", "(", "machine", ")", "ret", "=", "__salt__", "[", "'cmd.retcode'", "]", "(", "cmd", ",", "runas", "=", "vm_", ".", "get", "(", "'runas'", ")", ",", "cwd", "=", "vm_", ".", "get", "(", "'cwd'", ")", ")", "return", "ret", "==", "0"], "docstring": "Hard shutdown the virtual machine. (vagrant halt)\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt <host> vagrant.stop <salt_id>", "docstring_tokens": ["Hard", "shutdown", "the", "virtual", "machine", ".", "(", "vagrant", "halt", ")"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/modules/vagrant.py#L440-L457", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/modules/vagrant.py", "func_name": "reboot", "original_string": "def reboot(name, provision=False):\n    '''\n    Reboot a VM. (vagrant reload)\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt <host> vagrant.reboot <salt_id> provision=True\n\n    :param name: The salt_id name you will use to control this VM\n    :param provision: (False) also re-run the Vagrant provisioning scripts.\n    '''\n    vm_ = get_vm_info(name)\n    machine = vm_['machine']\n    prov = '--provision' if provision else ''\n\n    cmd = 'vagrant reload {} {}'.format(machine, prov)\n    ret = __salt__['cmd.retcode'](cmd,\n                                  runas=vm_.get('runas'),\n                                  cwd=vm_.get('cwd'))\n    return ret == 0", "language": "python", "code": "def reboot(name, provision=False):\n    '''\n    Reboot a VM. (vagrant reload)\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt <host> vagrant.reboot <salt_id> provision=True\n\n    :param name: The salt_id name you will use to control this VM\n    :param provision: (False) also re-run the Vagrant provisioning scripts.\n    '''\n    vm_ = get_vm_info(name)\n    machine = vm_['machine']\n    prov = '--provision' if provision else ''\n\n    cmd = 'vagrant reload {} {}'.format(machine, prov)\n    ret = __salt__['cmd.retcode'](cmd,\n                                  runas=vm_.get('runas'),\n                                  cwd=vm_.get('cwd'))\n    return ret == 0", "code_tokens": ["def", "reboot", "(", "name", ",", "provision", "=", "False", ")", ":", "vm_", "=", "get_vm_info", "(", "name", ")", "machine", "=", "vm_", "[", "'machine'", "]", "prov", "=", "'--provision'", "if", "provision", "else", "''", "cmd", "=", "'vagrant reload {} {}'", ".", "format", "(", "machine", ",", "prov", ")", "ret", "=", "__salt__", "[", "'cmd.retcode'", "]", "(", "cmd", ",", "runas", "=", "vm_", ".", "get", "(", "'runas'", ")", ",", "cwd", "=", "vm_", ".", "get", "(", "'cwd'", ")", ")", "return", "ret", "==", "0"], "docstring": "Reboot a VM. (vagrant reload)\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt <host> vagrant.reboot <salt_id> provision=True\n\n    :param name: The salt_id name you will use to control this VM\n    :param provision: (False) also re-run the Vagrant provisioning scripts.", "docstring_tokens": ["Reboot", "a", "VM", ".", "(", "vagrant", "reload", ")"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/modules/vagrant.py#L480-L501", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/modules/vagrant.py", "func_name": "destroy", "original_string": "def destroy(name):\n    '''\n    Destroy and delete a virtual machine. (vagrant destroy -f)\n\n    This also removes the salt_id name defined by vagrant.init.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt <host> vagrant.destroy <salt_id>\n    '''\n    vm_ = get_vm_info(name)\n    machine = vm_['machine']\n\n    cmd = 'vagrant destroy -f {}'.format(machine)\n\n    ret = __salt__['cmd.run_all'](cmd,\n                                  runas=vm_.get('runas'),\n                                  cwd=vm_.get('cwd'),\n                                  output_loglevel='info')\n    if ret['retcode'] == 0:\n        _erase_vm_info(name)\n        return 'Destroyed VM {0}'.format(name)\n    return False", "language": "python", "code": "def destroy(name):\n    '''\n    Destroy and delete a virtual machine. (vagrant destroy -f)\n\n    This also removes the salt_id name defined by vagrant.init.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt <host> vagrant.destroy <salt_id>\n    '''\n    vm_ = get_vm_info(name)\n    machine = vm_['machine']\n\n    cmd = 'vagrant destroy -f {}'.format(machine)\n\n    ret = __salt__['cmd.run_all'](cmd,\n                                  runas=vm_.get('runas'),\n                                  cwd=vm_.get('cwd'),\n                                  output_loglevel='info')\n    if ret['retcode'] == 0:\n        _erase_vm_info(name)\n        return 'Destroyed VM {0}'.format(name)\n    return False", "code_tokens": ["def", "destroy", "(", "name", ")", ":", "vm_", "=", "get_vm_info", "(", "name", ")", "machine", "=", "vm_", "[", "'machine'", "]", "cmd", "=", "'vagrant destroy -f {}'", ".", "format", "(", "machine", ")", "ret", "=", "__salt__", "[", "'cmd.run_all'", "]", "(", "cmd", ",", "runas", "=", "vm_", ".", "get", "(", "'runas'", ")", ",", "cwd", "=", "vm_", ".", "get", "(", "'cwd'", ")", ",", "output_loglevel", "=", "'info'", ")", "if", "ret", "[", "'retcode'", "]", "==", "0", ":", "_erase_vm_info", "(", "name", ")", "return", "'Destroyed VM {0}'", ".", "format", "(", "name", ")", "return", "False"], "docstring": "Destroy and delete a virtual machine. (vagrant destroy -f)\n\n    This also removes the salt_id name defined by vagrant.init.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt <host> vagrant.destroy <salt_id>", "docstring_tokens": ["Destroy", "and", "delete", "a", "virtual", "machine", ".", "(", "vagrant", "destroy", "-", "f", ")"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/modules/vagrant.py#L504-L528", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/modules/vagrant.py", "func_name": "get_ssh_config", "original_string": "def get_ssh_config(name, network_mask='', get_private_key=False):\n    r'''\n    Retrieve hints of how you might connect to a Vagrant VM.\n\n    :param name: the salt_id of the machine\n    :param network_mask: a CIDR mask to search for the VM's address\n    :param get_private_key: (default: False) return the key used for ssh login\n    :return: a dict of ssh login information for the VM\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt <host> vagrant.get_ssh_config <salt_id>\n        salt my_laptop vagrant.get_ssh_config quail1 network_mask=10.0.0.0/8 get_private_key=True\n\n    The returned dictionary contains:\n\n    - key_filename:  the name of the private key file on the VM host computer\n    - ssh_username:  the username to be used to log in to the VM\n    - ssh_host:  the IP address used to log in to the VM.  (This will usually be `127.0.0.1`)\n    - ssh_port:  the TCP port used to log in to the VM.  (This will often be `2222`)\n    - \\[ip_address:\\]  (if `network_mask` is defined. see below)\n    - \\[private_key:\\]  (if `get_private_key` is True) the private key for ssh_username\n\n    About `network_mask`:\n\n    Vagrant usually uses a redirected TCP port on its host computer to log in to a VM using ssh.\n    This redirected port and its IP address are \"ssh_port\" and \"ssh_host\".  The ssh_host is\n    usually the localhost (127.0.0.1).\n    This makes it impossible for a third machine (such as a salt-cloud master) to contact the VM\n    unless the VM has another network interface defined.  You will usually want a bridged network\n    defined by having a `config.vm.network \"public_network\"` statement in your `Vagrantfile`.\n\n    The IP address of the bridged adapter will typically be assigned by DHCP and unknown to you,\n    but you should be able to determine what IP network the address will be chosen from.\n    If you enter a CIDR network mask, Salt will attempt to find the VM's address for you.\n    The host machine will send an \"ifconfig\" command to the VM (using ssh to `ssh_host`:`ssh_port`)\n    and return the IP address of the first interface it can find which matches your mask.\n    '''\n    vm_ = get_vm_info(name)\n\n    ssh_config = _vagrant_ssh_config(vm_)\n\n    try:\n        ans = {'key_filename': ssh_config['IdentityFile'],\n               'ssh_username': ssh_config['User'],\n               'ssh_host': ssh_config['HostName'],\n               'ssh_port': ssh_config['Port'],\n               }\n\n    except KeyError:\n        raise CommandExecutionError(\n            'Insufficient SSH information to contact VM {}. '\n            'Is it running?'.format(vm_.get('machine', '(default)')))\n\n    if network_mask:\n        #  ask the new VM to report its network address\n        command = 'ssh -i {IdentityFile} -p {Port} ' \\\n                  '-oStrictHostKeyChecking={StrictHostKeyChecking} ' \\\n                  '-oUserKnownHostsFile={UserKnownHostsFile} ' \\\n                  '-oControlPath=none ' \\\n                  '{User}@{HostName} ifconfig'.format(**ssh_config)\n\n        log.info(\n            'Trying ssh -p %s %s@%s ifconfig',\n            ssh_config['Port'], ssh_config['User'], ssh_config['HostName']\n        )\n        reply = __salt__['cmd.shell'](command)\n        log.info('--->\\n%s', reply)\n        target_network_range = ipaddress.ip_network(network_mask, strict=False)\n\n        for line in reply.split('\\n'):\n            try:  # try to find a bridged network address\n                # the lines we are looking for appear like:\n                #    \"inet addr:10.124.31.185  Bcast:10.124.31.255  Mask:255.255.248.0\"\n                # or \"inet6 addr: fe80::a00:27ff:fe04:7aac/64 Scope:Link\"\n                tokens = line.replace('addr:', '', 1).split()  # remove \"addr:\" if it exists, then split\n                found_address = None\n                if \"inet\" in tokens:\n                    nxt = tokens.index(\"inet\") + 1\n                    found_address = ipaddress.ip_address(tokens[nxt])\n                elif \"inet6\" in tokens:\n                    nxt = tokens.index(\"inet6\") + 1\n                    found_address = ipaddress.ip_address(tokens[nxt].split('/')[0])\n                if found_address in target_network_range:\n                    ans['ip_address'] = six.text_type(found_address)\n                    break  # we have located a good matching address\n            except (IndexError, AttributeError, TypeError):\n                pass  # all syntax and type errors loop here\n                # falling out if the loop leaves us remembering the last candidate\n        log.info('Network IP address in %s detected as: %s',\n                 target_network_range, ans.get('ip_address', '(not found)'))\n\n    if get_private_key:\n        # retrieve the Vagrant private key from the host\n        try:\n            with salt.utils.files.fopen(ssh_config['IdentityFile']) as pks:\n                ans['private_key'] = salt.utils.stringutils.to_unicode(pks.read())\n        except (OSError, IOError) as e:\n            raise CommandExecutionError(\"Error processing Vagrant private key file: {}\".format(e))\n    return ans", "language": "python", "code": "def get_ssh_config(name, network_mask='', get_private_key=False):\n    r'''\n    Retrieve hints of how you might connect to a Vagrant VM.\n\n    :param name: the salt_id of the machine\n    :param network_mask: a CIDR mask to search for the VM's address\n    :param get_private_key: (default: False) return the key used for ssh login\n    :return: a dict of ssh login information for the VM\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt <host> vagrant.get_ssh_config <salt_id>\n        salt my_laptop vagrant.get_ssh_config quail1 network_mask=10.0.0.0/8 get_private_key=True\n\n    The returned dictionary contains:\n\n    - key_filename:  the name of the private key file on the VM host computer\n    - ssh_username:  the username to be used to log in to the VM\n    - ssh_host:  the IP address used to log in to the VM.  (This will usually be `127.0.0.1`)\n    - ssh_port:  the TCP port used to log in to the VM.  (This will often be `2222`)\n    - \\[ip_address:\\]  (if `network_mask` is defined. see below)\n    - \\[private_key:\\]  (if `get_private_key` is True) the private key for ssh_username\n\n    About `network_mask`:\n\n    Vagrant usually uses a redirected TCP port on its host computer to log in to a VM using ssh.\n    This redirected port and its IP address are \"ssh_port\" and \"ssh_host\".  The ssh_host is\n    usually the localhost (127.0.0.1).\n    This makes it impossible for a third machine (such as a salt-cloud master) to contact the VM\n    unless the VM has another network interface defined.  You will usually want a bridged network\n    defined by having a `config.vm.network \"public_network\"` statement in your `Vagrantfile`.\n\n    The IP address of the bridged adapter will typically be assigned by DHCP and unknown to you,\n    but you should be able to determine what IP network the address will be chosen from.\n    If you enter a CIDR network mask, Salt will attempt to find the VM's address for you.\n    The host machine will send an \"ifconfig\" command to the VM (using ssh to `ssh_host`:`ssh_port`)\n    and return the IP address of the first interface it can find which matches your mask.\n    '''\n    vm_ = get_vm_info(name)\n\n    ssh_config = _vagrant_ssh_config(vm_)\n\n    try:\n        ans = {'key_filename': ssh_config['IdentityFile'],\n               'ssh_username': ssh_config['User'],\n               'ssh_host': ssh_config['HostName'],\n               'ssh_port': ssh_config['Port'],\n               }\n\n    except KeyError:\n        raise CommandExecutionError(\n            'Insufficient SSH information to contact VM {}. '\n            'Is it running?'.format(vm_.get('machine', '(default)')))\n\n    if network_mask:\n        #  ask the new VM to report its network address\n        command = 'ssh -i {IdentityFile} -p {Port} ' \\\n                  '-oStrictHostKeyChecking={StrictHostKeyChecking} ' \\\n                  '-oUserKnownHostsFile={UserKnownHostsFile} ' \\\n                  '-oControlPath=none ' \\\n                  '{User}@{HostName} ifconfig'.format(**ssh_config)\n\n        log.info(\n            'Trying ssh -p %s %s@%s ifconfig',\n            ssh_config['Port'], ssh_config['User'], ssh_config['HostName']\n        )\n        reply = __salt__['cmd.shell'](command)\n        log.info('--->\\n%s', reply)\n        target_network_range = ipaddress.ip_network(network_mask, strict=False)\n\n        for line in reply.split('\\n'):\n            try:  # try to find a bridged network address\n                # the lines we are looking for appear like:\n                #    \"inet addr:10.124.31.185  Bcast:10.124.31.255  Mask:255.255.248.0\"\n                # or \"inet6 addr: fe80::a00:27ff:fe04:7aac/64 Scope:Link\"\n                tokens = line.replace('addr:', '', 1).split()  # remove \"addr:\" if it exists, then split\n                found_address = None\n                if \"inet\" in tokens:\n                    nxt = tokens.index(\"inet\") + 1\n                    found_address = ipaddress.ip_address(tokens[nxt])\n                elif \"inet6\" in tokens:\n                    nxt = tokens.index(\"inet6\") + 1\n                    found_address = ipaddress.ip_address(tokens[nxt].split('/')[0])\n                if found_address in target_network_range:\n                    ans['ip_address'] = six.text_type(found_address)\n                    break  # we have located a good matching address\n            except (IndexError, AttributeError, TypeError):\n                pass  # all syntax and type errors loop here\n                # falling out if the loop leaves us remembering the last candidate\n        log.info('Network IP address in %s detected as: %s',\n                 target_network_range, ans.get('ip_address', '(not found)'))\n\n    if get_private_key:\n        # retrieve the Vagrant private key from the host\n        try:\n            with salt.utils.files.fopen(ssh_config['IdentityFile']) as pks:\n                ans['private_key'] = salt.utils.stringutils.to_unicode(pks.read())\n        except (OSError, IOError) as e:\n            raise CommandExecutionError(\"Error processing Vagrant private key file: {}\".format(e))\n    return ans", "code_tokens": ["def", "get_ssh_config", "(", "name", ",", "network_mask", "=", "''", ",", "get_private_key", "=", "False", ")", ":", "vm_", "=", "get_vm_info", "(", "name", ")", "ssh_config", "=", "_vagrant_ssh_config", "(", "vm_", ")", "try", ":", "ans", "=", "{", "'key_filename'", ":", "ssh_config", "[", "'IdentityFile'", "]", ",", "'ssh_username'", ":", "ssh_config", "[", "'User'", "]", ",", "'ssh_host'", ":", "ssh_config", "[", "'HostName'", "]", ",", "'ssh_port'", ":", "ssh_config", "[", "'Port'", "]", ",", "}", "except", "KeyError", ":", "raise", "CommandExecutionError", "(", "'Insufficient SSH information to contact VM {}. '", "'Is it running?'", ".", "format", "(", "vm_", ".", "get", "(", "'machine'", ",", "'(default)'", ")", ")", ")", "if", "network_mask", ":", "#  ask the new VM to report its network address", "command", "=", "'ssh -i {IdentityFile} -p {Port} '", "'-oStrictHostKeyChecking={StrictHostKeyChecking} '", "'-oUserKnownHostsFile={UserKnownHostsFile} '", "'-oControlPath=none '", "'{User}@{HostName} ifconfig'", ".", "format", "(", "*", "*", "ssh_config", ")", "log", ".", "info", "(", "'Trying ssh -p %s %s@%s ifconfig'", ",", "ssh_config", "[", "'Port'", "]", ",", "ssh_config", "[", "'User'", "]", ",", "ssh_config", "[", "'HostName'", "]", ")", "reply", "=", "__salt__", "[", "'cmd.shell'", "]", "(", "command", ")", "log", ".", "info", "(", "'--->\\n%s'", ",", "reply", ")", "target_network_range", "=", "ipaddress", ".", "ip_network", "(", "network_mask", ",", "strict", "=", "False", ")", "for", "line", "in", "reply", ".", "split", "(", "'\\n'", ")", ":", "try", ":", "# try to find a bridged network address", "# the lines we are looking for appear like:", "#    \"inet addr:10.124.31.185  Bcast:10.124.31.255  Mask:255.255.248.0\"", "# or \"inet6 addr: fe80::a00:27ff:fe04:7aac/64 Scope:Link\"", "tokens", "=", "line", ".", "replace", "(", "'addr:'", ",", "''", ",", "1", ")", ".", "split", "(", ")", "# remove \"addr:\" if it exists, then split", "found_address", "=", "None", "if", "\"inet\"", "in", "tokens", ":", "nxt", "=", "tokens", ".", "index", "(", "\"inet\"", ")", "+", "1", "found_address", "=", "ipaddress", ".", "ip_address", "(", "tokens", "[", "nxt", "]", ")", "elif", "\"inet6\"", "in", "tokens", ":", "nxt", "=", "tokens", ".", "index", "(", "\"inet6\"", ")", "+", "1", "found_address", "=", "ipaddress", ".", "ip_address", "(", "tokens", "[", "nxt", "]", ".", "split", "(", "'/'", ")", "[", "0", "]", ")", "if", "found_address", "in", "target_network_range", ":", "ans", "[", "'ip_address'", "]", "=", "six", ".", "text_type", "(", "found_address", ")", "break", "# we have located a good matching address", "except", "(", "IndexError", ",", "AttributeError", ",", "TypeError", ")", ":", "pass", "# all syntax and type errors loop here", "# falling out if the loop leaves us remembering the last candidate", "log", ".", "info", "(", "'Network IP address in %s detected as: %s'", ",", "target_network_range", ",", "ans", ".", "get", "(", "'ip_address'", ",", "'(not found)'", ")", ")", "if", "get_private_key", ":", "# retrieve the Vagrant private key from the host", "try", ":", "with", "salt", ".", "utils", ".", "files", ".", "fopen", "(", "ssh_config", "[", "'IdentityFile'", "]", ")", "as", "pks", ":", "ans", "[", "'private_key'", "]", "=", "salt", ".", "utils", ".", "stringutils", ".", "to_unicode", "(", "pks", ".", "read", "(", ")", ")", "except", "(", "OSError", ",", "IOError", ")", "as", "e", ":", "raise", "CommandExecutionError", "(", "\"Error processing Vagrant private key file: {}\"", ".", "format", "(", "e", ")", ")", "return", "ans"], "docstring": "r'''\n    Retrieve hints of how you might connect to a Vagrant VM.\n\n    :param name: the salt_id of the machine\n    :param network_mask: a CIDR mask to search for the VM's address\n    :param get_private_key: (default: False) return the key used for ssh login\n    :return: a dict of ssh login information for the VM\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt <host> vagrant.get_ssh_config <salt_id>\n        salt my_laptop vagrant.get_ssh_config quail1 network_mask=10.0.0.0/8 get_private_key=True\n\n    The returned dictionary contains:\n\n    - key_filename:  the name of the private key file on the VM host computer\n    - ssh_username:  the username to be used to log in to the VM\n    - ssh_host:  the IP address used to log in to the VM.  (This will usually be `127.0.0.1`)\n    - ssh_port:  the TCP port used to log in to the VM.  (This will often be `2222`)\n    - \\[ip_address:\\]  (if `network_mask` is defined. see below)\n    - \\[private_key:\\]  (if `get_private_key` is True) the private key for ssh_username\n\n    About `network_mask`:\n\n    Vagrant usually uses a redirected TCP port on its host computer to log in to a VM using ssh.\n    This redirected port and its IP address are \"ssh_port\" and \"ssh_host\".  The ssh_host is\n    usually the localhost (127.0.0.1).\n    This makes it impossible for a third machine (such as a salt-cloud master) to contact the VM\n    unless the VM has another network interface defined.  You will usually want a bridged network\n    defined by having a `config.vm.network \"public_network\"` statement in your `Vagrantfile`.\n\n    The IP address of the bridged adapter will typically be assigned by DHCP and unknown to you,\n    but you should be able to determine what IP network the address will be chosen from.\n    If you enter a CIDR network mask, Salt will attempt to find the VM's address for you.\n    The host machine will send an \"ifconfig\" command to the VM (using ssh to `ssh_host`:`ssh_port`)\n    and return the IP address of the first interface it can find which matches your mask.", "docstring_tokens": ["r", "Retrieve", "hints", "of", "how", "you", "might", "connect", "to", "a", "Vagrant", "VM", "."], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/modules/vagrant.py#L531-L632", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/states/esxvm.py", "func_name": "vm_configured", "original_string": "def vm_configured(name, vm_name, cpu, memory, image, version, interfaces,\n                  disks, scsi_devices, serial_ports, datacenter, datastore,\n                  placement, cd_dvd_drives=None, sata_controllers=None,\n                  advanced_configs=None, template=None, tools=True,\n                  power_on=False, deploy=False):\n    '''\n    Selects the correct operation to be executed on a virtual machine, non\n    existing machines will be created, existing ones will be updated if the\n    config differs.\n    '''\n    result = {'name': name,\n              'result': None,\n              'changes': {},\n              'comment': ''}\n\n    log.trace('Validating virtual machine configuration')\n    schema = ESXVirtualMachineConfigSchema.serialize()\n    log.trace('schema = %s', schema)\n    try:\n        jsonschema.validate({'vm_name': vm_name,\n                             'cpu': cpu,\n                             'memory': memory,\n                             'image': image,\n                             'version': version,\n                             'interfaces': interfaces,\n                             'disks': disks,\n                             'scsi_devices': scsi_devices,\n                             'serial_ports': serial_ports,\n                             'cd_dvd_drives': cd_dvd_drives,\n                             'sata_controllers': sata_controllers,\n                             'datacenter': datacenter,\n                             'datastore': datastore,\n                             'placement': placement,\n                             'template': template,\n                             'tools': tools,\n                             'power_on': power_on,\n                             'deploy': deploy}, schema)\n    except jsonschema.exceptions.ValidationError as exc:\n        raise salt.exceptions.InvalidConfigError(exc)\n\n    service_instance = __salt__['vsphere.get_service_instance_via_proxy']()\n    try:\n        __salt__['vsphere.get_vm'](vm_name, vm_properties=['name'],\n                                   service_instance=service_instance)\n    except salt.exceptions.VMwareObjectRetrievalError:\n        vm_file = __salt__['vsphere.get_vm_config_file'](\n            vm_name, datacenter,\n            placement, datastore,\n            service_instance=service_instance)\n        if vm_file:\n            if __opts__['test']:\n                result.update({'comment': 'The virtual machine {0}'\n                                          ' will be registered.'.format(vm_name)})\n                __salt__['vsphere.disconnect'](service_instance)\n                return result\n            result = vm_registered(vm_name, datacenter, placement,\n                                   vm_file, power_on=power_on)\n            return result\n        else:\n            if __opts__['test']:\n                result.update({'comment': 'The virtual machine {0}'\n                                          ' will be created.'.format(vm_name)})\n                __salt__['vsphere.disconnect'](service_instance)\n                return result\n            if template:\n                result = vm_cloned(name)\n            else:\n                result = vm_created(name, vm_name, cpu, memory, image, version,\n                                    interfaces, disks, scsi_devices,\n                                    serial_ports, datacenter, datastore,\n                                    placement, cd_dvd_drives=cd_dvd_drives,\n                                    advanced_configs=advanced_configs,\n                                    power_on=power_on)\n            return result\n\n    result = vm_updated(name, vm_name, cpu, memory, image, version,\n                        interfaces, disks, scsi_devices,\n                        serial_ports, datacenter, datastore,\n                        cd_dvd_drives=cd_dvd_drives,\n                        sata_controllers=sata_controllers,\n                        advanced_configs=advanced_configs,\n                        power_on=power_on)\n    __salt__['vsphere.disconnect'](service_instance)\n\n    log.trace(result)\n    return result", "language": "python", "code": "def vm_configured(name, vm_name, cpu, memory, image, version, interfaces,\n                  disks, scsi_devices, serial_ports, datacenter, datastore,\n                  placement, cd_dvd_drives=None, sata_controllers=None,\n                  advanced_configs=None, template=None, tools=True,\n                  power_on=False, deploy=False):\n    '''\n    Selects the correct operation to be executed on a virtual machine, non\n    existing machines will be created, existing ones will be updated if the\n    config differs.\n    '''\n    result = {'name': name,\n              'result': None,\n              'changes': {},\n              'comment': ''}\n\n    log.trace('Validating virtual machine configuration')\n    schema = ESXVirtualMachineConfigSchema.serialize()\n    log.trace('schema = %s', schema)\n    try:\n        jsonschema.validate({'vm_name': vm_name,\n                             'cpu': cpu,\n                             'memory': memory,\n                             'image': image,\n                             'version': version,\n                             'interfaces': interfaces,\n                             'disks': disks,\n                             'scsi_devices': scsi_devices,\n                             'serial_ports': serial_ports,\n                             'cd_dvd_drives': cd_dvd_drives,\n                             'sata_controllers': sata_controllers,\n                             'datacenter': datacenter,\n                             'datastore': datastore,\n                             'placement': placement,\n                             'template': template,\n                             'tools': tools,\n                             'power_on': power_on,\n                             'deploy': deploy}, schema)\n    except jsonschema.exceptions.ValidationError as exc:\n        raise salt.exceptions.InvalidConfigError(exc)\n\n    service_instance = __salt__['vsphere.get_service_instance_via_proxy']()\n    try:\n        __salt__['vsphere.get_vm'](vm_name, vm_properties=['name'],\n                                   service_instance=service_instance)\n    except salt.exceptions.VMwareObjectRetrievalError:\n        vm_file = __salt__['vsphere.get_vm_config_file'](\n            vm_name, datacenter,\n            placement, datastore,\n            service_instance=service_instance)\n        if vm_file:\n            if __opts__['test']:\n                result.update({'comment': 'The virtual machine {0}'\n                                          ' will be registered.'.format(vm_name)})\n                __salt__['vsphere.disconnect'](service_instance)\n                return result\n            result = vm_registered(vm_name, datacenter, placement,\n                                   vm_file, power_on=power_on)\n            return result\n        else:\n            if __opts__['test']:\n                result.update({'comment': 'The virtual machine {0}'\n                                          ' will be created.'.format(vm_name)})\n                __salt__['vsphere.disconnect'](service_instance)\n                return result\n            if template:\n                result = vm_cloned(name)\n            else:\n                result = vm_created(name, vm_name, cpu, memory, image, version,\n                                    interfaces, disks, scsi_devices,\n                                    serial_ports, datacenter, datastore,\n                                    placement, cd_dvd_drives=cd_dvd_drives,\n                                    advanced_configs=advanced_configs,\n                                    power_on=power_on)\n            return result\n\n    result = vm_updated(name, vm_name, cpu, memory, image, version,\n                        interfaces, disks, scsi_devices,\n                        serial_ports, datacenter, datastore,\n                        cd_dvd_drives=cd_dvd_drives,\n                        sata_controllers=sata_controllers,\n                        advanced_configs=advanced_configs,\n                        power_on=power_on)\n    __salt__['vsphere.disconnect'](service_instance)\n\n    log.trace(result)\n    return result", "code_tokens": ["def", "vm_configured", "(", "name", ",", "vm_name", ",", "cpu", ",", "memory", ",", "image", ",", "version", ",", "interfaces", ",", "disks", ",", "scsi_devices", ",", "serial_ports", ",", "datacenter", ",", "datastore", ",", "placement", ",", "cd_dvd_drives", "=", "None", ",", "sata_controllers", "=", "None", ",", "advanced_configs", "=", "None", ",", "template", "=", "None", ",", "tools", "=", "True", ",", "power_on", "=", "False", ",", "deploy", "=", "False", ")", ":", "result", "=", "{", "'name'", ":", "name", ",", "'result'", ":", "None", ",", "'changes'", ":", "{", "}", ",", "'comment'", ":", "''", "}", "log", ".", "trace", "(", "'Validating virtual machine configuration'", ")", "schema", "=", "ESXVirtualMachineConfigSchema", ".", "serialize", "(", ")", "log", ".", "trace", "(", "'schema = %s'", ",", "schema", ")", "try", ":", "jsonschema", ".", "validate", "(", "{", "'vm_name'", ":", "vm_name", ",", "'cpu'", ":", "cpu", ",", "'memory'", ":", "memory", ",", "'image'", ":", "image", ",", "'version'", ":", "version", ",", "'interfaces'", ":", "interfaces", ",", "'disks'", ":", "disks", ",", "'scsi_devices'", ":", "scsi_devices", ",", "'serial_ports'", ":", "serial_ports", ",", "'cd_dvd_drives'", ":", "cd_dvd_drives", ",", "'sata_controllers'", ":", "sata_controllers", ",", "'datacenter'", ":", "datacenter", ",", "'datastore'", ":", "datastore", ",", "'placement'", ":", "placement", ",", "'template'", ":", "template", ",", "'tools'", ":", "tools", ",", "'power_on'", ":", "power_on", ",", "'deploy'", ":", "deploy", "}", ",", "schema", ")", "except", "jsonschema", ".", "exceptions", ".", "ValidationError", "as", "exc", ":", "raise", "salt", ".", "exceptions", ".", "InvalidConfigError", "(", "exc", ")", "service_instance", "=", "__salt__", "[", "'vsphere.get_service_instance_via_proxy'", "]", "(", ")", "try", ":", "__salt__", "[", "'vsphere.get_vm'", "]", "(", "vm_name", ",", "vm_properties", "=", "[", "'name'", "]", ",", "service_instance", "=", "service_instance", ")", "except", "salt", ".", "exceptions", ".", "VMwareObjectRetrievalError", ":", "vm_file", "=", "__salt__", "[", "'vsphere.get_vm_config_file'", "]", "(", "vm_name", ",", "datacenter", ",", "placement", ",", "datastore", ",", "service_instance", "=", "service_instance", ")", "if", "vm_file", ":", "if", "__opts__", "[", "'test'", "]", ":", "result", ".", "update", "(", "{", "'comment'", ":", "'The virtual machine {0}'", "' will be registered.'", ".", "format", "(", "vm_name", ")", "}", ")", "__salt__", "[", "'vsphere.disconnect'", "]", "(", "service_instance", ")", "return", "result", "result", "=", "vm_registered", "(", "vm_name", ",", "datacenter", ",", "placement", ",", "vm_file", ",", "power_on", "=", "power_on", ")", "return", "result", "else", ":", "if", "__opts__", "[", "'test'", "]", ":", "result", ".", "update", "(", "{", "'comment'", ":", "'The virtual machine {0}'", "' will be created.'", ".", "format", "(", "vm_name", ")", "}", ")", "__salt__", "[", "'vsphere.disconnect'", "]", "(", "service_instance", ")", "return", "result", "if", "template", ":", "result", "=", "vm_cloned", "(", "name", ")", "else", ":", "result", "=", "vm_created", "(", "name", ",", "vm_name", ",", "cpu", ",", "memory", ",", "image", ",", "version", ",", "interfaces", ",", "disks", ",", "scsi_devices", ",", "serial_ports", ",", "datacenter", ",", "datastore", ",", "placement", ",", "cd_dvd_drives", "=", "cd_dvd_drives", ",", "advanced_configs", "=", "advanced_configs", ",", "power_on", "=", "power_on", ")", "return", "result", "result", "=", "vm_updated", "(", "name", ",", "vm_name", ",", "cpu", ",", "memory", ",", "image", ",", "version", ",", "interfaces", ",", "disks", ",", "scsi_devices", ",", "serial_ports", ",", "datacenter", ",", "datastore", ",", "cd_dvd_drives", "=", "cd_dvd_drives", ",", "sata_controllers", "=", "sata_controllers", ",", "advanced_configs", "=", "advanced_configs", ",", "power_on", "=", "power_on", ")", "__salt__", "[", "'vsphere.disconnect'", "]", "(", "service_instance", ")", "log", ".", "trace", "(", "result", ")", "return", "result"], "docstring": "Selects the correct operation to be executed on a virtual machine, non\n    existing machines will be created, existing ones will be updated if the\n    config differs.", "docstring_tokens": ["Selects", "the", "correct", "operation", "to", "be", "executed", "on", "a", "virtual", "machine", "non", "existing", "machines", "will", "be", "created", "existing", "ones", "will", "be", "updated", "if", "the", "config", "differs", "."], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/states/esxvm.py#L227-L312", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/states/esxvm.py", "func_name": "vm_updated", "original_string": "def vm_updated(name, vm_name, cpu, memory, image, version, interfaces,\n               disks, scsi_devices, serial_ports, datacenter, datastore,\n               cd_dvd_drives=None, sata_controllers=None,\n               advanced_configs=None, power_on=False):\n    '''\n    Updates a virtual machine configuration if there is a difference between\n    the given and deployed configuration.\n    '''\n    result = {'name': name,\n              'result': None,\n              'changes': {},\n              'comment': ''}\n\n    service_instance = __salt__['vsphere.get_service_instance_via_proxy']()\n    current_config = __salt__['vsphere.get_vm_config'](\n        vm_name,\n        datacenter=datacenter,\n        objects=False,\n        service_instance=service_instance)\n\n    diffs = __salt__['vsphere.compare_vm_configs'](\n        {'name': vm_name,\n         'cpu': cpu,\n         'memory': memory,\n         'image': image,\n         'version': version,\n         'interfaces': interfaces,\n         'disks': disks,\n         'scsi_devices': scsi_devices,\n         'serial_ports': serial_ports,\n         'datacenter': datacenter,\n         'datastore': datastore,\n         'cd_drives': cd_dvd_drives,\n         'sata_controllers': sata_controllers,\n         'advanced_configs': advanced_configs},\n        current_config)\n    if not diffs:\n        result.update({\n            'result': True,\n            'changes': {},\n            'comment': 'Virtual machine {0} is already up to date'.format(vm_name)})\n        return result\n\n    if __opts__['test']:\n        comment = 'State vm_updated will update virtual machine \\'{0}\\' ' \\\n                  'in datacenter \\'{1}\\':\\n{2}'.format(vm_name,\n                                                       datacenter,\n                  '\\n'.join([':\\n'.join([key, difference.changes_str])\n                      for key, difference in six.iteritems(diffs)]))\n        result.update({'result': None,\n                       'comment': comment})\n        __salt__['vsphere.disconnect'](service_instance)\n        return result\n\n    try:\n        changes = __salt__['vsphere.update_vm'](vm_name, cpu, memory, image,\n                                                version, interfaces, disks,\n                                                scsi_devices, serial_ports,\n                                                datacenter, datastore,\n                                                cd_dvd_drives=cd_dvd_drives,\n                                                sata_controllers=sata_controllers,\n                                                advanced_configs=advanced_configs,\n                                                service_instance=service_instance)\n    except salt.exceptions.CommandExecutionError as exc:\n        log.error('Error: %s', exc)\n        if service_instance:\n            __salt__['vsphere.disconnect'](service_instance)\n        result.update({\n            'result': False,\n            'comment': six.text_type(exc)})\n        return result\n\n    if power_on:\n        try:\n            __salt__['vsphere.power_on_vm'](vm_name, datacenter)\n        except salt.exceptions.VMwarePowerOnError as exc:\n            log.error('Error: %s', exc)\n            if service_instance:\n                __salt__['vsphere.disconnect'](service_instance)\n            result.update({\n                'result': False,\n                'comment': six.text_type(exc)})\n            return result\n        changes.update({'power_on': True})\n\n    __salt__['vsphere.disconnect'](service_instance)\n\n    result = {'name': name,\n              'result': True,\n              'changes': changes,\n              'comment': 'Virtual machine '\n                         '{0} was updated successfully'.format(vm_name)}\n\n    return result", "language": "python", "code": "def vm_updated(name, vm_name, cpu, memory, image, version, interfaces,\n               disks, scsi_devices, serial_ports, datacenter, datastore,\n               cd_dvd_drives=None, sata_controllers=None,\n               advanced_configs=None, power_on=False):\n    '''\n    Updates a virtual machine configuration if there is a difference between\n    the given and deployed configuration.\n    '''\n    result = {'name': name,\n              'result': None,\n              'changes': {},\n              'comment': ''}\n\n    service_instance = __salt__['vsphere.get_service_instance_via_proxy']()\n    current_config = __salt__['vsphere.get_vm_config'](\n        vm_name,\n        datacenter=datacenter,\n        objects=False,\n        service_instance=service_instance)\n\n    diffs = __salt__['vsphere.compare_vm_configs'](\n        {'name': vm_name,\n         'cpu': cpu,\n         'memory': memory,\n         'image': image,\n         'version': version,\n         'interfaces': interfaces,\n         'disks': disks,\n         'scsi_devices': scsi_devices,\n         'serial_ports': serial_ports,\n         'datacenter': datacenter,\n         'datastore': datastore,\n         'cd_drives': cd_dvd_drives,\n         'sata_controllers': sata_controllers,\n         'advanced_configs': advanced_configs},\n        current_config)\n    if not diffs:\n        result.update({\n            'result': True,\n            'changes': {},\n            'comment': 'Virtual machine {0} is already up to date'.format(vm_name)})\n        return result\n\n    if __opts__['test']:\n        comment = 'State vm_updated will update virtual machine \\'{0}\\' ' \\\n                  'in datacenter \\'{1}\\':\\n{2}'.format(vm_name,\n                                                       datacenter,\n                  '\\n'.join([':\\n'.join([key, difference.changes_str])\n                      for key, difference in six.iteritems(diffs)]))\n        result.update({'result': None,\n                       'comment': comment})\n        __salt__['vsphere.disconnect'](service_instance)\n        return result\n\n    try:\n        changes = __salt__['vsphere.update_vm'](vm_name, cpu, memory, image,\n                                                version, interfaces, disks,\n                                                scsi_devices, serial_ports,\n                                                datacenter, datastore,\n                                                cd_dvd_drives=cd_dvd_drives,\n                                                sata_controllers=sata_controllers,\n                                                advanced_configs=advanced_configs,\n                                                service_instance=service_instance)\n    except salt.exceptions.CommandExecutionError as exc:\n        log.error('Error: %s', exc)\n        if service_instance:\n            __salt__['vsphere.disconnect'](service_instance)\n        result.update({\n            'result': False,\n            'comment': six.text_type(exc)})\n        return result\n\n    if power_on:\n        try:\n            __salt__['vsphere.power_on_vm'](vm_name, datacenter)\n        except salt.exceptions.VMwarePowerOnError as exc:\n            log.error('Error: %s', exc)\n            if service_instance:\n                __salt__['vsphere.disconnect'](service_instance)\n            result.update({\n                'result': False,\n                'comment': six.text_type(exc)})\n            return result\n        changes.update({'power_on': True})\n\n    __salt__['vsphere.disconnect'](service_instance)\n\n    result = {'name': name,\n              'result': True,\n              'changes': changes,\n              'comment': 'Virtual machine '\n                         '{0} was updated successfully'.format(vm_name)}\n\n    return result", "code_tokens": ["def", "vm_updated", "(", "name", ",", "vm_name", ",", "cpu", ",", "memory", ",", "image", ",", "version", ",", "interfaces", ",", "disks", ",", "scsi_devices", ",", "serial_ports", ",", "datacenter", ",", "datastore", ",", "cd_dvd_drives", "=", "None", ",", "sata_controllers", "=", "None", ",", "advanced_configs", "=", "None", ",", "power_on", "=", "False", ")", ":", "result", "=", "{", "'name'", ":", "name", ",", "'result'", ":", "None", ",", "'changes'", ":", "{", "}", ",", "'comment'", ":", "''", "}", "service_instance", "=", "__salt__", "[", "'vsphere.get_service_instance_via_proxy'", "]", "(", ")", "current_config", "=", "__salt__", "[", "'vsphere.get_vm_config'", "]", "(", "vm_name", ",", "datacenter", "=", "datacenter", ",", "objects", "=", "False", ",", "service_instance", "=", "service_instance", ")", "diffs", "=", "__salt__", "[", "'vsphere.compare_vm_configs'", "]", "(", "{", "'name'", ":", "vm_name", ",", "'cpu'", ":", "cpu", ",", "'memory'", ":", "memory", ",", "'image'", ":", "image", ",", "'version'", ":", "version", ",", "'interfaces'", ":", "interfaces", ",", "'disks'", ":", "disks", ",", "'scsi_devices'", ":", "scsi_devices", ",", "'serial_ports'", ":", "serial_ports", ",", "'datacenter'", ":", "datacenter", ",", "'datastore'", ":", "datastore", ",", "'cd_drives'", ":", "cd_dvd_drives", ",", "'sata_controllers'", ":", "sata_controllers", ",", "'advanced_configs'", ":", "advanced_configs", "}", ",", "current_config", ")", "if", "not", "diffs", ":", "result", ".", "update", "(", "{", "'result'", ":", "True", ",", "'changes'", ":", "{", "}", ",", "'comment'", ":", "'Virtual machine {0} is already up to date'", ".", "format", "(", "vm_name", ")", "}", ")", "return", "result", "if", "__opts__", "[", "'test'", "]", ":", "comment", "=", "'State vm_updated will update virtual machine \\'{0}\\' '", "'in datacenter \\'{1}\\':\\n{2}'", ".", "format", "(", "vm_name", ",", "datacenter", ",", "'\\n'", ".", "join", "(", "[", "':\\n'", ".", "join", "(", "[", "key", ",", "difference", ".", "changes_str", "]", ")", "for", "key", ",", "difference", "in", "six", ".", "iteritems", "(", "diffs", ")", "]", ")", ")", "result", ".", "update", "(", "{", "'result'", ":", "None", ",", "'comment'", ":", "comment", "}", ")", "__salt__", "[", "'vsphere.disconnect'", "]", "(", "service_instance", ")", "return", "result", "try", ":", "changes", "=", "__salt__", "[", "'vsphere.update_vm'", "]", "(", "vm_name", ",", "cpu", ",", "memory", ",", "image", ",", "version", ",", "interfaces", ",", "disks", ",", "scsi_devices", ",", "serial_ports", ",", "datacenter", ",", "datastore", ",", "cd_dvd_drives", "=", "cd_dvd_drives", ",", "sata_controllers", "=", "sata_controllers", ",", "advanced_configs", "=", "advanced_configs", ",", "service_instance", "=", "service_instance", ")", "except", "salt", ".", "exceptions", ".", "CommandExecutionError", "as", "exc", ":", "log", ".", "error", "(", "'Error: %s'", ",", "exc", ")", "if", "service_instance", ":", "__salt__", "[", "'vsphere.disconnect'", "]", "(", "service_instance", ")", "result", ".", "update", "(", "{", "'result'", ":", "False", ",", "'comment'", ":", "six", ".", "text_type", "(", "exc", ")", "}", ")", "return", "result", "if", "power_on", ":", "try", ":", "__salt__", "[", "'vsphere.power_on_vm'", "]", "(", "vm_name", ",", "datacenter", ")", "except", "salt", ".", "exceptions", ".", "VMwarePowerOnError", "as", "exc", ":", "log", ".", "error", "(", "'Error: %s'", ",", "exc", ")", "if", "service_instance", ":", "__salt__", "[", "'vsphere.disconnect'", "]", "(", "service_instance", ")", "result", ".", "update", "(", "{", "'result'", ":", "False", ",", "'comment'", ":", "six", ".", "text_type", "(", "exc", ")", "}", ")", "return", "result", "changes", ".", "update", "(", "{", "'power_on'", ":", "True", "}", ")", "__salt__", "[", "'vsphere.disconnect'", "]", "(", "service_instance", ")", "result", "=", "{", "'name'", ":", "name", ",", "'result'", ":", "True", ",", "'changes'", ":", "changes", ",", "'comment'", ":", "'Virtual machine '", "'{0} was updated successfully'", ".", "format", "(", "vm_name", ")", "}", "return", "result"], "docstring": "Updates a virtual machine configuration if there is a difference between\n    the given and deployed configuration.", "docstring_tokens": ["Updates", "a", "virtual", "machine", "configuration", "if", "there", "is", "a", "difference", "between", "the", "given", "and", "deployed", "configuration", "."], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/states/esxvm.py#L328-L421", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/states/esxvm.py", "func_name": "vm_created", "original_string": "def vm_created(name, vm_name, cpu, memory, image, version, interfaces,\n               disks, scsi_devices, serial_ports, datacenter, datastore,\n               placement, ide_controllers=None, sata_controllers=None,\n               cd_dvd_drives=None, advanced_configs=None, power_on=False):\n    '''\n    Creates a virtual machine with the given properties if it doesn't exist.\n    '''\n    result = {'name': name,\n              'result': None,\n              'changes': {},\n              'comment': ''}\n\n    if __opts__['test']:\n        result['comment'] = 'Virtual machine {0} will be created'.format(\n                vm_name)\n        return result\n\n    service_instance = __salt__['vsphere.get_service_instance_via_proxy']()\n    try:\n        info = __salt__['vsphere.create_vm'](vm_name, cpu, memory, image,\n                                             version, datacenter, datastore,\n                                             placement, interfaces, disks,\n                                             scsi_devices,\n                                             serial_ports=serial_ports,\n                                             ide_controllers=ide_controllers,\n                                             sata_controllers=sata_controllers,\n                                             cd_drives=cd_dvd_drives,\n                                             advanced_configs=advanced_configs,\n                                             service_instance=service_instance)\n    except salt.exceptions.CommandExecutionError as exc:\n        log.error('Error: %s', exc)\n        if service_instance:\n            __salt__['vsphere.disconnect'](service_instance)\n        result.update({\n            'result': False,\n            'comment': six.text_type(exc)})\n        return result\n\n    if power_on:\n        try:\n            __salt__['vsphere.power_on_vm'](vm_name, datacenter,\n                                            service_instance=service_instance)\n        except salt.exceptions.VMwarePowerOnError as exc:\n            log.error('Error: %s', exc)\n            if service_instance:\n                __salt__['vsphere.disconnect'](service_instance)\n            result.update({\n                'result': False,\n                'comment': six.text_type(exc)})\n            return result\n        info['power_on'] = power_on\n\n    changes = {'name': vm_name, 'info': info}\n    __salt__['vsphere.disconnect'](service_instance)\n    result = {'name': name,\n              'result': True,\n              'changes': changes,\n              'comment': 'Virtual machine '\n                         '{0} created successfully'.format(vm_name)}\n\n    return result", "language": "python", "code": "def vm_created(name, vm_name, cpu, memory, image, version, interfaces,\n               disks, scsi_devices, serial_ports, datacenter, datastore,\n               placement, ide_controllers=None, sata_controllers=None,\n               cd_dvd_drives=None, advanced_configs=None, power_on=False):\n    '''\n    Creates a virtual machine with the given properties if it doesn't exist.\n    '''\n    result = {'name': name,\n              'result': None,\n              'changes': {},\n              'comment': ''}\n\n    if __opts__['test']:\n        result['comment'] = 'Virtual machine {0} will be created'.format(\n                vm_name)\n        return result\n\n    service_instance = __salt__['vsphere.get_service_instance_via_proxy']()\n    try:\n        info = __salt__['vsphere.create_vm'](vm_name, cpu, memory, image,\n                                             version, datacenter, datastore,\n                                             placement, interfaces, disks,\n                                             scsi_devices,\n                                             serial_ports=serial_ports,\n                                             ide_controllers=ide_controllers,\n                                             sata_controllers=sata_controllers,\n                                             cd_drives=cd_dvd_drives,\n                                             advanced_configs=advanced_configs,\n                                             service_instance=service_instance)\n    except salt.exceptions.CommandExecutionError as exc:\n        log.error('Error: %s', exc)\n        if service_instance:\n            __salt__['vsphere.disconnect'](service_instance)\n        result.update({\n            'result': False,\n            'comment': six.text_type(exc)})\n        return result\n\n    if power_on:\n        try:\n            __salt__['vsphere.power_on_vm'](vm_name, datacenter,\n                                            service_instance=service_instance)\n        except salt.exceptions.VMwarePowerOnError as exc:\n            log.error('Error: %s', exc)\n            if service_instance:\n                __salt__['vsphere.disconnect'](service_instance)\n            result.update({\n                'result': False,\n                'comment': six.text_type(exc)})\n            return result\n        info['power_on'] = power_on\n\n    changes = {'name': vm_name, 'info': info}\n    __salt__['vsphere.disconnect'](service_instance)\n    result = {'name': name,\n              'result': True,\n              'changes': changes,\n              'comment': 'Virtual machine '\n                         '{0} created successfully'.format(vm_name)}\n\n    return result", "code_tokens": ["def", "vm_created", "(", "name", ",", "vm_name", ",", "cpu", ",", "memory", ",", "image", ",", "version", ",", "interfaces", ",", "disks", ",", "scsi_devices", ",", "serial_ports", ",", "datacenter", ",", "datastore", ",", "placement", ",", "ide_controllers", "=", "None", ",", "sata_controllers", "=", "None", ",", "cd_dvd_drives", "=", "None", ",", "advanced_configs", "=", "None", ",", "power_on", "=", "False", ")", ":", "result", "=", "{", "'name'", ":", "name", ",", "'result'", ":", "None", ",", "'changes'", ":", "{", "}", ",", "'comment'", ":", "''", "}", "if", "__opts__", "[", "'test'", "]", ":", "result", "[", "'comment'", "]", "=", "'Virtual machine {0} will be created'", ".", "format", "(", "vm_name", ")", "return", "result", "service_instance", "=", "__salt__", "[", "'vsphere.get_service_instance_via_proxy'", "]", "(", ")", "try", ":", "info", "=", "__salt__", "[", "'vsphere.create_vm'", "]", "(", "vm_name", ",", "cpu", ",", "memory", ",", "image", ",", "version", ",", "datacenter", ",", "datastore", ",", "placement", ",", "interfaces", ",", "disks", ",", "scsi_devices", ",", "serial_ports", "=", "serial_ports", ",", "ide_controllers", "=", "ide_controllers", ",", "sata_controllers", "=", "sata_controllers", ",", "cd_drives", "=", "cd_dvd_drives", ",", "advanced_configs", "=", "advanced_configs", ",", "service_instance", "=", "service_instance", ")", "except", "salt", ".", "exceptions", ".", "CommandExecutionError", "as", "exc", ":", "log", ".", "error", "(", "'Error: %s'", ",", "exc", ")", "if", "service_instance", ":", "__salt__", "[", "'vsphere.disconnect'", "]", "(", "service_instance", ")", "result", ".", "update", "(", "{", "'result'", ":", "False", ",", "'comment'", ":", "six", ".", "text_type", "(", "exc", ")", "}", ")", "return", "result", "if", "power_on", ":", "try", ":", "__salt__", "[", "'vsphere.power_on_vm'", "]", "(", "vm_name", ",", "datacenter", ",", "service_instance", "=", "service_instance", ")", "except", "salt", ".", "exceptions", ".", "VMwarePowerOnError", "as", "exc", ":", "log", ".", "error", "(", "'Error: %s'", ",", "exc", ")", "if", "service_instance", ":", "__salt__", "[", "'vsphere.disconnect'", "]", "(", "service_instance", ")", "result", ".", "update", "(", "{", "'result'", ":", "False", ",", "'comment'", ":", "six", ".", "text_type", "(", "exc", ")", "}", ")", "return", "result", "info", "[", "'power_on'", "]", "=", "power_on", "changes", "=", "{", "'name'", ":", "vm_name", ",", "'info'", ":", "info", "}", "__salt__", "[", "'vsphere.disconnect'", "]", "(", "service_instance", ")", "result", "=", "{", "'name'", ":", "name", ",", "'result'", ":", "True", ",", "'changes'", ":", "changes", ",", "'comment'", ":", "'Virtual machine '", "'{0} created successfully'", ".", "format", "(", "vm_name", ")", "}", "return", "result"], "docstring": "Creates a virtual machine with the given properties if it doesn't exist.", "docstring_tokens": ["Creates", "a", "virtual", "machine", "with", "the", "given", "properties", "if", "it", "doesn", "t", "exist", "."], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/states/esxvm.py#L424-L484", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/states/esxvm.py", "func_name": "vm_registered", "original_string": "def vm_registered(vm_name, datacenter, placement, vm_file, power_on=False):\n    '''\n    Registers a virtual machine if the machine files are available on\n    the main datastore.\n    '''\n    result = {'name': vm_name,\n              'result': None,\n              'changes': {},\n              'comment': ''}\n\n    vmx_path = '{0}{1}'.format(vm_file.folderPath, vm_file.file[0].path)\n    log.trace('Registering virtual machine with vmx file: %s', vmx_path)\n    service_instance = __salt__['vsphere.get_service_instance_via_proxy']()\n    try:\n        __salt__['vsphere.register_vm'](vm_name, datacenter,\n                                        placement, vmx_path,\n                                        service_instance=service_instance)\n    except salt.exceptions.VMwareMultipleObjectsError as exc:\n        log.error('Error: %s', exc)\n        if service_instance:\n            __salt__['vsphere.disconnect'](service_instance)\n        result.update({'result': False,\n                       'comment': six.text_type(exc)})\n        return result\n    except salt.exceptions.VMwareVmRegisterError as exc:\n        log.error('Error: %s', exc)\n        if service_instance:\n            __salt__['vsphere.disconnect'](service_instance)\n        result.update({'result': False,\n                       'comment': six.text_type(exc)})\n        return result\n\n    if power_on:\n        try:\n            __salt__['vsphere.power_on_vm'](vm_name, datacenter,\n                                            service_instance=service_instance)\n        except salt.exceptions.VMwarePowerOnError as exc:\n            log.error('Error: %s', exc)\n            if service_instance:\n                __salt__['vsphere.disconnect'](service_instance)\n            result.update({\n                'result': False,\n                'comment': six.text_type(exc)})\n            return result\n    __salt__['vsphere.disconnect'](service_instance)\n    result.update({'result': True,\n                   'changes': {'name': vm_name, 'power_on': power_on},\n                   'comment': 'Virtual machine '\n                              '{0} registered successfully'.format(vm_name)})\n\n    return result", "language": "python", "code": "def vm_registered(vm_name, datacenter, placement, vm_file, power_on=False):\n    '''\n    Registers a virtual machine if the machine files are available on\n    the main datastore.\n    '''\n    result = {'name': vm_name,\n              'result': None,\n              'changes': {},\n              'comment': ''}\n\n    vmx_path = '{0}{1}'.format(vm_file.folderPath, vm_file.file[0].path)\n    log.trace('Registering virtual machine with vmx file: %s', vmx_path)\n    service_instance = __salt__['vsphere.get_service_instance_via_proxy']()\n    try:\n        __salt__['vsphere.register_vm'](vm_name, datacenter,\n                                        placement, vmx_path,\n                                        service_instance=service_instance)\n    except salt.exceptions.VMwareMultipleObjectsError as exc:\n        log.error('Error: %s', exc)\n        if service_instance:\n            __salt__['vsphere.disconnect'](service_instance)\n        result.update({'result': False,\n                       'comment': six.text_type(exc)})\n        return result\n    except salt.exceptions.VMwareVmRegisterError as exc:\n        log.error('Error: %s', exc)\n        if service_instance:\n            __salt__['vsphere.disconnect'](service_instance)\n        result.update({'result': False,\n                       'comment': six.text_type(exc)})\n        return result\n\n    if power_on:\n        try:\n            __salt__['vsphere.power_on_vm'](vm_name, datacenter,\n                                            service_instance=service_instance)\n        except salt.exceptions.VMwarePowerOnError as exc:\n            log.error('Error: %s', exc)\n            if service_instance:\n                __salt__['vsphere.disconnect'](service_instance)\n            result.update({\n                'result': False,\n                'comment': six.text_type(exc)})\n            return result\n    __salt__['vsphere.disconnect'](service_instance)\n    result.update({'result': True,\n                   'changes': {'name': vm_name, 'power_on': power_on},\n                   'comment': 'Virtual machine '\n                              '{0} registered successfully'.format(vm_name)})\n\n    return result", "code_tokens": ["def", "vm_registered", "(", "vm_name", ",", "datacenter", ",", "placement", ",", "vm_file", ",", "power_on", "=", "False", ")", ":", "result", "=", "{", "'name'", ":", "vm_name", ",", "'result'", ":", "None", ",", "'changes'", ":", "{", "}", ",", "'comment'", ":", "''", "}", "vmx_path", "=", "'{0}{1}'", ".", "format", "(", "vm_file", ".", "folderPath", ",", "vm_file", ".", "file", "[", "0", "]", ".", "path", ")", "log", ".", "trace", "(", "'Registering virtual machine with vmx file: %s'", ",", "vmx_path", ")", "service_instance", "=", "__salt__", "[", "'vsphere.get_service_instance_via_proxy'", "]", "(", ")", "try", ":", "__salt__", "[", "'vsphere.register_vm'", "]", "(", "vm_name", ",", "datacenter", ",", "placement", ",", "vmx_path", ",", "service_instance", "=", "service_instance", ")", "except", "salt", ".", "exceptions", ".", "VMwareMultipleObjectsError", "as", "exc", ":", "log", ".", "error", "(", "'Error: %s'", ",", "exc", ")", "if", "service_instance", ":", "__salt__", "[", "'vsphere.disconnect'", "]", "(", "service_instance", ")", "result", ".", "update", "(", "{", "'result'", ":", "False", ",", "'comment'", ":", "six", ".", "text_type", "(", "exc", ")", "}", ")", "return", "result", "except", "salt", ".", "exceptions", ".", "VMwareVmRegisterError", "as", "exc", ":", "log", ".", "error", "(", "'Error: %s'", ",", "exc", ")", "if", "service_instance", ":", "__salt__", "[", "'vsphere.disconnect'", "]", "(", "service_instance", ")", "result", ".", "update", "(", "{", "'result'", ":", "False", ",", "'comment'", ":", "six", ".", "text_type", "(", "exc", ")", "}", ")", "return", "result", "if", "power_on", ":", "try", ":", "__salt__", "[", "'vsphere.power_on_vm'", "]", "(", "vm_name", ",", "datacenter", ",", "service_instance", "=", "service_instance", ")", "except", "salt", ".", "exceptions", ".", "VMwarePowerOnError", "as", "exc", ":", "log", ".", "error", "(", "'Error: %s'", ",", "exc", ")", "if", "service_instance", ":", "__salt__", "[", "'vsphere.disconnect'", "]", "(", "service_instance", ")", "result", ".", "update", "(", "{", "'result'", ":", "False", ",", "'comment'", ":", "six", ".", "text_type", "(", "exc", ")", "}", ")", "return", "result", "__salt__", "[", "'vsphere.disconnect'", "]", "(", "service_instance", ")", "result", ".", "update", "(", "{", "'result'", ":", "True", ",", "'changes'", ":", "{", "'name'", ":", "vm_name", ",", "'power_on'", ":", "power_on", "}", ",", "'comment'", ":", "'Virtual machine '", "'{0} registered successfully'", ".", "format", "(", "vm_name", ")", "}", ")", "return", "result"], "docstring": "Registers a virtual machine if the machine files are available on\n    the main datastore.", "docstring_tokens": ["Registers", "a", "virtual", "machine", "if", "the", "machine", "files", "are", "available", "on", "the", "main", "datastore", "."], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/states/esxvm.py#L487-L537", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/states/npm.py", "func_name": "installed", "original_string": "def installed(name,\n              pkgs=None,\n              dir=None,\n              user=None,\n              force_reinstall=False,\n              registry=None,\n              env=None):\n    '''\n    Verify that the given package is installed and is at the correct version\n    (if specified).\n\n    .. code-block:: yaml\n\n        coffee-script:\n          npm.installed:\n            - user: someuser\n\n        coffee-script@1.0.1:\n          npm.installed: []\n\n    name\n        The package to install\n\n        .. versionchanged:: 2014.7.2\n            This parameter is no longer lowercased by salt so that\n            case-sensitive NPM package names will work.\n\n    pkgs\n        A list of packages to install with a single npm invocation; specifying\n        this argument will ignore the ``name`` argument\n\n        .. versionadded:: 2014.7.0\n\n    dir\n        The target directory in which to install the package, or None for\n        global installation\n\n    user\n        The user to run NPM with\n\n        .. versionadded:: 0.17.0\n\n    registry\n        The NPM registry from which to install the package\n\n        .. versionadded:: 2014.7.0\n\n    env\n        A list of environment variables to be set prior to execution. The\n        format is the same as the :py:func:`cmd.run <salt.states.cmd.run>`.\n        state function.\n\n        .. versionadded:: 2014.7.0\n\n    force_reinstall\n        Install the package even if it is already installed\n    '''\n    ret = {'name': name, 'result': None, 'comment': '', 'changes': {}}\n\n    pkg_list = pkgs if pkgs else [name]\n\n    try:\n        installed_pkgs = __salt__['npm.list'](dir=dir, runas=user, env=env, depth=0)\n    except (CommandNotFoundError, CommandExecutionError) as err:\n        ret['result'] = False\n        ret['comment'] = 'Error looking up \\'{0}\\': {1}'.format(name, err)\n        return ret\n    else:\n        installed_pkgs = dict((p, info)\n                for p, info in six.iteritems(installed_pkgs))\n\n    pkgs_satisfied = []\n    pkgs_to_install = []\n\n    def _pkg_is_installed(pkg, installed_pkgs):\n        '''\n        Helper function to determine if a package is installed\n\n        This performs more complex comparison than just checking\n        keys, such as examining source repos to see if the package\n        was installed by a different name from the same repo\n\n        :pkg str: The package to compare\n        :installed_pkgs: A dictionary produced by npm list --json\n        '''\n        if (pkg_name in installed_pkgs and\n            'version' in installed_pkgs[pkg_name]):\n            return True\n        # Check to see if we are trying to install from a URI\n        elif '://' in pkg_name:  # TODO Better way?\n            for pkg_details in installed_pkgs.values():\n                try:\n                    pkg_from = pkg_details.get('from', '').split('://')[1]\n                    # Catch condition where we may have specified package as\n                    # git://github.com/foo/bar but packager describes it as\n                    # git://github.com/foo/bar.git in the package\n                    if not pkg_from.endswith('.git') and pkg_name.startswith('git://'):\n                        pkg_from += '.git'\n                    if pkg_name.split('://')[1] == pkg_from:\n                        return True\n                except IndexError:\n                    pass\n        return False\n    for pkg in pkg_list:\n        # Valid:\n        #\n        # @google-cloud/bigquery@^0.9.6\n        # @foobar\n        # buffer-equal-constant-time@1.0.1\n        # coffee-script\n        matches = re.search(r'^(@?[^@\\s]+)(?:@(\\S+))?', pkg)\n        pkg_name, pkg_ver = matches.group(1), matches.group(2) or None\n\n        if force_reinstall is True:\n            pkgs_to_install.append(pkg)\n            continue\n        if not _pkg_is_installed(pkg, installed_pkgs):\n            pkgs_to_install.append(pkg)\n            continue\n\n        installed_name_ver = '{0}@{1}'.format(pkg_name,\n                installed_pkgs[pkg_name]['version'])\n\n        # If given an explicit version check the installed version matches.\n        if pkg_ver:\n            if installed_pkgs[pkg_name].get('version') != pkg_ver:\n                pkgs_to_install.append(pkg)\n            else:\n                pkgs_satisfied.append(installed_name_ver)\n\n            continue\n        else:\n            pkgs_satisfied.append(installed_name_ver)\n            continue\n\n    if __opts__['test']:\n        ret['result'] = None\n\n        comment_msg = []\n        if pkgs_to_install:\n            comment_msg.append('NPM package(s) \\'{0}\\' are set to be installed'\n                .format(', '.join(pkgs_to_install)))\n\n            ret['changes'] = {'old': [], 'new': pkgs_to_install}\n\n        if pkgs_satisfied:\n            comment_msg.append('Package(s) \\'{0}\\' satisfied by {1}'\n                .format(', '.join(pkg_list), ', '.join(pkgs_satisfied)))\n            ret['result'] = True\n\n        ret['comment'] = '. '.join(comment_msg)\n        return ret\n\n    if not pkgs_to_install:\n        ret['result'] = True\n        ret['comment'] = ('Package(s) \\'{0}\\' satisfied by {1}'\n                .format(', '.join(pkg_list), ', '.join(pkgs_satisfied)))\n        return ret\n\n    try:\n        cmd_args = {\n            'dir': dir,\n            'runas': user,\n            'registry': registry,\n            'env': env,\n            'pkgs': pkg_list,\n        }\n\n        call = __salt__['npm.install'](**cmd_args)\n    except (CommandNotFoundError, CommandExecutionError) as err:\n        ret['result'] = False\n        ret['comment'] = 'Error installing \\'{0}\\': {1}'.format(\n                ', '.join(pkg_list), err)\n        return ret\n\n    if call and (isinstance(call, list) or isinstance(call, dict)):\n        ret['result'] = True\n        ret['changes'] = {'old': [], 'new': pkgs_to_install}\n        ret['comment'] = 'Package(s) \\'{0}\\' successfully installed'.format(\n                ', '.join(pkgs_to_install))\n    else:\n        ret['result'] = False\n        ret['comment'] = 'Could not install package(s) \\'{0}\\''.format(\n                ', '.join(pkg_list))\n\n    return ret", "language": "python", "code": "def installed(name,\n              pkgs=None,\n              dir=None,\n              user=None,\n              force_reinstall=False,\n              registry=None,\n              env=None):\n    '''\n    Verify that the given package is installed and is at the correct version\n    (if specified).\n\n    .. code-block:: yaml\n\n        coffee-script:\n          npm.installed:\n            - user: someuser\n\n        coffee-script@1.0.1:\n          npm.installed: []\n\n    name\n        The package to install\n\n        .. versionchanged:: 2014.7.2\n            This parameter is no longer lowercased by salt so that\n            case-sensitive NPM package names will work.\n\n    pkgs\n        A list of packages to install with a single npm invocation; specifying\n        this argument will ignore the ``name`` argument\n\n        .. versionadded:: 2014.7.0\n\n    dir\n        The target directory in which to install the package, or None for\n        global installation\n\n    user\n        The user to run NPM with\n\n        .. versionadded:: 0.17.0\n\n    registry\n        The NPM registry from which to install the package\n\n        .. versionadded:: 2014.7.0\n\n    env\n        A list of environment variables to be set prior to execution. The\n        format is the same as the :py:func:`cmd.run <salt.states.cmd.run>`.\n        state function.\n\n        .. versionadded:: 2014.7.0\n\n    force_reinstall\n        Install the package even if it is already installed\n    '''\n    ret = {'name': name, 'result': None, 'comment': '', 'changes': {}}\n\n    pkg_list = pkgs if pkgs else [name]\n\n    try:\n        installed_pkgs = __salt__['npm.list'](dir=dir, runas=user, env=env, depth=0)\n    except (CommandNotFoundError, CommandExecutionError) as err:\n        ret['result'] = False\n        ret['comment'] = 'Error looking up \\'{0}\\': {1}'.format(name, err)\n        return ret\n    else:\n        installed_pkgs = dict((p, info)\n                for p, info in six.iteritems(installed_pkgs))\n\n    pkgs_satisfied = []\n    pkgs_to_install = []\n\n    def _pkg_is_installed(pkg, installed_pkgs):\n        '''\n        Helper function to determine if a package is installed\n\n        This performs more complex comparison than just checking\n        keys, such as examining source repos to see if the package\n        was installed by a different name from the same repo\n\n        :pkg str: The package to compare\n        :installed_pkgs: A dictionary produced by npm list --json\n        '''\n        if (pkg_name in installed_pkgs and\n            'version' in installed_pkgs[pkg_name]):\n            return True\n        # Check to see if we are trying to install from a URI\n        elif '://' in pkg_name:  # TODO Better way?\n            for pkg_details in installed_pkgs.values():\n                try:\n                    pkg_from = pkg_details.get('from', '').split('://')[1]\n                    # Catch condition where we may have specified package as\n                    # git://github.com/foo/bar but packager describes it as\n                    # git://github.com/foo/bar.git in the package\n                    if not pkg_from.endswith('.git') and pkg_name.startswith('git://'):\n                        pkg_from += '.git'\n                    if pkg_name.split('://')[1] == pkg_from:\n                        return True\n                except IndexError:\n                    pass\n        return False\n    for pkg in pkg_list:\n        # Valid:\n        #\n        # @google-cloud/bigquery@^0.9.6\n        # @foobar\n        # buffer-equal-constant-time@1.0.1\n        # coffee-script\n        matches = re.search(r'^(@?[^@\\s]+)(?:@(\\S+))?', pkg)\n        pkg_name, pkg_ver = matches.group(1), matches.group(2) or None\n\n        if force_reinstall is True:\n            pkgs_to_install.append(pkg)\n            continue\n        if not _pkg_is_installed(pkg, installed_pkgs):\n            pkgs_to_install.append(pkg)\n            continue\n\n        installed_name_ver = '{0}@{1}'.format(pkg_name,\n                installed_pkgs[pkg_name]['version'])\n\n        # If given an explicit version check the installed version matches.\n        if pkg_ver:\n            if installed_pkgs[pkg_name].get('version') != pkg_ver:\n                pkgs_to_install.append(pkg)\n            else:\n                pkgs_satisfied.append(installed_name_ver)\n\n            continue\n        else:\n            pkgs_satisfied.append(installed_name_ver)\n            continue\n\n    if __opts__['test']:\n        ret['result'] = None\n\n        comment_msg = []\n        if pkgs_to_install:\n            comment_msg.append('NPM package(s) \\'{0}\\' are set to be installed'\n                .format(', '.join(pkgs_to_install)))\n\n            ret['changes'] = {'old': [], 'new': pkgs_to_install}\n\n        if pkgs_satisfied:\n            comment_msg.append('Package(s) \\'{0}\\' satisfied by {1}'\n                .format(', '.join(pkg_list), ', '.join(pkgs_satisfied)))\n            ret['result'] = True\n\n        ret['comment'] = '. '.join(comment_msg)\n        return ret\n\n    if not pkgs_to_install:\n        ret['result'] = True\n        ret['comment'] = ('Package(s) \\'{0}\\' satisfied by {1}'\n                .format(', '.join(pkg_list), ', '.join(pkgs_satisfied)))\n        return ret\n\n    try:\n        cmd_args = {\n            'dir': dir,\n            'runas': user,\n            'registry': registry,\n            'env': env,\n            'pkgs': pkg_list,\n        }\n\n        call = __salt__['npm.install'](**cmd_args)\n    except (CommandNotFoundError, CommandExecutionError) as err:\n        ret['result'] = False\n        ret['comment'] = 'Error installing \\'{0}\\': {1}'.format(\n                ', '.join(pkg_list), err)\n        return ret\n\n    if call and (isinstance(call, list) or isinstance(call, dict)):\n        ret['result'] = True\n        ret['changes'] = {'old': [], 'new': pkgs_to_install}\n        ret['comment'] = 'Package(s) \\'{0}\\' successfully installed'.format(\n                ', '.join(pkgs_to_install))\n    else:\n        ret['result'] = False\n        ret['comment'] = 'Could not install package(s) \\'{0}\\''.format(\n                ', '.join(pkg_list))\n\n    return ret", "code_tokens": ["def", "installed", "(", "name", ",", "pkgs", "=", "None", ",", "dir", "=", "None", ",", "user", "=", "None", ",", "force_reinstall", "=", "False", ",", "registry", "=", "None", ",", "env", "=", "None", ")", ":", "ret", "=", "{", "'name'", ":", "name", ",", "'result'", ":", "None", ",", "'comment'", ":", "''", ",", "'changes'", ":", "{", "}", "}", "pkg_list", "=", "pkgs", "if", "pkgs", "else", "[", "name", "]", "try", ":", "installed_pkgs", "=", "__salt__", "[", "'npm.list'", "]", "(", "dir", "=", "dir", ",", "runas", "=", "user", ",", "env", "=", "env", ",", "depth", "=", "0", ")", "except", "(", "CommandNotFoundError", ",", "CommandExecutionError", ")", "as", "err", ":", "ret", "[", "'result'", "]", "=", "False", "ret", "[", "'comment'", "]", "=", "'Error looking up \\'{0}\\': {1}'", ".", "format", "(", "name", ",", "err", ")", "return", "ret", "else", ":", "installed_pkgs", "=", "dict", "(", "(", "p", ",", "info", ")", "for", "p", ",", "info", "in", "six", ".", "iteritems", "(", "installed_pkgs", ")", ")", "pkgs_satisfied", "=", "[", "]", "pkgs_to_install", "=", "[", "]", "def", "_pkg_is_installed", "(", "pkg", ",", "installed_pkgs", ")", ":", "'''\n        Helper function to determine if a package is installed\n\n        This performs more complex comparison than just checking\n        keys, such as examining source repos to see if the package\n        was installed by a different name from the same repo\n\n        :pkg str: The package to compare\n        :installed_pkgs: A dictionary produced by npm list --json\n        '''", "if", "(", "pkg_name", "in", "installed_pkgs", "and", "'version'", "in", "installed_pkgs", "[", "pkg_name", "]", ")", ":", "return", "True", "# Check to see if we are trying to install from a URI", "elif", "'://'", "in", "pkg_name", ":", "# TODO Better way?", "for", "pkg_details", "in", "installed_pkgs", ".", "values", "(", ")", ":", "try", ":", "pkg_from", "=", "pkg_details", ".", "get", "(", "'from'", ",", "''", ")", ".", "split", "(", "'://'", ")", "[", "1", "]", "# Catch condition where we may have specified package as", "# git://github.com/foo/bar but packager describes it as", "# git://github.com/foo/bar.git in the package", "if", "not", "pkg_from", ".", "endswith", "(", "'.git'", ")", "and", "pkg_name", ".", "startswith", "(", "'git://'", ")", ":", "pkg_from", "+=", "'.git'", "if", "pkg_name", ".", "split", "(", "'://'", ")", "[", "1", "]", "==", "pkg_from", ":", "return", "True", "except", "IndexError", ":", "pass", "return", "False", "for", "pkg", "in", "pkg_list", ":", "# Valid:", "#", "# @google-cloud/bigquery@^0.9.6", "# @foobar", "# buffer-equal-constant-time@1.0.1", "# coffee-script", "matches", "=", "re", ".", "search", "(", "r'^(@?[^@\\s]+)(?:@(\\S+))?'", ",", "pkg", ")", "pkg_name", ",", "pkg_ver", "=", "matches", ".", "group", "(", "1", ")", ",", "matches", ".", "group", "(", "2", ")", "or", "None", "if", "force_reinstall", "is", "True", ":", "pkgs_to_install", ".", "append", "(", "pkg", ")", "continue", "if", "not", "_pkg_is_installed", "(", "pkg", ",", "installed_pkgs", ")", ":", "pkgs_to_install", ".", "append", "(", "pkg", ")", "continue", "installed_name_ver", "=", "'{0}@{1}'", ".", "format", "(", "pkg_name", ",", "installed_pkgs", "[", "pkg_name", "]", "[", "'version'", "]", ")", "# If given an explicit version check the installed version matches.", "if", "pkg_ver", ":", "if", "installed_pkgs", "[", "pkg_name", "]", ".", "get", "(", "'version'", ")", "!=", "pkg_ver", ":", "pkgs_to_install", ".", "append", "(", "pkg", ")", "else", ":", "pkgs_satisfied", ".", "append", "(", "installed_name_ver", ")", "continue", "else", ":", "pkgs_satisfied", ".", "append", "(", "installed_name_ver", ")", "continue", "if", "__opts__", "[", "'test'", "]", ":", "ret", "[", "'result'", "]", "=", "None", "comment_msg", "=", "[", "]", "if", "pkgs_to_install", ":", "comment_msg", ".", "append", "(", "'NPM package(s) \\'{0}\\' are set to be installed'", ".", "format", "(", "', '", ".", "join", "(", "pkgs_to_install", ")", ")", ")", "ret", "[", "'changes'", "]", "=", "{", "'old'", ":", "[", "]", ",", "'new'", ":", "pkgs_to_install", "}", "if", "pkgs_satisfied", ":", "comment_msg", ".", "append", "(", "'Package(s) \\'{0}\\' satisfied by {1}'", ".", "format", "(", "', '", ".", "join", "(", "pkg_list", ")", ",", "', '", ".", "join", "(", "pkgs_satisfied", ")", ")", ")", "ret", "[", "'result'", "]", "=", "True", "ret", "[", "'comment'", "]", "=", "'. '", ".", "join", "(", "comment_msg", ")", "return", "ret", "if", "not", "pkgs_to_install", ":", "ret", "[", "'result'", "]", "=", "True", "ret", "[", "'comment'", "]", "=", "(", "'Package(s) \\'{0}\\' satisfied by {1}'", ".", "format", "(", "', '", ".", "join", "(", "pkg_list", ")", ",", "', '", ".", "join", "(", "pkgs_satisfied", ")", ")", ")", "return", "ret", "try", ":", "cmd_args", "=", "{", "'dir'", ":", "dir", ",", "'runas'", ":", "user", ",", "'registry'", ":", "registry", ",", "'env'", ":", "env", ",", "'pkgs'", ":", "pkg_list", ",", "}", "call", "=", "__salt__", "[", "'npm.install'", "]", "(", "*", "*", "cmd_args", ")", "except", "(", "CommandNotFoundError", ",", "CommandExecutionError", ")", "as", "err", ":", "ret", "[", "'result'", "]", "=", "False", "ret", "[", "'comment'", "]", "=", "'Error installing \\'{0}\\': {1}'", ".", "format", "(", "', '", ".", "join", "(", "pkg_list", ")", ",", "err", ")", "return", "ret", "if", "call", "and", "(", "isinstance", "(", "call", ",", "list", ")", "or", "isinstance", "(", "call", ",", "dict", ")", ")", ":", "ret", "[", "'result'", "]", "=", "True", "ret", "[", "'changes'", "]", "=", "{", "'old'", ":", "[", "]", ",", "'new'", ":", "pkgs_to_install", "}", "ret", "[", "'comment'", "]", "=", "'Package(s) \\'{0}\\' successfully installed'", ".", "format", "(", "', '", ".", "join", "(", "pkgs_to_install", ")", ")", "else", ":", "ret", "[", "'result'", "]", "=", "False", "ret", "[", "'comment'", "]", "=", "'Could not install package(s) \\'{0}\\''", ".", "format", "(", "', '", ".", "join", "(", "pkg_list", ")", ")", "return", "ret"], "docstring": "Verify that the given package is installed and is at the correct version\n    (if specified).\n\n    .. code-block:: yaml\n\n        coffee-script:\n          npm.installed:\n            - user: someuser\n\n        coffee-script@1.0.1:\n          npm.installed: []\n\n    name\n        The package to install\n\n        .. versionchanged:: 2014.7.2\n            This parameter is no longer lowercased by salt so that\n            case-sensitive NPM package names will work.\n\n    pkgs\n        A list of packages to install with a single npm invocation; specifying\n        this argument will ignore the ``name`` argument\n\n        .. versionadded:: 2014.7.0\n\n    dir\n        The target directory in which to install the package, or None for\n        global installation\n\n    user\n        The user to run NPM with\n\n        .. versionadded:: 0.17.0\n\n    registry\n        The NPM registry from which to install the package\n\n        .. versionadded:: 2014.7.0\n\n    env\n        A list of environment variables to be set prior to execution. The\n        format is the same as the :py:func:`cmd.run <salt.states.cmd.run>`.\n        state function.\n\n        .. versionadded:: 2014.7.0\n\n    force_reinstall\n        Install the package even if it is already installed", "docstring_tokens": ["Verify", "that", "the", "given", "package", "is", "installed", "and", "is", "at", "the", "correct", "version", "(", "if", "specified", ")", "."], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/states/npm.py#L38-L223", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/states/npm.py", "func_name": "removed", "original_string": "def removed(name, dir=None, user=None):\n    '''\n    Verify that the given package is not installed.\n\n    dir\n        The target directory in which to install the package, or None for\n        global installation\n\n    user\n        The user to run NPM with\n\n        .. versionadded:: 0.17.0\n    '''\n    ret = {'name': name, 'result': None, 'comment': '', 'changes': {}}\n\n    try:\n        installed_pkgs = __salt__['npm.list'](dir=dir, depth=0)\n    except (CommandExecutionError, CommandNotFoundError) as err:\n        ret['result'] = False\n        ret['comment'] = 'Error uninstalling \\'{0}\\': {1}'.format(name, err)\n        return ret\n\n    if name not in installed_pkgs:\n        ret['result'] = True\n        ret['comment'] = 'Package \\'{0}\\' is not installed'.format(name)\n        return ret\n\n    if __opts__['test']:\n        ret['result'] = None\n        ret['comment'] = 'Package \\'{0}\\' is set to be removed'.format(name)\n        return ret\n\n    if __salt__['npm.uninstall'](pkg=name, dir=dir, runas=user):\n        ret['result'] = True\n        ret['changes'][name] = 'Removed'\n        ret['comment'] = 'Package \\'{0}\\' was successfully removed'.format(name)\n    else:\n        ret['result'] = False\n        ret['comment'] = 'Error removing package \\'{0}\\''.format(name)\n\n    return ret", "language": "python", "code": "def removed(name, dir=None, user=None):\n    '''\n    Verify that the given package is not installed.\n\n    dir\n        The target directory in which to install the package, or None for\n        global installation\n\n    user\n        The user to run NPM with\n\n        .. versionadded:: 0.17.0\n    '''\n    ret = {'name': name, 'result': None, 'comment': '', 'changes': {}}\n\n    try:\n        installed_pkgs = __salt__['npm.list'](dir=dir, depth=0)\n    except (CommandExecutionError, CommandNotFoundError) as err:\n        ret['result'] = False\n        ret['comment'] = 'Error uninstalling \\'{0}\\': {1}'.format(name, err)\n        return ret\n\n    if name not in installed_pkgs:\n        ret['result'] = True\n        ret['comment'] = 'Package \\'{0}\\' is not installed'.format(name)\n        return ret\n\n    if __opts__['test']:\n        ret['result'] = None\n        ret['comment'] = 'Package \\'{0}\\' is set to be removed'.format(name)\n        return ret\n\n    if __salt__['npm.uninstall'](pkg=name, dir=dir, runas=user):\n        ret['result'] = True\n        ret['changes'][name] = 'Removed'\n        ret['comment'] = 'Package \\'{0}\\' was successfully removed'.format(name)\n    else:\n        ret['result'] = False\n        ret['comment'] = 'Error removing package \\'{0}\\''.format(name)\n\n    return ret", "code_tokens": ["def", "removed", "(", "name", ",", "dir", "=", "None", ",", "user", "=", "None", ")", ":", "ret", "=", "{", "'name'", ":", "name", ",", "'result'", ":", "None", ",", "'comment'", ":", "''", ",", "'changes'", ":", "{", "}", "}", "try", ":", "installed_pkgs", "=", "__salt__", "[", "'npm.list'", "]", "(", "dir", "=", "dir", ",", "depth", "=", "0", ")", "except", "(", "CommandExecutionError", ",", "CommandNotFoundError", ")", "as", "err", ":", "ret", "[", "'result'", "]", "=", "False", "ret", "[", "'comment'", "]", "=", "'Error uninstalling \\'{0}\\': {1}'", ".", "format", "(", "name", ",", "err", ")", "return", "ret", "if", "name", "not", "in", "installed_pkgs", ":", "ret", "[", "'result'", "]", "=", "True", "ret", "[", "'comment'", "]", "=", "'Package \\'{0}\\' is not installed'", ".", "format", "(", "name", ")", "return", "ret", "if", "__opts__", "[", "'test'", "]", ":", "ret", "[", "'result'", "]", "=", "None", "ret", "[", "'comment'", "]", "=", "'Package \\'{0}\\' is set to be removed'", ".", "format", "(", "name", ")", "return", "ret", "if", "__salt__", "[", "'npm.uninstall'", "]", "(", "pkg", "=", "name", ",", "dir", "=", "dir", ",", "runas", "=", "user", ")", ":", "ret", "[", "'result'", "]", "=", "True", "ret", "[", "'changes'", "]", "[", "name", "]", "=", "'Removed'", "ret", "[", "'comment'", "]", "=", "'Package \\'{0}\\' was successfully removed'", ".", "format", "(", "name", ")", "else", ":", "ret", "[", "'result'", "]", "=", "False", "ret", "[", "'comment'", "]", "=", "'Error removing package \\'{0}\\''", ".", "format", "(", "name", ")", "return", "ret"], "docstring": "Verify that the given package is not installed.\n\n    dir\n        The target directory in which to install the package, or None for\n        global installation\n\n    user\n        The user to run NPM with\n\n        .. versionadded:: 0.17.0", "docstring_tokens": ["Verify", "that", "the", "given", "package", "is", "not", "installed", "."], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/states/npm.py#L226-L266", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/states/npm.py", "func_name": "bootstrap", "original_string": "def bootstrap(name, user=None, silent=True):\n    '''\n    Bootstraps a node.js application.\n\n    Will execute 'npm install --json' on the specified directory.\n\n    user\n        The user to run NPM with\n\n        .. versionadded:: 0.17.0\n    '''\n    ret = {'name': name, 'result': None, 'comment': '', 'changes': {}}\n\n    if __opts__['test']:\n        try:\n            call = __salt__['npm.install'](dir=name, runas=user, pkg=None, silent=silent, dry_run=True)\n            if call:\n                ret['result'] = None\n                ret['changes'] = {'old': [], 'new': call}\n                ret['comment'] = '{0} is set to be bootstrapped'.format(name)\n            else:\n                ret['result'] = True\n                ret['comment'] = '{0} is already bootstrapped'.format(name)\n        except (CommandNotFoundError, CommandExecutionError) as err:\n            ret['result'] = False\n            ret['comment'] = 'Error Bootstrapping \\'{0}\\': {1}'.format(name, err)\n        return ret\n\n    try:\n        call = __salt__['npm.install'](dir=name, runas=user, pkg=None, silent=silent)\n    except (CommandNotFoundError, CommandExecutionError) as err:\n        ret['result'] = False\n        ret['comment'] = 'Error Bootstrapping \\'{0}\\': {1}'.format(name, err)\n        return ret\n\n    if not call:\n        ret['result'] = True\n        ret['comment'] = 'Directory is already bootstrapped'\n        return ret\n\n    # npm.install will return a string if it can't parse a JSON result\n    if isinstance(call, six.string_types):\n        ret['result'] = False\n        ret['changes'] = call\n        ret['comment'] = 'Could not bootstrap directory'\n    else:\n        ret['result'] = True\n        ret['changes'] = {name: 'Bootstrapped'}\n        ret['comment'] = 'Directory was successfully bootstrapped'\n\n    return ret", "language": "python", "code": "def bootstrap(name, user=None, silent=True):\n    '''\n    Bootstraps a node.js application.\n\n    Will execute 'npm install --json' on the specified directory.\n\n    user\n        The user to run NPM with\n\n        .. versionadded:: 0.17.0\n    '''\n    ret = {'name': name, 'result': None, 'comment': '', 'changes': {}}\n\n    if __opts__['test']:\n        try:\n            call = __salt__['npm.install'](dir=name, runas=user, pkg=None, silent=silent, dry_run=True)\n            if call:\n                ret['result'] = None\n                ret['changes'] = {'old': [], 'new': call}\n                ret['comment'] = '{0} is set to be bootstrapped'.format(name)\n            else:\n                ret['result'] = True\n                ret['comment'] = '{0} is already bootstrapped'.format(name)\n        except (CommandNotFoundError, CommandExecutionError) as err:\n            ret['result'] = False\n            ret['comment'] = 'Error Bootstrapping \\'{0}\\': {1}'.format(name, err)\n        return ret\n\n    try:\n        call = __salt__['npm.install'](dir=name, runas=user, pkg=None, silent=silent)\n    except (CommandNotFoundError, CommandExecutionError) as err:\n        ret['result'] = False\n        ret['comment'] = 'Error Bootstrapping \\'{0}\\': {1}'.format(name, err)\n        return ret\n\n    if not call:\n        ret['result'] = True\n        ret['comment'] = 'Directory is already bootstrapped'\n        return ret\n\n    # npm.install will return a string if it can't parse a JSON result\n    if isinstance(call, six.string_types):\n        ret['result'] = False\n        ret['changes'] = call\n        ret['comment'] = 'Could not bootstrap directory'\n    else:\n        ret['result'] = True\n        ret['changes'] = {name: 'Bootstrapped'}\n        ret['comment'] = 'Directory was successfully bootstrapped'\n\n    return ret", "code_tokens": ["def", "bootstrap", "(", "name", ",", "user", "=", "None", ",", "silent", "=", "True", ")", ":", "ret", "=", "{", "'name'", ":", "name", ",", "'result'", ":", "None", ",", "'comment'", ":", "''", ",", "'changes'", ":", "{", "}", "}", "if", "__opts__", "[", "'test'", "]", ":", "try", ":", "call", "=", "__salt__", "[", "'npm.install'", "]", "(", "dir", "=", "name", ",", "runas", "=", "user", ",", "pkg", "=", "None", ",", "silent", "=", "silent", ",", "dry_run", "=", "True", ")", "if", "call", ":", "ret", "[", "'result'", "]", "=", "None", "ret", "[", "'changes'", "]", "=", "{", "'old'", ":", "[", "]", ",", "'new'", ":", "call", "}", "ret", "[", "'comment'", "]", "=", "'{0} is set to be bootstrapped'", ".", "format", "(", "name", ")", "else", ":", "ret", "[", "'result'", "]", "=", "True", "ret", "[", "'comment'", "]", "=", "'{0} is already bootstrapped'", ".", "format", "(", "name", ")", "except", "(", "CommandNotFoundError", ",", "CommandExecutionError", ")", "as", "err", ":", "ret", "[", "'result'", "]", "=", "False", "ret", "[", "'comment'", "]", "=", "'Error Bootstrapping \\'{0}\\': {1}'", ".", "format", "(", "name", ",", "err", ")", "return", "ret", "try", ":", "call", "=", "__salt__", "[", "'npm.install'", "]", "(", "dir", "=", "name", ",", "runas", "=", "user", ",", "pkg", "=", "None", ",", "silent", "=", "silent", ")", "except", "(", "CommandNotFoundError", ",", "CommandExecutionError", ")", "as", "err", ":", "ret", "[", "'result'", "]", "=", "False", "ret", "[", "'comment'", "]", "=", "'Error Bootstrapping \\'{0}\\': {1}'", ".", "format", "(", "name", ",", "err", ")", "return", "ret", "if", "not", "call", ":", "ret", "[", "'result'", "]", "=", "True", "ret", "[", "'comment'", "]", "=", "'Directory is already bootstrapped'", "return", "ret", "# npm.install will return a string if it can't parse a JSON result", "if", "isinstance", "(", "call", ",", "six", ".", "string_types", ")", ":", "ret", "[", "'result'", "]", "=", "False", "ret", "[", "'changes'", "]", "=", "call", "ret", "[", "'comment'", "]", "=", "'Could not bootstrap directory'", "else", ":", "ret", "[", "'result'", "]", "=", "True", "ret", "[", "'changes'", "]", "=", "{", "name", ":", "'Bootstrapped'", "}", "ret", "[", "'comment'", "]", "=", "'Directory was successfully bootstrapped'", "return", "ret"], "docstring": "Bootstraps a node.js application.\n\n    Will execute 'npm install --json' on the specified directory.\n\n    user\n        The user to run NPM with\n\n        .. versionadded:: 0.17.0", "docstring_tokens": ["Bootstraps", "a", "node", ".", "js", "application", "."], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/states/npm.py#L269-L319", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/states/npm.py", "func_name": "cache_cleaned", "original_string": "def cache_cleaned(name=None,\n                  user=None,\n                  force=False):\n    '''\n    Ensure that the given package is not cached.\n\n    If no package is specified, this ensures the entire cache is cleared.\n\n    name\n        The name of the package to remove from the cache, or None for all packages\n\n    user\n        The user to run NPM with\n\n    force\n        Force cleaning of cache.  Required for npm@5 and greater\n\n        .. versionadded:: 2016.11.6\n    '''\n    ret = {'name': name, 'result': None, 'comment': '', 'changes': {}}\n    specific_pkg = None\n\n    try:\n        cached_pkgs = __salt__['npm.cache_list'](path=name, runas=user)\n    except (CommandExecutionError, CommandNotFoundError) as err:\n        ret['result'] = False\n        ret['comment'] = 'Error looking up cached {0}: {1}'.format(\n            name or 'packages', err)\n        return ret\n\n    if name:\n        all_cached_pkgs = __salt__['npm.cache_list'](path=None, runas=user)\n        # The first package is always the cache path\n        cache_root_path = all_cached_pkgs[0]\n        specific_pkg = '{0}/{1}/'.format(cache_root_path, name)\n\n        if specific_pkg not in cached_pkgs:\n            ret['result'] = True\n            ret['comment'] = 'Package {0} is not in the cache'.format(name)\n            return ret\n\n    if __opts__['test']:\n        ret['result'] = None\n        ret['comment'] = 'Cached {0} set to be removed'.format(name or 'packages')\n        return ret\n\n    if __salt__['npm.cache_clean'](path=name, runas=user):\n        ret['result'] = True\n        ret['changes'][name or 'cache'] = 'Removed'\n        ret['comment'] = 'Cached {0} successfully removed'.format(\n            name or 'packages'\n        )\n    else:\n        ret['result'] = False\n        ret['comment'] = 'Error cleaning cached {0}'.format(name or 'packages')\n\n    return ret", "language": "python", "code": "def cache_cleaned(name=None,\n                  user=None,\n                  force=False):\n    '''\n    Ensure that the given package is not cached.\n\n    If no package is specified, this ensures the entire cache is cleared.\n\n    name\n        The name of the package to remove from the cache, or None for all packages\n\n    user\n        The user to run NPM with\n\n    force\n        Force cleaning of cache.  Required for npm@5 and greater\n\n        .. versionadded:: 2016.11.6\n    '''\n    ret = {'name': name, 'result': None, 'comment': '', 'changes': {}}\n    specific_pkg = None\n\n    try:\n        cached_pkgs = __salt__['npm.cache_list'](path=name, runas=user)\n    except (CommandExecutionError, CommandNotFoundError) as err:\n        ret['result'] = False\n        ret['comment'] = 'Error looking up cached {0}: {1}'.format(\n            name or 'packages', err)\n        return ret\n\n    if name:\n        all_cached_pkgs = __salt__['npm.cache_list'](path=None, runas=user)\n        # The first package is always the cache path\n        cache_root_path = all_cached_pkgs[0]\n        specific_pkg = '{0}/{1}/'.format(cache_root_path, name)\n\n        if specific_pkg not in cached_pkgs:\n            ret['result'] = True\n            ret['comment'] = 'Package {0} is not in the cache'.format(name)\n            return ret\n\n    if __opts__['test']:\n        ret['result'] = None\n        ret['comment'] = 'Cached {0} set to be removed'.format(name or 'packages')\n        return ret\n\n    if __salt__['npm.cache_clean'](path=name, runas=user):\n        ret['result'] = True\n        ret['changes'][name or 'cache'] = 'Removed'\n        ret['comment'] = 'Cached {0} successfully removed'.format(\n            name or 'packages'\n        )\n    else:\n        ret['result'] = False\n        ret['comment'] = 'Error cleaning cached {0}'.format(name or 'packages')\n\n    return ret", "code_tokens": ["def", "cache_cleaned", "(", "name", "=", "None", ",", "user", "=", "None", ",", "force", "=", "False", ")", ":", "ret", "=", "{", "'name'", ":", "name", ",", "'result'", ":", "None", ",", "'comment'", ":", "''", ",", "'changes'", ":", "{", "}", "}", "specific_pkg", "=", "None", "try", ":", "cached_pkgs", "=", "__salt__", "[", "'npm.cache_list'", "]", "(", "path", "=", "name", ",", "runas", "=", "user", ")", "except", "(", "CommandExecutionError", ",", "CommandNotFoundError", ")", "as", "err", ":", "ret", "[", "'result'", "]", "=", "False", "ret", "[", "'comment'", "]", "=", "'Error looking up cached {0}: {1}'", ".", "format", "(", "name", "or", "'packages'", ",", "err", ")", "return", "ret", "if", "name", ":", "all_cached_pkgs", "=", "__salt__", "[", "'npm.cache_list'", "]", "(", "path", "=", "None", ",", "runas", "=", "user", ")", "# The first package is always the cache path", "cache_root_path", "=", "all_cached_pkgs", "[", "0", "]", "specific_pkg", "=", "'{0}/{1}/'", ".", "format", "(", "cache_root_path", ",", "name", ")", "if", "specific_pkg", "not", "in", "cached_pkgs", ":", "ret", "[", "'result'", "]", "=", "True", "ret", "[", "'comment'", "]", "=", "'Package {0} is not in the cache'", ".", "format", "(", "name", ")", "return", "ret", "if", "__opts__", "[", "'test'", "]", ":", "ret", "[", "'result'", "]", "=", "None", "ret", "[", "'comment'", "]", "=", "'Cached {0} set to be removed'", ".", "format", "(", "name", "or", "'packages'", ")", "return", "ret", "if", "__salt__", "[", "'npm.cache_clean'", "]", "(", "path", "=", "name", ",", "runas", "=", "user", ")", ":", "ret", "[", "'result'", "]", "=", "True", "ret", "[", "'changes'", "]", "[", "name", "or", "'cache'", "]", "=", "'Removed'", "ret", "[", "'comment'", "]", "=", "'Cached {0} successfully removed'", ".", "format", "(", "name", "or", "'packages'", ")", "else", ":", "ret", "[", "'result'", "]", "=", "False", "ret", "[", "'comment'", "]", "=", "'Error cleaning cached {0}'", ".", "format", "(", "name", "or", "'packages'", ")", "return", "ret"], "docstring": "Ensure that the given package is not cached.\n\n    If no package is specified, this ensures the entire cache is cleared.\n\n    name\n        The name of the package to remove from the cache, or None for all packages\n\n    user\n        The user to run NPM with\n\n    force\n        Force cleaning of cache.  Required for npm@5 and greater\n\n        .. versionadded:: 2016.11.6", "docstring_tokens": ["Ensure", "that", "the", "given", "package", "is", "not", "cached", "."], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/states/npm.py#L322-L378", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/states/splunk_search.py", "func_name": "present", "original_string": "def present(name, profile=\"splunk\", **kwargs):\n    '''\n    Ensure a search is present\n\n    .. code-block:: yaml\n\n        API Error Search:\n          splunk_search.present:\n            search: index=main sourcetype=blah\n            template: alert_5min\n\n    The following parameters are required:\n\n    name\n        This is the name of the search in splunk\n    '''\n    ret = {\n        'name': name,\n        'changes': {},\n        'result': None,\n        'comment': ''\n    }\n\n    target = __salt__['splunk_search.get'](name, profile=profile)\n    if target:\n        if __opts__['test']:\n            ret['comment'] = \"Would update {0}\".format(name)\n            return ret\n        # found a search... updating\n        result = __salt__['splunk_search.update'](\n            name, profile=profile, **kwargs\n        )\n        if not result:\n            # no update\n            ret['result'] = True\n            ret['comment'] = \"No changes\"\n        else:\n            (newvalues, diffs) = result\n            old_content = dict(target.content)\n            old_changes = {}\n            for x in newvalues:\n                old_changes[x] = old_content.get(x, None)\n            ret['result'] = True\n            ret['changes']['diff'] = diffs\n            ret['changes']['old'] = old_changes\n            ret['changes']['new'] = newvalues\n    else:\n        if __opts__['test']:\n            ret['comment'] = \"Would create {0}\".format(name)\n            return ret\n        # creating a new search\n        result = __salt__['splunk_search.create'](\n            name, profile=profile, **kwargs\n        )\n        if result:\n            ret['result'] = True\n            ret['changes']['old'] = False\n            ret['changes']['new'] = kwargs\n        else:\n            ret['result'] = False\n            ret['comment'] = 'Failed to create {0}'.format(name)\n    return ret", "language": "python", "code": "def present(name, profile=\"splunk\", **kwargs):\n    '''\n    Ensure a search is present\n\n    .. code-block:: yaml\n\n        API Error Search:\n          splunk_search.present:\n            search: index=main sourcetype=blah\n            template: alert_5min\n\n    The following parameters are required:\n\n    name\n        This is the name of the search in splunk\n    '''\n    ret = {\n        'name': name,\n        'changes': {},\n        'result': None,\n        'comment': ''\n    }\n\n    target = __salt__['splunk_search.get'](name, profile=profile)\n    if target:\n        if __opts__['test']:\n            ret['comment'] = \"Would update {0}\".format(name)\n            return ret\n        # found a search... updating\n        result = __salt__['splunk_search.update'](\n            name, profile=profile, **kwargs\n        )\n        if not result:\n            # no update\n            ret['result'] = True\n            ret['comment'] = \"No changes\"\n        else:\n            (newvalues, diffs) = result\n            old_content = dict(target.content)\n            old_changes = {}\n            for x in newvalues:\n                old_changes[x] = old_content.get(x, None)\n            ret['result'] = True\n            ret['changes']['diff'] = diffs\n            ret['changes']['old'] = old_changes\n            ret['changes']['new'] = newvalues\n    else:\n        if __opts__['test']:\n            ret['comment'] = \"Would create {0}\".format(name)\n            return ret\n        # creating a new search\n        result = __salt__['splunk_search.create'](\n            name, profile=profile, **kwargs\n        )\n        if result:\n            ret['result'] = True\n            ret['changes']['old'] = False\n            ret['changes']['new'] = kwargs\n        else:\n            ret['result'] = False\n            ret['comment'] = 'Failed to create {0}'.format(name)\n    return ret", "code_tokens": ["def", "present", "(", "name", ",", "profile", "=", "\"splunk\"", ",", "*", "*", "kwargs", ")", ":", "ret", "=", "{", "'name'", ":", "name", ",", "'changes'", ":", "{", "}", ",", "'result'", ":", "None", ",", "'comment'", ":", "''", "}", "target", "=", "__salt__", "[", "'splunk_search.get'", "]", "(", "name", ",", "profile", "=", "profile", ")", "if", "target", ":", "if", "__opts__", "[", "'test'", "]", ":", "ret", "[", "'comment'", "]", "=", "\"Would update {0}\"", ".", "format", "(", "name", ")", "return", "ret", "# found a search... updating", "result", "=", "__salt__", "[", "'splunk_search.update'", "]", "(", "name", ",", "profile", "=", "profile", ",", "*", "*", "kwargs", ")", "if", "not", "result", ":", "# no update", "ret", "[", "'result'", "]", "=", "True", "ret", "[", "'comment'", "]", "=", "\"No changes\"", "else", ":", "(", "newvalues", ",", "diffs", ")", "=", "result", "old_content", "=", "dict", "(", "target", ".", "content", ")", "old_changes", "=", "{", "}", "for", "x", "in", "newvalues", ":", "old_changes", "[", "x", "]", "=", "old_content", ".", "get", "(", "x", ",", "None", ")", "ret", "[", "'result'", "]", "=", "True", "ret", "[", "'changes'", "]", "[", "'diff'", "]", "=", "diffs", "ret", "[", "'changes'", "]", "[", "'old'", "]", "=", "old_changes", "ret", "[", "'changes'", "]", "[", "'new'", "]", "=", "newvalues", "else", ":", "if", "__opts__", "[", "'test'", "]", ":", "ret", "[", "'comment'", "]", "=", "\"Would create {0}\"", ".", "format", "(", "name", ")", "return", "ret", "# creating a new search", "result", "=", "__salt__", "[", "'splunk_search.create'", "]", "(", "name", ",", "profile", "=", "profile", ",", "*", "*", "kwargs", ")", "if", "result", ":", "ret", "[", "'result'", "]", "=", "True", "ret", "[", "'changes'", "]", "[", "'old'", "]", "=", "False", "ret", "[", "'changes'", "]", "[", "'new'", "]", "=", "kwargs", "else", ":", "ret", "[", "'result'", "]", "=", "False", "ret", "[", "'comment'", "]", "=", "'Failed to create {0}'", ".", "format", "(", "name", ")", "return", "ret"], "docstring": "Ensure a search is present\n\n    .. code-block:: yaml\n\n        API Error Search:\n          splunk_search.present:\n            search: index=main sourcetype=blah\n            template: alert_5min\n\n    The following parameters are required:\n\n    name\n        This is the name of the search in splunk", "docstring_tokens": ["Ensure", "a", "search", "is", "present"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/states/splunk_search.py#L26-L87", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/states/splunk_search.py", "func_name": "absent", "original_string": "def absent(name, profile=\"splunk\"):\n    '''\n    Ensure a search is absent\n\n    .. code-block:: yaml\n\n        API Error Search:\n          splunk_search.absent\n\n    The following parameters are required:\n\n    name\n        This is the name of the search in splunk\n    '''\n    ret = {\n        'name': name,\n        'changes': {},\n        'result': True,\n        'comment': '{0} is absent.'.format(name)\n    }\n\n    target = __salt__['splunk_search.get'](name, profile=profile)\n    if target:\n        if __opts__['test']:\n            ret = {}\n            ret[\"name\"] = name\n            ret['comment'] = \"Would delete {0}\".format(name)\n            ret['result'] = None\n            return ret\n\n        result = __salt__['splunk_search.delete'](name, profile=profile)\n        if result:\n            ret['comment'] = '{0} was deleted'.format(name)\n        else:\n            ret['comment'] = 'Failed to delete {0}'.format(name)\n            ret['result'] = False\n    return ret", "language": "python", "code": "def absent(name, profile=\"splunk\"):\n    '''\n    Ensure a search is absent\n\n    .. code-block:: yaml\n\n        API Error Search:\n          splunk_search.absent\n\n    The following parameters are required:\n\n    name\n        This is the name of the search in splunk\n    '''\n    ret = {\n        'name': name,\n        'changes': {},\n        'result': True,\n        'comment': '{0} is absent.'.format(name)\n    }\n\n    target = __salt__['splunk_search.get'](name, profile=profile)\n    if target:\n        if __opts__['test']:\n            ret = {}\n            ret[\"name\"] = name\n            ret['comment'] = \"Would delete {0}\".format(name)\n            ret['result'] = None\n            return ret\n\n        result = __salt__['splunk_search.delete'](name, profile=profile)\n        if result:\n            ret['comment'] = '{0} was deleted'.format(name)\n        else:\n            ret['comment'] = 'Failed to delete {0}'.format(name)\n            ret['result'] = False\n    return ret", "code_tokens": ["def", "absent", "(", "name", ",", "profile", "=", "\"splunk\"", ")", ":", "ret", "=", "{", "'name'", ":", "name", ",", "'changes'", ":", "{", "}", ",", "'result'", ":", "True", ",", "'comment'", ":", "'{0} is absent.'", ".", "format", "(", "name", ")", "}", "target", "=", "__salt__", "[", "'splunk_search.get'", "]", "(", "name", ",", "profile", "=", "profile", ")", "if", "target", ":", "if", "__opts__", "[", "'test'", "]", ":", "ret", "=", "{", "}", "ret", "[", "\"name\"", "]", "=", "name", "ret", "[", "'comment'", "]", "=", "\"Would delete {0}\"", ".", "format", "(", "name", ")", "ret", "[", "'result'", "]", "=", "None", "return", "ret", "result", "=", "__salt__", "[", "'splunk_search.delete'", "]", "(", "name", ",", "profile", "=", "profile", ")", "if", "result", ":", "ret", "[", "'comment'", "]", "=", "'{0} was deleted'", ".", "format", "(", "name", ")", "else", ":", "ret", "[", "'comment'", "]", "=", "'Failed to delete {0}'", ".", "format", "(", "name", ")", "ret", "[", "'result'", "]", "=", "False", "return", "ret"], "docstring": "Ensure a search is absent\n\n    .. code-block:: yaml\n\n        API Error Search:\n          splunk_search.absent\n\n    The following parameters are required:\n\n    name\n        This is the name of the search in splunk", "docstring_tokens": ["Ensure", "a", "search", "is", "absent"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/states/splunk_search.py#L90-L126", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/states/modjk.py", "func_name": "_bulk_state", "original_string": "def _bulk_state(saltfunc, lbn, workers, profile):\n    '''\n    Generic function for bulk worker operation\n    '''\n    ret = {'name': lbn,\n           'result': True,\n           'changes': {},\n           'comment': ''}\n\n    if not isinstance(workers, list):\n        ret['result'] = False\n        ret['comment'] = 'workers should be a list not a {0}'.format(\n            type(workers)\n        )\n        return ret\n\n    if __opts__['test']:\n        ret['result'] = None\n        return ret\n\n    log.info('executing %s to modjk workers %s', saltfunc, workers)\n    try:\n        cmdret = __salt__[saltfunc](workers, lbn, profile=profile)\n    except KeyError:\n        ret['result'] = False\n        ret['comment'] = 'unsupported function {0}'.format(\n            saltfunc\n        )\n        return ret\n\n    errors = []\n    for worker, ok in six.iteritems(cmdret):\n        if not ok:\n            errors.append(worker)\n\n    ret['changes'] = {'status': cmdret}\n    if errors:\n        ret['result'] = False\n        ret['comment'] = '{0} failed on some workers'.format(saltfunc)\n\n    return ret", "language": "python", "code": "def _bulk_state(saltfunc, lbn, workers, profile):\n    '''\n    Generic function for bulk worker operation\n    '''\n    ret = {'name': lbn,\n           'result': True,\n           'changes': {},\n           'comment': ''}\n\n    if not isinstance(workers, list):\n        ret['result'] = False\n        ret['comment'] = 'workers should be a list not a {0}'.format(\n            type(workers)\n        )\n        return ret\n\n    if __opts__['test']:\n        ret['result'] = None\n        return ret\n\n    log.info('executing %s to modjk workers %s', saltfunc, workers)\n    try:\n        cmdret = __salt__[saltfunc](workers, lbn, profile=profile)\n    except KeyError:\n        ret['result'] = False\n        ret['comment'] = 'unsupported function {0}'.format(\n            saltfunc\n        )\n        return ret\n\n    errors = []\n    for worker, ok in six.iteritems(cmdret):\n        if not ok:\n            errors.append(worker)\n\n    ret['changes'] = {'status': cmdret}\n    if errors:\n        ret['result'] = False\n        ret['comment'] = '{0} failed on some workers'.format(saltfunc)\n\n    return ret", "code_tokens": ["def", "_bulk_state", "(", "saltfunc", ",", "lbn", ",", "workers", ",", "profile", ")", ":", "ret", "=", "{", "'name'", ":", "lbn", ",", "'result'", ":", "True", ",", "'changes'", ":", "{", "}", ",", "'comment'", ":", "''", "}", "if", "not", "isinstance", "(", "workers", ",", "list", ")", ":", "ret", "[", "'result'", "]", "=", "False", "ret", "[", "'comment'", "]", "=", "'workers should be a list not a {0}'", ".", "format", "(", "type", "(", "workers", ")", ")", "return", "ret", "if", "__opts__", "[", "'test'", "]", ":", "ret", "[", "'result'", "]", "=", "None", "return", "ret", "log", ".", "info", "(", "'executing %s to modjk workers %s'", ",", "saltfunc", ",", "workers", ")", "try", ":", "cmdret", "=", "__salt__", "[", "saltfunc", "]", "(", "workers", ",", "lbn", ",", "profile", "=", "profile", ")", "except", "KeyError", ":", "ret", "[", "'result'", "]", "=", "False", "ret", "[", "'comment'", "]", "=", "'unsupported function {0}'", ".", "format", "(", "saltfunc", ")", "return", "ret", "errors", "=", "[", "]", "for", "worker", ",", "ok", "in", "six", ".", "iteritems", "(", "cmdret", ")", ":", "if", "not", "ok", ":", "errors", ".", "append", "(", "worker", ")", "ret", "[", "'changes'", "]", "=", "{", "'status'", ":", "cmdret", "}", "if", "errors", ":", "ret", "[", "'result'", "]", "=", "False", "ret", "[", "'comment'", "]", "=", "'{0} failed on some workers'", ".", "format", "(", "saltfunc", ")", "return", "ret"], "docstring": "Generic function for bulk worker operation", "docstring_tokens": ["Generic", "function", "for", "bulk", "worker", "operation"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/states/modjk.py#L24-L64", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/states/modjk.py", "func_name": "worker_stopped", "original_string": "def worker_stopped(name, workers=None, profile='default'):\n    '''\n    Stop all the workers in the modjk load balancer\n\n    Example:\n\n    .. code-block:: yaml\n\n        loadbalancer:\n          modjk.worker_stopped:\n            - workers:\n              - app1\n              - app2\n    '''\n    if workers is None:\n        workers = []\n    return _bulk_state(\n        'modjk.bulk_stop', name, workers, profile\n    )", "language": "python", "code": "def worker_stopped(name, workers=None, profile='default'):\n    '''\n    Stop all the workers in the modjk load balancer\n\n    Example:\n\n    .. code-block:: yaml\n\n        loadbalancer:\n          modjk.worker_stopped:\n            - workers:\n              - app1\n              - app2\n    '''\n    if workers is None:\n        workers = []\n    return _bulk_state(\n        'modjk.bulk_stop', name, workers, profile\n    )", "code_tokens": ["def", "worker_stopped", "(", "name", ",", "workers", "=", "None", ",", "profile", "=", "'default'", ")", ":", "if", "workers", "is", "None", ":", "workers", "=", "[", "]", "return", "_bulk_state", "(", "'modjk.bulk_stop'", ",", "name", ",", "workers", ",", "profile", ")"], "docstring": "Stop all the workers in the modjk load balancer\n\n    Example:\n\n    .. code-block:: yaml\n\n        loadbalancer:\n          modjk.worker_stopped:\n            - workers:\n              - app1\n              - app2", "docstring_tokens": ["Stop", "all", "the", "workers", "in", "the", "modjk", "load", "balancer"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/states/modjk.py#L67-L85", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/states/modjk.py", "func_name": "worker_activated", "original_string": "def worker_activated(name, workers=None, profile='default'):\n    '''\n    Activate all the workers in the modjk load balancer\n\n    Example:\n\n    .. code-block:: yaml\n\n        loadbalancer:\n          modjk.worker_activated:\n            - workers:\n              - app1\n              - app2\n    '''\n    if workers is None:\n        workers = []\n    return _bulk_state(\n        'modjk.bulk_activate', name, workers, profile\n    )", "language": "python", "code": "def worker_activated(name, workers=None, profile='default'):\n    '''\n    Activate all the workers in the modjk load balancer\n\n    Example:\n\n    .. code-block:: yaml\n\n        loadbalancer:\n          modjk.worker_activated:\n            - workers:\n              - app1\n              - app2\n    '''\n    if workers is None:\n        workers = []\n    return _bulk_state(\n        'modjk.bulk_activate', name, workers, profile\n    )", "code_tokens": ["def", "worker_activated", "(", "name", ",", "workers", "=", "None", ",", "profile", "=", "'default'", ")", ":", "if", "workers", "is", "None", ":", "workers", "=", "[", "]", "return", "_bulk_state", "(", "'modjk.bulk_activate'", ",", "name", ",", "workers", ",", "profile", ")"], "docstring": "Activate all the workers in the modjk load balancer\n\n    Example:\n\n    .. code-block:: yaml\n\n        loadbalancer:\n          modjk.worker_activated:\n            - workers:\n              - app1\n              - app2", "docstring_tokens": ["Activate", "all", "the", "workers", "in", "the", "modjk", "load", "balancer"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/states/modjk.py#L88-L106", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/states/modjk.py", "func_name": "worker_disabled", "original_string": "def worker_disabled(name, workers=None, profile='default'):\n    '''\n    Disable all the workers in the modjk load balancer\n\n    Example:\n\n    .. code-block:: yaml\n\n        loadbalancer:\n          modjk.worker_disabled:\n            - workers:\n              - app1\n              - app2\n    '''\n    if workers is None:\n        workers = []\n    return _bulk_state(\n        'modjk.bulk_disable', name, workers, profile\n    )", "language": "python", "code": "def worker_disabled(name, workers=None, profile='default'):\n    '''\n    Disable all the workers in the modjk load balancer\n\n    Example:\n\n    .. code-block:: yaml\n\n        loadbalancer:\n          modjk.worker_disabled:\n            - workers:\n              - app1\n              - app2\n    '''\n    if workers is None:\n        workers = []\n    return _bulk_state(\n        'modjk.bulk_disable', name, workers, profile\n    )", "code_tokens": ["def", "worker_disabled", "(", "name", ",", "workers", "=", "None", ",", "profile", "=", "'default'", ")", ":", "if", "workers", "is", "None", ":", "workers", "=", "[", "]", "return", "_bulk_state", "(", "'modjk.bulk_disable'", ",", "name", ",", "workers", ",", "profile", ")"], "docstring": "Disable all the workers in the modjk load balancer\n\n    Example:\n\n    .. code-block:: yaml\n\n        loadbalancer:\n          modjk.worker_disabled:\n            - workers:\n              - app1\n              - app2", "docstring_tokens": ["Disable", "all", "the", "workers", "in", "the", "modjk", "load", "balancer"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/states/modjk.py#L109-L127", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/states/modjk.py", "func_name": "worker_recover", "original_string": "def worker_recover(name, workers=None, profile='default'):\n    '''\n    Recover all the workers in the modjk load balancer\n\n    Example:\n\n    .. code-block:: yaml\n\n        loadbalancer:\n          modjk.worker_recover:\n            - workers:\n              - app1\n              - app2\n    '''\n    if workers is None:\n        workers = []\n    return _bulk_state(\n        'modjk.bulk_recover', name, workers, profile\n    )", "language": "python", "code": "def worker_recover(name, workers=None, profile='default'):\n    '''\n    Recover all the workers in the modjk load balancer\n\n    Example:\n\n    .. code-block:: yaml\n\n        loadbalancer:\n          modjk.worker_recover:\n            - workers:\n              - app1\n              - app2\n    '''\n    if workers is None:\n        workers = []\n    return _bulk_state(\n        'modjk.bulk_recover', name, workers, profile\n    )", "code_tokens": ["def", "worker_recover", "(", "name", ",", "workers", "=", "None", ",", "profile", "=", "'default'", ")", ":", "if", "workers", "is", "None", ":", "workers", "=", "[", "]", "return", "_bulk_state", "(", "'modjk.bulk_recover'", ",", "name", ",", "workers", ",", "profile", ")"], "docstring": "Recover all the workers in the modjk load balancer\n\n    Example:\n\n    .. code-block:: yaml\n\n        loadbalancer:\n          modjk.worker_recover:\n            - workers:\n              - app1\n              - app2", "docstring_tokens": ["Recover", "all", "the", "workers", "in", "the", "modjk", "load", "balancer"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/states/modjk.py#L130-L148", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/states/firewalld.py", "func_name": "_parse_forward", "original_string": "def _parse_forward(mapping):\n    '''\n    Parses a port forwarding statement in the form used by this state:\n\n    from_port:to_port:protocol[:destination]\n\n    and returns a ForwardingMapping object\n    '''\n    if len(mapping.split(':')) > 3:\n        (srcport, destport, protocol, destaddr) = mapping.split(':')\n    else:\n        (srcport, destport, protocol) = mapping.split(':')\n        destaddr = ''\n    return ForwardingMapping(srcport, destport, protocol, destaddr)", "language": "python", "code": "def _parse_forward(mapping):\n    '''\n    Parses a port forwarding statement in the form used by this state:\n\n    from_port:to_port:protocol[:destination]\n\n    and returns a ForwardingMapping object\n    '''\n    if len(mapping.split(':')) > 3:\n        (srcport, destport, protocol, destaddr) = mapping.split(':')\n    else:\n        (srcport, destport, protocol) = mapping.split(':')\n        destaddr = ''\n    return ForwardingMapping(srcport, destport, protocol, destaddr)", "code_tokens": ["def", "_parse_forward", "(", "mapping", ")", ":", "if", "len", "(", "mapping", ".", "split", "(", "':'", ")", ")", ">", "3", ":", "(", "srcport", ",", "destport", ",", "protocol", ",", "destaddr", ")", "=", "mapping", ".", "split", "(", "':'", ")", "else", ":", "(", "srcport", ",", "destport", ",", "protocol", ")", "=", "mapping", ".", "split", "(", "':'", ")", "destaddr", "=", "''", "return", "ForwardingMapping", "(", "srcport", ",", "destport", ",", "protocol", ",", "destaddr", ")"], "docstring": "Parses a port forwarding statement in the form used by this state:\n\n    from_port:to_port:protocol[:destination]\n\n    and returns a ForwardingMapping object", "docstring_tokens": ["Parses", "a", "port", "forwarding", "statement", "in", "the", "form", "used", "by", "this", "state", ":"], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/states/firewalld.py#L129-L142", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/states/firewalld.py", "func_name": "present", "original_string": "def present(name,\n            block_icmp=None,\n            prune_block_icmp=False,\n            default=None,\n            masquerade=False,\n            ports=None,\n            prune_ports=False,\n            port_fwd=None,\n            prune_port_fwd=False,\n            services=None,\n            prune_services=False,\n            interfaces=None,\n            prune_interfaces=False,\n            sources=None,\n            prune_sources=False,\n            rich_rules=None,\n            prune_rich_rules=False):\n\n    '''\n    Ensure a zone has specific attributes.\n\n    name\n        The zone to modify.\n\n    default : None\n        Set this zone as the default zone if ``True``.\n\n    masquerade : False\n        Enable or disable masquerade for a zone.\n\n    block_icmp : None\n        List of ICMP types to block in the zone.\n\n    prune_block_icmp : False\n        If ``True``, remove all but the specified block_icmp from the zone.\n\n    ports : None\n        List of ports to add to the zone.\n\n    prune_ports : False\n        If ``True``, remove all but the specified ports from the zone.\n\n    port_fwd : None\n        List of port forwards to add to the zone.\n\n    prune_port_fwd : False\n        If ``True``, remove all but the specified port_fwd from the zone.\n\n    services : None\n        List of services to add to the zone.\n\n    prune_services : False\n        If ``True``, remove all but the specified services from the zone.\n        .. note:: Currently defaults to True for compatibility, but will be changed to False in a future release.\n\n    interfaces : None\n        List of interfaces to add to the zone.\n\n    prune_interfaces : False\n        If ``True``, remove all but the specified interfaces from the zone.\n\n    sources : None\n        List of sources to add to the zone.\n\n    prune_sources : False\n        If ``True``, remove all but the specified sources from the zone.\n\n    rich_rules : None\n        List of rich rules to add to the zone.\n\n    prune_rich_rules : False\n        If ``True``, remove all but the specified rich rules from the zone.\n    '''\n    ret = _present(name, block_icmp, prune_block_icmp, default, masquerade, ports, prune_ports,\n            port_fwd, prune_port_fwd, services, prune_services, interfaces, prune_interfaces,\n            sources, prune_sources, rich_rules, prune_rich_rules)\n\n    # Reload firewalld service on changes\n    if ret['changes'] != {}:\n        __salt__['firewalld.reload_rules']()\n\n    return ret", "language": "python", "code": "def present(name,\n            block_icmp=None,\n            prune_block_icmp=False,\n            default=None,\n            masquerade=False,\n            ports=None,\n            prune_ports=False,\n            port_fwd=None,\n            prune_port_fwd=False,\n            services=None,\n            prune_services=False,\n            interfaces=None,\n            prune_interfaces=False,\n            sources=None,\n            prune_sources=False,\n            rich_rules=None,\n            prune_rich_rules=False):\n\n    '''\n    Ensure a zone has specific attributes.\n\n    name\n        The zone to modify.\n\n    default : None\n        Set this zone as the default zone if ``True``.\n\n    masquerade : False\n        Enable or disable masquerade for a zone.\n\n    block_icmp : None\n        List of ICMP types to block in the zone.\n\n    prune_block_icmp : False\n        If ``True``, remove all but the specified block_icmp from the zone.\n\n    ports : None\n        List of ports to add to the zone.\n\n    prune_ports : False\n        If ``True``, remove all but the specified ports from the zone.\n\n    port_fwd : None\n        List of port forwards to add to the zone.\n\n    prune_port_fwd : False\n        If ``True``, remove all but the specified port_fwd from the zone.\n\n    services : None\n        List of services to add to the zone.\n\n    prune_services : False\n        If ``True``, remove all but the specified services from the zone.\n        .. note:: Currently defaults to True for compatibility, but will be changed to False in a future release.\n\n    interfaces : None\n        List of interfaces to add to the zone.\n\n    prune_interfaces : False\n        If ``True``, remove all but the specified interfaces from the zone.\n\n    sources : None\n        List of sources to add to the zone.\n\n    prune_sources : False\n        If ``True``, remove all but the specified sources from the zone.\n\n    rich_rules : None\n        List of rich rules to add to the zone.\n\n    prune_rich_rules : False\n        If ``True``, remove all but the specified rich rules from the zone.\n    '''\n    ret = _present(name, block_icmp, prune_block_icmp, default, masquerade, ports, prune_ports,\n            port_fwd, prune_port_fwd, services, prune_services, interfaces, prune_interfaces,\n            sources, prune_sources, rich_rules, prune_rich_rules)\n\n    # Reload firewalld service on changes\n    if ret['changes'] != {}:\n        __salt__['firewalld.reload_rules']()\n\n    return ret", "code_tokens": ["def", "present", "(", "name", ",", "block_icmp", "=", "None", ",", "prune_block_icmp", "=", "False", ",", "default", "=", "None", ",", "masquerade", "=", "False", ",", "ports", "=", "None", ",", "prune_ports", "=", "False", ",", "port_fwd", "=", "None", ",", "prune_port_fwd", "=", "False", ",", "services", "=", "None", ",", "prune_services", "=", "False", ",", "interfaces", "=", "None", ",", "prune_interfaces", "=", "False", ",", "sources", "=", "None", ",", "prune_sources", "=", "False", ",", "rich_rules", "=", "None", ",", "prune_rich_rules", "=", "False", ")", ":", "ret", "=", "_present", "(", "name", ",", "block_icmp", ",", "prune_block_icmp", ",", "default", ",", "masquerade", ",", "ports", ",", "prune_ports", ",", "port_fwd", ",", "prune_port_fwd", ",", "services", ",", "prune_services", ",", "interfaces", ",", "prune_interfaces", ",", "sources", ",", "prune_sources", ",", "rich_rules", ",", "prune_rich_rules", ")", "# Reload firewalld service on changes", "if", "ret", "[", "'changes'", "]", "!=", "{", "}", ":", "__salt__", "[", "'firewalld.reload_rules'", "]", "(", ")", "return", "ret"], "docstring": "Ensure a zone has specific attributes.\n\n    name\n        The zone to modify.\n\n    default : None\n        Set this zone as the default zone if ``True``.\n\n    masquerade : False\n        Enable or disable masquerade for a zone.\n\n    block_icmp : None\n        List of ICMP types to block in the zone.\n\n    prune_block_icmp : False\n        If ``True``, remove all but the specified block_icmp from the zone.\n\n    ports : None\n        List of ports to add to the zone.\n\n    prune_ports : False\n        If ``True``, remove all but the specified ports from the zone.\n\n    port_fwd : None\n        List of port forwards to add to the zone.\n\n    prune_port_fwd : False\n        If ``True``, remove all but the specified port_fwd from the zone.\n\n    services : None\n        List of services to add to the zone.\n\n    prune_services : False\n        If ``True``, remove all but the specified services from the zone.\n        .. note:: Currently defaults to True for compatibility, but will be changed to False in a future release.\n\n    interfaces : None\n        List of interfaces to add to the zone.\n\n    prune_interfaces : False\n        If ``True``, remove all but the specified interfaces from the zone.\n\n    sources : None\n        List of sources to add to the zone.\n\n    prune_sources : False\n        If ``True``, remove all but the specified sources from the zone.\n\n    rich_rules : None\n        List of rich rules to add to the zone.\n\n    prune_rich_rules : False\n        If ``True``, remove all but the specified rich rules from the zone.", "docstring_tokens": ["Ensure", "a", "zone", "has", "specific", "attributes", "."], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/states/firewalld.py#L155-L236", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/states/firewalld.py", "func_name": "service", "original_string": "def service(name,\n            ports=None,\n            protocols=None):\n    '''\n    Ensure the service exists and encompasses the specified ports and\n    protocols.\n\n    .. versionadded:: 2016.11.0\n    '''\n    ret = {'name': name,\n           'result': False,\n           'changes': {},\n           'comment': ''}\n\n    if name not in __salt__['firewalld.get_services']():\n        __salt__['firewalld.new_service'](name, restart=False)\n\n    ports = ports or []\n\n    try:\n        _current_ports = __salt__['firewalld.get_service_ports'](name)\n    except CommandExecutionError as err:\n        ret['comment'] = 'Error: {0}'.format(err)\n        return ret\n\n    new_ports = set(ports) - set(_current_ports)\n    old_ports = set(_current_ports) - set(ports)\n\n    for port in new_ports:\n        if not __opts__['test']:\n            try:\n                __salt__['firewalld.add_service_port'](name, port)\n            except CommandExecutionError as err:\n                ret['comment'] = 'Error: {0}'.format(err)\n                return ret\n\n    for port in old_ports:\n        if not __opts__['test']:\n            try:\n                __salt__['firewalld.remove_service_port'](name, port)\n            except CommandExecutionError as err:\n                ret['comment'] = 'Error: {0}'.format(err)\n                return ret\n\n    if new_ports or old_ports:\n        ret['changes'].update({'ports':\n                                {'old': _current_ports,\n                                 'new': ports}})\n\n    protocols = protocols or []\n\n    try:\n        _current_protocols = __salt__['firewalld.get_service_protocols'](name)\n    except CommandExecutionError as err:\n        ret['comment'] = 'Error: {0}'.format(err)\n        return ret\n\n    new_protocols = set(protocols) - set(_current_protocols)\n    old_protocols = set(_current_protocols) - set(protocols)\n\n    for protocol in new_protocols:\n        if not __opts__['test']:\n            try:\n                __salt__['firewalld.add_service_protocol'](name, protocol)\n            except CommandExecutionError as err:\n                ret['comment'] = 'Error: {0}'.format(err)\n                return ret\n\n    for protocol in old_protocols:\n        if not __opts__['test']:\n            try:\n                __salt__['firewalld.remove_service_protocol'](name, protocol)\n            except CommandExecutionError as err:\n                ret['comment'] = 'Error: {0}'.format(err)\n                return ret\n\n    if new_protocols or old_protocols:\n        ret['changes'].update({'protocols':\n                              {'old': _current_protocols,\n                               'new': protocols}})\n\n    if ret['changes'] != {}:\n        __salt__['firewalld.reload_rules']()\n\n    ret['result'] = True\n    if ret['changes'] == {}:\n        ret['comment'] = '\\'{0}\\' is already in the desired state.'.format(\n            name)\n        return ret\n\n    if __opts__['test']:\n        ret['result'] = None\n        ret['comment'] = 'Configuration for \\'{0}\\' will change.'.format(name)\n        return ret\n\n    ret['comment'] = '\\'{0}\\' was configured.'.format(name)\n    return ret", "language": "python", "code": "def service(name,\n            ports=None,\n            protocols=None):\n    '''\n    Ensure the service exists and encompasses the specified ports and\n    protocols.\n\n    .. versionadded:: 2016.11.0\n    '''\n    ret = {'name': name,\n           'result': False,\n           'changes': {},\n           'comment': ''}\n\n    if name not in __salt__['firewalld.get_services']():\n        __salt__['firewalld.new_service'](name, restart=False)\n\n    ports = ports or []\n\n    try:\n        _current_ports = __salt__['firewalld.get_service_ports'](name)\n    except CommandExecutionError as err:\n        ret['comment'] = 'Error: {0}'.format(err)\n        return ret\n\n    new_ports = set(ports) - set(_current_ports)\n    old_ports = set(_current_ports) - set(ports)\n\n    for port in new_ports:\n        if not __opts__['test']:\n            try:\n                __salt__['firewalld.add_service_port'](name, port)\n            except CommandExecutionError as err:\n                ret['comment'] = 'Error: {0}'.format(err)\n                return ret\n\n    for port in old_ports:\n        if not __opts__['test']:\n            try:\n                __salt__['firewalld.remove_service_port'](name, port)\n            except CommandExecutionError as err:\n                ret['comment'] = 'Error: {0}'.format(err)\n                return ret\n\n    if new_ports or old_ports:\n        ret['changes'].update({'ports':\n                                {'old': _current_ports,\n                                 'new': ports}})\n\n    protocols = protocols or []\n\n    try:\n        _current_protocols = __salt__['firewalld.get_service_protocols'](name)\n    except CommandExecutionError as err:\n        ret['comment'] = 'Error: {0}'.format(err)\n        return ret\n\n    new_protocols = set(protocols) - set(_current_protocols)\n    old_protocols = set(_current_protocols) - set(protocols)\n\n    for protocol in new_protocols:\n        if not __opts__['test']:\n            try:\n                __salt__['firewalld.add_service_protocol'](name, protocol)\n            except CommandExecutionError as err:\n                ret['comment'] = 'Error: {0}'.format(err)\n                return ret\n\n    for protocol in old_protocols:\n        if not __opts__['test']:\n            try:\n                __salt__['firewalld.remove_service_protocol'](name, protocol)\n            except CommandExecutionError as err:\n                ret['comment'] = 'Error: {0}'.format(err)\n                return ret\n\n    if new_protocols or old_protocols:\n        ret['changes'].update({'protocols':\n                              {'old': _current_protocols,\n                               'new': protocols}})\n\n    if ret['changes'] != {}:\n        __salt__['firewalld.reload_rules']()\n\n    ret['result'] = True\n    if ret['changes'] == {}:\n        ret['comment'] = '\\'{0}\\' is already in the desired state.'.format(\n            name)\n        return ret\n\n    if __opts__['test']:\n        ret['result'] = None\n        ret['comment'] = 'Configuration for \\'{0}\\' will change.'.format(name)\n        return ret\n\n    ret['comment'] = '\\'{0}\\' was configured.'.format(name)\n    return ret", "code_tokens": ["def", "service", "(", "name", ",", "ports", "=", "None", ",", "protocols", "=", "None", ")", ":", "ret", "=", "{", "'name'", ":", "name", ",", "'result'", ":", "False", ",", "'changes'", ":", "{", "}", ",", "'comment'", ":", "''", "}", "if", "name", "not", "in", "__salt__", "[", "'firewalld.get_services'", "]", "(", ")", ":", "__salt__", "[", "'firewalld.new_service'", "]", "(", "name", ",", "restart", "=", "False", ")", "ports", "=", "ports", "or", "[", "]", "try", ":", "_current_ports", "=", "__salt__", "[", "'firewalld.get_service_ports'", "]", "(", "name", ")", "except", "CommandExecutionError", "as", "err", ":", "ret", "[", "'comment'", "]", "=", "'Error: {0}'", ".", "format", "(", "err", ")", "return", "ret", "new_ports", "=", "set", "(", "ports", ")", "-", "set", "(", "_current_ports", ")", "old_ports", "=", "set", "(", "_current_ports", ")", "-", "set", "(", "ports", ")", "for", "port", "in", "new_ports", ":", "if", "not", "__opts__", "[", "'test'", "]", ":", "try", ":", "__salt__", "[", "'firewalld.add_service_port'", "]", "(", "name", ",", "port", ")", "except", "CommandExecutionError", "as", "err", ":", "ret", "[", "'comment'", "]", "=", "'Error: {0}'", ".", "format", "(", "err", ")", "return", "ret", "for", "port", "in", "old_ports", ":", "if", "not", "__opts__", "[", "'test'", "]", ":", "try", ":", "__salt__", "[", "'firewalld.remove_service_port'", "]", "(", "name", ",", "port", ")", "except", "CommandExecutionError", "as", "err", ":", "ret", "[", "'comment'", "]", "=", "'Error: {0}'", ".", "format", "(", "err", ")", "return", "ret", "if", "new_ports", "or", "old_ports", ":", "ret", "[", "'changes'", "]", ".", "update", "(", "{", "'ports'", ":", "{", "'old'", ":", "_current_ports", ",", "'new'", ":", "ports", "}", "}", ")", "protocols", "=", "protocols", "or", "[", "]", "try", ":", "_current_protocols", "=", "__salt__", "[", "'firewalld.get_service_protocols'", "]", "(", "name", ")", "except", "CommandExecutionError", "as", "err", ":", "ret", "[", "'comment'", "]", "=", "'Error: {0}'", ".", "format", "(", "err", ")", "return", "ret", "new_protocols", "=", "set", "(", "protocols", ")", "-", "set", "(", "_current_protocols", ")", "old_protocols", "=", "set", "(", "_current_protocols", ")", "-", "set", "(", "protocols", ")", "for", "protocol", "in", "new_protocols", ":", "if", "not", "__opts__", "[", "'test'", "]", ":", "try", ":", "__salt__", "[", "'firewalld.add_service_protocol'", "]", "(", "name", ",", "protocol", ")", "except", "CommandExecutionError", "as", "err", ":", "ret", "[", "'comment'", "]", "=", "'Error: {0}'", ".", "format", "(", "err", ")", "return", "ret", "for", "protocol", "in", "old_protocols", ":", "if", "not", "__opts__", "[", "'test'", "]", ":", "try", ":", "__salt__", "[", "'firewalld.remove_service_protocol'", "]", "(", "name", ",", "protocol", ")", "except", "CommandExecutionError", "as", "err", ":", "ret", "[", "'comment'", "]", "=", "'Error: {0}'", ".", "format", "(", "err", ")", "return", "ret", "if", "new_protocols", "or", "old_protocols", ":", "ret", "[", "'changes'", "]", ".", "update", "(", "{", "'protocols'", ":", "{", "'old'", ":", "_current_protocols", ",", "'new'", ":", "protocols", "}", "}", ")", "if", "ret", "[", "'changes'", "]", "!=", "{", "}", ":", "__salt__", "[", "'firewalld.reload_rules'", "]", "(", ")", "ret", "[", "'result'", "]", "=", "True", "if", "ret", "[", "'changes'", "]", "==", "{", "}", ":", "ret", "[", "'comment'", "]", "=", "'\\'{0}\\' is already in the desired state.'", ".", "format", "(", "name", ")", "return", "ret", "if", "__opts__", "[", "'test'", "]", ":", "ret", "[", "'result'", "]", "=", "None", "ret", "[", "'comment'", "]", "=", "'Configuration for \\'{0}\\' will change.'", ".", "format", "(", "name", ")", "return", "ret", "ret", "[", "'comment'", "]", "=", "'\\'{0}\\' was configured.'", ".", "format", "(", "name", ")", "return", "ret"], "docstring": "Ensure the service exists and encompasses the specified ports and\n    protocols.\n\n    .. versionadded:: 2016.11.0", "docstring_tokens": ["Ensure", "the", "service", "exists", "and", "encompasses", "the", "specified", "ports", "and", "protocols", "."], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/states/firewalld.py#L239-L335", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/states/firewalld.py", "func_name": "_present", "original_string": "def _present(name,\n            block_icmp=None,\n            prune_block_icmp=False,\n            default=None,\n            masquerade=False,\n            ports=None,\n            prune_ports=False,\n            port_fwd=None,\n            prune_port_fwd=False,\n            services=None,\n            # TODO: prune_services=False in future release\n            # prune_services=False,\n            prune_services=None,\n            interfaces=None,\n            prune_interfaces=False,\n            sources=None,\n            prune_sources=False,\n            rich_rules=None,\n            prune_rich_rules=False):\n    '''\n    Ensure a zone has specific attributes.\n    '''\n    ret = {'name': name,\n           'result': False,\n           'changes': {},\n           'comment': ''}\n\n    try:\n        zones = __salt__['firewalld.get_zones'](permanent=True)\n    except CommandExecutionError as err:\n        ret['comment'] = 'Error: {0}'.format(err)\n        return ret\n\n    if name not in zones:\n        if not __opts__['test']:\n            try:\n                __salt__['firewalld.new_zone'](name)\n            except CommandExecutionError as err:\n                ret['comment'] = 'Error: {0}'.format(err)\n                return ret\n\n        ret['changes'].update({name:\n                                {'old': zones,\n                                'new': name}})\n\n    if block_icmp or prune_block_icmp:\n        block_icmp = block_icmp or []\n        new_icmp_types = []\n        old_icmp_types = []\n\n        try:\n            _current_icmp_blocks = __salt__['firewalld.list_icmp_block'](name,\n                permanent=True)\n        except CommandExecutionError as err:\n            ret['comment'] = 'Error: {0}'.format(err)\n            return ret\n\n        if block_icmp:\n            try:\n                _valid_icmp_types = __salt__['firewalld.get_icmp_types'](\n                    permanent=True)\n            except CommandExecutionError as err:\n                ret['comment'] = 'Error: {0}'.format(err)\n                return ret\n\n            # log errors for invalid ICMP types in block_icmp input\n            for icmp_type in set(block_icmp) - set(_valid_icmp_types):\n                log.error('%s is an invalid ICMP type', icmp_type)\n                block_icmp.remove(icmp_type)\n\n            new_icmp_types = set(block_icmp) - set(_current_icmp_blocks)\n            for icmp_type in new_icmp_types:\n                if not __opts__['test']:\n                    try:\n                        __salt__['firewalld.block_icmp'](name, icmp_type,\n                                                         permanent=True)\n                    except CommandExecutionError as err:\n                        ret['comment'] = 'Error: {0}'.format(err)\n                        return ret\n\n        if prune_block_icmp:\n            old_icmp_types = set(_current_icmp_blocks) - set(block_icmp)\n            for icmp_type in old_icmp_types:\n                # no need to check against _valid_icmp_types here, because all\n                # elements in old_icmp_types are guaranteed to be in\n                # _current_icmp_blocks, whose elements are inherently valid\n                if not __opts__['test']:\n                    try:\n                        __salt__['firewalld.allow_icmp'](name, icmp_type,\n                                                         permanent=True)\n                    except CommandExecutionError as err:\n                        ret['comment'] = 'Error: {0}'.format(err)\n                        return ret\n\n        if new_icmp_types or old_icmp_types:\n            # If we're not pruning, include current items in new output so it's clear\n            # that they're still present\n            if not prune_block_icmp:\n                block_icmp = list(new_icmp_types | set(_current_icmp_blocks))\n            ret['changes'].update({'icmp_types':\n                                    {'old': _current_icmp_blocks,\n                                    'new': block_icmp}})\n\n    # that's the only parameter that can't be permanent or runtime, it's\n    # directly both\n    if default:\n        try:\n            default_zone = __salt__['firewalld.default_zone']()\n        except CommandExecutionError as err:\n            ret['comment'] = 'Error: {0}'.format(err)\n            return ret\n        if name != default_zone:\n            if not __opts__['test']:\n                try:\n                    __salt__['firewalld.set_default_zone'](name)\n                except CommandExecutionError as err:\n                    ret['comment'] = 'Error: {0}'.format(err)\n                    return ret\n            ret['changes'].update({'default':\n                                  {'old': default_zone,\n                                   'new': name}})\n\n    try:\n        masquerade_ret = __salt__['firewalld.get_masquerade'](name,\n            permanent=True)\n    except CommandExecutionError as err:\n        ret['comment'] = 'Error: {0}'.format(err)\n        return ret\n\n    if masquerade and not masquerade_ret:\n        if not __opts__['test']:\n            try:\n                __salt__['firewalld.add_masquerade'](name, permanent=True)\n            except CommandExecutionError as err:\n                ret['comment'] = 'Error: {0}'.format(err)\n                return ret\n        ret['changes'].update({'masquerade':\n                              {'old': '',\n                               'new': 'Masquerading successfully set.'}})\n    elif not masquerade and masquerade_ret:\n        if not __opts__['test']:\n            try:\n                __salt__['firewalld.remove_masquerade'](name,\n                                                        permanent=True)\n            except CommandExecutionError as err:\n                ret['comment'] = 'Error: {0}'.format(err)\n                return ret\n        ret['changes'].update({'masquerade':\n                              {'old': '',\n                               'new': 'Masquerading successfully '\n                               'disabled.'}})\n\n    if ports or prune_ports:\n        ports = ports or []\n        try:\n            _current_ports = __salt__['firewalld.list_ports'](name, permanent=True)\n        except CommandExecutionError as err:\n            ret['comment'] = 'Error: {0}'.format(err)\n            return ret\n\n        new_ports = set(ports) - set(_current_ports)\n        old_ports = []\n\n        for port in new_ports:\n            if not __opts__['test']:\n                try:\n                    # TODO: force_masquerade to be removed in future release\n                    __salt__['firewalld.add_port'](name, port, permanent=True, force_masquerade=False)\n                except CommandExecutionError as err:\n                    ret['comment'] = 'Error: {0}'.format(err)\n                    return ret\n\n        if prune_ports:\n            old_ports = set(_current_ports) - set(ports)\n            for port in old_ports:\n                if not __opts__['test']:\n                    try:\n                        __salt__['firewalld.remove_port'](name, port, permanent=True)\n                    except CommandExecutionError as err:\n                        ret['comment'] = 'Error: {0}'.format(err)\n                        return ret\n\n        if new_ports or old_ports:\n            # If we're not pruning, include current items in new output so it's clear\n            # that they're still present\n            if not prune_ports:\n                ports = list(new_ports | set(_current_ports))\n            ret['changes'].update({'ports':\n                                    {'old': _current_ports,\n                                    'new': ports}})\n\n    if port_fwd or prune_port_fwd:\n        port_fwd = port_fwd or []\n        try:\n            _current_port_fwd = __salt__['firewalld.list_port_fwd'](name,\n                                                                    permanent=True)\n        except CommandExecutionError as err:\n            ret['comment'] = 'Error: {0}'.format(err)\n            return ret\n\n        port_fwd = [_parse_forward(fwd) for fwd in port_fwd]\n        _current_port_fwd = [\n            ForwardingMapping(\n                srcport=fwd['Source port'],\n                destport=fwd['Destination port'],\n                protocol=fwd['Protocol'],\n                destaddr=fwd['Destination address']\n            ) for fwd in _current_port_fwd]\n\n        new_port_fwd = set(port_fwd) - set(_current_port_fwd)\n        old_port_fwd = []\n\n        for fwd in new_port_fwd:\n            if not __opts__['test']:\n                try:\n                    # TODO: force_masquerade to be removed in future release\n                    __salt__['firewalld.add_port_fwd'](name, fwd.srcport,\n                        fwd.destport, fwd.protocol, fwd.destaddr, permanent=True,\n                        force_masquerade=False)\n                except CommandExecutionError as err:\n                    ret['comment'] = 'Error: {0}'.format(err)\n                    return ret\n\n        if prune_port_fwd:\n            old_port_fwd = set(_current_port_fwd) - set(port_fwd)\n            for fwd in old_port_fwd:\n                if not __opts__['test']:\n                    try:\n                        __salt__['firewalld.remove_port_fwd'](name, fwd.srcport,\n                            fwd.destport, fwd.protocol, fwd.destaddr, permanent=True)\n                    except CommandExecutionError as err:\n                        ret['comment'] = 'Error: {0}'.format(err)\n                        return ret\n\n        if new_port_fwd or old_port_fwd:\n            # If we're not pruning, include current items in new output so it's clear\n            # that they're still present\n            if not prune_port_fwd:\n                port_fwd = list(new_port_fwd | set(_current_port_fwd))\n            ret['changes'].update({'port_fwd':\n                                    {'old': [fwd.todict() for fwd in\n                                             _current_port_fwd],\n                                    'new': [fwd.todict() for fwd in port_fwd]}})\n\n    if services or prune_services:\n        services = services or []\n        try:\n            _current_services = __salt__['firewalld.list_services'](name,\n                permanent=True)\n        except CommandExecutionError as err:\n            ret['comment'] = 'Error: {0}'.format(err)\n            return ret\n\n        new_services = set(services) - set(_current_services)\n        old_services = []\n\n        for new_service in new_services:\n            if not __opts__['test']:\n                try:\n                    __salt__['firewalld.add_service'](new_service, name,\n                                                      permanent=True)\n                except CommandExecutionError as err:\n                    ret['comment'] = 'Error: {0}'.format(err)\n                    return ret\n\n        if prune_services:\n            old_services = set(_current_services) - set(services)\n            for old_service in old_services:\n                if not __opts__['test']:\n                    try:\n                        __salt__['firewalld.remove_service'](old_service, name,\n                                                             permanent=True)\n                    except CommandExecutionError as err:\n                        ret['comment'] = 'Error: {0}'.format(err)\n                        return ret\n\n        if new_services or old_services:\n            # If we're not pruning, include current items in new output so it's clear\n            # that they're still present\n            if not prune_services:\n                services = list(new_services | set(_current_services))\n            ret['changes'].update({'services':\n                                    {'old': _current_services,\n                                    'new': services}})\n\n    if interfaces or prune_interfaces:\n        interfaces = interfaces or []\n        try:\n            _current_interfaces = __salt__['firewalld.get_interfaces'](name,\n                permanent=True)\n        except CommandExecutionError as err:\n            ret['comment'] = 'Error: {0}'.format(err)\n            return ret\n\n        new_interfaces = set(interfaces) - set(_current_interfaces)\n        old_interfaces = []\n\n        for interface in new_interfaces:\n            if not __opts__['test']:\n                try:\n                    __salt__['firewalld.add_interface'](name, interface,\n                                                        permanent=True)\n                except CommandExecutionError as err:\n                    ret['comment'] = 'Error: {0}'.format(err)\n                    return ret\n\n        if prune_interfaces:\n            old_interfaces = set(_current_interfaces) - set(interfaces)\n            for interface in old_interfaces:\n                if not __opts__['test']:\n                    try:\n                        __salt__['firewalld.remove_interface'](name, interface,\n                                                               permanent=True)\n                    except CommandExecutionError as err:\n                        ret['comment'] = 'Error: {0}'.format(err)\n                        return ret\n\n        if new_interfaces or old_interfaces:\n            # If we're not pruning, include current items in new output so it's clear\n            # that they're still present\n            if not prune_interfaces:\n                interfaces = list(new_interfaces | set(_current_interfaces))\n            ret['changes'].update({'interfaces':\n                                    {'old': _current_interfaces,\n                                    'new': interfaces}})\n\n    if sources or prune_sources:\n        sources = sources or []\n        try:\n            _current_sources = __salt__['firewalld.get_sources'](name,\n                                                                 permanent=True)\n        except CommandExecutionError as err:\n            ret['comment'] = 'Error: {0}'.format(err)\n            return ret\n\n        new_sources = set(sources) - set(_current_sources)\n        old_sources = []\n\n        for source in new_sources:\n            if not __opts__['test']:\n                try:\n                    __salt__['firewalld.add_source'](name, source, permanent=True)\n                except CommandExecutionError as err:\n                    ret['comment'] = 'Error: {0}'.format(err)\n                    return ret\n\n        if prune_sources:\n            old_sources = set(_current_sources) - set(sources)\n            for source in old_sources:\n                if not __opts__['test']:\n                    try:\n                        __salt__['firewalld.remove_source'](name, source,\n                                                            permanent=True)\n                    except CommandExecutionError as err:\n                        ret['comment'] = 'Error: {0}'.format(err)\n                        return ret\n\n        if new_sources or old_sources:\n            # If we're not pruning, include current items in new output so it's clear\n            # that they're still present\n            if not prune_sources:\n                sources = list(new_sources | set(_current_sources))\n            ret['changes'].update({'sources':\n                                    {'old': _current_sources,\n                                    'new': sources}})\n\n    if rich_rules or prune_rich_rules:\n        rich_rules = rich_rules or []\n        try:\n            _current_rich_rules = __salt__['firewalld.get_rich_rules'](name,\n                permanent=True)\n        except CommandExecutionError as err:\n            ret['comment'] = 'Error: {0}'.format(err)\n            return ret\n\n        new_rich_rules = set(rich_rules) - set(_current_rich_rules)\n        old_rich_rules = []\n\n        for rich_rule in new_rich_rules:\n            if not __opts__['test']:\n                try:\n                    __salt__['firewalld.add_rich_rule'](name, rich_rule,\n                                                        permanent=True)\n                except CommandExecutionError as err:\n                    ret['comment'] = 'Error: {0}'.format(err)\n                    return ret\n\n        if prune_rich_rules:\n            old_rich_rules = set(_current_rich_rules) - set(rich_rules)\n            for rich_rule in old_rich_rules:\n                if not __opts__['test']:\n                    try:\n                        __salt__['firewalld.remove_rich_rule'](name, rich_rule,\n                                                               permanent=True)\n                    except CommandExecutionError as err:\n                        ret['comment'] = 'Error: {0}'.format(err)\n                        return ret\n\n        if new_rich_rules or old_rich_rules:\n            # If we're not pruning, include current items in new output so it's clear\n            # that they're still present\n            if not prune_rich_rules:\n                rich_rules = list(new_rich_rules | set(_current_rich_rules))\n            ret['changes'].update({'rich_rules':\n                                  {'old': _current_rich_rules,\n                                   'new': rich_rules}})\n\n    # No changes\n    if ret['changes'] == {}:\n        ret['result'] = True\n        ret['comment'] = '\\'{0}\\' is already in the desired state.'.format(name)\n        return ret\n\n    # test=True and changes predicted\n    if __opts__['test']:\n        ret['result'] = None\n        # build comment string\n        nested.__opts__ = __opts__\n        comment = []\n        comment.append('Configuration for \\'{0}\\' will change:'.format(name))\n        comment.append(nested.output(ret['changes']).rstrip())\n        ret['comment'] = '\\n'.join(comment)\n        ret['changes'] = {}\n        return ret\n\n    # Changes were made successfully\n    ret['result'] = True\n    ret['comment'] = '\\'{0}\\' was configured.'.format(name)\n    return ret", "language": "python", "code": "def _present(name,\n            block_icmp=None,\n            prune_block_icmp=False,\n            default=None,\n            masquerade=False,\n            ports=None,\n            prune_ports=False,\n            port_fwd=None,\n            prune_port_fwd=False,\n            services=None,\n            # TODO: prune_services=False in future release\n            # prune_services=False,\n            prune_services=None,\n            interfaces=None,\n            prune_interfaces=False,\n            sources=None,\n            prune_sources=False,\n            rich_rules=None,\n            prune_rich_rules=False):\n    '''\n    Ensure a zone has specific attributes.\n    '''\n    ret = {'name': name,\n           'result': False,\n           'changes': {},\n           'comment': ''}\n\n    try:\n        zones = __salt__['firewalld.get_zones'](permanent=True)\n    except CommandExecutionError as err:\n        ret['comment'] = 'Error: {0}'.format(err)\n        return ret\n\n    if name not in zones:\n        if not __opts__['test']:\n            try:\n                __salt__['firewalld.new_zone'](name)\n            except CommandExecutionError as err:\n                ret['comment'] = 'Error: {0}'.format(err)\n                return ret\n\n        ret['changes'].update({name:\n                                {'old': zones,\n                                'new': name}})\n\n    if block_icmp or prune_block_icmp:\n        block_icmp = block_icmp or []\n        new_icmp_types = []\n        old_icmp_types = []\n\n        try:\n            _current_icmp_blocks = __salt__['firewalld.list_icmp_block'](name,\n                permanent=True)\n        except CommandExecutionError as err:\n            ret['comment'] = 'Error: {0}'.format(err)\n            return ret\n\n        if block_icmp:\n            try:\n                _valid_icmp_types = __salt__['firewalld.get_icmp_types'](\n                    permanent=True)\n            except CommandExecutionError as err:\n                ret['comment'] = 'Error: {0}'.format(err)\n                return ret\n\n            # log errors for invalid ICMP types in block_icmp input\n            for icmp_type in set(block_icmp) - set(_valid_icmp_types):\n                log.error('%s is an invalid ICMP type', icmp_type)\n                block_icmp.remove(icmp_type)\n\n            new_icmp_types = set(block_icmp) - set(_current_icmp_blocks)\n            for icmp_type in new_icmp_types:\n                if not __opts__['test']:\n                    try:\n                        __salt__['firewalld.block_icmp'](name, icmp_type,\n                                                         permanent=True)\n                    except CommandExecutionError as err:\n                        ret['comment'] = 'Error: {0}'.format(err)\n                        return ret\n\n        if prune_block_icmp:\n            old_icmp_types = set(_current_icmp_blocks) - set(block_icmp)\n            for icmp_type in old_icmp_types:\n                # no need to check against _valid_icmp_types here, because all\n                # elements in old_icmp_types are guaranteed to be in\n                # _current_icmp_blocks, whose elements are inherently valid\n                if not __opts__['test']:\n                    try:\n                        __salt__['firewalld.allow_icmp'](name, icmp_type,\n                                                         permanent=True)\n                    except CommandExecutionError as err:\n                        ret['comment'] = 'Error: {0}'.format(err)\n                        return ret\n\n        if new_icmp_types or old_icmp_types:\n            # If we're not pruning, include current items in new output so it's clear\n            # that they're still present\n            if not prune_block_icmp:\n                block_icmp = list(new_icmp_types | set(_current_icmp_blocks))\n            ret['changes'].update({'icmp_types':\n                                    {'old': _current_icmp_blocks,\n                                    'new': block_icmp}})\n\n    # that's the only parameter that can't be permanent or runtime, it's\n    # directly both\n    if default:\n        try:\n            default_zone = __salt__['firewalld.default_zone']()\n        except CommandExecutionError as err:\n            ret['comment'] = 'Error: {0}'.format(err)\n            return ret\n        if name != default_zone:\n            if not __opts__['test']:\n                try:\n                    __salt__['firewalld.set_default_zone'](name)\n                except CommandExecutionError as err:\n                    ret['comment'] = 'Error: {0}'.format(err)\n                    return ret\n            ret['changes'].update({'default':\n                                  {'old': default_zone,\n                                   'new': name}})\n\n    try:\n        masquerade_ret = __salt__['firewalld.get_masquerade'](name,\n            permanent=True)\n    except CommandExecutionError as err:\n        ret['comment'] = 'Error: {0}'.format(err)\n        return ret\n\n    if masquerade and not masquerade_ret:\n        if not __opts__['test']:\n            try:\n                __salt__['firewalld.add_masquerade'](name, permanent=True)\n            except CommandExecutionError as err:\n                ret['comment'] = 'Error: {0}'.format(err)\n                return ret\n        ret['changes'].update({'masquerade':\n                              {'old': '',\n                               'new': 'Masquerading successfully set.'}})\n    elif not masquerade and masquerade_ret:\n        if not __opts__['test']:\n            try:\n                __salt__['firewalld.remove_masquerade'](name,\n                                                        permanent=True)\n            except CommandExecutionError as err:\n                ret['comment'] = 'Error: {0}'.format(err)\n                return ret\n        ret['changes'].update({'masquerade':\n                              {'old': '',\n                               'new': 'Masquerading successfully '\n                               'disabled.'}})\n\n    if ports or prune_ports:\n        ports = ports or []\n        try:\n            _current_ports = __salt__['firewalld.list_ports'](name, permanent=True)\n        except CommandExecutionError as err:\n            ret['comment'] = 'Error: {0}'.format(err)\n            return ret\n\n        new_ports = set(ports) - set(_current_ports)\n        old_ports = []\n\n        for port in new_ports:\n            if not __opts__['test']:\n                try:\n                    # TODO: force_masquerade to be removed in future release\n                    __salt__['firewalld.add_port'](name, port, permanent=True, force_masquerade=False)\n                except CommandExecutionError as err:\n                    ret['comment'] = 'Error: {0}'.format(err)\n                    return ret\n\n        if prune_ports:\n            old_ports = set(_current_ports) - set(ports)\n            for port in old_ports:\n                if not __opts__['test']:\n                    try:\n                        __salt__['firewalld.remove_port'](name, port, permanent=True)\n                    except CommandExecutionError as err:\n                        ret['comment'] = 'Error: {0}'.format(err)\n                        return ret\n\n        if new_ports or old_ports:\n            # If we're not pruning, include current items in new output so it's clear\n            # that they're still present\n            if not prune_ports:\n                ports = list(new_ports | set(_current_ports))\n            ret['changes'].update({'ports':\n                                    {'old': _current_ports,\n                                    'new': ports}})\n\n    if port_fwd or prune_port_fwd:\n        port_fwd = port_fwd or []\n        try:\n            _current_port_fwd = __salt__['firewalld.list_port_fwd'](name,\n                                                                    permanent=True)\n        except CommandExecutionError as err:\n            ret['comment'] = 'Error: {0}'.format(err)\n            return ret\n\n        port_fwd = [_parse_forward(fwd) for fwd in port_fwd]\n        _current_port_fwd = [\n            ForwardingMapping(\n                srcport=fwd['Source port'],\n                destport=fwd['Destination port'],\n                protocol=fwd['Protocol'],\n                destaddr=fwd['Destination address']\n            ) for fwd in _current_port_fwd]\n\n        new_port_fwd = set(port_fwd) - set(_current_port_fwd)\n        old_port_fwd = []\n\n        for fwd in new_port_fwd:\n            if not __opts__['test']:\n                try:\n                    # TODO: force_masquerade to be removed in future release\n                    __salt__['firewalld.add_port_fwd'](name, fwd.srcport,\n                        fwd.destport, fwd.protocol, fwd.destaddr, permanent=True,\n                        force_masquerade=False)\n                except CommandExecutionError as err:\n                    ret['comment'] = 'Error: {0}'.format(err)\n                    return ret\n\n        if prune_port_fwd:\n            old_port_fwd = set(_current_port_fwd) - set(port_fwd)\n            for fwd in old_port_fwd:\n                if not __opts__['test']:\n                    try:\n                        __salt__['firewalld.remove_port_fwd'](name, fwd.srcport,\n                            fwd.destport, fwd.protocol, fwd.destaddr, permanent=True)\n                    except CommandExecutionError as err:\n                        ret['comment'] = 'Error: {0}'.format(err)\n                        return ret\n\n        if new_port_fwd or old_port_fwd:\n            # If we're not pruning, include current items in new output so it's clear\n            # that they're still present\n            if not prune_port_fwd:\n                port_fwd = list(new_port_fwd | set(_current_port_fwd))\n            ret['changes'].update({'port_fwd':\n                                    {'old': [fwd.todict() for fwd in\n                                             _current_port_fwd],\n                                    'new': [fwd.todict() for fwd in port_fwd]}})\n\n    if services or prune_services:\n        services = services or []\n        try:\n            _current_services = __salt__['firewalld.list_services'](name,\n                permanent=True)\n        except CommandExecutionError as err:\n            ret['comment'] = 'Error: {0}'.format(err)\n            return ret\n\n        new_services = set(services) - set(_current_services)\n        old_services = []\n\n        for new_service in new_services:\n            if not __opts__['test']:\n                try:\n                    __salt__['firewalld.add_service'](new_service, name,\n                                                      permanent=True)\n                except CommandExecutionError as err:\n                    ret['comment'] = 'Error: {0}'.format(err)\n                    return ret\n\n        if prune_services:\n            old_services = set(_current_services) - set(services)\n            for old_service in old_services:\n                if not __opts__['test']:\n                    try:\n                        __salt__['firewalld.remove_service'](old_service, name,\n                                                             permanent=True)\n                    except CommandExecutionError as err:\n                        ret['comment'] = 'Error: {0}'.format(err)\n                        return ret\n\n        if new_services or old_services:\n            # If we're not pruning, include current items in new output so it's clear\n            # that they're still present\n            if not prune_services:\n                services = list(new_services | set(_current_services))\n            ret['changes'].update({'services':\n                                    {'old': _current_services,\n                                    'new': services}})\n\n    if interfaces or prune_interfaces:\n        interfaces = interfaces or []\n        try:\n            _current_interfaces = __salt__['firewalld.get_interfaces'](name,\n                permanent=True)\n        except CommandExecutionError as err:\n            ret['comment'] = 'Error: {0}'.format(err)\n            return ret\n\n        new_interfaces = set(interfaces) - set(_current_interfaces)\n        old_interfaces = []\n\n        for interface in new_interfaces:\n            if not __opts__['test']:\n                try:\n                    __salt__['firewalld.add_interface'](name, interface,\n                                                        permanent=True)\n                except CommandExecutionError as err:\n                    ret['comment'] = 'Error: {0}'.format(err)\n                    return ret\n\n        if prune_interfaces:\n            old_interfaces = set(_current_interfaces) - set(interfaces)\n            for interface in old_interfaces:\n                if not __opts__['test']:\n                    try:\n                        __salt__['firewalld.remove_interface'](name, interface,\n                                                               permanent=True)\n                    except CommandExecutionError as err:\n                        ret['comment'] = 'Error: {0}'.format(err)\n                        return ret\n\n        if new_interfaces or old_interfaces:\n            # If we're not pruning, include current items in new output so it's clear\n            # that they're still present\n            if not prune_interfaces:\n                interfaces = list(new_interfaces | set(_current_interfaces))\n            ret['changes'].update({'interfaces':\n                                    {'old': _current_interfaces,\n                                    'new': interfaces}})\n\n    if sources or prune_sources:\n        sources = sources or []\n        try:\n            _current_sources = __salt__['firewalld.get_sources'](name,\n                                                                 permanent=True)\n        except CommandExecutionError as err:\n            ret['comment'] = 'Error: {0}'.format(err)\n            return ret\n\n        new_sources = set(sources) - set(_current_sources)\n        old_sources = []\n\n        for source in new_sources:\n            if not __opts__['test']:\n                try:\n                    __salt__['firewalld.add_source'](name, source, permanent=True)\n                except CommandExecutionError as err:\n                    ret['comment'] = 'Error: {0}'.format(err)\n                    return ret\n\n        if prune_sources:\n            old_sources = set(_current_sources) - set(sources)\n            for source in old_sources:\n                if not __opts__['test']:\n                    try:\n                        __salt__['firewalld.remove_source'](name, source,\n                                                            permanent=True)\n                    except CommandExecutionError as err:\n                        ret['comment'] = 'Error: {0}'.format(err)\n                        return ret\n\n        if new_sources or old_sources:\n            # If we're not pruning, include current items in new output so it's clear\n            # that they're still present\n            if not prune_sources:\n                sources = list(new_sources | set(_current_sources))\n            ret['changes'].update({'sources':\n                                    {'old': _current_sources,\n                                    'new': sources}})\n\n    if rich_rules or prune_rich_rules:\n        rich_rules = rich_rules or []\n        try:\n            _current_rich_rules = __salt__['firewalld.get_rich_rules'](name,\n                permanent=True)\n        except CommandExecutionError as err:\n            ret['comment'] = 'Error: {0}'.format(err)\n            return ret\n\n        new_rich_rules = set(rich_rules) - set(_current_rich_rules)\n        old_rich_rules = []\n\n        for rich_rule in new_rich_rules:\n            if not __opts__['test']:\n                try:\n                    __salt__['firewalld.add_rich_rule'](name, rich_rule,\n                                                        permanent=True)\n                except CommandExecutionError as err:\n                    ret['comment'] = 'Error: {0}'.format(err)\n                    return ret\n\n        if prune_rich_rules:\n            old_rich_rules = set(_current_rich_rules) - set(rich_rules)\n            for rich_rule in old_rich_rules:\n                if not __opts__['test']:\n                    try:\n                        __salt__['firewalld.remove_rich_rule'](name, rich_rule,\n                                                               permanent=True)\n                    except CommandExecutionError as err:\n                        ret['comment'] = 'Error: {0}'.format(err)\n                        return ret\n\n        if new_rich_rules or old_rich_rules:\n            # If we're not pruning, include current items in new output so it's clear\n            # that they're still present\n            if not prune_rich_rules:\n                rich_rules = list(new_rich_rules | set(_current_rich_rules))\n            ret['changes'].update({'rich_rules':\n                                  {'old': _current_rich_rules,\n                                   'new': rich_rules}})\n\n    # No changes\n    if ret['changes'] == {}:\n        ret['result'] = True\n        ret['comment'] = '\\'{0}\\' is already in the desired state.'.format(name)\n        return ret\n\n    # test=True and changes predicted\n    if __opts__['test']:\n        ret['result'] = None\n        # build comment string\n        nested.__opts__ = __opts__\n        comment = []\n        comment.append('Configuration for \\'{0}\\' will change:'.format(name))\n        comment.append(nested.output(ret['changes']).rstrip())\n        ret['comment'] = '\\n'.join(comment)\n        ret['changes'] = {}\n        return ret\n\n    # Changes were made successfully\n    ret['result'] = True\n    ret['comment'] = '\\'{0}\\' was configured.'.format(name)\n    return ret", "code_tokens": ["def", "_present", "(", "name", ",", "block_icmp", "=", "None", ",", "prune_block_icmp", "=", "False", ",", "default", "=", "None", ",", "masquerade", "=", "False", ",", "ports", "=", "None", ",", "prune_ports", "=", "False", ",", "port_fwd", "=", "None", ",", "prune_port_fwd", "=", "False", ",", "services", "=", "None", ",", "# TODO: prune_services=False in future release", "# prune_services=False,", "prune_services", "=", "None", ",", "interfaces", "=", "None", ",", "prune_interfaces", "=", "False", ",", "sources", "=", "None", ",", "prune_sources", "=", "False", ",", "rich_rules", "=", "None", ",", "prune_rich_rules", "=", "False", ")", ":", "ret", "=", "{", "'name'", ":", "name", ",", "'result'", ":", "False", ",", "'changes'", ":", "{", "}", ",", "'comment'", ":", "''", "}", "try", ":", "zones", "=", "__salt__", "[", "'firewalld.get_zones'", "]", "(", "permanent", "=", "True", ")", "except", "CommandExecutionError", "as", "err", ":", "ret", "[", "'comment'", "]", "=", "'Error: {0}'", ".", "format", "(", "err", ")", "return", "ret", "if", "name", "not", "in", "zones", ":", "if", "not", "__opts__", "[", "'test'", "]", ":", "try", ":", "__salt__", "[", "'firewalld.new_zone'", "]", "(", "name", ")", "except", "CommandExecutionError", "as", "err", ":", "ret", "[", "'comment'", "]", "=", "'Error: {0}'", ".", "format", "(", "err", ")", "return", "ret", "ret", "[", "'changes'", "]", ".", "update", "(", "{", "name", ":", "{", "'old'", ":", "zones", ",", "'new'", ":", "name", "}", "}", ")", "if", "block_icmp", "or", "prune_block_icmp", ":", "block_icmp", "=", "block_icmp", "or", "[", "]", "new_icmp_types", "=", "[", "]", "old_icmp_types", "=", "[", "]", "try", ":", "_current_icmp_blocks", "=", "__salt__", "[", "'firewalld.list_icmp_block'", "]", "(", "name", ",", "permanent", "=", "True", ")", "except", "CommandExecutionError", "as", "err", ":", "ret", "[", "'comment'", "]", "=", "'Error: {0}'", ".", "format", "(", "err", ")", "return", "ret", "if", "block_icmp", ":", "try", ":", "_valid_icmp_types", "=", "__salt__", "[", "'firewalld.get_icmp_types'", "]", "(", "permanent", "=", "True", ")", "except", "CommandExecutionError", "as", "err", ":", "ret", "[", "'comment'", "]", "=", "'Error: {0}'", ".", "format", "(", "err", ")", "return", "ret", "# log errors for invalid ICMP types in block_icmp input", "for", "icmp_type", "in", "set", "(", "block_icmp", ")", "-", "set", "(", "_valid_icmp_types", ")", ":", "log", ".", "error", "(", "'%s is an invalid ICMP type'", ",", "icmp_type", ")", "block_icmp", ".", "remove", "(", "icmp_type", ")", "new_icmp_types", "=", "set", "(", "block_icmp", ")", "-", "set", "(", "_current_icmp_blocks", ")", "for", "icmp_type", "in", "new_icmp_types", ":", "if", "not", "__opts__", "[", "'test'", "]", ":", "try", ":", "__salt__", "[", "'firewalld.block_icmp'", "]", "(", "name", ",", "icmp_type", ",", "permanent", "=", "True", ")", "except", "CommandExecutionError", "as", "err", ":", "ret", "[", "'comment'", "]", "=", "'Error: {0}'", ".", "format", "(", "err", ")", "return", "ret", "if", "prune_block_icmp", ":", "old_icmp_types", "=", "set", "(", "_current_icmp_blocks", ")", "-", "set", "(", "block_icmp", ")", "for", "icmp_type", "in", "old_icmp_types", ":", "# no need to check against _valid_icmp_types here, because all", "# elements in old_icmp_types are guaranteed to be in", "# _current_icmp_blocks, whose elements are inherently valid", "if", "not", "__opts__", "[", "'test'", "]", ":", "try", ":", "__salt__", "[", "'firewalld.allow_icmp'", "]", "(", "name", ",", "icmp_type", ",", "permanent", "=", "True", ")", "except", "CommandExecutionError", "as", "err", ":", "ret", "[", "'comment'", "]", "=", "'Error: {0}'", ".", "format", "(", "err", ")", "return", "ret", "if", "new_icmp_types", "or", "old_icmp_types", ":", "# If we're not pruning, include current items in new output so it's clear", "# that they're still present", "if", "not", "prune_block_icmp", ":", "block_icmp", "=", "list", "(", "new_icmp_types", "|", "set", "(", "_current_icmp_blocks", ")", ")", "ret", "[", "'changes'", "]", ".", "update", "(", "{", "'icmp_types'", ":", "{", "'old'", ":", "_current_icmp_blocks", ",", "'new'", ":", "block_icmp", "}", "}", ")", "# that's the only parameter that can't be permanent or runtime, it's", "# directly both", "if", "default", ":", "try", ":", "default_zone", "=", "__salt__", "[", "'firewalld.default_zone'", "]", "(", ")", "except", "CommandExecutionError", "as", "err", ":", "ret", "[", "'comment'", "]", "=", "'Error: {0}'", ".", "format", "(", "err", ")", "return", "ret", "if", "name", "!=", "default_zone", ":", "if", "not", "__opts__", "[", "'test'", "]", ":", "try", ":", "__salt__", "[", "'firewalld.set_default_zone'", "]", "(", "name", ")", "except", "CommandExecutionError", "as", "err", ":", "ret", "[", "'comment'", "]", "=", "'Error: {0}'", ".", "format", "(", "err", ")", "return", "ret", "ret", "[", "'changes'", "]", ".", "update", "(", "{", "'default'", ":", "{", "'old'", ":", "default_zone", ",", "'new'", ":", "name", "}", "}", ")", "try", ":", "masquerade_ret", "=", "__salt__", "[", "'firewalld.get_masquerade'", "]", "(", "name", ",", "permanent", "=", "True", ")", "except", "CommandExecutionError", "as", "err", ":", "ret", "[", "'comment'", "]", "=", "'Error: {0}'", ".", "format", "(", "err", ")", "return", "ret", "if", "masquerade", "and", "not", "masquerade_ret", ":", "if", "not", "__opts__", "[", "'test'", "]", ":", "try", ":", "__salt__", "[", "'firewalld.add_masquerade'", "]", "(", "name", ",", "permanent", "=", "True", ")", "except", "CommandExecutionError", "as", "err", ":", "ret", "[", "'comment'", "]", "=", "'Error: {0}'", ".", "format", "(", "err", ")", "return", "ret", "ret", "[", "'changes'", "]", ".", "update", "(", "{", "'masquerade'", ":", "{", "'old'", ":", "''", ",", "'new'", ":", "'Masquerading successfully set.'", "}", "}", ")", "elif", "not", "masquerade", "and", "masquerade_ret", ":", "if", "not", "__opts__", "[", "'test'", "]", ":", "try", ":", "__salt__", "[", "'firewalld.remove_masquerade'", "]", "(", "name", ",", "permanent", "=", "True", ")", "except", "CommandExecutionError", "as", "err", ":", "ret", "[", "'comment'", "]", "=", "'Error: {0}'", ".", "format", "(", "err", ")", "return", "ret", "ret", "[", "'changes'", "]", ".", "update", "(", "{", "'masquerade'", ":", "{", "'old'", ":", "''", ",", "'new'", ":", "'Masquerading successfully '", "'disabled.'", "}", "}", ")", "if", "ports", "or", "prune_ports", ":", "ports", "=", "ports", "or", "[", "]", "try", ":", "_current_ports", "=", "__salt__", "[", "'firewalld.list_ports'", "]", "(", "name", ",", "permanent", "=", "True", ")", "except", "CommandExecutionError", "as", "err", ":", "ret", "[", "'comment'", "]", "=", "'Error: {0}'", ".", "format", "(", "err", ")", "return", "ret", "new_ports", "=", "set", "(", "ports", ")", "-", "set", "(", "_current_ports", ")", "old_ports", "=", "[", "]", "for", "port", "in", "new_ports", ":", "if", "not", "__opts__", "[", "'test'", "]", ":", "try", ":", "# TODO: force_masquerade to be removed in future release", "__salt__", "[", "'firewalld.add_port'", "]", "(", "name", ",", "port", ",", "permanent", "=", "True", ",", "force_masquerade", "=", "False", ")", "except", "CommandExecutionError", "as", "err", ":", "ret", "[", "'comment'", "]", "=", "'Error: {0}'", ".", "format", "(", "err", ")", "return", "ret", "if", "prune_ports", ":", "old_ports", "=", "set", "(", "_current_ports", ")", "-", "set", "(", "ports", ")", "for", "port", "in", "old_ports", ":", "if", "not", "__opts__", "[", "'test'", "]", ":", "try", ":", "__salt__", "[", "'firewalld.remove_port'", "]", "(", "name", ",", "port", ",", "permanent", "=", "True", ")", "except", "CommandExecutionError", "as", "err", ":", "ret", "[", "'comment'", "]", "=", "'Error: {0}'", ".", "format", "(", "err", ")", "return", "ret", "if", "new_ports", "or", "old_ports", ":", "# If we're not pruning, include current items in new output so it's clear", "# that they're still present", "if", "not", "prune_ports", ":", "ports", "=", "list", "(", "new_ports", "|", "set", "(", "_current_ports", ")", ")", "ret", "[", "'changes'", "]", ".", "update", "(", "{", "'ports'", ":", "{", "'old'", ":", "_current_ports", ",", "'new'", ":", "ports", "}", "}", ")", "if", "port_fwd", "or", "prune_port_fwd", ":", "port_fwd", "=", "port_fwd", "or", "[", "]", "try", ":", "_current_port_fwd", "=", "__salt__", "[", "'firewalld.list_port_fwd'", "]", "(", "name", ",", "permanent", "=", "True", ")", "except", "CommandExecutionError", "as", "err", ":", "ret", "[", "'comment'", "]", "=", "'Error: {0}'", ".", "format", "(", "err", ")", "return", "ret", "port_fwd", "=", "[", "_parse_forward", "(", "fwd", ")", "for", "fwd", "in", "port_fwd", "]", "_current_port_fwd", "=", "[", "ForwardingMapping", "(", "srcport", "=", "fwd", "[", "'Source port'", "]", ",", "destport", "=", "fwd", "[", "'Destination port'", "]", ",", "protocol", "=", "fwd", "[", "'Protocol'", "]", ",", "destaddr", "=", "fwd", "[", "'Destination address'", "]", ")", "for", "fwd", "in", "_current_port_fwd", "]", "new_port_fwd", "=", "set", "(", "port_fwd", ")", "-", "set", "(", "_current_port_fwd", ")", "old_port_fwd", "=", "[", "]", "for", "fwd", "in", "new_port_fwd", ":", "if", "not", "__opts__", "[", "'test'", "]", ":", "try", ":", "# TODO: force_masquerade to be removed in future release", "__salt__", "[", "'firewalld.add_port_fwd'", "]", "(", "name", ",", "fwd", ".", "srcport", ",", "fwd", ".", "destport", ",", "fwd", ".", "protocol", ",", "fwd", ".", "destaddr", ",", "permanent", "=", "True", ",", "force_masquerade", "=", "False", ")", "except", "CommandExecutionError", "as", "err", ":", "ret", "[", "'comment'", "]", "=", "'Error: {0}'", ".", "format", "(", "err", ")", "return", "ret", "if", "prune_port_fwd", ":", "old_port_fwd", "=", "set", "(", "_current_port_fwd", ")", "-", "set", "(", "port_fwd", ")", "for", "fwd", "in", "old_port_fwd", ":", "if", "not", "__opts__", "[", "'test'", "]", ":", "try", ":", "__salt__", "[", "'firewalld.remove_port_fwd'", "]", "(", "name", ",", "fwd", ".", "srcport", ",", "fwd", ".", "destport", ",", "fwd", ".", "protocol", ",", "fwd", ".", "destaddr", ",", "permanent", "=", "True", ")", "except", "CommandExecutionError", "as", "err", ":", "ret", "[", "'comment'", "]", "=", "'Error: {0}'", ".", "format", "(", "err", ")", "return", "ret", "if", "new_port_fwd", "or", "old_port_fwd", ":", "# If we're not pruning, include current items in new output so it's clear", "# that they're still present", "if", "not", "prune_port_fwd", ":", "port_fwd", "=", "list", "(", "new_port_fwd", "|", "set", "(", "_current_port_fwd", ")", ")", "ret", "[", "'changes'", "]", ".", "update", "(", "{", "'port_fwd'", ":", "{", "'old'", ":", "[", "fwd", ".", "todict", "(", ")", "for", "fwd", "in", "_current_port_fwd", "]", ",", "'new'", ":", "[", "fwd", ".", "todict", "(", ")", "for", "fwd", "in", "port_fwd", "]", "}", "}", ")", "if", "services", "or", "prune_services", ":", "services", "=", "services", "or", "[", "]", "try", ":", "_current_services", "=", "__salt__", "[", "'firewalld.list_services'", "]", "(", "name", ",", "permanent", "=", "True", ")", "except", "CommandExecutionError", "as", "err", ":", "ret", "[", "'comment'", "]", "=", "'Error: {0}'", ".", "format", "(", "err", ")", "return", "ret", "new_services", "=", "set", "(", "services", ")", "-", "set", "(", "_current_services", ")", "old_services", "=", "[", "]", "for", "new_service", "in", "new_services", ":", "if", "not", "__opts__", "[", "'test'", "]", ":", "try", ":", "__salt__", "[", "'firewalld.add_service'", "]", "(", "new_service", ",", "name", ",", "permanent", "=", "True", ")", "except", "CommandExecutionError", "as", "err", ":", "ret", "[", "'comment'", "]", "=", "'Error: {0}'", ".", "format", "(", "err", ")", "return", "ret", "if", "prune_services", ":", "old_services", "=", "set", "(", "_current_services", ")", "-", "set", "(", "services", ")", "for", "old_service", "in", "old_services", ":", "if", "not", "__opts__", "[", "'test'", "]", ":", "try", ":", "__salt__", "[", "'firewalld.remove_service'", "]", "(", "old_service", ",", "name", ",", "permanent", "=", "True", ")", "except", "CommandExecutionError", "as", "err", ":", "ret", "[", "'comment'", "]", "=", "'Error: {0}'", ".", "format", "(", "err", ")", "return", "ret", "if", "new_services", "or", "old_services", ":", "# If we're not pruning, include current items in new output so it's clear", "# that they're still present", "if", "not", "prune_services", ":", "services", "=", "list", "(", "new_services", "|", "set", "(", "_current_services", ")", ")", "ret", "[", "'changes'", "]", ".", "update", "(", "{", "'services'", ":", "{", "'old'", ":", "_current_services", ",", "'new'", ":", "services", "}", "}", ")", "if", "interfaces", "or", "prune_interfaces", ":", "interfaces", "=", "interfaces", "or", "[", "]", "try", ":", "_current_interfaces", "=", "__salt__", "[", "'firewalld.get_interfaces'", "]", "(", "name", ",", "permanent", "=", "True", ")", "except", "CommandExecutionError", "as", "err", ":", "ret", "[", "'comment'", "]", "=", "'Error: {0}'", ".", "format", "(", "err", ")", "return", "ret", "new_interfaces", "=", "set", "(", "interfaces", ")", "-", "set", "(", "_current_interfaces", ")", "old_interfaces", "=", "[", "]", "for", "interface", "in", "new_interfaces", ":", "if", "not", "__opts__", "[", "'test'", "]", ":", "try", ":", "__salt__", "[", "'firewalld.add_interface'", "]", "(", "name", ",", "interface", ",", "permanent", "=", "True", ")", "except", "CommandExecutionError", "as", "err", ":", "ret", "[", "'comment'", "]", "=", "'Error: {0}'", ".", "format", "(", "err", ")", "return", "ret", "if", "prune_interfaces", ":", "old_interfaces", "=", "set", "(", "_current_interfaces", ")", "-", "set", "(", "interfaces", ")", "for", "interface", "in", "old_interfaces", ":", "if", "not", "__opts__", "[", "'test'", "]", ":", "try", ":", "__salt__", "[", "'firewalld.remove_interface'", "]", "(", "name", ",", "interface", ",", "permanent", "=", "True", ")", "except", "CommandExecutionError", "as", "err", ":", "ret", "[", "'comment'", "]", "=", "'Error: {0}'", ".", "format", "(", "err", ")", "return", "ret", "if", "new_interfaces", "or", "old_interfaces", ":", "# If we're not pruning, include current items in new output so it's clear", "# that they're still present", "if", "not", "prune_interfaces", ":", "interfaces", "=", "list", "(", "new_interfaces", "|", "set", "(", "_current_interfaces", ")", ")", "ret", "[", "'changes'", "]", ".", "update", "(", "{", "'interfaces'", ":", "{", "'old'", ":", "_current_interfaces", ",", "'new'", ":", "interfaces", "}", "}", ")", "if", "sources", "or", "prune_sources", ":", "sources", "=", "sources", "or", "[", "]", "try", ":", "_current_sources", "=", "__salt__", "[", "'firewalld.get_sources'", "]", "(", "name", ",", "permanent", "=", "True", ")", "except", "CommandExecutionError", "as", "err", ":", "ret", "[", "'comment'", "]", "=", "'Error: {0}'", ".", "format", "(", "err", ")", "return", "ret", "new_sources", "=", "set", "(", "sources", ")", "-", "set", "(", "_current_sources", ")", "old_sources", "=", "[", "]", "for", "source", "in", "new_sources", ":", "if", "not", "__opts__", "[", "'test'", "]", ":", "try", ":", "__salt__", "[", "'firewalld.add_source'", "]", "(", "name", ",", "source", ",", "permanent", "=", "True", ")", "except", "CommandExecutionError", "as", "err", ":", "ret", "[", "'comment'", "]", "=", "'Error: {0}'", ".", "format", "(", "err", ")", "return", "ret", "if", "prune_sources", ":", "old_sources", "=", "set", "(", "_current_sources", ")", "-", "set", "(", "sources", ")", "for", "source", "in", "old_sources", ":", "if", "not", "__opts__", "[", "'test'", "]", ":", "try", ":", "__salt__", "[", "'firewalld.remove_source'", "]", "(", "name", ",", "source", ",", "permanent", "=", "True", ")", "except", "CommandExecutionError", "as", "err", ":", "ret", "[", "'comment'", "]", "=", "'Error: {0}'", ".", "format", "(", "err", ")", "return", "ret", "if", "new_sources", "or", "old_sources", ":", "# If we're not pruning, include current items in new output so it's clear", "# that they're still present", "if", "not", "prune_sources", ":", "sources", "=", "list", "(", "new_sources", "|", "set", "(", "_current_sources", ")", ")", "ret", "[", "'changes'", "]", ".", "update", "(", "{", "'sources'", ":", "{", "'old'", ":", "_current_sources", ",", "'new'", ":", "sources", "}", "}", ")", "if", "rich_rules", "or", "prune_rich_rules", ":", "rich_rules", "=", "rich_rules", "or", "[", "]", "try", ":", "_current_rich_rules", "=", "__salt__", "[", "'firewalld.get_rich_rules'", "]", "(", "name", ",", "permanent", "=", "True", ")", "except", "CommandExecutionError", "as", "err", ":", "ret", "[", "'comment'", "]", "=", "'Error: {0}'", ".", "format", "(", "err", ")", "return", "ret", "new_rich_rules", "=", "set", "(", "rich_rules", ")", "-", "set", "(", "_current_rich_rules", ")", "old_rich_rules", "=", "[", "]", "for", "rich_rule", "in", "new_rich_rules", ":", "if", "not", "__opts__", "[", "'test'", "]", ":", "try", ":", "__salt__", "[", "'firewalld.add_rich_rule'", "]", "(", "name", ",", "rich_rule", ",", "permanent", "=", "True", ")", "except", "CommandExecutionError", "as", "err", ":", "ret", "[", "'comment'", "]", "=", "'Error: {0}'", ".", "format", "(", "err", ")", "return", "ret", "if", "prune_rich_rules", ":", "old_rich_rules", "=", "set", "(", "_current_rich_rules", ")", "-", "set", "(", "rich_rules", ")", "for", "rich_rule", "in", "old_rich_rules", ":", "if", "not", "__opts__", "[", "'test'", "]", ":", "try", ":", "__salt__", "[", "'firewalld.remove_rich_rule'", "]", "(", "name", ",", "rich_rule", ",", "permanent", "=", "True", ")", "except", "CommandExecutionError", "as", "err", ":", "ret", "[", "'comment'", "]", "=", "'Error: {0}'", ".", "format", "(", "err", ")", "return", "ret", "if", "new_rich_rules", "or", "old_rich_rules", ":", "# If we're not pruning, include current items in new output so it's clear", "# that they're still present", "if", "not", "prune_rich_rules", ":", "rich_rules", "=", "list", "(", "new_rich_rules", "|", "set", "(", "_current_rich_rules", ")", ")", "ret", "[", "'changes'", "]", ".", "update", "(", "{", "'rich_rules'", ":", "{", "'old'", ":", "_current_rich_rules", ",", "'new'", ":", "rich_rules", "}", "}", ")", "# No changes", "if", "ret", "[", "'changes'", "]", "==", "{", "}", ":", "ret", "[", "'result'", "]", "=", "True", "ret", "[", "'comment'", "]", "=", "'\\'{0}\\' is already in the desired state.'", ".", "format", "(", "name", ")", "return", "ret", "# test=True and changes predicted", "if", "__opts__", "[", "'test'", "]", ":", "ret", "[", "'result'", "]", "=", "None", "# build comment string", "nested", ".", "__opts__", "=", "__opts__", "comment", "=", "[", "]", "comment", ".", "append", "(", "'Configuration for \\'{0}\\' will change:'", ".", "format", "(", "name", ")", ")", "comment", ".", "append", "(", "nested", ".", "output", "(", "ret", "[", "'changes'", "]", ")", ".", "rstrip", "(", ")", ")", "ret", "[", "'comment'", "]", "=", "'\\n'", ".", "join", "(", "comment", ")", "ret", "[", "'changes'", "]", "=", "{", "}", "return", "ret", "# Changes were made successfully", "ret", "[", "'result'", "]", "=", "True", "ret", "[", "'comment'", "]", "=", "'\\'{0}\\' was configured.'", ".", "format", "(", "name", ")", "return", "ret"], "docstring": "Ensure a zone has specific attributes.", "docstring_tokens": ["Ensure", "a", "zone", "has", "specific", "attributes", "."], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/states/firewalld.py#L338-L766", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/states/firewalld.py", "func_name": "ForwardingMapping.todict", "original_string": "def todict(self):\n        '''\n        Returns a pretty dictionary meant for command line output.\n        '''\n        return {\n            'Source port': self.srcport,\n            'Destination port': self.destport,\n            'Protocol': self.protocol,\n            'Destination address': self.destaddr}", "language": "python", "code": "def todict(self):\n        '''\n        Returns a pretty dictionary meant for command line output.\n        '''\n        return {\n            'Source port': self.srcport,\n            'Destination port': self.destport,\n            'Protocol': self.protocol,\n            'Destination address': self.destaddr}", "code_tokens": ["def", "todict", "(", "self", ")", ":", "return", "{", "'Source port'", ":", "self", ".", "srcport", ",", "'Destination port'", ":", "self", ".", "destport", ",", "'Protocol'", ":", "self", ".", "protocol", ",", "'Destination address'", ":", "self", ".", "destaddr", "}"], "docstring": "Returns a pretty dictionary meant for command line output.", "docstring_tokens": ["Returns", "a", "pretty", "dictionary", "meant", "for", "command", "line", "output", "."], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/states/firewalld.py#L118-L126", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/modules/jenkinsmod.py", "func_name": "_connect", "original_string": "def _connect():\n    '''\n    Return server object used to interact with Jenkins.\n\n    :return: server object used to interact with Jenkins\n    '''\n    jenkins_url = __salt__['config.get']('jenkins.url') or \\\n        __salt__['config.get']('jenkins:url') or \\\n        __salt__['pillar.get']('jenkins.url')\n\n    jenkins_user = __salt__['config.get']('jenkins.user') or \\\n        __salt__['config.get']('jenkins:user') or \\\n        __salt__['pillar.get']('jenkins.user')\n\n    jenkins_password = __salt__['config.get']('jenkins.password') or \\\n        __salt__['config.get']('jenkins:password') or \\\n        __salt__['pillar.get']('jenkins.password')\n\n    if not jenkins_url:\n        raise SaltInvocationError('No Jenkins URL found.')\n\n    return jenkins.Jenkins(jenkins_url,\n                           username=jenkins_user,\n                           password=jenkins_password)", "language": "python", "code": "def _connect():\n    '''\n    Return server object used to interact with Jenkins.\n\n    :return: server object used to interact with Jenkins\n    '''\n    jenkins_url = __salt__['config.get']('jenkins.url') or \\\n        __salt__['config.get']('jenkins:url') or \\\n        __salt__['pillar.get']('jenkins.url')\n\n    jenkins_user = __salt__['config.get']('jenkins.user') or \\\n        __salt__['config.get']('jenkins:user') or \\\n        __salt__['pillar.get']('jenkins.user')\n\n    jenkins_password = __salt__['config.get']('jenkins.password') or \\\n        __salt__['config.get']('jenkins:password') or \\\n        __salt__['pillar.get']('jenkins.password')\n\n    if not jenkins_url:\n        raise SaltInvocationError('No Jenkins URL found.')\n\n    return jenkins.Jenkins(jenkins_url,\n                           username=jenkins_user,\n                           password=jenkins_password)", "code_tokens": ["def", "_connect", "(", ")", ":", "jenkins_url", "=", "__salt__", "[", "'config.get'", "]", "(", "'jenkins.url'", ")", "or", "__salt__", "[", "'config.get'", "]", "(", "'jenkins:url'", ")", "or", "__salt__", "[", "'pillar.get'", "]", "(", "'jenkins.url'", ")", "jenkins_user", "=", "__salt__", "[", "'config.get'", "]", "(", "'jenkins.user'", ")", "or", "__salt__", "[", "'config.get'", "]", "(", "'jenkins:user'", ")", "or", "__salt__", "[", "'pillar.get'", "]", "(", "'jenkins.user'", ")", "jenkins_password", "=", "__salt__", "[", "'config.get'", "]", "(", "'jenkins.password'", ")", "or", "__salt__", "[", "'config.get'", "]", "(", "'jenkins:password'", ")", "or", "__salt__", "[", "'pillar.get'", "]", "(", "'jenkins.password'", ")", "if", "not", "jenkins_url", ":", "raise", "SaltInvocationError", "(", "'No Jenkins URL found.'", ")", "return", "jenkins", ".", "Jenkins", "(", "jenkins_url", ",", "username", "=", "jenkins_user", ",", "password", "=", "jenkins_password", ")"], "docstring": "Return server object used to interact with Jenkins.\n\n    :return: server object used to interact with Jenkins", "docstring_tokens": ["Return", "server", "object", "used", "to", "interact", "with", "Jenkins", "."], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/modules/jenkinsmod.py#L69-L92", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/modules/jenkinsmod.py", "func_name": "_retrieve_config_xml", "original_string": "def _retrieve_config_xml(config_xml, saltenv):\n    '''\n    Helper to cache the config XML and raise a CommandExecutionError if we fail\n    to do so. If we successfully cache the file, return the cached path.\n    '''\n    ret = __salt__['cp.cache_file'](config_xml, saltenv)\n\n    if not ret:\n        raise CommandExecutionError('Failed to retrieve {0}'.format(config_xml))\n\n    return ret", "language": "python", "code": "def _retrieve_config_xml(config_xml, saltenv):\n    '''\n    Helper to cache the config XML and raise a CommandExecutionError if we fail\n    to do so. If we successfully cache the file, return the cached path.\n    '''\n    ret = __salt__['cp.cache_file'](config_xml, saltenv)\n\n    if not ret:\n        raise CommandExecutionError('Failed to retrieve {0}'.format(config_xml))\n\n    return ret", "code_tokens": ["def", "_retrieve_config_xml", "(", "config_xml", ",", "saltenv", ")", ":", "ret", "=", "__salt__", "[", "'cp.cache_file'", "]", "(", "config_xml", ",", "saltenv", ")", "if", "not", "ret", ":", "raise", "CommandExecutionError", "(", "'Failed to retrieve {0}'", ".", "format", "(", "config_xml", ")", ")", "return", "ret"], "docstring": "Helper to cache the config XML and raise a CommandExecutionError if we fail\n    to do so. If we successfully cache the file, return the cached path.", "docstring_tokens": ["Helper", "to", "cache", "the", "config", "XML", "and", "raise", "a", "CommandExecutionError", "if", "we", "fail", "to", "do", "so", ".", "If", "we", "successfully", "cache", "the", "file", "return", "the", "cached", "path", "."], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/modules/jenkinsmod.py#L95-L105", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/modules/jenkinsmod.py", "func_name": "job_exists", "original_string": "def job_exists(name=None):\n    '''\n    Check whether the job exists in configured Jenkins jobs.\n\n    :param name: The name of the job is check if it exists.\n    :return: True if job exists, False if job does not exist.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' jenkins.job_exists jobname\n\n    '''\n    if not name:\n        raise SaltInvocationError('Required parameter \\'name\\' is missing')\n\n    server = _connect()\n    if server.job_exists(name):\n        return True\n    else:\n        return False", "language": "python", "code": "def job_exists(name=None):\n    '''\n    Check whether the job exists in configured Jenkins jobs.\n\n    :param name: The name of the job is check if it exists.\n    :return: True if job exists, False if job does not exist.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' jenkins.job_exists jobname\n\n    '''\n    if not name:\n        raise SaltInvocationError('Required parameter \\'name\\' is missing')\n\n    server = _connect()\n    if server.job_exists(name):\n        return True\n    else:\n        return False", "code_tokens": ["def", "job_exists", "(", "name", "=", "None", ")", ":", "if", "not", "name", ":", "raise", "SaltInvocationError", "(", "'Required parameter \\'name\\' is missing'", ")", "server", "=", "_connect", "(", ")", "if", "server", ".", "job_exists", "(", "name", ")", ":", "return", "True", "else", ":", "return", "False"], "docstring": "Check whether the job exists in configured Jenkins jobs.\n\n    :param name: The name of the job is check if it exists.\n    :return: True if job exists, False if job does not exist.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' jenkins.job_exists jobname", "docstring_tokens": ["Check", "whether", "the", "job", "exists", "in", "configured", "Jenkins", "jobs", "."], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/modules/jenkinsmod.py#L170-L191", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/modules/jenkinsmod.py", "func_name": "get_job_info", "original_string": "def get_job_info(name=None):\n    '''\n    Return information about the Jenkins job.\n\n    :param name: The name of the job is check if it exists.\n    :return: Information about the Jenkins job.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' jenkins.get_job_info jobname\n\n    '''\n    if not name:\n        raise SaltInvocationError('Required parameter \\'name\\' is missing')\n\n    server = _connect()\n\n    if not job_exists(name):\n        raise CommandExecutionError('Job \\'{0}\\' does not exist'.format(name))\n\n    job_info = server.get_job_info(name)\n    if job_info:\n        return job_info\n    return False", "language": "python", "code": "def get_job_info(name=None):\n    '''\n    Return information about the Jenkins job.\n\n    :param name: The name of the job is check if it exists.\n    :return: Information about the Jenkins job.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' jenkins.get_job_info jobname\n\n    '''\n    if not name:\n        raise SaltInvocationError('Required parameter \\'name\\' is missing')\n\n    server = _connect()\n\n    if not job_exists(name):\n        raise CommandExecutionError('Job \\'{0}\\' does not exist'.format(name))\n\n    job_info = server.get_job_info(name)\n    if job_info:\n        return job_info\n    return False", "code_tokens": ["def", "get_job_info", "(", "name", "=", "None", ")", ":", "if", "not", "name", ":", "raise", "SaltInvocationError", "(", "'Required parameter \\'name\\' is missing'", ")", "server", "=", "_connect", "(", ")", "if", "not", "job_exists", "(", "name", ")", ":", "raise", "CommandExecutionError", "(", "'Job \\'{0}\\' does not exist'", ".", "format", "(", "name", ")", ")", "job_info", "=", "server", ".", "get_job_info", "(", "name", ")", "if", "job_info", ":", "return", "job_info", "return", "False"], "docstring": "Return information about the Jenkins job.\n\n    :param name: The name of the job is check if it exists.\n    :return: Information about the Jenkins job.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' jenkins.get_job_info jobname", "docstring_tokens": ["Return", "information", "about", "the", "Jenkins", "job", "."], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/modules/jenkinsmod.py#L194-L219", "partition": "train"}
{"repo": "saltstack/salt", "path": "salt/modules/jenkinsmod.py", "func_name": "build_job", "original_string": "def build_job(name=None, parameters=None):\n    '''\n    Initiate a build for the provided job.\n\n    :param name: The name of the job is check if it exists.\n    :param parameters: Parameters to send to the job.\n    :return: True is successful, otherwise raise an exception.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' jenkins.build_job jobname\n\n    '''\n    if not name:\n        raise SaltInvocationError('Required parameter \\'name\\' is missing')\n\n    server = _connect()\n\n    if not job_exists(name):\n        raise CommandExecutionError('Job \\'{0}\\' does not exist.'.format(name))\n\n    try:\n        server.build_job(name, parameters)\n    except jenkins.JenkinsException as err:\n        raise CommandExecutionError(\n            'Encountered error building job \\'{0}\\': {1}'.format(name, err)\n        )\n    return True", "language": "python", "code": "def build_job(name=None, parameters=None):\n    '''\n    Initiate a build for the provided job.\n\n    :param name: The name of the job is check if it exists.\n    :param parameters: Parameters to send to the job.\n    :return: True is successful, otherwise raise an exception.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' jenkins.build_job jobname\n\n    '''\n    if not name:\n        raise SaltInvocationError('Required parameter \\'name\\' is missing')\n\n    server = _connect()\n\n    if not job_exists(name):\n        raise CommandExecutionError('Job \\'{0}\\' does not exist.'.format(name))\n\n    try:\n        server.build_job(name, parameters)\n    except jenkins.JenkinsException as err:\n        raise CommandExecutionError(\n            'Encountered error building job \\'{0}\\': {1}'.format(name, err)\n        )\n    return True", "code_tokens": ["def", "build_job", "(", "name", "=", "None", ",", "parameters", "=", "None", ")", ":", "if", "not", "name", ":", "raise", "SaltInvocationError", "(", "'Required parameter \\'name\\' is missing'", ")", "server", "=", "_connect", "(", ")", "if", "not", "job_exists", "(", "name", ")", ":", "raise", "CommandExecutionError", "(", "'Job \\'{0}\\' does not exist.'", ".", "format", "(", "name", ")", ")", "try", ":", "server", ".", "build_job", "(", "name", ",", "parameters", ")", "except", "jenkins", ".", "JenkinsException", "as", "err", ":", "raise", "CommandExecutionError", "(", "'Encountered error building job \\'{0}\\': {1}'", ".", "format", "(", "name", ",", "err", ")", ")", "return", "True"], "docstring": "Initiate a build for the provided job.\n\n    :param name: The name of the job is check if it exists.\n    :param parameters: Parameters to send to the job.\n    :return: True is successful, otherwise raise an exception.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' jenkins.build_job jobname", "docstring_tokens": ["Initiate", "a", "build", "for", "the", "provided", "job", "."], "sha": "e8541fd6e744ab0df786c0f76102e41631f45d46", "url": "https://github.com/saltstack/salt/blob/e8541fd6e744ab0df786c0f76102e41631f45d46/salt/modules/jenkinsmod.py#L222-L251", "partition": "train"}